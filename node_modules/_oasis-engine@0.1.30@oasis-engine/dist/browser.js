(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.oasisEngine = {}));
}(this, (function (exports) { 'use strict';

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }

  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !_isNativeFunction(Class)) return Class;

      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }

      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);

        _cache.set(Class, Wrapper);
      }

      function Wrapper() {
        return _construct(Class, arguments, _getPrototypeOf(this).constructor);
      }

      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class);
    };

    return _wrapNativeSuper(Class);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn(this, result);
    };
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get(target, property, receiver || target);
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it;

    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;

        var F = function () {};

        return {
          s: F,
          n: function () {
            if (i >= o.length) return {
              done: true
            };
            return {
              done: false,
              value: o[i++]
            };
          },
          e: function (e) {
            throw e;
          },
          f: F
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var normalCompletion = true,
        didErr = false,
        err;
    return {
      s: function () {
        it = o[Symbol.iterator]();
      },
      n: function () {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function (e) {
        didErr = true;
        err = e;
      },
      f: function () {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }

  var IntersectInfo;

  (function (IntersectInfo2) {
    IntersectInfo2[IntersectInfo2["EXCLUDE"] = 0] = "EXCLUDE";
    IntersectInfo2[IntersectInfo2["INTERSECT"] = 1] = "INTERSECT";
    IntersectInfo2[IntersectInfo2["INCLUDE"] = 2] = "INCLUDE";
  })(IntersectInfo || (IntersectInfo = {}));

  function pointDistanceToPlane(plane, pt) {
    return plane.x * pt.x + plane.y * pt.y + plane.z * pt.z + plane.w;
  }

  function getMaxScaleByModelMatrix(modelMatrix) {
    var m = modelMatrix.elements;
    var scaleXSq = m[0] * m[0] + m[1] * m[1] + m[2] * m[2];
    var scaleYSq = m[4] * m[4] + m[5] * m[5] + m[6] * m[6];
    var scaleZSq = m[8] * m[8] + m[9] * m[9] + m[10] * m[10];
    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
  }

  var MathUtil = /*#__PURE__*/function () {
    function MathUtil() {
      _classCallCheck(this, MathUtil);
    }

    _createClass(MathUtil, null, [{
      key: "clamp",
      value: function clamp(v, min, max) {
        return Math.max(min, Math.min(max, v));
      }
    }, {
      key: "equals",
      value: function equals(a, b) {
        return Math.abs(a - b) <= MathUtil.zeroTolerance;
      }
    }, {
      key: "isPowerOf2",
      value: function isPowerOf2(v) {
        return (v & v - 1) === 0;
      }
    }, {
      key: "radianToDegree",
      value: function radianToDegree(r) {
        return r * MathUtil.radToDegreeFactor;
      }
    }, {
      key: "degreeToRadian",
      value: function degreeToRadian(d) {
        return d * MathUtil.degreeToRadFactor;
      }
    }]);

    return MathUtil;
  }();

  MathUtil.zeroTolerance = 1e-6;
  MathUtil.radToDegreeFactor = 180 / Math.PI;
  MathUtil.degreeToRadFactor = Math.PI / 180;

  var Vector3 = /*#__PURE__*/function () {
    _createClass(Vector3, null, [{
      key: "add",
      value: function add(left, right, out) {
        out.x = left.x + right.x;
        out.y = left.y + right.y;
        out.z = left.z + right.z;
      }
    }, {
      key: "subtract",
      value: function subtract(left, right, out) {
        out.x = left.x - right.x;
        out.y = left.y - right.y;
        out.z = left.z - right.z;
      }
    }, {
      key: "multiply",
      value: function multiply(left, right, out) {
        out.x = left.x * right.x;
        out.y = left.y * right.y;
        out.z = left.z * right.z;
      }
    }, {
      key: "divide",
      value: function divide(left, right, out) {
        out.x = left.x / right.x;
        out.y = left.y / right.y;
        out.z = left.z / right.z;
      }
    }, {
      key: "dot",
      value: function dot(left, right) {
        return left.x * right.x + left.y * right.y + left.z * right.z;
      }
    }, {
      key: "cross",
      value: function cross(left, right, out) {
        var ax = left.x;
        var ay = left.y;
        var az = left.z;
        var bx = right.x;
        var by = right.y;
        var bz = right.z;
        out.x = ay * bz - az * by;
        out.y = az * bx - ax * bz;
        out.z = ax * by - ay * bx;
      }
    }, {
      key: "distance",
      value: function distance(a, b) {
        var x = b.x - a.x;
        var y = b.y - a.y;
        var z = b.z - a.z;
        return Math.sqrt(x * x + y * y + z * z);
      }
    }, {
      key: "distanceSquared",
      value: function distanceSquared(a, b) {
        var x = b.x - a.x;
        var y = b.y - a.y;
        var z = b.z - a.z;
        return x * x + y * y + z * z;
      }
    }, {
      key: "equals",
      value: function equals(left, right) {
        return MathUtil.equals(left.x, right.x) && MathUtil.equals(left.y, right.y) && MathUtil.equals(left.z, right.z);
      }
    }, {
      key: "lerp",
      value: function lerp(start, end, t, out) {
        var x = start.x,
            y = start.y,
            z = start.z;
        out.x = x + (end.x - x) * t;
        out.y = y + (end.y - y) * t;
        out.z = z + (end.z - z) * t;
      }
    }, {
      key: "max",
      value: function max(left, right, out) {
        out.x = Math.max(left.x, right.x);
        out.y = Math.max(left.y, right.y);
        out.z = Math.max(left.z, right.z);
      }
    }, {
      key: "min",
      value: function min(left, right, out) {
        out.x = Math.min(left.x, right.x);
        out.y = Math.min(left.y, right.y);
        out.z = Math.min(left.z, right.z);
      }
    }, {
      key: "negate",
      value: function negate(a, out) {
        out.x = -a.x;
        out.y = -a.y;
        out.z = -a.z;
      }
    }, {
      key: "normalize",
      value: function normalize(a, out) {
        var x = a.x,
            y = a.y,
            z = a.z;
        var len = Math.sqrt(x * x + y * y + z * z);

        if (len > 0) {
          len = 1 / len;
          out.x = x * len;
          out.y = y * len;
          out.z = z * len;
        }
      }
    }, {
      key: "scale",
      value: function scale(a, s, out) {
        out.x = a.x * s;
        out.y = a.y * s;
        out.z = a.z * s;
      }
    }, {
      key: "transformNormal",
      value: function transformNormal(v, m, out) {
        var x = v.x,
            y = v.y,
            z = v.z;
        var e = m.elements;
        out.x = x * e[0] + y * e[4] + z * e[8];
        out.y = x * e[1] + y * e[5] + z * e[9];
        out.z = x * e[2] + y * e[6] + z * e[10];
      }
    }, {
      key: "transformToVec3",
      value: function transformToVec3(v, m, out) {
        var x = v.x,
            y = v.y,
            z = v.z;
        var e = m.elements;
        out.x = x * e[0] + y * e[4] + z * e[8] + e[12];
        out.y = x * e[1] + y * e[5] + z * e[9] + e[13];
        out.z = x * e[2] + y * e[6] + z * e[10] + e[14];
      }
    }, {
      key: "transformToVec4",
      value: function transformToVec4(v, m, out) {
        var x = v.x,
            y = v.y,
            z = v.z;
        var e = m.elements;
        out.x = x * e[0] + y * e[4] + z * e[8] + e[12];
        out.y = x * e[1] + y * e[5] + z * e[9] + e[13];
        out.z = x * e[2] + y * e[6] + z * e[10] + e[14];
        out.w = x * e[3] + y * e[7] + z * e[11] + e[15];
      }
    }, {
      key: "transformCoordinate",
      value: function transformCoordinate(v, m, out) {
        var x = v.x,
            y = v.y,
            z = v.z;
        var e = m.elements;
        var w = x * e[3] + y * e[7] + z * e[11] + e[15];
        w = 1 / w;
        out.x = (x * e[0] + y * e[4] + z * e[8] + e[12]) * w;
        out.y = (x * e[1] + y * e[5] + z * e[9] + e[13]) * w;
        out.z = (x * e[2] + y * e[6] + z * e[10] + e[14]) * w;
      }
    }, {
      key: "transformByQuat",
      value: function transformByQuat(v, q, out) {
        var x = v.x,
            y = v.y,
            z = v.z;
        var qx = q.x;
        var qy = q.y;
        var qz = q.z;
        var qw = q.w;
        var ix = qw * x + qy * z - qz * y;
        var iy = qw * y + qz * x - qx * z;
        var iz = qw * z + qx * y - qy * x;
        var iw = -qx * x - qy * y - qz * z;
        out.x = ix * qw - iw * qx - iy * qz + iz * qy;
        out.y = iy * qw - iw * qy - iz * qx + ix * qz;
        out.z = iz * qw - iw * qz - ix * qy + iy * qx;
      }
    }]);

    function Vector3() {
      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

      _classCallCheck(this, Vector3);

      this.x = x;
      this.y = y;
      this.z = z;
    }

    _createClass(Vector3, [{
      key: "setValue",
      value: function setValue(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
        return this;
      }
    }, {
      key: "setValueByArray",
      value: function setValueByArray(array) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        return this;
      }
    }, {
      key: "add",
      value: function add(right) {
        this.x += right.x;
        this.y += right.y;
        this.z += right.z;
        return this;
      }
    }, {
      key: "subtract",
      value: function subtract(right) {
        this.x -= right.x;
        this.y -= right.y;
        this.z -= right.z;
        return this;
      }
    }, {
      key: "multiply",
      value: function multiply(right) {
        this.x *= right.x;
        this.y *= right.y;
        this.z *= right.z;
        return this;
      }
    }, {
      key: "divide",
      value: function divide(right) {
        this.x /= right.x;
        this.y /= right.y;
        this.z /= right.z;
        return this;
      }
    }, {
      key: "length",
      value: function length() {
        var x = this.x,
            y = this.y,
            z = this.z;
        return Math.sqrt(x * x + y * y + z * z);
      }
    }, {
      key: "lengthSquared",
      value: function lengthSquared() {
        var x = this.x,
            y = this.y,
            z = this.z;
        return x * x + y * y + z * z;
      }
    }, {
      key: "negate",
      value: function negate() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        return this;
      }
    }, {
      key: "normalize",
      value: function normalize() {
        Vector3.normalize(this, this);
        return this;
      }
    }, {
      key: "scale",
      value: function scale(s) {
        this.x *= s;
        this.y *= s;
        this.z *= s;
        return this;
      }
    }, {
      key: "toArray",
      value: function toArray(out) {
        var outOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        out[outOffset] = this.x;
        out[outOffset + 1] = this.y;
        out[outOffset + 2] = this.z;
      }
    }, {
      key: "clone",
      value: function clone() {
        return new Vector3(this.x, this.y, this.z);
      }
    }, {
      key: "cloneTo",
      value: function cloneTo(out) {
        out.x = this.x;
        out.y = this.y;
        out.z = this.z;
        return out;
      }
    }, {
      key: "transformNormal",
      value: function transformNormal(m) {
        Vector3.transformNormal(this, m, this);
        return this;
      }
    }, {
      key: "transformToVec3",
      value: function transformToVec3(m) {
        Vector3.transformToVec3(this, m, this);
        return this;
      }
    }, {
      key: "transformCoordinate",
      value: function transformCoordinate(m) {
        Vector3.transformCoordinate(this, m, this);
        return this;
      }
    }, {
      key: "transformByQuat",
      value: function transformByQuat(q) {
        Vector3.transformByQuat(this, q, this);
        return this;
      }
    }]);

    return Vector3;
  }();

  Vector3._zero = new Vector3(0, 0, 0);
  Vector3._one = new Vector3(1, 1, 1);
  Vector3._tempVector3 = new Vector3();

  var BoundingSphere = /*#__PURE__*/function () {
    function BoundingSphere(minLocal, maxLocal, modelMatrix) {
      _classCallCheck(this, BoundingSphere);

      this.center = new Vector3();
      this.radius = 0;
      this.centerWorld = new Vector3();
      this.radiusWorld = 0;
      var distance = Vector3.distance(minLocal, maxLocal);
      this.radius = distance * 0.5;
      Vector3.add(minLocal, maxLocal, this.center);
      this.center.scale(0.5);
      this.updateByModelMatrix(modelMatrix);
    }

    _createClass(BoundingSphere, [{
      key: "updateByModelMatrix",
      value: function updateByModelMatrix(modelMatrix) {
        Vector3.transformCoordinate(this.center, modelMatrix, this.centerWorld);
        this.radiusWorld = this.radius * getMaxScaleByModelMatrix(modelMatrix);
      }
    }, {
      key: "intersectsFrustum",
      value: function intersectsFrustum(frustumPlanes) {
        for (var i = 0; i < 6; i++) {
          var distance = pointDistanceToPlane(frustumPlanes[i], this.centerWorld);

          if (distance < -this.radiusWorld) {
            return IntersectInfo.EXCLUDE;
          }

          if (distance < this.radiusWorld) {
            return IntersectInfo.INTERSECT;
          }
        }

        return IntersectInfo.INCLUDE;
      }
    }, {
      key: "isInFrustum",
      value: function isInFrustum(frustumPlanes) {
        for (var i = 0; i < 6; i++) {
          var distance = pointDistanceToPlane(frustumPlanes[i], this.centerWorld);

          if (distance < -this.radiusWorld) {
            return false;
          }
        }

        return true;
      }
    }]);

    return BoundingSphere;
  }();

  var BoundingBox = /*#__PURE__*/function () {
    function BoundingBox(minWorld, maxWorld) {
      _classCallCheck(this, BoundingBox);

      this.min = new Vector3();
      this.max = new Vector3();
      this.update(minWorld, maxWorld);
    }

    _createClass(BoundingBox, [{
      key: "update",
      value: function update(minWorld, maxWorld) {
        minWorld.cloneTo(this.min);
        maxWorld.cloneTo(this.max);
      }
    }, {
      key: "setFromCenterAndSize",
      value: function setFromCenterAndSize(center, size) {
        var halfSize = new Vector3();
        Vector3.scale(size, 0.5, halfSize);
        Vector3.subtract(center, halfSize, this.min);
        Vector3.add(center, halfSize, this.max);
      }
    }, {
      key: "intersectsFrustum",
      value: function intersectsFrustum(frustumPlanes) {
        var min = this.min,
            max = this.max;
        var p1 = new Vector3();
        var p2 = new Vector3();

        for (var i = 0; i < 6; i++) {
          var plane = frustumPlanes[i];
          p1.x = plane.x > 0 ? min.x : max.x;
          p2.x = plane.x > 0 ? max.x : min.x;
          p1.y = plane.y > 0 ? min.y : max.y;
          p2.y = plane.y > 0 ? max.y : min.y;
          p1.z = plane.z > 0 ? min.z : max.z;
          p2.z = plane.z > 0 ? max.z : min.z;
          var d1 = pointDistanceToPlane(plane, p1);
          var d2 = pointDistanceToPlane(plane, p2);

          if (d1 < 0 && d2 < 0) {
            return IntersectInfo.EXCLUDE;
          }

          if (d1 < 0 || d2 < 0) {
            return IntersectInfo.INTERSECT;
          }
        }

        return IntersectInfo.INCLUDE;
      }
    }, {
      key: "isInFrustum",
      value: function isInFrustum(frustumPlanes) {
        var min = this.min;
        var max = this.max;
        var p = new Vector3();

        for (var i = 0; i < 6; i++) {
          var plane = frustumPlanes[i];
          p.x = plane.x > 0 ? max.x : min.x;
          p.y = plane.y > 0 ? max.y : min.y;
          p.z = plane.z > 0 ? max.z : min.z;

          if (pointDistanceToPlane(plane, p) < 0) {
            return false;
          }
        }

        return true;
      }
    }, {
      key: "clone",
      value: function clone() {
        return new BoundingBox(this.min, this.max);
      }
    }, {
      key: "cloneTo",
      value: function cloneTo(out) {
        this.min.cloneTo(out.min);
        this.max.cloneTo(out.max);
      }
    }]);

    return BoundingBox;
  }();

  var Matrix3x3 = /*#__PURE__*/function () {
    function Matrix3x3() {
      var m11 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var m12 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var m13 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var m21 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var m22 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
      var m23 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
      var m31 = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
      var m32 = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
      var m33 = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 1;

      _classCallCheck(this, Matrix3x3);

      this.elements = new Float32Array(9);
      var e = this.elements;
      e[0] = m11;
      e[1] = m12;
      e[2] = m13;
      e[3] = m21;
      e[4] = m22;
      e[5] = m23;
      e[6] = m31;
      e[7] = m32;
      e[8] = m33;
    }

    _createClass(Matrix3x3, [{
      key: "setValue",
      value: function setValue(m11, m12, m13, m21, m22, m23, m31, m32, m33) {
        var e = this.elements;
        e[0] = m11;
        e[1] = m12;
        e[2] = m13;
        e[3] = m21;
        e[4] = m22;
        e[5] = m23;
        e[6] = m31;
        e[7] = m32;
        e[8] = m33;
        return this;
      }
    }, {
      key: "setValueByArray",
      value: function setValueByArray(array) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var srce = this.elements;

        for (var i = 0; i < 12; i++) {
          srce[i] = array[i + offset];
        }

        return this;
      }
    }, {
      key: "setValueByMatrix",
      value: function setValueByMatrix(a) {
        var ae = a.elements;
        var e = this.elements;
        e[0] = ae[0];
        e[1] = ae[1];
        e[2] = ae[2];
        e[3] = ae[4];
        e[4] = ae[5];
        e[5] = ae[6];
        e[6] = ae[8];
        e[7] = ae[9];
        e[8] = ae[10];
        return this;
      }
    }, {
      key: "toArray",
      value: function toArray(out) {
        var outOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var e = this.elements;
        out[outOffset] = e[0];
        out[outOffset + 1] = e[1];
        out[outOffset + 2] = e[2];
        out[outOffset + 3] = e[3];
        out[outOffset + 4] = e[4];
        out[outOffset + 5] = e[5];
        out[outOffset + 6] = e[6];
        out[outOffset + 7] = e[7];
        out[outOffset + 8] = e[8];
      }
    }, {
      key: "clone",
      value: function clone() {
        var e = this.elements;
        var ret = new Matrix3x3(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8]);
        return ret;
      }
    }, {
      key: "cloneTo",
      value: function cloneTo(out) {
        var e = this.elements;
        var oe = out.elements;
        oe[0] = e[0];
        oe[1] = e[1];
        oe[2] = e[2];
        oe[3] = e[3];
        oe[4] = e[4];
        oe[5] = e[5];
        oe[6] = e[6];
        oe[7] = e[7];
        oe[8] = e[8];
        return out;
      }
    }, {
      key: "add",
      value: function add(right) {
        Matrix3x3.add(this, right, this);
        return this;
      }
    }, {
      key: "subtract",
      value: function subtract(right) {
        Matrix3x3.subtract(this, right, this);
        return this;
      }
    }, {
      key: "multiply",
      value: function multiply(right) {
        Matrix3x3.multiply(this, right, this);
        return this;
      }
    }, {
      key: "determinant",
      value: function determinant() {
        var e = this.elements;
        var a11 = e[0],
            a12 = e[1],
            a13 = e[2];
        var a21 = e[3],
            a22 = e[4],
            a23 = e[5];
        var a31 = e[6],
            a32 = e[7],
            a33 = e[8];
        var b12 = a33 * a22 - a23 * a32;
        var b22 = -a33 * a21 + a23 * a31;
        var b32 = a32 * a21 - a22 * a31;
        return a11 * b12 + a12 * b22 + a13 * b32;
      }
    }, {
      key: "identity",
      value: function identity() {
        var e = this.elements;
        e[0] = 1;
        e[1] = 0;
        e[2] = 0;
        e[3] = 0;
        e[4] = 1;
        e[5] = 0;
        e[6] = 0;
        e[7] = 0;
        e[8] = 1;
        return this;
      }
    }, {
      key: "invert",
      value: function invert() {
        Matrix3x3.invert(this, this);
        return this;
      }
    }, {
      key: "rotate",
      value: function rotate(r) {
        Matrix3x3.rotate(this, r, this);
        return this;
      }
    }, {
      key: "scale",
      value: function scale(s) {
        Matrix3x3.scale(this, s, this);
        return this;
      }
    }, {
      key: "translate",
      value: function translate(trans) {
        Matrix3x3.translate(this, trans, this);
        return this;
      }
    }, {
      key: "transpose",
      value: function transpose() {
        Matrix3x3.transpose(this, this);
        return this;
      }
    }], [{
      key: "add",
      value: function add(left, right, out) {
        var le = left.elements;
        var re = right.elements;
        var oe = out.elements;
        oe[0] = le[0] + re[0];
        oe[1] = le[1] + re[1];
        oe[2] = le[2] + re[2];
        oe[3] = le[3] + re[3];
        oe[4] = le[4] + re[4];
        oe[5] = le[5] + re[5];
        oe[6] = le[6] + re[6];
        oe[7] = le[7] + re[7];
        oe[8] = le[8] + re[8];
      }
    }, {
      key: "subtract",
      value: function subtract(left, right, out) {
        var le = left.elements;
        var re = right.elements;
        var oe = out.elements;
        oe[0] = le[0] - re[0];
        oe[1] = le[1] - re[1];
        oe[2] = le[2] - re[2];
        oe[3] = le[3] - re[3];
        oe[4] = le[4] - re[4];
        oe[5] = le[5] - re[5];
        oe[6] = le[6] - re[6];
        oe[7] = le[7] - re[7];
        oe[8] = le[8] - re[8];
      }
    }, {
      key: "multiply",
      value: function multiply(left, right, out) {
        var le = left.elements;
        var re = right.elements;
        var oe = out.elements;
        var l11 = le[0],
            l12 = le[1],
            l13 = le[2];
        var l21 = le[3],
            l22 = le[4],
            l23 = le[5];
        var l31 = le[6],
            l32 = le[7],
            l33 = le[8];
        var r11 = re[0],
            r12 = re[1],
            r13 = re[2];
        var r21 = re[3],
            r22 = re[4],
            r23 = re[5];
        var r31 = re[6],
            r32 = re[7],
            r33 = re[8];
        oe[0] = l11 * r11 + l21 * r12 + l31 * r13;
        oe[1] = l12 * r11 + l22 * r12 + l32 * r13;
        oe[2] = l13 * r11 + l23 * r12 + l33 * r13;
        oe[3] = l11 * r21 + l21 * r22 + l31 * r23;
        oe[4] = l12 * r21 + l22 * r22 + l32 * r23;
        oe[5] = l13 * r21 + l23 * r22 + l33 * r23;
        oe[6] = l11 * r31 + l21 * r32 + l31 * r33;
        oe[7] = l12 * r31 + l22 * r32 + l32 * r33;
        oe[8] = l13 * r31 + l23 * r32 + l33 * r33;
      }
    }, {
      key: "equals",
      value: function equals(left, right) {
        var le = left.elements;
        var re = right.elements;
        return MathUtil.equals(le[0], re[0]) && MathUtil.equals(le[1], re[1]) && MathUtil.equals(le[2], re[2]) && MathUtil.equals(le[3], re[3]) && MathUtil.equals(le[4], re[4]) && MathUtil.equals(le[5], re[5]) && MathUtil.equals(le[6], re[6]) && MathUtil.equals(le[7], re[7]) && MathUtil.equals(le[8], re[8]);
      }
    }, {
      key: "rotationQuaternion",
      value: function rotationQuaternion(q, out) {
        var oe = out.elements;
        var x = q.x,
            y = q.y,
            z = q.z,
            w = q.w;
        var x2 = x + x;
        var y2 = y + y;
        var z2 = z + z;
        var xx = x * x2;
        var yx = y * x2;
        var yy = y * y2;
        var zx = z * x2;
        var zy = z * y2;
        var zz = z * z2;
        var wx = w * x2;
        var wy = w * y2;
        var wz = w * z2;
        oe[0] = 1 - yy - zz;
        oe[3] = yx - wz;
        oe[6] = zx + wy;
        oe[1] = yx + wz;
        oe[4] = 1 - xx - zz;
        oe[7] = zy - wx;
        oe[2] = zx - wy;
        oe[5] = zy + wx;
        oe[8] = 1 - xx - yy;
      }
    }, {
      key: "scaling",
      value: function scaling(s, out) {
        var oe = out.elements;
        oe[0] = s.x;
        oe[1] = 0;
        oe[2] = 0;
        oe[3] = 0;
        oe[4] = s.y;
        oe[5] = 0;
        oe[6] = 0;
        oe[7] = 0;
        oe[8] = 1;
      }
    }, {
      key: "translation",
      value: function translation(trans, out) {
        var oe = out.elements;
        oe[0] = 1;
        oe[1] = 0;
        oe[2] = 0;
        oe[3] = 0;
        oe[4] = 1;
        oe[5] = 0;
        oe[6] = trans.x;
        oe[7] = trans.y;
        oe[8] = 1;
      }
    }, {
      key: "invert",
      value: function invert(a, out) {
        var ae = a.elements;
        var oe = out.elements;
        var a11 = ae[0],
            a12 = ae[1],
            a13 = ae[2];
        var a21 = ae[3],
            a22 = ae[4],
            a23 = ae[5];
        var a31 = ae[6],
            a32 = ae[7],
            a33 = ae[8];
        var b12 = a33 * a22 - a23 * a32;
        var b22 = -a33 * a21 + a23 * a31;
        var b32 = a32 * a21 - a22 * a31;
        var det = a11 * b12 + a12 * b22 + a13 * b32;

        if (!det) {
          return;
        }

        det = 1 / det;
        oe[0] = b12 * det;
        oe[1] = (-a33 * a12 + a13 * a32) * det;
        oe[2] = (a23 * a12 - a13 * a22) * det;
        oe[3] = b22 * det;
        oe[4] = (a33 * a11 - a13 * a31) * det;
        oe[5] = (-a23 * a11 + a13 * a21) * det;
        oe[6] = b32 * det;
        oe[7] = (-a32 * a11 + a12 * a31) * det;
        oe[8] = (a22 * a11 - a12 * a21) * det;
      }
    }, {
      key: "normalMatrix",
      value: function normalMatrix(mat4, out) {
        var ae = mat4.elements;
        var oe = out.elements;
        var a11 = ae[0],
            a12 = ae[1],
            a13 = ae[2],
            a14 = ae[3];
        var a21 = ae[4],
            a22 = ae[5],
            a23 = ae[6],
            a24 = ae[7];
        var a31 = ae[8],
            a32 = ae[9],
            a33 = ae[10],
            a34 = ae[11];
        var a41 = ae[12],
            a42 = ae[13],
            a43 = ae[14],
            a44 = ae[15];
        var b00 = a11 * a22 - a12 * a21;
        var b01 = a11 * a23 - a13 * a21;
        var b02 = a11 * a24 - a14 * a21;
        var b03 = a12 * a23 - a13 * a22;
        var b04 = a12 * a24 - a14 * a22;
        var b05 = a13 * a24 - a14 * a23;
        var b06 = a31 * a42 - a32 * a41;
        var b07 = a31 * a43 - a33 * a41;
        var b08 = a31 * a44 - a34 * a41;
        var b09 = a32 * a43 - a33 * a42;
        var b10 = a32 * a44 - a34 * a42;
        var b11 = a33 * a44 - a34 * a43;
        var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

        if (!det) {
          return null;
        }

        det = 1 / det;
        oe[0] = (a22 * b11 - a23 * b10 + a24 * b09) * det;
        oe[1] = (a23 * b08 - a21 * b11 - a24 * b07) * det;
        oe[2] = (a21 * b10 - a22 * b08 + a24 * b06) * det;
        oe[3] = (a13 * b10 - a12 * b11 - a14 * b09) * det;
        oe[4] = (a11 * b11 - a13 * b08 + a14 * b07) * det;
        oe[5] = (a12 * b08 - a11 * b10 - a14 * b06) * det;
        oe[6] = (a42 * b05 - a43 * b04 + a44 * b03) * det;
        oe[7] = (a43 * b02 - a41 * b05 - a44 * b01) * det;
        oe[8] = (a41 * b04 - a42 * b02 + a44 * b00) * det;
      }
    }, {
      key: "rotate",
      value: function rotate(a, r, out) {
        var ae = a.elements;
        var oe = out.elements;
        var s = Math.sin(r);
        var c = Math.cos(r);
        var a11 = ae[0],
            a12 = ae[1],
            a13 = ae[2];
        var a21 = ae[3],
            a22 = ae[4],
            a23 = ae[5];
        var a31 = ae[6],
            a32 = ae[7],
            a33 = ae[8];
        oe[0] = c * a11 + s * a21;
        oe[1] = c * a12 + s * a22;
        oe[2] = c * a13 + s * a23;
        oe[3] = c * a21 - s * a11;
        oe[4] = c * a22 - s * a12;
        oe[5] = c * a23 - s * a13;
        oe[6] = a31;
        oe[7] = a32;
        oe[8] = a33;
      }
    }, {
      key: "scale",
      value: function scale(m, s, out) {
        var x = s.x,
            y = s.y;
        var ae = m.elements;
        var oe = out.elements;
        oe[0] = x * ae[0];
        oe[1] = x * ae[1];
        oe[2] = x * ae[2];
        oe[3] = y * ae[3];
        oe[4] = y * ae[4];
        oe[5] = y * ae[5];
        oe[6] = ae[6];
        oe[7] = ae[7];
        oe[8] = ae[8];
      }
    }, {
      key: "translate",
      value: function translate(m, trans, out) {
        var x = trans.x,
            y = trans.y;
        var ae = m.elements;
        var oe = out.elements;
        var a11 = ae[0],
            a12 = ae[1],
            a13 = ae[2];
        var a21 = ae[3],
            a22 = ae[4],
            a23 = ae[5];
        var a31 = ae[6],
            a32 = ae[7],
            a33 = ae[8];
        oe[0] = a11;
        oe[1] = a12;
        oe[2] = a13;
        oe[3] = a21;
        oe[4] = a22;
        oe[5] = a23;
        oe[6] = x * a11 + y * a21 + a31;
        oe[7] = x * a12 + y * a22 + a32;
        oe[8] = x * a13 + y * a23 + a33;
      }
    }, {
      key: "transpose",
      value: function transpose(a, out) {
        var ae = a.elements;
        var oe = out.elements;

        if (out === a) {
          var a12 = ae[1];
          var a13 = ae[2];
          var a23 = ae[5];
          oe[1] = ae[3];
          oe[2] = ae[6];
          oe[3] = a12;
          oe[5] = ae[7];
          oe[6] = a13;
          oe[7] = a23;
        } else {
          oe[0] = ae[0];
          oe[1] = ae[3];
          oe[2] = ae[6];
          oe[3] = ae[1];
          oe[4] = ae[4];
          oe[5] = ae[7];
          oe[6] = ae[2];
          oe[7] = ae[5];
          oe[8] = ae[8];
        }
      }
    }]);

    return Matrix3x3;
  }();

  var Quaternion = /*#__PURE__*/function () {
    _createClass(Quaternion, null, [{
      key: "add",
      value: function add(left, right, out) {
        out.x = left.x + right.x;
        out.y = left.y + right.y;
        out.z = left.z + right.z;
        out.w = left.w + right.w;
      }
    }, {
      key: "multiply",
      value: function multiply(left, right, out) {
        var ax = left.x,
            ay = left.y,
            az = left.z,
            aw = left.w;
        var bx = right.x,
            by = right.y,
            bz = right.z,
            bw = right.w;
        out.x = ax * bw + aw * bx + ay * bz - az * by;
        out.y = ay * bw + aw * by + az * bx - ax * bz;
        out.z = az * bw + aw * bz + ax * by - ay * bx;
        out.w = aw * bw - ax * bx - ay * by - az * bz;
      }
    }, {
      key: "conjugate",
      value: function conjugate(a, out) {
        out.x = -a.x;
        out.y = -a.y;
        out.z = -a.z;
        out.w = a.w;
      }
    }, {
      key: "dot",
      value: function dot(left, right) {
        return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;
      }
    }, {
      key: "equals",
      value: function equals(left, right) {
        return MathUtil.equals(left.x, right.x) && MathUtil.equals(left.y, right.y) && MathUtil.equals(left.z, right.z) && MathUtil.equals(left.w, right.w);
      }
    }, {
      key: "rotationAxisAngle",
      value: function rotationAxisAngle(axis, rad, out) {
        var normalAxis = Quaternion._tempVector3;
        Vector3.normalize(axis, normalAxis);
        rad *= 0.5;
        var s = Math.sin(rad);
        out.x = normalAxis.x * s;
        out.y = normalAxis.y * s;
        out.z = normalAxis.z * s;
        out.w = Math.cos(rad);
      }
    }, {
      key: "rotationEuler",
      value: function rotationEuler(x, y, z, out) {
        Quaternion.rotationYawPitchRoll(y, x, z, out);
      }
    }, {
      key: "rotationYawPitchRoll",
      value: function rotationYawPitchRoll(yaw, pitch, roll, out) {
        var halfRoll = roll * 0.5;
        var halfPitch = pitch * 0.5;
        var halfYaw = yaw * 0.5;
        var sinRoll = Math.sin(halfRoll);
        var cosRoll = Math.cos(halfRoll);
        var sinPitch = Math.sin(halfPitch);
        var cosPitch = Math.cos(halfPitch);
        var sinYaw = Math.sin(halfYaw);
        var cosYaw = Math.cos(halfYaw);
        var cosYawPitch = cosYaw * cosPitch;
        var sinYawPitch = sinYaw * sinPitch;
        out.x = cosYaw * sinPitch * cosRoll + sinYaw * cosPitch * sinRoll;
        out.y = sinYaw * cosPitch * cosRoll - cosYaw * sinPitch * sinRoll;
        out.z = cosYawPitch * sinRoll - sinYawPitch * cosRoll;
        out.w = cosYawPitch * cosRoll + sinYawPitch * sinRoll;
      }
    }, {
      key: "rotationMatrix3x3",
      value: function rotationMatrix3x3(m, out) {
        var me = m.elements;
        var m11 = me[0],
            m12 = me[1],
            m13 = me[2];
        var m21 = me[3],
            m22 = me[4],
            m23 = me[5];
        var m31 = me[6],
            m32 = me[7],
            m33 = me[8];
        var scale = m11 + m22 + m33;
        var sqrt, half;

        if (scale > 0) {
          sqrt = Math.sqrt(scale + 1);
          out.w = sqrt * 0.5;
          sqrt = 0.5 / sqrt;
          out.x = (m23 - m32) * sqrt;
          out.y = (m31 - m13) * sqrt;
          out.z = (m12 - m21) * sqrt;
        } else if (m11 >= m22 && m11 >= m33) {
          sqrt = Math.sqrt(1 + m11 - m22 - m33);
          half = 0.5 / sqrt;
          out.x = 0.5 * sqrt;
          out.y = (m12 + m21) * half;
          out.z = (m13 + m31) * half;
          out.w = (m23 - m32) * half;
        } else if (m22 > m33) {
          sqrt = Math.sqrt(1 + m22 - m11 - m33);
          half = 0.5 / sqrt;
          out.x = (m21 + m12) * half;
          out.y = 0.5 * sqrt;
          out.z = (m32 + m23) * half;
          out.w = (m31 - m13) * half;
        } else {
          sqrt = Math.sqrt(1 + m33 - m11 - m22);
          half = 0.5 / sqrt;
          out.x = (m13 + m31) * half;
          out.y = (m23 + m32) * half;
          out.z = 0.5 * sqrt;
          out.w = (m12 - m21) * half;
        }
      }
    }, {
      key: "invert",
      value: function invert(a, out) {
        var x = a.x,
            y = a.y,
            z = a.z,
            w = a.w;
        var dot = x * x + y * y + z * z + w * w;

        if (dot > MathUtil.zeroTolerance) {
          var invDot = 1 / dot;
          out.x = -x * invDot;
          out.y = -y * invDot;
          out.z = -z * invDot;
          out.w = w * invDot;
        }
      }
    }, {
      key: "lerp",
      value: function lerp(start, end, t, out) {
        var inv = 1 - t;

        if (Quaternion.dot(start, end) >= 0) {
          out.x = start.x * inv + end.x * t;
          out.y = start.y * inv + end.y * t;
          out.z = start.z * inv + end.z * t;
          out.w = start.w * inv + end.w * t;
        } else {
          out.x = start.x * inv - end.x * t;
          out.y = start.y * inv - end.y * t;
          out.z = start.z * inv - end.z * t;
          out.w = start.w * inv - end.w * t;
        }

        out.normalize();
      }
    }, {
      key: "slerp",
      value: function slerp(start, end, t, out) {
        var ax = start.x;
        var ay = start.y;
        var az = start.z;
        var aw = start.w;
        var bx = end.x;
        var by = end.y;
        var bz = end.z;
        var bw = end.w;
        var scale0, scale1;
        var cosom = ax * bx + ay * by + az * bz + aw * bw;

        if (cosom < 0) {
          cosom = -cosom;
          bx = -bx;
          by = -by;
          bz = -bz;
          bw = -bw;
        }

        if (1 - cosom > MathUtil.zeroTolerance) {
          var omega = Math.acos(cosom);
          var sinom = Math.sin(omega);
          scale0 = Math.sin((1 - t) * omega) / sinom;
          scale1 = Math.sin(t * omega) / sinom;
        } else {
          scale0 = 1 - t;
          scale1 = t;
        }

        out.x = scale0 * ax + scale1 * bx;
        out.y = scale0 * ay + scale1 * by;
        out.z = scale0 * az + scale1 * bz;
        out.w = scale0 * aw + scale1 * bw;
      }
    }, {
      key: "normalize",
      value: function normalize(a, out) {
        var x = a.x,
            y = a.y,
            z = a.z,
            w = a.w;
        var len = Math.sqrt(x * x + y * y + z * z + w * w);

        if (len > MathUtil.zeroTolerance) {
          len = 1 / len;
          out.x = x * len;
          out.y = y * len;
          out.z = z * len;
          out.w = w * len;
        }
      }
    }, {
      key: "rotationX",
      value: function rotationX(rad, out) {
        rad *= 0.5;
        var s = Math.sin(rad);
        var c = Math.cos(rad);
        out.x = s;
        out.y = 0;
        out.z = 0;
        out.w = c;
      }
    }, {
      key: "rotationY",
      value: function rotationY(rad, out) {
        rad *= 0.5;
        var s = Math.sin(rad);
        var c = Math.cos(rad);
        out.x = 0;
        out.y = s;
        out.z = 0;
        out.w = c;
      }
    }, {
      key: "rotationZ",
      value: function rotationZ(rad, out) {
        rad *= 0.5;
        var s = Math.sin(rad);
        var c = Math.cos(rad);
        out.x = 0;
        out.y = 0;
        out.z = s;
        out.w = c;
      }
    }, {
      key: "rotateX",
      value: function rotateX(q, rad, out) {
        var x = q.x,
            y = q.y,
            z = q.z,
            w = q.w;
        rad *= 0.5;
        var bx = Math.sin(rad);
        var bw = Math.cos(rad);
        out.x = x * bw + w * bx;
        out.y = y * bw + z * bx;
        out.z = z * bw - y * bx;
        out.w = w * bw - x * bx;
      }
    }, {
      key: "rotateY",
      value: function rotateY(q, rad, out) {
        var x = q.x,
            y = q.y,
            z = q.z,
            w = q.w;
        rad *= 0.5;
        var by = Math.sin(rad);
        var bw = Math.cos(rad);
        out.x = x * bw - z * by;
        out.y = y * bw + w * by;
        out.z = z * bw + x * by;
        out.w = w * bw - y * by;
      }
    }, {
      key: "rotateZ",
      value: function rotateZ(q, rad, out) {
        var x = q.x,
            y = q.y,
            z = q.z,
            w = q.w;
        rad *= 0.5;
        var bz = Math.sin(rad);
        var bw = Math.cos(rad);
        out.x = x * bw + y * bz;
        out.y = y * bw - x * bz;
        out.z = z * bw + w * bz;
        out.w = w * bw - z * bz;
      }
    }, {
      key: "scale",
      value: function scale(a, s, out) {
        out.x = a.x * s;
        out.y = a.y * s;
        out.z = a.z * s;
        out.w = a.w * s;
      }
    }]);

    function Quaternion() {
      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var w = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

      _classCallCheck(this, Quaternion);

      this.x = x;
      this.y = y;
      this.z = z;
      this.w = w;
    }

    _createClass(Quaternion, [{
      key: "setValue",
      value: function setValue(x, y, z, w) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        return this;
      }
    }, {
      key: "setValueByArray",
      value: function setValueByArray(array) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        this.w = array[offset + 3];
        return this;
      }
    }, {
      key: "conjugate",
      value: function conjugate() {
        this.x *= -1;
        this.y *= -1;
        this.z *= -1;
        return this;
      }
    }, {
      key: "getAxisAngle",
      value: function getAxisAngle(out) {
        var x = this.x,
            y = this.y,
            z = this.z;
        var length = x * x + y * y + z * z;

        if (length < MathUtil.zeroTolerance) {
          out.x = 1;
          out.y = 0;
          out.z = 0;
          return 0;
        } else {
          var inv = 1 / length;
          out.x = this.x * inv;
          out.y = this.y * inv;
          out.z = this.z * inv;
          return Math.acos(this.w) * 2;
        }
      }
    }, {
      key: "identity",
      value: function identity() {
        this.x = 0;
        this.y = 0;
        this.z = 0;
        this.w = 1;
        return this;
      }
    }, {
      key: "length",
      value: function length() {
        var x = this.x,
            y = this.y,
            z = this.z,
            w = this.w;
        return Math.sqrt(x * x + y * y + z * z + w * w);
      }
    }, {
      key: "lengthSquared",
      value: function lengthSquared() {
        var x = this.x,
            y = this.y,
            z = this.z,
            w = this.w;
        return x * x + y * y + z * z + w * w;
      }
    }, {
      key: "normalize",
      value: function normalize() {
        Quaternion.normalize(this, this);
        return this;
      }
    }, {
      key: "toEuler",
      value: function toEuler(out) {
        this.toYawPitchRoll(out);
        var t = out.x;
        out.x = out.y;
        out.y = t;
        return out;
      }
    }, {
      key: "toYawPitchRoll",
      value: function toYawPitchRoll(out) {
        var x = this.x,
            y = this.y,
            z = this.z,
            w = this.w;
        var xx = x * x;
        var yy = y * y;
        var zz = z * z;
        var xy = x * y;
        var zw = z * w;
        var zx = z * x;
        var yw = y * w;
        var yz = y * z;
        var xw = x * w;
        out.y = Math.asin(2 * (xw - yz));

        if (Math.cos(out.y) > MathUtil.zeroTolerance) {
          out.z = Math.atan2(2 * (xy + zw), 1 - 2 * (zz + xx));
          out.x = Math.atan2(2 * (zx + yw), 1 - 2 * (yy + xx));
        } else {
          out.z = Math.atan2(-2 * (xy - zw), 1 - 2 * (yy + zz));
          out.x = 0;
        }

        return out;
      }
    }, {
      key: "toArray",
      value: function toArray(out) {
        var outOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        out[outOffset] = this.x;
        out[outOffset + 1] = this.y;
        out[outOffset + 2] = this.z;
        out[outOffset + 3] = this.w;
      }
    }, {
      key: "clone",
      value: function clone() {
        return new Quaternion(this.x, this.y, this.z, this.w);
      }
    }, {
      key: "cloneTo",
      value: function cloneTo(out) {
        out.x = this.x;
        out.y = this.y;
        out.z = this.z;
        out.w = this.w;
        return out;
      }
    }, {
      key: "rotateX",
      value: function rotateX(rad) {
        Quaternion.rotateX(this, rad, this);
        return this;
      }
    }, {
      key: "rotateY",
      value: function rotateY(rad) {
        Quaternion.rotateY(this, rad, this);
        return this;
      }
    }, {
      key: "rotateZ",
      value: function rotateZ(rad) {
        Quaternion.rotateZ(this, rad, this);
        return this;
      }
    }, {
      key: "rotationAxisAngle",
      value: function rotationAxisAngle(axis, rad) {
        Quaternion.rotationAxisAngle(axis, rad, this);
        return this;
      }
    }, {
      key: "multiply",
      value: function multiply(quat) {
        Quaternion.multiply(this, quat, this);
        return this;
      }
    }, {
      key: "invert",
      value: function invert() {
        Quaternion.invert(this, this);
        return this;
      }
    }, {
      key: "dot",
      value: function dot(quat) {
        return Quaternion.dot(this, quat);
      }
    }, {
      key: "lerp",
      value: function lerp(quat, t) {
        Quaternion.lerp(this, quat, t, this);
        return this;
      }
    }]);

    return Quaternion;
  }();

  Quaternion._tempVector3 = new Vector3();

  var Matrix = /*#__PURE__*/function () {
    function Matrix() {
      var m11 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var m12 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var m13 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var m14 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var m21 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var m22 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;
      var m23 = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
      var m24 = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
      var m31 = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;
      var m32 = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;
      var m33 = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 1;
      var m34 = arguments.length > 11 && arguments[11] !== undefined ? arguments[11] : 0;
      var m41 = arguments.length > 12 && arguments[12] !== undefined ? arguments[12] : 0;
      var m42 = arguments.length > 13 && arguments[13] !== undefined ? arguments[13] : 0;
      var m43 = arguments.length > 14 && arguments[14] !== undefined ? arguments[14] : 0;
      var m44 = arguments.length > 15 && arguments[15] !== undefined ? arguments[15] : 1;

      _classCallCheck(this, Matrix);

      this.elements = new Float32Array(16);
      var e = this.elements;
      e[0] = m11;
      e[1] = m12;
      e[2] = m13;
      e[3] = m14;
      e[4] = m21;
      e[5] = m22;
      e[6] = m23;
      e[7] = m24;
      e[8] = m31;
      e[9] = m32;
      e[10] = m33;
      e[11] = m34;
      e[12] = m41;
      e[13] = m42;
      e[14] = m43;
      e[15] = m44;
    }

    _createClass(Matrix, [{
      key: "setValue",
      value: function setValue(m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44) {
        var e = this.elements;
        e[0] = m11;
        e[1] = m12;
        e[2] = m13;
        e[3] = m14;
        e[4] = m21;
        e[5] = m22;
        e[6] = m23;
        e[7] = m24;
        e[8] = m31;
        e[9] = m32;
        e[10] = m33;
        e[11] = m34;
        e[12] = m41;
        e[13] = m42;
        e[14] = m43;
        e[15] = m44;
        return this;
      }
    }, {
      key: "setValueByArray",
      value: function setValueByArray(array) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var srce = this.elements;

        for (var i = 0; i < 16; i++) {
          srce[i] = array[i + offset];
        }

        return this;
      }
    }, {
      key: "toArray",
      value: function toArray(out) {
        var outOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var e = this.elements;
        out[outOffset] = e[0];
        out[outOffset + 1] = e[1];
        out[outOffset + 2] = e[2];
        out[outOffset + 3] = e[3];
        out[outOffset + 4] = e[4];
        out[outOffset + 5] = e[5];
        out[outOffset + 6] = e[6];
        out[outOffset + 7] = e[7];
        out[outOffset + 8] = e[8];
        out[outOffset + 9] = e[9];
        out[outOffset + 10] = e[10];
        out[outOffset + 11] = e[11];
        out[outOffset + 12] = e[12];
        out[outOffset + 13] = e[13];
        out[outOffset + 14] = e[14];
        out[outOffset + 15] = e[15];
      }
    }, {
      key: "clone",
      value: function clone() {
        var e = this.elements;
        var ret = new Matrix(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15]);
        return ret;
      }
    }, {
      key: "cloneTo",
      value: function cloneTo(out) {
        var e = this.elements;
        var oe = out.elements;
        oe[0] = e[0];
        oe[1] = e[1];
        oe[2] = e[2];
        oe[3] = e[3];
        oe[4] = e[4];
        oe[5] = e[5];
        oe[6] = e[6];
        oe[7] = e[7];
        oe[8] = e[8];
        oe[9] = e[9];
        oe[10] = e[10];
        oe[11] = e[11];
        oe[12] = e[12];
        oe[13] = e[13];
        oe[14] = e[14];
        oe[15] = e[15];
        return out;
      }
    }, {
      key: "multiply",
      value: function multiply(right) {
        Matrix.multiply(this, right, this);
        return this;
      }
    }, {
      key: "determinant",
      value: function determinant() {
        var e = this.elements;
        var a11 = e[0],
            a12 = e[1],
            a13 = e[2],
            a14 = e[3];
        var a21 = e[4],
            a22 = e[5],
            a23 = e[6],
            a24 = e[7];
        var a31 = e[8],
            a32 = e[9],
            a33 = e[10],
            a34 = e[11];
        var a41 = e[12],
            a42 = e[13],
            a43 = e[14],
            a44 = e[15];
        var b00 = a11 * a22 - a12 * a21;
        var b01 = a11 * a23 - a13 * a21;
        var b02 = a11 * a24 - a14 * a21;
        var b03 = a12 * a23 - a13 * a22;
        var b04 = a12 * a24 - a14 * a22;
        var b05 = a13 * a24 - a14 * a23;
        var b06 = a31 * a42 - a32 * a41;
        var b07 = a31 * a43 - a33 * a41;
        var b08 = a31 * a44 - a34 * a41;
        var b09 = a32 * a43 - a33 * a42;
        var b10 = a32 * a44 - a34 * a42;
        var b11 = a33 * a44 - a34 * a43;
        return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
      }
    }, {
      key: "decompose",
      value: function decompose(pos, q, s) {
        var rm = Matrix._tempMat30;
        var e = this.elements;
        var rme = rm.elements;
        var m11 = e[0];
        var m12 = e[1];
        var m13 = e[2];
        var m14 = e[3];
        var m21 = e[4];
        var m22 = e[5];
        var m23 = e[6];
        var m24 = e[7];
        var m31 = e[8];
        var m32 = e[9];
        var m33 = e[10];
        var m34 = e[11];
        pos.x = e[12];
        pos.y = e[13];
        pos.z = e[14];
        var xs = Math.sign(m11 * m12 * m13 * m14) < 0 ? -1 : 1;
        var ys = Math.sign(m21 * m22 * m23 * m24) < 0 ? -1 : 1;
        var zs = Math.sign(m31 * m32 * m33 * m34) < 0 ? -1 : 1;
        var sx = xs * Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
        var sy = ys * Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
        var sz = zs * Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
        s.x = sx;
        s.y = sy;
        s.z = sz;

        if (Math.abs(sx) < MathUtil.zeroTolerance || Math.abs(sy) < MathUtil.zeroTolerance || Math.abs(sz) < MathUtil.zeroTolerance) {
          q.identity();
          return false;
        } else {
          var invSX = 1 / sx;
          var invSY = 1 / sy;
          var invSZ = 1 / sz;
          rme[0] = m11 * invSX;
          rme[1] = m12 * invSX;
          rme[2] = m13 * invSX;
          rme[3] = m21 * invSY;
          rme[4] = m22 * invSY;
          rme[5] = m23 * invSY;
          rme[6] = m31 * invSZ;
          rme[7] = m32 * invSZ;
          rme[8] = m33 * invSZ;
          Quaternion.rotationMatrix3x3(rm, q);
          return true;
        }
      }
    }, {
      key: "getRotation",
      value: function getRotation(out) {
        var e = this.elements;
        var trace = e[0] + e[5] + e[10];

        if (trace > MathUtil.zeroTolerance) {
          var S = Math.sqrt(trace + 1) * 2;
          out.w = 0.25 * S;
          out.x = (e[6] - e[9]) / S;
          out.y = (e[8] - e[2]) / S;
          out.z = (e[1] - e[4]) / S;
        } else if (e[0] > e[5] && e[0] > e[10]) {
          var _S = Math.sqrt(1 + e[0] - e[5] - e[10]) * 2;

          out.w = (e[6] - e[9]) / _S;
          out.x = 0.25 * _S;
          out.y = (e[1] + e[4]) / _S;
          out.z = (e[8] + e[2]) / _S;
        } else if (e[5] > e[10]) {
          var _S2 = Math.sqrt(1 + e[5] - e[0] - e[10]) * 2;

          out.w = (e[8] - e[2]) / _S2;
          out.x = (e[1] + e[4]) / _S2;
          out.y = 0.25 * _S2;
          out.z = (e[6] + e[9]) / _S2;
        } else {
          var _S3 = Math.sqrt(1 + e[10] - e[0] - e[5]) * 2;

          out.w = (e[1] - e[4]) / _S3;
          out.x = (e[8] + e[2]) / _S3;
          out.y = (e[6] + e[9]) / _S3;
          out.z = 0.25 * _S3;
        }

        return out;
      }
    }, {
      key: "getScaling",
      value: function getScaling(out) {
        var e = this.elements;
        var m11 = e[0],
            m12 = e[1],
            m13 = e[2];
        var m21 = e[4],
            m22 = e[5],
            m23 = e[6];
        var m31 = e[8],
            m32 = e[9],
            m33 = e[10];
        out.x = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
        out.y = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
        out.z = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
        return out;
      }
    }, {
      key: "getTranslation",
      value: function getTranslation(out) {
        var e = this.elements;
        out.x = e[12];
        out.y = e[13];
        out.z = e[14];
        return out;
      }
    }, {
      key: "identity",
      value: function identity() {
        var e = this.elements;
        e[0] = 1;
        e[1] = 0;
        e[2] = 0;
        e[3] = 0;
        e[4] = 0;
        e[5] = 1;
        e[6] = 0;
        e[7] = 0;
        e[8] = 0;
        e[9] = 0;
        e[10] = 1;
        e[11] = 0;
        e[12] = 0;
        e[13] = 0;
        e[14] = 0;
        e[15] = 1;
        return this;
      }
    }, {
      key: "invert",
      value: function invert() {
        Matrix.invert(this, this);
        return this;
      }
    }, {
      key: "rotateAxisAngle",
      value: function rotateAxisAngle(axis, r) {
        Matrix.rotateAxisAngle(this, axis, r, this);
        return this;
      }
    }, {
      key: "scale",
      value: function scale(s) {
        Matrix.scale(this, s, this);
        return this;
      }
    }, {
      key: "translate",
      value: function translate(v) {
        Matrix.translate(this, v, this);
        return this;
      }
    }, {
      key: "transpose",
      value: function transpose() {
        Matrix.transpose(this, this);
        return this;
      }
    }], [{
      key: "multiply",
      value: function multiply(left, right, out) {
        var le = left.elements;
        var re = right.elements;
        var oe = out.elements;
        var l11 = le[0],
            l12 = le[1],
            l13 = le[2],
            l14 = le[3];
        var l21 = le[4],
            l22 = le[5],
            l23 = le[6],
            l24 = le[7];
        var l31 = le[8],
            l32 = le[9],
            l33 = le[10],
            l34 = le[11];
        var l41 = le[12],
            l42 = le[13],
            l43 = le[14],
            l44 = le[15];
        var r11 = re[0],
            r12 = re[1],
            r13 = re[2],
            r14 = re[3];
        var r21 = re[4],
            r22 = re[5],
            r23 = re[6],
            r24 = re[7];
        var r31 = re[8],
            r32 = re[9],
            r33 = re[10],
            r34 = re[11];
        var r41 = re[12],
            r42 = re[13],
            r43 = re[14],
            r44 = re[15];
        oe[0] = l11 * r11 + l21 * r12 + l31 * r13 + l41 * r14;
        oe[1] = l12 * r11 + l22 * r12 + l32 * r13 + l42 * r14;
        oe[2] = l13 * r11 + l23 * r12 + l33 * r13 + l43 * r14;
        oe[3] = l14 * r11 + l24 * r12 + l34 * r13 + l44 * r14;
        oe[4] = l11 * r21 + l21 * r22 + l31 * r23 + l41 * r24;
        oe[5] = l12 * r21 + l22 * r22 + l32 * r23 + l42 * r24;
        oe[6] = l13 * r21 + l23 * r22 + l33 * r23 + l43 * r24;
        oe[7] = l14 * r21 + l24 * r22 + l34 * r23 + l44 * r24;
        oe[8] = l11 * r31 + l21 * r32 + l31 * r33 + l41 * r34;
        oe[9] = l12 * r31 + l22 * r32 + l32 * r33 + l42 * r34;
        oe[10] = l13 * r31 + l23 * r32 + l33 * r33 + l43 * r34;
        oe[11] = l14 * r31 + l24 * r32 + l34 * r33 + l44 * r34;
        oe[12] = l11 * r41 + l21 * r42 + l31 * r43 + l41 * r44;
        oe[13] = l12 * r41 + l22 * r42 + l32 * r43 + l42 * r44;
        oe[14] = l13 * r41 + l23 * r42 + l33 * r43 + l43 * r44;
        oe[15] = l14 * r41 + l24 * r42 + l34 * r43 + l44 * r44;
      }
    }, {
      key: "equals",
      value: function equals(left, right) {
        var le = left.elements;
        var re = right.elements;
        return MathUtil.equals(le[0], re[0]) && MathUtil.equals(le[1], re[1]) && MathUtil.equals(le[2], re[2]) && MathUtil.equals(le[3], re[3]) && MathUtil.equals(le[4], re[4]) && MathUtil.equals(le[5], re[5]) && MathUtil.equals(le[6], re[6]) && MathUtil.equals(le[7], re[7]) && MathUtil.equals(le[8], re[8]) && MathUtil.equals(le[9], re[9]) && MathUtil.equals(le[10], re[10]) && MathUtil.equals(le[11], re[11]) && MathUtil.equals(le[12], re[12]) && MathUtil.equals(le[13], re[13]) && MathUtil.equals(le[14], re[14]) && MathUtil.equals(le[15], re[15]);
      }
    }, {
      key: "rotationQuaternion",
      value: function rotationQuaternion(q, out) {
        var oe = out.elements;
        var x = q.x,
            y = q.y,
            z = q.z,
            w = q.w;
        var x2 = x + x;
        var y2 = y + y;
        var z2 = z + z;
        var xx = x * x2;
        var yx = y * x2;
        var yy = y * y2;
        var zx = z * x2;
        var zy = z * y2;
        var zz = z * z2;
        var wx = w * x2;
        var wy = w * y2;
        var wz = w * z2;
        oe[0] = 1 - yy - zz;
        oe[1] = yx + wz;
        oe[2] = zx - wy;
        oe[3] = 0;
        oe[4] = yx - wz;
        oe[5] = 1 - xx - zz;
        oe[6] = zy + wx;
        oe[7] = 0;
        oe[8] = zx + wy;
        oe[9] = zy - wx;
        oe[10] = 1 - xx - yy;
        oe[11] = 0;
        oe[12] = 0;
        oe[13] = 0;
        oe[14] = 0;
        oe[15] = 1;
      }
    }, {
      key: "rotationAxisAngle",
      value: function rotationAxisAngle(axis, r, out) {
        var oe = out.elements;
        var x = axis.x,
            y = axis.y,
            z = axis.z;
        var len = Math.sqrt(x * x + y * y + z * z);
        var s, c, t;

        if (Math.abs(len) < MathUtil.zeroTolerance) {
          return;
        }

        len = 1 / len;
        x *= len;
        y *= len;
        z *= len;
        s = Math.sin(r);
        c = Math.cos(r);
        t = 1 - c;
        oe[0] = x * x * t + c;
        oe[1] = y * x * t + z * s;
        oe[2] = z * x * t - y * s;
        oe[3] = 0;
        oe[4] = x * y * t - z * s;
        oe[5] = y * y * t + c;
        oe[6] = z * y * t + x * s;
        oe[7] = 0;
        oe[8] = x * z * t + y * s;
        oe[9] = y * z * t - x * s;
        oe[10] = z * z * t + c;
        oe[11] = 0;
        oe[12] = 0;
        oe[13] = 0;
        oe[14] = 0;
        oe[15] = 1;
      }
    }, {
      key: "rotationTranslation",
      value: function rotationTranslation(q, trans, out) {
        Matrix.rotationQuaternion(q, out);
        var oe = out.elements;
        oe[12] = trans.x;
        oe[13] = trans.y;
        oe[14] = trans.z;
      }
    }, {
      key: "affineTransformation",
      value: function affineTransformation(scale, rotation, trans, out) {
        var oe = out.elements;
        var x = rotation.x,
            y = rotation.y,
            z = rotation.z,
            w = rotation.w;
        var x2 = x + x;
        var y2 = y + y;
        var z2 = z + z;
        var xx = x * x2;
        var xy = x * y2;
        var xz = x * z2;
        var yy = y * y2;
        var yz = y * z2;
        var zz = z * z2;
        var wx = w * x2;
        var wy = w * y2;
        var wz = w * z2;
        var sx = scale.x;
        var sy = scale.y;
        var sz = scale.z;
        oe[0] = (1 - (yy + zz)) * sx;
        oe[1] = (xy + wz) * sx;
        oe[2] = (xz - wy) * sx;
        oe[3] = 0;
        oe[4] = (xy - wz) * sy;
        oe[5] = (1 - (xx + zz)) * sy;
        oe[6] = (yz + wx) * sy;
        oe[7] = 0;
        oe[8] = (xz + wy) * sz;
        oe[9] = (yz - wx) * sz;
        oe[10] = (1 - (xx + yy)) * sz;
        oe[11] = 0;
        oe[12] = trans.x;
        oe[13] = trans.y;
        oe[14] = trans.z;
        oe[15] = 1;
      }
    }, {
      key: "scaling",
      value: function scaling(s, out) {
        var oe = out.elements;
        oe[0] = s.x;
        oe[1] = 0;
        oe[2] = 0;
        oe[3] = 0;
        oe[4] = 0;
        oe[5] = s.y;
        oe[6] = 0;
        oe[7] = 0;
        oe[8] = 0;
        oe[9] = 0;
        oe[10] = s.z;
        oe[11] = 0;
        oe[12] = 0;
        oe[13] = 0;
        oe[14] = 0;
        oe[15] = 1;
      }
    }, {
      key: "translation",
      value: function translation(trans, out) {
        var oe = out.elements;
        oe[0] = 1;
        oe[1] = 0;
        oe[2] = 0;
        oe[3] = 0;
        oe[4] = 0;
        oe[5] = 1;
        oe[6] = 0;
        oe[7] = 0;
        oe[8] = 0;
        oe[9] = 0;
        oe[10] = 1;
        oe[11] = 0;
        oe[12] = trans.x;
        oe[13] = trans.y;
        oe[14] = trans.z;
        oe[15] = 1;
      }
    }, {
      key: "invert",
      value: function invert(a, out) {
        var ae = a.elements;
        var oe = out.elements;
        var a11 = ae[0],
            a12 = ae[1],
            a13 = ae[2],
            a14 = ae[3];
        var a21 = ae[4],
            a22 = ae[5],
            a23 = ae[6],
            a24 = ae[7];
        var a31 = ae[8],
            a32 = ae[9],
            a33 = ae[10],
            a34 = ae[11];
        var a41 = ae[12],
            a42 = ae[13],
            a43 = ae[14],
            a44 = ae[15];
        var b00 = a11 * a22 - a12 * a21;
        var b01 = a11 * a23 - a13 * a21;
        var b02 = a11 * a24 - a14 * a21;
        var b03 = a12 * a23 - a13 * a22;
        var b04 = a12 * a24 - a14 * a22;
        var b05 = a13 * a24 - a14 * a23;
        var b06 = a31 * a42 - a32 * a41;
        var b07 = a31 * a43 - a33 * a41;
        var b08 = a31 * a44 - a34 * a41;
        var b09 = a32 * a43 - a33 * a42;
        var b10 = a32 * a44 - a34 * a42;
        var b11 = a33 * a44 - a34 * a43;
        var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

        if (!det) {
          return null;
        }

        det = 1 / det;
        oe[0] = (a22 * b11 - a23 * b10 + a24 * b09) * det;
        oe[1] = (a13 * b10 - a12 * b11 - a14 * b09) * det;
        oe[2] = (a42 * b05 - a43 * b04 + a44 * b03) * det;
        oe[3] = (a33 * b04 - a32 * b05 - a34 * b03) * det;
        oe[4] = (a23 * b08 - a21 * b11 - a24 * b07) * det;
        oe[5] = (a11 * b11 - a13 * b08 + a14 * b07) * det;
        oe[6] = (a43 * b02 - a41 * b05 - a44 * b01) * det;
        oe[7] = (a31 * b05 - a33 * b02 + a34 * b01) * det;
        oe[8] = (a21 * b10 - a22 * b08 + a24 * b06) * det;
        oe[9] = (a12 * b08 - a11 * b10 - a14 * b06) * det;
        oe[10] = (a41 * b04 - a42 * b02 + a44 * b00) * det;
        oe[11] = (a32 * b02 - a31 * b04 - a34 * b00) * det;
        oe[12] = (a22 * b07 - a21 * b09 - a23 * b06) * det;
        oe[13] = (a11 * b09 - a12 * b07 + a13 * b06) * det;
        oe[14] = (a42 * b01 - a41 * b03 - a43 * b00) * det;
        oe[15] = (a31 * b03 - a32 * b01 + a33 * b00) * det;
      }
    }, {
      key: "lookAt",
      value: function lookAt(eye, target, up, out) {
        var oe = out.elements;
        var xAxis = Matrix._tempVec30;
        var yAxis = Matrix._tempVec31;
        var zAxis = Matrix._tempVec32;
        Vector3.subtract(eye, target, zAxis);
        zAxis.normalize();
        Vector3.cross(up, zAxis, xAxis);
        xAxis.normalize();
        Vector3.cross(zAxis, xAxis, yAxis);
        oe[0] = xAxis.x;
        oe[1] = yAxis.x;
        oe[2] = zAxis.x;
        oe[3] = 0;
        oe[4] = xAxis.y;
        oe[5] = yAxis.y;
        oe[6] = zAxis.y;
        oe[7] = 0;
        oe[8] = xAxis.z;
        oe[9] = yAxis.z;
        oe[10] = zAxis.z;
        oe[11] = 0;
        oe[12] = -Vector3.dot(xAxis, eye);
        oe[13] = -Vector3.dot(yAxis, eye);
        oe[14] = -Vector3.dot(zAxis, eye);
        oe[15] = 1;
      }
    }, {
      key: "ortho",
      value: function ortho(left, right, bottom, top, near, far, out) {
        var oe = out.elements;
        var lr = 1 / (left - right);
        var bt = 1 / (bottom - top);
        var nf = 1 / (near - far);
        oe[0] = -2 * lr;
        oe[1] = 0;
        oe[2] = 0;
        oe[3] = 0;
        oe[4] = 0;
        oe[5] = -2 * bt;
        oe[6] = 0;
        oe[7] = 0;
        oe[8] = 0;
        oe[9] = 0;
        oe[10] = 2 * nf;
        oe[11] = 0;
        oe[12] = (left + right) * lr;
        oe[13] = (top + bottom) * bt;
        oe[14] = (far + near) * nf;
        oe[15] = 1;
      }
    }, {
      key: "perspective",
      value: function perspective(fovy, aspect, near, far, out) {
        var oe = out.elements;
        var f = 1 / Math.tan(fovy / 2);
        var nf = 1 / (near - far);
        oe[0] = f / aspect;
        oe[1] = 0;
        oe[2] = 0;
        oe[3] = 0;
        oe[4] = 0;
        oe[5] = f;
        oe[6] = 0;
        oe[7] = 0;
        oe[8] = 0;
        oe[9] = 0;
        oe[10] = (far + near) * nf;
        oe[11] = -1;
        oe[12] = 0;
        oe[13] = 0;
        oe[14] = 2 * far * near * nf;
        oe[15] = 0;
      }
    }, {
      key: "rotateAxisAngle",
      value: function rotateAxisAngle(m, axis, r, out) {
        var x = axis.x,
            y = axis.y,
            z = axis.z;
        var len = Math.sqrt(x * x + y * y + z * z);

        if (Math.abs(len) < MathUtil.zeroTolerance) {
          return;
        }

        var me = m.elements;
        var oe = out.elements;
        var s, c, t;
        len = 1 / len;
        x *= len;
        y *= len;
        z *= len;
        s = Math.sin(r);
        c = Math.cos(r);
        t = 1 - c;
        var a11 = me[0],
            a12 = me[1],
            a13 = me[2],
            a14 = me[3];
        var a21 = me[4],
            a22 = me[5],
            a23 = me[6],
            a24 = me[7];
        var a31 = me[8],
            a32 = me[9],
            a33 = me[10],
            a34 = me[11];
        var b11 = x * x * t + c;
        var b12 = y * x * t + z * s;
        var b13 = z * x * t - y * s;
        var b21 = x * y * t - z * s;
        var b22 = y * y * t + c;
        var b23 = z * y * t + x * s;
        var b31 = x * z * t + y * s;
        var b32 = y * z * t - x * s;
        var b33 = z * z * t + c;
        oe[0] = a11 * b11 + a21 * b12 + a31 * b13;
        oe[1] = a12 * b11 + a22 * b12 + a32 * b13;
        oe[2] = a13 * b11 + a23 * b12 + a33 * b13;
        oe[3] = a14 * b11 + a24 * b12 + a34 * b13;
        oe[4] = a11 * b21 + a21 * b22 + a31 * b23;
        oe[5] = a12 * b21 + a22 * b22 + a32 * b23;
        oe[6] = a13 * b21 + a23 * b22 + a33 * b23;
        oe[7] = a14 * b21 + a24 * b22 + a34 * b23;
        oe[8] = a11 * b31 + a21 * b32 + a31 * b33;
        oe[9] = a12 * b31 + a22 * b32 + a32 * b33;
        oe[10] = a13 * b31 + a23 * b32 + a33 * b33;
        oe[11] = a14 * b31 + a24 * b32 + a34 * b33;

        if (m !== out) {
          oe[12] = me[12];
          oe[13] = me[13];
          oe[14] = me[14];
          oe[15] = me[15];
        }
      }
    }, {
      key: "scale",
      value: function scale(m, s, out) {
        var me = m.elements;
        var oe = out.elements;
        var x = s.x,
            y = s.y,
            z = s.z;
        oe[0] = me[0] * x;
        oe[1] = me[1] * x;
        oe[2] = me[2] * x;
        oe[3] = me[3] * x;
        oe[4] = me[4] * y;
        oe[5] = me[5] * y;
        oe[6] = me[6] * y;
        oe[7] = me[7] * y;
        oe[8] = me[8] * z;
        oe[9] = me[9] * z;
        oe[10] = me[10] * z;
        oe[11] = me[11] * z;
        oe[12] = me[12];
        oe[13] = me[13];
        oe[14] = me[14];
        oe[15] = me[15];
      }
    }, {
      key: "translate",
      value: function translate(m, v, out) {
        var me = m.elements;
        var oe = out.elements;
        var x = v.x,
            y = v.y,
            z = v.z;

        if (m === out) {
          oe[12] = me[0] * x + me[4] * y + me[8] * z + me[12];
          oe[13] = me[1] * x + me[5] * y + me[9] * z + me[13];
          oe[14] = me[2] * x + me[6] * y + me[10] * z + me[14];
          oe[15] = me[3] * x + me[7] * y + me[11] * z + me[15];
        } else {
          var a11 = me[0],
              a12 = me[1],
              a13 = me[2],
              a14 = me[3];
          var a21 = me[4],
              a22 = me[5],
              a23 = me[6],
              a24 = me[7];
          var a31 = me[8],
              a32 = me[9],
              a33 = me[10],
              a34 = me[11];
          oe[0] = a11, oe[1] = a12, oe[2] = a13, oe[3] = a14;
          oe[4] = a21, oe[5] = a22, oe[6] = a23, oe[7] = a24;
          oe[8] = a31, oe[9] = a32, oe[10] = a33, oe[11] = a34;
          oe[12] = a11 * x + a21 * y + a31 * z + me[12];
          oe[13] = a12 * x + a22 * y + a32 * z + me[13];
          oe[14] = a13 * x + a23 * y + a33 * z + me[14];
          oe[15] = a14 * x + a24 * y + a34 * z + me[15];
        }
      }
    }, {
      key: "transpose",
      value: function transpose(a, out) {
        var ae = a.elements;
        var oe = out.elements;

        if (out === a) {
          var a12 = ae[1];
          var a13 = ae[2];
          var a14 = ae[3];
          var a23 = ae[6];
          var a24 = ae[7];
          var a34 = ae[11];
          oe[1] = ae[4];
          oe[2] = ae[8];
          oe[3] = ae[12];
          oe[4] = a12;
          oe[6] = ae[9];
          oe[7] = ae[13];
          oe[8] = a13;
          oe[9] = a23;
          oe[11] = ae[14];
          oe[12] = a14;
          oe[13] = a24;
          oe[14] = a34;
        } else {
          oe[0] = ae[0];
          oe[1] = ae[4];
          oe[2] = ae[8];
          oe[3] = ae[12];
          oe[4] = ae[1];
          oe[5] = ae[5];
          oe[6] = ae[9];
          oe[7] = ae[13];
          oe[8] = ae[2];
          oe[9] = ae[6];
          oe[10] = ae[10];
          oe[11] = ae[14];
          oe[12] = ae[3];
          oe[13] = ae[7];
          oe[14] = ae[11];
          oe[15] = ae[15];
        }
      }
    }]);

    return Matrix;
  }();

  Matrix._tempVec30 = new Vector3();
  Matrix._tempVec31 = new Vector3();
  Matrix._tempVec32 = new Vector3();
  Matrix._tempMat30 = new Matrix3x3();
  Matrix._tempMat40 = new Matrix();
  Matrix._identity = new Matrix(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);

  var OBB = /*#__PURE__*/function () {
    function OBB(minLocal, maxLocal, modelMatrix) {
      _classCallCheck(this, OBB);

      this.min = new Vector3();
      this.max = new Vector3();
      this.corners = [];
      this.minWorld = new Vector3();
      this.maxWorld = new Vector3();
      this.cornersWorld = [];
      minLocal.cloneTo(this.min);
      maxLocal.cloneTo(this.max);
      this.corners = this.getCornersFromMinMax(minLocal, maxLocal);
      this.updateByModelMatrix(modelMatrix);
    }

    _createClass(OBB, [{
      key: "getCornersFromMinMax",
      value: function getCornersFromMinMax(min, max) {
        var minX = min.x,
            minY = min.y,
            minZ = min.z,
            maxX = max.x,
            maxY = max.y,
            maxZ = max.z;
        var corners = [new Vector3(minX, minY, minZ), new Vector3(maxX, maxY, maxZ), new Vector3(maxX, minY, minZ), new Vector3(minX, maxY, minZ), new Vector3(minX, minY, maxZ), new Vector3(maxX, maxY, minZ), new Vector3(minX, maxY, maxZ), new Vector3(maxX, minY, maxZ)];
        return corners;
      }
    }, {
      key: "updateByModelMatrix",
      value: function updateByModelMatrix(modelMatrix) {
        var min = this.minWorld;
        var max = this.maxWorld;
        min.setValue(Infinity, Infinity, Infinity);
        max.setValue(-Infinity, -Infinity, -Infinity);

        for (var i = 0; i < 8; ++i) {
          var corner = this.corners[i];
          var cornerWorld = OBB._tempVec3;
          Vector3.transformCoordinate(corner, modelMatrix, cornerWorld);
          Vector3.min(min, cornerWorld, min);
          Vector3.max(max, cornerWorld, max);
          this.cornersWorld[i] = new Vector3();
          cornerWorld.cloneTo(this.cornersWorld[i]);
        }
      }
    }, {
      key: "intersectsFrustum",
      value: function intersectsFrustum(frustumPlanes) {
        var cornersWorld = this.cornersWorld;

        for (var i = 0; i < 6; i++) {
          var plane = frustumPlanes[i];
          var isInPlane = false;

          for (var j = 0; j < 8; j++) {
            if (pointDistanceToPlane(plane, cornersWorld[j]) > 0) {
              isInPlane = true;
            } else if (isInPlane) {
              return IntersectInfo.INTERSECT;
            }
          }

          if (!isInPlane) {
            return IntersectInfo.EXCLUDE;
          }
        }

        return IntersectInfo.INCLUDE;
      }
    }, {
      key: "isInFrustum",
      value: function isInFrustum(frustumPlanes) {
        var cornersWorld = this.cornersWorld;

        for (var i = 0; i < 6; i++) {
          var plane = frustumPlanes[i];
          var isInPlane = false;

          for (var j = 0; j < 8; j++) {
            if (pointDistanceToPlane(plane, cornersWorld[j]) > 0) {
              isInPlane = true;
              break;
            }
          }

          if (!isInPlane) {
            return false;
          }
        }

        return true;
      }
    }]);

    return OBB;
  }();

  OBB._tempVec3 = new Vector3();

  var Ray = /*#__PURE__*/function () {
    function Ray(origin, direction) {
      _classCallCheck(this, Ray);

      this.origin = new Vector3();
      this.direction = new Vector3();
      origin && origin.cloneTo(this.origin);
      direction && direction.cloneTo(this.direction);
    }

    _createClass(Ray, [{
      key: "intersectPlane",
      value: function intersectPlane(point, normal) {
        var origin = this.origin;
        var denom = Vector3.dot(normal, this.direction);

        if (Math.abs(denom) > 1e-6) {
          var p0l0 = new Vector3();
          Vector3.subtract(point, origin, p0l0);
          var t = Vector3.dot(p0l0, normal) / denom;

          if (t >= 0) {
            return t;
          }
        }

        return false;
      }
    }, {
      key: "getPoint",
      value: function getPoint(distance) {
        var point = new Vector3();
        Vector3.scale(this.direction, distance, point);
        return point.add(this.origin);
      }
    }, {
      key: "intersectSphere",
      value: function intersectSphere(center, radius) {
        var dir = this.direction;
        var L = new Vector3();
        Vector3.subtract(this.origin, center, L);
        var a = Vector3.dot(dir, dir);
        var b = 2 * Vector3.dot(dir, L);
        var c = Vector3.dot(L, L) - radius * radius;

        var s = this._solveQuadratic(a, b, c);

        if (s) {
          return s[0];
        } else {
          return false;
        }
      }
    }, {
      key: "intersectAABB",
      value: function intersectAABB(max, min) {
        var dir = this.direction;
        var orig = this.origin;
        var invdir = new Vector3(1 / dir.x, 1 / dir.y, 1 / dir.z);
        var bounds = [min, max];
        var sign = [dir.x < 0 ? 1 : 0, dir.y < 0 ? 1 : 0, dir.z < 0 ? 1 : 0];
        var tmin = (bounds[sign[0]].x - orig.x) * invdir.x;
        var tmax = (bounds[1 - sign[0]].x - orig.x) * invdir.x;
        var tymin = (bounds[sign[1]].y - orig.y) * invdir.y;
        var tymax = (bounds[1 - sign[1]].y - orig.y) * invdir.y;

        if (tmin > tymax || tymin > tmax) {
          return false;
        }

        if (tymin > tmin) {
          tmin = tymin;
        }

        if (tymax < tmax) {
          tmax = tymax;
        }

        var tzmin = (bounds[sign[2]].z - orig.z) * invdir.z;
        var tzmax = (bounds[1 - sign[2]].z - orig.z) * invdir.z;

        if (tmin > tzmax || tzmin > tmax) {
          return false;
        }

        if (tzmin > tmin) {
          tmin = tzmin;
        }

        if (tzmax < tmax) {
          tmax = tzmax;
        }

        var t = tmin;

        if (t < 0) {
          t = tmax;

          if (t < 0) {
            return false;
          }
        }

        return t;
      }
    }, {
      key: "_solveQuadratic",
      value: function _solveQuadratic(a, b, c) {
        var discr = b * b - 4 * a * c;

        if (discr < 0) {
          return false;
        } else if (discr == 0) {
          var x = -0.5 * b / a;
          return [x, x];
        } else {
          var r = Math.sqrt(discr);
          var q = b > 0 ? -0.5 * (b + r) : -0.5 * (b - r);
          var x0 = q / a;
          var x1 = c / q;

          if (x0 <= x1) {
            return [x0, x1];
          } else {
            return [x1, x0];
          }
        }
      }
    }]);

    return Ray;
  }();

  var RaycastHit = function RaycastHit() {
    _classCallCheck(this, RaycastHit);

    this.distance = Number.MAX_VALUE;
    this.collider = null;
    this.point = null;
  };

  var ESP = MathUtil.zeroTolerance;

  var Spherical = /*#__PURE__*/function () {
    function Spherical(radius, phi, theta) {
      _classCallCheck(this, Spherical);

      this.radius = radius !== void 0 ? radius : 1;
      this.phi = phi !== void 0 ? phi : 0;
      this.theta = theta !== void 0 ? theta : 0;
    }

    _createClass(Spherical, [{
      key: "set",
      value: function set(radius, phi, theta) {
        this.radius = radius;
        this.phi = phi;
        this.theta = theta;
        return this;
      }
    }, {
      key: "makeSafe",
      value: function makeSafe() {
        this.phi = MathUtil.clamp(this.phi, ESP, Math.PI - ESP);
        return this;
      }
    }, {
      key: "setFromVec3",
      value: function setFromVec3(v3) {
        this.radius = v3.length();

        if (this.radius === 0) {
          this.theta = 0;
          this.phi = 0;
        } else {
          this.theta = Math.atan2(v3.x, v3.z);
          this.phi = Math.acos(MathUtil.clamp(v3.y / this.radius, -1, 1));
        }

        return this;
      }
    }, {
      key: "setToVec3",
      value: function setToVec3(v3) {
        var sinPhiRadius = Math.sin(this.phi) * this.radius;
        v3.x = sinPhiRadius * Math.sin(this.theta);
        v3.y = Math.cos(this.phi) * this.radius;
        v3.z = sinPhiRadius * Math.cos(this.theta);
        return this;
      }
    }]);

    return Spherical;
  }();

  var Vector2 = /*#__PURE__*/function () {
    _createClass(Vector2, null, [{
      key: "add",
      value: function add(left, right, out) {
        out.x = left.x + right.x;
        out.y = left.y + right.y;
      }
    }, {
      key: "subtract",
      value: function subtract(left, right, out) {
        out.x = left.x - right.x;
        out.y = left.y - right.y;
      }
    }, {
      key: "multiply",
      value: function multiply(left, right, out) {
        out.x = left.x * right.x;
        out.y = left.y * right.y;
      }
    }, {
      key: "divide",
      value: function divide(left, right, out) {
        out.x = left.x / right.x;
        out.y = left.y / right.y;
      }
    }, {
      key: "dot",
      value: function dot(left, right) {
        return left.x * right.x + left.y * right.y;
      }
    }, {
      key: "distance",
      value: function distance(left, right) {
        var x = right.x - left.x;
        var y = right.y - left.y;
        return Math.sqrt(x * x + y * y);
      }
    }, {
      key: "distanceSquared",
      value: function distanceSquared(left, right) {
        var x = right.x - left.x;
        var y = right.y - left.y;
        return x * x + y * y;
      }
    }, {
      key: "equals",
      value: function equals(left, right) {
        return MathUtil.equals(left.x, right.x) && MathUtil.equals(left.y, right.y);
      }
    }, {
      key: "lerp",
      value: function lerp(left, right, t, out) {
        var x = left.x,
            y = left.y;
        out.x = x + (right.x - x) * t;
        out.y = y + (right.y - y) * t;
      }
    }, {
      key: "max",
      value: function max(left, right, out) {
        out.x = Math.max(left.x, right.x);
        out.y = Math.max(left.y, right.y);
      }
    }, {
      key: "min",
      value: function min(left, right, out) {
        out.x = Math.min(left.x, right.x);
        out.y = Math.min(left.y, right.y);
      }
    }, {
      key: "negate",
      value: function negate(left, out) {
        out.x = -left.x;
        out.y = -left.y;
      }
    }, {
      key: "normalize",
      value: function normalize(left, out) {
        var x = left.x,
            y = left.y;
        var len = Math.sqrt(x * x + y * y);

        if (len > MathUtil.zeroTolerance) {
          len = 1 / len;
          out.x = x * len;
          out.y = y * len;
        }
      }
    }, {
      key: "scale",
      value: function scale(left, s, out) {
        out.x = left.x * s;
        out.y = left.y * s;
      }
    }]);

    function Vector2() {
      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      _classCallCheck(this, Vector2);

      this.x = x;
      this.y = y;
    }

    _createClass(Vector2, [{
      key: "setValue",
      value: function setValue(x, y) {
        this.x = x;
        this.y = y;
        return this;
      }
    }, {
      key: "setValueByArray",
      value: function setValueByArray(array) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        this.x = array[offset];
        this.y = array[offset + 1];
        return this;
      }
    }, {
      key: "add",
      value: function add(right) {
        this.x += right.x;
        this.y += right.y;
        return this;
      }
    }, {
      key: "subtract",
      value: function subtract(right) {
        this.x -= right.x;
        this.y -= right.y;
        return this;
      }
    }, {
      key: "multiply",
      value: function multiply(right) {
        this.x *= right.x;
        this.y *= right.y;
        return this;
      }
    }, {
      key: "divide",
      value: function divide(right) {
        this.x /= right.x;
        this.y /= right.y;
        return this;
      }
    }, {
      key: "length",
      value: function length() {
        var x = this.x,
            y = this.y;
        return Math.sqrt(x * x + y * y);
      }
    }, {
      key: "lengthSquared",
      value: function lengthSquared() {
        var x = this.x,
            y = this.y;
        return x * x + y * y;
      }
    }, {
      key: "negate",
      value: function negate() {
        this.x = -this.x;
        this.y = -this.y;
        return this;
      }
    }, {
      key: "normalize",
      value: function normalize() {
        Vector2.normalize(this, this);
        return this;
      }
    }, {
      key: "scale",
      value: function scale(s) {
        this.x *= s;
        this.y *= s;
        return this;
      }
    }, {
      key: "toArray",
      value: function toArray(out) {
        var outOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        out[outOffset] = this.x;
        out[outOffset + 1] = this.y;
      }
    }, {
      key: "clone",
      value: function clone() {
        return new Vector2(this.x, this.y);
      }
    }, {
      key: "cloneTo",
      value: function cloneTo(out) {
        out.x = this.x;
        out.y = this.y;
        return out;
      }
    }]);

    return Vector2;
  }();

  Vector2._zero = new Vector2(0, 0);
  Vector2._one = new Vector2(1, 1);

  var Vector4 = /*#__PURE__*/function () {
    _createClass(Vector4, null, [{
      key: "add",
      value: function add(left, right, out) {
        out.x = left.x + right.x;
        out.y = left.y + right.y;
        out.z = left.z + right.z;
        out.w = left.w + right.w;
      }
    }, {
      key: "subtract",
      value: function subtract(left, right, out) {
        out.x = left.x - right.x;
        out.y = left.y - right.y;
        out.z = left.z - right.z;
        out.w = left.w - right.w;
      }
    }, {
      key: "multiply",
      value: function multiply(left, right, out) {
        out.x = left.x * right.x;
        out.y = left.y * right.y;
        out.z = left.z * right.z;
        out.w = left.w * right.w;
      }
    }, {
      key: "divide",
      value: function divide(left, right, out) {
        out.x = left.x / right.x;
        out.y = left.y / right.y;
        out.z = left.z / right.z;
        out.w = left.w / right.w;
      }
    }, {
      key: "dot",
      value: function dot(left, right) {
        return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;
      }
    }, {
      key: "distance",
      value: function distance(a, b) {
        var x = b.x - a.x;
        var y = b.y - a.y;
        var z = b.z - a.z;
        var w = b.w - a.w;
        return Math.sqrt(x * x + y * y + z * z + w * w);
      }
    }, {
      key: "distanceSquared",
      value: function distanceSquared(a, b) {
        var x = b.x - a.x;
        var y = b.y - a.y;
        var z = b.z - a.z;
        var w = b.w - a.w;
        return x * x + y * y + z * z + w * w;
      }
    }, {
      key: "equals",
      value: function equals(left, right) {
        return MathUtil.equals(left.x, right.x) && MathUtil.equals(left.y, right.y) && MathUtil.equals(left.z, right.z) && MathUtil.equals(left.w, right.w);
      }
    }, {
      key: "lerp",
      value: function lerp(start, end, t, out) {
        var x = start.x,
            y = start.y,
            z = start.z,
            w = start.w;
        out.x = x + (end.x - x) * t;
        out.y = y + (end.y - y) * t;
        out.z = z + (end.z - z) * t;
        out.w = w + (end.w - w) * t;
      }
    }, {
      key: "max",
      value: function max(left, right, out) {
        out.x = Math.max(left.x, right.x);
        out.y = Math.max(left.y, right.y);
        out.z = Math.max(left.z, right.z);
        out.w = Math.max(left.w, right.w);
      }
    }, {
      key: "min",
      value: function min(left, right, out) {
        out.x = Math.min(left.x, right.x);
        out.y = Math.min(left.y, right.y);
        out.z = Math.min(left.z, right.z);
        out.w = Math.min(left.w, right.w);
      }
    }, {
      key: "negate",
      value: function negate(a, out) {
        out.x = -a.x;
        out.y = -a.y;
        out.z = -a.z;
        out.w = -a.w;
      }
    }, {
      key: "normalize",
      value: function normalize(a, out) {
        var x = a.x,
            y = a.y,
            z = a.z,
            w = a.w;
        var len = Math.sqrt(x * x + y * y + z * z + w * w);

        if (len > MathUtil.zeroTolerance) {
          len = 1 / len;
          out.x = x * len;
          out.y = y * len;
          out.z = z * len;
          out.w = w * len;
        }
      }
    }, {
      key: "scale",
      value: function scale(a, s, out) {
        out.x = a.x * s;
        out.y = a.y * s;
        out.z = a.z * s;
        out.w = a.w * s;
      }
    }, {
      key: "transform",
      value: function transform(v, m, out) {
        var x = v.x,
            y = v.y,
            z = v.z,
            w = v.w;
        var e = m.elements;
        out.x = x * e[0] + y * e[4] + z * e[8] + w * e[12];
        out.y = x * e[1] + y * e[5] + z * e[9] + w * e[13];
        out.z = x * e[2] + y * e[6] + z * e[10] + w * e[14];
        out.w = x * e[3] + y * e[7] + z * e[11] + w * e[15];
      }
    }, {
      key: "transformByQuat",
      value: function transformByQuat(v, q, out) {
        var x = v.x,
            y = v.y,
            z = v.z,
            w = v.w;
        var qx = q.x;
        var qy = q.y;
        var qz = q.z;
        var qw = q.w;
        var ix = qw * x + qy * z - qz * y;
        var iy = qw * y + qz * x - qx * z;
        var iz = qw * z + qx * y - qy * x;
        var iw = -qx * x - qy * y - qz * z;
        out.x = ix * qw - iw * qx - iy * qz + iz * qy;
        out.y = iy * qw - iw * qy - iz * qx + ix * qz;
        out.z = iz * qw - iw * qz - ix * qy + iy * qx;
        out.w = w;
      }
    }]);

    function Vector4() {
      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var w = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

      _classCallCheck(this, Vector4);

      this.x = x;
      this.y = y;
      this.z = z;
      this.w = w;
    }

    _createClass(Vector4, [{
      key: "setValue",
      value: function setValue(x, y, z, w) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        return this;
      }
    }, {
      key: "setValueByArray",
      value: function setValueByArray(array) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        this.w = array[offset + 3];
        return this;
      }
    }, {
      key: "add",
      value: function add(right) {
        this.x += right.x;
        this.y += right.y;
        this.z += right.z;
        this.w += right.w;
        return this;
      }
    }, {
      key: "subtract",
      value: function subtract(right) {
        this.x -= right.x;
        this.y -= right.y;
        this.z -= right.z;
        this.w -= right.w;
        return this;
      }
    }, {
      key: "multiply",
      value: function multiply(right) {
        this.x *= right.x;
        this.y *= right.y;
        this.z *= right.z;
        this.w *= right.w;
        return this;
      }
    }, {
      key: "divide",
      value: function divide(right) {
        this.x /= right.x;
        this.y /= right.y;
        this.z /= right.z;
        this.w /= right.w;
        return this;
      }
    }, {
      key: "length",
      value: function length() {
        var x = this.x,
            y = this.y,
            z = this.z,
            w = this.w;
        return Math.sqrt(x * x + y * y + z * z + w * w);
      }
    }, {
      key: "lengthSquared",
      value: function lengthSquared() {
        var x = this.x,
            y = this.y,
            z = this.z,
            w = this.w;
        return x * x + y * y + z * z + w * w;
      }
    }, {
      key: "negate",
      value: function negate() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        this.w = -this.w;
        return this;
      }
    }, {
      key: "normalize",
      value: function normalize() {
        Vector4.normalize(this, this);
        return this;
      }
    }, {
      key: "scale",
      value: function scale(s) {
        this.x *= s;
        this.y *= s;
        this.z *= s;
        this.w *= s;
        return this;
      }
    }, {
      key: "toArray",
      value: function toArray(out) {
        var outOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        out[outOffset] = this.x;
        out[outOffset + 1] = this.y;
        out[outOffset + 2] = this.z;
        out[outOffset + 3] = this.w;
      }
    }, {
      key: "clone",
      value: function clone() {
        var ret = new Vector4(this.x, this.y, this.z, this.w);
        return ret;
      }
    }, {
      key: "cloneTo",
      value: function cloneTo(out) {
        out.x = this.x;
        out.y = this.y;
        out.z = this.z;
        out.w = this.w;
        return out;
      }
    }]);

    return Vector4;
  }();

  Vector4._zero = new Vector4(0, 0, 0, 0);
  Vector4._one = new Vector4(1, 1, 1, 1);

  (function (AssetPromiseStatus2) {
    AssetPromiseStatus2[AssetPromiseStatus2["Success"] = 0] = "Success";
    AssetPromiseStatus2[AssetPromiseStatus2["Pending"] = 1] = "Pending";
    AssetPromiseStatus2[AssetPromiseStatus2["Failed"] = 2] = "Failed";
  })(exports.AssetPromiseStatus || (exports.AssetPromiseStatus = {}));

  var AssetPromise = /*#__PURE__*/function (_Promise) {
    _inherits(AssetPromise, _Promise);

    var _super = _createSuper(AssetPromise);

    _createClass(AssetPromise, [{
      key: "onProgress",
      value: function onProgress(callback) {
        this._listeners.add(callback);

        return this;
      }
    }, {
      key: "cancel",
      value: function cancel() {
        if (this._status !== 1) {
          return this;
        }

        this._reject("Promise Canceled");

        return this;
      }
    }, {
      key: "status",
      get: function get() {
        return this._status;
      }
    }, {
      key: "progress",
      get: function get() {
        return this._progress;
      }
    }], [{
      key: "all",
      value: function all(promises) {
        return new AssetPromise(function (resolve, reject, setProgress) {
          if (!Array.isArray(promises)) {
            return resolve([promises]);
          }

          var completed = 0;
          var total = promises.length;
          var results = new Array(total);
          promises.forEach(function (value, index) {
            Promise.resolve(value).then(function (result) {
              results[index] = result;
              completed += 1;
              setProgress(completed / total);

              if (completed == total) {
                resolve(results);
              }
            })["catch"](function (err) {
              return reject(err);
            });
          });
        });
      }
    }]);

    function AssetPromise(executor) {
      var _this;

      _classCallCheck(this, AssetPromise);

      var newReject;

      var setProgress = function setProgress(progress) {
        if (progress <= _this._progress) {
          return;
        }

        _this._progress = progress;

        var _iterator = _createForOfIteratorHelper(_this._listeners),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var listener = _step.value;
            listener(progress);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      };

      _this = _super.call(this, function (resolve, reject) {
        newReject = function newReject(reason) {
          Promise.resolve().then(function () {
            _this._status = 2;
            reject(reason);
          });
        };

        executor(function (value) {
          Promise.resolve().then(function () {
            setProgress(1);
            _this._status = 0;
            resolve(value);
          });
        }, newReject, function (progress) {
          Promise.resolve().then(function () {
            setProgress(progress);
          });
        });
      });
      _this._reject = newReject;
      _this._listeners = new Set();
      _this._progress = 0;
      _this._status = 1;
      return _this;
    }

    return AssetPromise;
  }( /*#__PURE__*/_wrapNativeSuper(Promise));

  var Util = {
    isArray: "isArray" in Array ? Array.isArray : function (value) {
      return toString.call(value) === "[object Array]";
    },
    isArrayLike: function isArrayLike(x) {
      return !!x && typeof x.length === "number" && typeof x !== "function";
    },
    clone: function clone(obj) {
      if (_typeof(obj) !== "object" || obj === null) {
        return obj;
      }

      var rst;

      if (Util.isArrayLike(obj)) {
        rst = obj.slice();

        for (var i = 0, l = obj.length; i < l; i++) {
          rst[i] = Util.clone(obj[i]);
        }
      } else {
        rst = {};

        for (var k in obj) {
          if (obj.hasOwnProperty(k)) {
            rst[k] = Util.clone(obj[k]);
          }
        }
      }

      return rst;
    },
    downloadBlob: function downloadBlob(blob) {
      var fileName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

      if (navigator && navigator.msSaveBlob) {
        navigator.msSaveBlob(blob, fileName);
        return;
      }

      var url = window.URL.createObjectURL(blob);
      var a = document.createElement("a");
      document.body.appendChild(a);
      a.style.display = "none";
      a.href = url;
      a.download = fileName;
      a.addEventListener("click", function () {
        if (a.parentElement) {
          a.parentElement.removeChild(a);
        }
      });
      a.click();
      window.URL.revokeObjectURL(url);
    }
  };

  function removeFromArray(array, item) {
    var index = array.indexOf(item);

    if (index < 0) {
      return false;
    }

    var last = array.length - 1;

    if (index !== last) {
      var end = array[last];
      array[index] = end;
    }

    array.length--;
    return true;
  }

  function ObjectValues(obj) {
    return Object.keys(obj).map(function (key) {
      return obj[key];
    });
  }

  var ResourceManager = /*#__PURE__*/function () {
    function ResourceManager(engine) {
      _classCallCheck(this, ResourceManager);

      this.engine = engine;
      this.retryCount = 1;
      this.retryInterval = 0;
      this.timeout = 2e4;
      this._assetPool = Object.create(null);
      this._assetUrlPool = Object.create(null);
      this._refObjectPool = Object.create(null);
      this._loadingPromises = {};
    }

    _createClass(ResourceManager, [{
      key: "load",
      value: function load(assetInfo) {
        var _this2 = this;

        if (!Array.isArray(assetInfo)) {
          return this._loadSingleItem(assetInfo);
        }

        var promises = assetInfo.map(function (item) {
          return _this2._loadSingleItem(item);
        });
        return AssetPromise.all(promises);
      }
    }, {
      key: "cancelNotLoaded",
      value: function cancelNotLoaded(url) {
        var _this3 = this;

        if (!url) {
          ObjectValues(this._loadingPromises).forEach(function (promise) {
            promise.cancel();
          });
        } else if (typeof url === "string") {
          var _this$_loadingPromise;

          (_this$_loadingPromise = this._loadingPromises[url]) === null || _this$_loadingPromise === void 0 ? void 0 : _this$_loadingPromise.cancel();
        } else {
          url.forEach(function (p) {
            var _this3$_loadingPromis;

            (_this3$_loadingPromis = _this3._loadingPromises[p]) === null || _this3$_loadingPromis === void 0 ? void 0 : _this3$_loadingPromis.cancel();
          });
        }
      }
    }, {
      key: "gc",
      value: function gc() {
        var objects = ObjectValues(this._refObjectPool);

        for (var i = 0, len = objects.length; i < len; i++) {
          if (!objects[i].isGCIgnored) {
            objects[i].destroy();
          }
        }
      }
    }, {
      key: "getAssetPath",
      value: function getAssetPath(instanceId) {
        return this._assetPool[instanceId];
      }
    }, {
      key: "_addAsset",
      value: function _addAsset(path, asset) {
        this._assetPool[asset.instanceId] = path;
        this._assetUrlPool[path] = asset;
      }
    }, {
      key: "_deleteAsset",
      value: function _deleteAsset(asset) {
        var id = asset.instanceId;
        var path = this._assetPool[id];

        if (path) {
          delete this._assetPool[id];
          delete this._assetUrlPool[path];
        }
      }
    }, {
      key: "_addRefObject",
      value: function _addRefObject(id, asset) {
        this._refObjectPool[id] = asset;
      }
    }, {
      key: "_deleteRefObject",
      value: function _deleteRefObject(id) {
        delete this._refObjectPool[id];
      }
    }, {
      key: "_assignDefaultOptions",
      value: function _assignDefaultOptions(assetInfo) {
        var _assetInfo$type, _assetInfo$retryCount, _assetInfo$timeout, _assetInfo$retryInter, _assetInfo$url;

        assetInfo.type = (_assetInfo$type = assetInfo.type) !== null && _assetInfo$type !== void 0 ? _assetInfo$type : ResourceManager._getTypeByUrl(assetInfo.url);

        if (assetInfo.type === void 0) {
          throw "asset type should be specified: ".concat(assetInfo.url);
        }

        assetInfo.retryCount = (_assetInfo$retryCount = assetInfo.retryCount) !== null && _assetInfo$retryCount !== void 0 ? _assetInfo$retryCount : this.retryCount;
        assetInfo.timeout = (_assetInfo$timeout = assetInfo.timeout) !== null && _assetInfo$timeout !== void 0 ? _assetInfo$timeout : this.timeout;
        assetInfo.retryInterval = (_assetInfo$retryInter = assetInfo.retryInterval) !== null && _assetInfo$retryInter !== void 0 ? _assetInfo$retryInter : this.retryInterval;
        assetInfo.url = (_assetInfo$url = assetInfo.url) !== null && _assetInfo$url !== void 0 ? _assetInfo$url : assetInfo.urls.join(",");
        return assetInfo;
      }
    }, {
      key: "_loadSingleItem",
      value: function _loadSingleItem(item) {
        var _this4 = this;

        var info = this._assignDefaultOptions(typeof item === "string" ? {
          url: item
        } : item);

        var url = info.url;

        if (this._assetUrlPool[url]) {
          return new AssetPromise(function (resolve) {
            resolve(_this4._assetUrlPool[url]);
          });
        }

        if (this._loadingPromises[url]) {
          return this._loadingPromises[info.url];
        }

        var loader = ResourceManager._loaders[info.type];
        var promise = loader.load(info, this);
        this._loadingPromises[url] = promise;
        promise.then(function (res) {
          if (loader.useCache) _this4._addAsset(url, res);
          delete _this4._loadingPromises[url];
        })["catch"](function () {});
        return promise;
      }
    }], [{
      key: "_addLoader",
      value: function _addLoader(type, loader, extnames) {
        this._loaders[type] = loader;

        for (var i = 0, len = extnames.length; i < len; i++) {
          this._extTypeMapping[extnames[i]] = type;
        }
      }
    }, {
      key: "_getTypeByUrl",
      value: function _getTypeByUrl(url) {
        var path = url.split("?")[0];
        return this._extTypeMapping[path.substring(path.lastIndexOf(".") + 1)];
      }
    }]);

    return ResourceManager;
  }();

  ResourceManager._loaders = {};
  ResourceManager._extTypeMapping = {};

  function resourceLoader(assetType, extnames) {
    var useCache = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    return function (Target) {
      var loader = new Target(useCache);

      ResourceManager._addLoader(assetType, loader, extnames);
    };
  }

  var Event = /*#__PURE__*/function () {
    _createClass(Event, [{
      key: "propagationStopped",
      get: function get() {
        return this._propagationStopped;
      }
    }, {
      key: "target",
      get: function get() {
        return this._target;
      },
      set: function set(t) {
        this._target = t;
      }
    }, {
      key: "timeStamp",
      get: function get() {
        return this._timeStamp;
      }
    }, {
      key: "currentTarget",
      get: function get() {
        return this._currentTarget;
      },
      set: function set(t) {
        this._currentTarget = t;
      }
    }, {
      key: "bubbles",
      get: function get() {
        return this._bubbles;
      }
    }, {
      key: "type",
      get: function get() {
        return this._type;
      }
    }]);

    function Event(type) {
      var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var bubbles = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

      _classCallCheck(this, Event);

      this._timeStamp = new Date().getTime();
      this._target = target;
      this.data = data;
      this._currentTarget = null;
      this._bubbles = bubbles;
      this._propagationStopped = false;
      this._type = type;
    }

    _createClass(Event, [{
      key: "stopPropagation",
      value: function stopPropagation() {
        this._propagationStopped = true;
      }
    }]);

    return Event;
  }();

  var CloneMode;

  (function (CloneMode2) {
    CloneMode2[CloneMode2["Ignore"] = 0] = "Ignore";
    CloneMode2[CloneMode2["Assignment"] = 1] = "Assignment";
    CloneMode2[CloneMode2["Shallow"] = 2] = "Shallow";
    CloneMode2[CloneMode2["Deep"] = 3] = "Deep";
  })(CloneMode || (CloneMode = {}));

  function ignoreClone(target, propertyKey) {
    CloneManager.registerCloneMode(target, propertyKey, CloneMode.Ignore);
  }

  function shallowClone(target, propertyKey) {
    CloneManager.registerCloneMode(target, propertyKey, CloneMode.Shallow);
  }

  function deepClone(target, propertyKey) {
    CloneManager.registerCloneMode(target, propertyKey, CloneMode.Deep);
  }

  var CloneManager = /*#__PURE__*/function () {
    function CloneManager() {
      _classCallCheck(this, CloneManager);
    }

    _createClass(CloneManager, null, [{
      key: "registerCloneMode",
      value: function registerCloneMode(target, propertyKey, mode) {
        var targetMap = CloneManager._subCloneModeMap.get(target.constructor);

        if (!targetMap) {
          targetMap = Object.create(null);

          CloneManager._subCloneModeMap.set(target.constructor, targetMap);
        }

        targetMap[propertyKey] = mode;
      }
    }, {
      key: "getCloneModeMode",
      value: function getCloneModeMode(type) {
        var cloneModes = CloneManager._cloneModeMap.get(type);

        if (!cloneModes) {
          cloneModes = Object.create(null);

          CloneManager._cloneModeMap.set(type, cloneModes);

          var obejctType = CloneManager._obejctType;
          var cloneModeMap = CloneManager._subCloneModeMap;

          while (type !== obejctType) {
            var subCloneModes = cloneModeMap.get(type);

            if (subCloneModes) {
              _extends(cloneModes, subCloneModes);
            }

            type = Object.getPrototypeOf(type);
          }
        }

        return cloneModes;
      }
    }]);

    return CloneManager;
  }();

  CloneManager._subCloneModeMap = new Map();
  CloneManager._cloneModeMap = new Map();
  CloneManager._obejctType = Object.getPrototypeOf(Object);
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;

  var __decorate = function __decorate(decorators, target, key, kind) {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;

    for (var i = decorators.length - 1, decorator; i >= 0; i--) {
      if (decorator = decorators[i]) result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    }

    if (kind && result) __defProp(target, key, result);
    return result;
  };

  var EngineObject = function EngineObject(engine) {
    _classCallCheck(this, EngineObject);

    this.instanceId = ++EngineObject._instanceIdCounter;
    this._engine = engine;
  };

  EngineObject._instanceIdCounter = 0;

  __decorate([ignoreClone], EngineObject.prototype, "instanceId", 2);

  __decorate([ignoreClone], EngineObject.prototype, "_engine", 2);

  var __defProp$1 = Object.defineProperty;
  var __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor;

  var __decorate$1 = function __decorate$1(decorators, target, key, kind) {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$1(target, key) : target;

    for (var i = decorators.length - 1, decorator; i >= 0; i--) {
      if (decorator = decorators[i]) result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    }

    if (kind && result) __defProp$1(target, key, result);
    return result;
  };

  var EventDispatcher = /*#__PURE__*/function (_EngineObject) {
    _inherits(EventDispatcher, _EngineObject);

    var _super2 = _createSuper(EventDispatcher);

    function EventDispatcher() {
      var _this5;

      _classCallCheck(this, EventDispatcher);

      _this5 = _super2.apply(this, arguments);
      _this5._evts = Object.create(null);
      _this5._evtCount = 0;
      return _this5;
    }

    _createClass(EventDispatcher, [{
      key: "hasEvent",
      value: function hasEvent(event) {
        return this._evts[event] != null;
      }
    }, {
      key: "eventNames",
      value: function eventNames() {
        if (this._evtCount === 0) return [];
        return Object.keys(this._evts);
      }
    }, {
      key: "listenerCount",
      value: function listenerCount(event) {
        var listeners = this._evts[event];
        if (!listeners) return 0;
        if (listeners.fn) return 1;
        return listeners.length;
      }
    }, {
      key: "dispatch",
      value: function dispatch(event, data) {
        if (!this._evts[event]) {
          return false;
        }

        var listeners = this._evts[event];

        if (listeners.fn) {
          if (listeners.once) this.removeEventListener(event, listeners.fn);
          listeners.fn(data);
        } else {
          var l = listeners.length;

          for (var i = 0; i < l; i++) {
            if (listeners[i].once) this.removeEventListener(event, listeners[i].fn);
            listeners[i].fn(data);
          }
        }

        return true;
      }
    }, {
      key: "on",
      value: function on(event, fn) {
        return this.addEventListener(event, fn);
      }
    }, {
      key: "once",
      value: function once(event, fn) {
        return this.addEventListener(event, fn, true);
      }
    }, {
      key: "addEventListener",
      value: function addEventListener(event, fn, once) {
        var listener = {
          fn: fn,
          once: once
        };
        var events = this._evts;

        if (!events[event]) {
          events[event] = listener;
          this._evtCount++;
        } else if (!events[event].fn) {
          events[event].push(listener);
        } else {
          events[event] = [events[event], listener];
        }

        return this;
      }
    }, {
      key: "off",
      value: function off(event, fn) {
        if (!this._evts[event]) return this;

        if (!fn) {
          this._clearEvent(event);

          return this;
        }

        var listeners = this._evts[event];

        if (listeners.fn && listeners.fn === fn) {
          this._clearEvent(event);
        } else {
          var index = listeners.indexOf(fn);

          if (index > -1) {
            var temp = listeners[listeners.length - 1];
            listeners[index] = temp;
            listeners.length--;

            if (listeners.length === 1) {
              this._evts[event] = listeners[0];
            }
          }
        }

        return this;
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(event, fn) {
        return this.off(event, fn);
      }
    }, {
      key: "removeAllEventListeners",
      value: function removeAllEventListeners(event) {
        if (event) {
          if (this._evts[event]) this._clearEvent(event);
        } else {
          this._evts = Object.create(null);
          this._evtCount = 0;
        }
      }
    }, {
      key: "trigger",
      value: function trigger(e) {
        this.dispatch(e.type, e.data);
      }
    }, {
      key: "_clearEvent",
      value: function _clearEvent(event) {
        if (--this._evtCount === 0) {
          this._evts = Object.create(null);
        } else {
          delete this._evts[event];
        }
      }
    }]);

    return EventDispatcher;
  }(EngineObject);

  __decorate$1([ignoreClone], EventDispatcher.prototype, "_evts", 2);

  var noop = function noop(message) {};

  var debug = console.log.bind(console);
  var info = console.info.bind(console);
  var warn = console.warn.bind(console);
  var error = console.error.bind(console);
  var Logger = {
    debug: noop,
    info: noop,
    warn: noop,
    error: noop,
    isEnabled: false,
    enable: function enable() {
      this.debug = debug;
      this.info = info;
      this.warn = warn;
      this.error = error;
      this.isEnabled = true;
    },
    disable: function disable() {
      this.debug = noop;
      this.info = noop;
      this.warn = noop;
      this.error = noop;
      this.isEnabled = false;
    }
  };

  var Time = /*#__PURE__*/function () {
    function Time() {
      _classCallCheck(this, Time);

      this._clock = performance ? performance : Date;
      this._timeScale = 1;
      this._deltaTime = 1e-4;

      var now = this._clock.now();

      this._startTime = now;
      this._lastTickTime = now;
    }

    _createClass(Time, [{
      key: "reset",
      value: function reset() {
        this._lastTickTime = this._clock.now();
      }
    }, {
      key: "tick",
      value: function tick() {
        var now = this.nowTime;
        this._deltaTime = (now - this._lastTickTime) * this._timeScale;
        this._lastTickTime = now;
      }
    }, {
      key: "nowTime",
      get: function get() {
        return this._clock.now();
      }
    }, {
      key: "deltaTime",
      get: function get() {
        return this._deltaTime;
      }
    }, {
      key: "timeScale",
      get: function get() {
        return this._timeScale;
      },
      set: function set(s) {
        this._timeScale = s;
      }
    }, {
      key: "unscaledDeltaTime",
      get: function get() {
        return this._deltaTime / this._timeScale;
      }
    }, {
      key: "timeSinceStartup",
      get: function get() {
        return this.nowTime - this._startTime;
      }
    }]);

    return Time;
  }();



  (function (InternalAssetType2) {
    InternalAssetType2[InternalAssetType2["Scene"] = 1] = "Scene";
    InternalAssetType2[InternalAssetType2["Cache"] = 2] = "Cache";
  })(exports.InternalAssetType || (exports.InternalAssetType = {}));



  (function (ClearMode2) {
    ClearMode2[ClearMode2["DONT_CLEAR"] = 0] = "DONT_CLEAR";
    ClearMode2[ClearMode2["SOLID_COLOR"] = 1] = "SOLID_COLOR";
    ClearMode2[ClearMode2["DEPTH_ONLY"] = 2] = "DEPTH_ONLY";
    ClearMode2[ClearMode2["COLOR_ONLY"] = 3] = "COLOR_ONLY";
    ClearMode2[ClearMode2["STENCIL_ONLY"] = 4] = "STENCIL_ONLY";
    ClearMode2[ClearMode2["ALL_CLEAR"] = 5] = "ALL_CLEAR";
  })(exports.ClearMode || (exports.ClearMode = {}));



  (function (MaterialType2) {
    MaterialType2[MaterialType2["OPAQUE"] = 1e3] = "OPAQUE";
    MaterialType2[MaterialType2["TRANSPARENT"] = 2e3] = "TRANSPARENT";
  })(exports.MaterialType || (exports.MaterialType = {}));



  (function (RenderState2) {
    RenderState2[RenderState2["BLEND"] = 3042] = "BLEND";
    RenderState2[RenderState2["CULL_FACE"] = 2884] = "CULL_FACE";
    RenderState2[RenderState2["DEPTH_TEST"] = 2929] = "DEPTH_TEST";
    RenderState2[RenderState2["ALPHA_TEST"] = 3008] = "ALPHA_TEST";
    RenderState2[RenderState2["POLYGON_OFFSET_FILL"] = 32823] = "POLYGON_OFFSET_FILL";
    RenderState2[RenderState2["SAMPLE_ALPHA_TO_COVERAGE"] = 32926] = "SAMPLE_ALPHA_TO_COVERAGE";
    RenderState2[RenderState2["SCISSOR_TEST"] = 3089] = "SCISSOR_TEST";
  })(exports.RenderState || (exports.RenderState = {}));



  (function (FrontFace2) {
    FrontFace2[FrontFace2["CW"] = 2304] = "CW";
    FrontFace2[FrontFace2["CCW"] = 2305] = "CCW";
  })(exports.FrontFace || (exports.FrontFace = {}));



  (function (CullFace2) {
    CullFace2[CullFace2["FRONT"] = 1028] = "FRONT";
    CullFace2[CullFace2["BACK"] = 1029] = "BACK";
    CullFace2[CullFace2["FRONT_AND_BACK"] = 1032] = "FRONT_AND_BACK";
  })(exports.CullFace || (exports.CullFace = {}));



  (function (Side2) {
    Side2[Side2["FRONT"] = 0] = "FRONT";
    Side2[Side2["BACK"] = 1] = "BACK";
    Side2[Side2["NONE"] = 2] = "NONE";
    Side2[Side2["DOUBLE"] = 3] = "DOUBLE";
  })(exports.Side || (exports.Side = {}));



  (function (CompFunc2) {
    CompFunc2[CompFunc2["NEVER"] = 512] = "NEVER";
    CompFunc2[CompFunc2["LESS"] = 513] = "LESS";
    CompFunc2[CompFunc2["EQUAL"] = 514] = "EQUAL";
    CompFunc2[CompFunc2["LEQUAL"] = 515] = "LEQUAL";
    CompFunc2[CompFunc2["GREATER"] = 516] = "GREATER";
    CompFunc2[CompFunc2["NOTEQUAL"] = 517] = "NOTEQUAL";
    CompFunc2[CompFunc2["GEQUAL"] = 518] = "GEQUAL";
    CompFunc2[CompFunc2["ALWAYS"] = 519] = "ALWAYS";
  })(exports.CompFunc || (exports.CompFunc = {}));



  (function (TextureFilter2) {
    TextureFilter2[TextureFilter2["NEAREST"] = 9728] = "NEAREST";
    TextureFilter2[TextureFilter2["LINEAR"] = 9729] = "LINEAR";
    TextureFilter2[TextureFilter2["NEAREST_MIPMAP_NEAREST"] = 9984] = "NEAREST_MIPMAP_NEAREST";
    TextureFilter2[TextureFilter2["LINEAR_MIPMAP_NEAREST"] = 9985] = "LINEAR_MIPMAP_NEAREST";
    TextureFilter2[TextureFilter2["NEAREST_MIPMAP_LINEAR"] = 9986] = "NEAREST_MIPMAP_LINEAR";
    TextureFilter2[TextureFilter2["LINEAR_MIPMAP_LINEAR"] = 9987] = "LINEAR_MIPMAP_LINEAR";
  })(exports.TextureFilter || (exports.TextureFilter = {}));



  (function (DataType2) {
    DataType2[DataType2["FLOAT"] = 5126] = "FLOAT";
    DataType2[DataType2["FLOAT_VEC2"] = 35664] = "FLOAT_VEC2";
    DataType2[DataType2["FLOAT_VEC3"] = 35665] = "FLOAT_VEC3";
    DataType2[DataType2["FLOAT_VEC4"] = 35666] = "FLOAT_VEC4";
    DataType2[DataType2["INT"] = 5124] = "INT";
    DataType2[DataType2["INT_VEC2"] = 35667] = "INT_VEC2";
    DataType2[DataType2["INT_VEC3"] = 35668] = "INT_VEC3";
    DataType2[DataType2["INT_VEC4"] = 35669] = "INT_VEC4";
    DataType2[DataType2["BOOL"] = 35670] = "BOOL";
    DataType2[DataType2["BOOL_VEC2"] = 35671] = "BOOL_VEC2";
    DataType2[DataType2["BOOL_VEC3"] = 35672] = "BOOL_VEC3";
    DataType2[DataType2["BOOL_VEC4"] = 35673] = "BOOL_VEC4";
    DataType2[DataType2["FLOAT_MAT2"] = 35674] = "FLOAT_MAT2";
    DataType2[DataType2["FLOAT_MAT3"] = 35675] = "FLOAT_MAT3";
    DataType2[DataType2["FLOAT_MAT4"] = 35676] = "FLOAT_MAT4";
    DataType2[DataType2["FLOAT_ARRAY"] = 35677] = "FLOAT_ARRAY";
    DataType2[DataType2["FLOAT_VEC2_ARRAY"] = 1e5] = "FLOAT_VEC2_ARRAY";
    DataType2[DataType2["FLOAT_VEC3_ARRAY"] = 100001] = "FLOAT_VEC3_ARRAY";
    DataType2[DataType2["FLOAT_VEC4_ARRAY"] = 100002] = "FLOAT_VEC4_ARRAY";
    DataType2[DataType2["INT_ARRAY"] = 100003] = "INT_ARRAY";
    DataType2[DataType2["INT_VEC2_ARRAY"] = 100004] = "INT_VEC2_ARRAY";
    DataType2[DataType2["INT_VEC3_ARRAY"] = 100005] = "INT_VEC3_ARRAY";
    DataType2[DataType2["INT_VEC4_ARRAY"] = 100006] = "INT_VEC4_ARRAY";
    DataType2[DataType2["FLOAT_MAT2_ARRAY"] = 100007] = "FLOAT_MAT2_ARRAY";
    DataType2[DataType2["FLOAT_MAT3_ARRAY"] = 100008] = "FLOAT_MAT3_ARRAY";
    DataType2[DataType2["FLOAT_MAT4_ARRAY"] = 100009] = "FLOAT_MAT4_ARRAY";
    DataType2[DataType2["SAMPLER_2D_ARRAY"] = 100010] = "SAMPLER_2D_ARRAY";
    DataType2[DataType2["SAMPLER_CUBE_ARRAY"] = 100011] = "SAMPLER_CUBE_ARRAY";
    DataType2[DataType2["SAMPLER_2D"] = 35678] = "SAMPLER_2D";
    DataType2[DataType2["SAMPLER_CUBE"] = 35680] = "SAMPLER_CUBE";
    DataType2[DataType2["BYTE"] = 5120] = "BYTE";
    DataType2[DataType2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
    DataType2[DataType2["SHORT"] = 5122] = "SHORT";
    DataType2[DataType2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
    DataType2[DataType2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
  })(exports.DataType || (exports.DataType = {}));



  (function (UniformSemantic2) {
    UniformSemantic2[UniformSemantic2["LOCAL"] = 1] = "LOCAL";
    UniformSemantic2[UniformSemantic2["MODEL"] = 2] = "MODEL";
    UniformSemantic2[UniformSemantic2["VIEW"] = 3] = "VIEW";
    UniformSemantic2[UniformSemantic2["PROJECTION"] = 4] = "PROJECTION";
    UniformSemantic2[UniformSemantic2["MODELVIEW"] = 5] = "MODELVIEW";
    UniformSemantic2[UniformSemantic2["VIEWPROJECTION"] = 21] = "VIEWPROJECTION";
    UniformSemantic2[UniformSemantic2["MODELVIEWPROJECTION"] = 6] = "MODELVIEWPROJECTION";
    UniformSemantic2[UniformSemantic2["MODELINVERSE"] = 7] = "MODELINVERSE";
    UniformSemantic2[UniformSemantic2["VIEWINVERSE"] = 8] = "VIEWINVERSE";
    UniformSemantic2[UniformSemantic2["PROJECTIONINVERSE"] = 9] = "PROJECTIONINVERSE";
    UniformSemantic2[UniformSemantic2["MODELVIEWINVERSE"] = 10] = "MODELVIEWINVERSE";
    UniformSemantic2[UniformSemantic2["MODELVIEWPROJECTIONINVERSE"] = 11] = "MODELVIEWPROJECTIONINVERSE";
    UniformSemantic2[UniformSemantic2["MODELINVERSETRANSPOSE"] = 12] = "MODELINVERSETRANSPOSE";
    UniformSemantic2[UniformSemantic2["MODELVIEWINVERSETRANSPOSE"] = 13] = "MODELVIEWINVERSETRANSPOSE";
    UniformSemantic2[UniformSemantic2["VIEWPORT"] = 14] = "VIEWPORT";
    UniformSemantic2[UniformSemantic2["JOINTMATRIX"] = 15] = "JOINTMATRIX";
    UniformSemantic2[UniformSemantic2["MORPHWEIGHTS"] = 16] = "MORPHWEIGHTS";
    UniformSemantic2[UniformSemantic2["EYEPOS"] = 17] = "EYEPOS";
    UniformSemantic2[UniformSemantic2["TIME"] = 18] = "TIME";
    UniformSemantic2[UniformSemantic2["JOINTTEXTURE"] = 19] = "JOINTTEXTURE";
    UniformSemantic2[UniformSemantic2["JOINTCOUNT"] = 20] = "JOINTCOUNT";
  })(exports.UniformSemantic || (exports.UniformSemantic = {}));



  (function (BlendFunc2) {
    BlendFunc2[BlendFunc2["ZERO"] = 0] = "ZERO";
    BlendFunc2[BlendFunc2["ONE"] = 1] = "ONE";
    BlendFunc2[BlendFunc2["SRC_COLOR"] = 768] = "SRC_COLOR";
    BlendFunc2[BlendFunc2["ONE_MINUS_SRC_COLOR"] = 769] = "ONE_MINUS_SRC_COLOR";
    BlendFunc2[BlendFunc2["SRC_ALPHA"] = 770] = "SRC_ALPHA";
    BlendFunc2[BlendFunc2["ONE_MINUS_SRC_ALPHA"] = 771] = "ONE_MINUS_SRC_ALPHA";
    BlendFunc2[BlendFunc2["DST_ALPHA"] = 772] = "DST_ALPHA";
    BlendFunc2[BlendFunc2["ONE_MINUS_DST_ALPHA"] = 773] = "ONE_MINUS_DST_ALPHA";
    BlendFunc2[BlendFunc2["DST_COLOR"] = 774] = "DST_COLOR";
    BlendFunc2[BlendFunc2["ONE_MINUS_DST_COLOR"] = 775] = "ONE_MINUS_DST_COLOR";
    BlendFunc2[BlendFunc2["SRC_ALPHA_SATURATE"] = 776] = "SRC_ALPHA_SATURATE";
    BlendFunc2[BlendFunc2["enumANT_COLOR"] = 32769] = "enumANT_COLOR";
    BlendFunc2[BlendFunc2["ONE_MINUS_enumANT_COLOR"] = 32770] = "ONE_MINUS_enumANT_COLOR";
    BlendFunc2[BlendFunc2["enumANT_ALPHA"] = 32771] = "enumANT_ALPHA";
    BlendFunc2[BlendFunc2["ONE_MINUS_enumANT_ALPHA"] = 32772] = "ONE_MINUS_enumANT_ALPHA";
  })(exports.BlendFunc || (exports.BlendFunc = {}));



  (function (MaskList2) {
    MaskList2[MaskList2["MASK1"] = 1] = "MASK1";
    MaskList2[MaskList2["MASK2"] = 2] = "MASK2";
    MaskList2[MaskList2["MASK3"] = 4] = "MASK3";
    MaskList2[MaskList2["MASK4"] = 8] = "MASK4";
    MaskList2[MaskList2["MASK5"] = 16] = "MASK5";
    MaskList2[MaskList2["MASK6"] = 32] = "MASK6";
    MaskList2[MaskList2["MASK7"] = 64] = "MASK7";
    MaskList2[MaskList2["MASK8"] = 128] = "MASK8";
    MaskList2[MaskList2["MASK9"] = 256] = "MASK9";
    MaskList2[MaskList2["MASK10"] = 512] = "MASK10";
    MaskList2[MaskList2["MASK11"] = 1024] = "MASK11";
    MaskList2[MaskList2["MASK12"] = 2048] = "MASK12";
    MaskList2[MaskList2["MASK13"] = 4096] = "MASK13";
    MaskList2[MaskList2["MASK14"] = 8192] = "MASK14";
    MaskList2[MaskList2["MASK15"] = 16384] = "MASK15";
    MaskList2[MaskList2["MASK16"] = 32768] = "MASK16";
    MaskList2[MaskList2["MASK17"] = 65536] = "MASK17";
    MaskList2[MaskList2["MASK18"] = 131072] = "MASK18";
    MaskList2[MaskList2["MASK19"] = 262144] = "MASK19";
    MaskList2[MaskList2["MASK20"] = 524288] = "MASK20";
    MaskList2[MaskList2["EVERYTHING"] = 268435455] = "EVERYTHING";
    MaskList2[MaskList2["SHADOW"] = 268435456] = "SHADOW";
    MaskList2[MaskList2["SHADOW_MAP"] = 536870912] = "SHADOW_MAP";
  })(exports.MaskList || (exports.MaskList = {}));



  (function (RefreshRate2) {
    RefreshRate2[RefreshRate2["ONCE"] = 1] = "ONCE";
    RefreshRate2[RefreshRate2["EVERYFRAME"] = 2] = "EVERYFRAME";
  })(exports.RefreshRate || (exports.RefreshRate = {}));



  (function (BoundingType2) {
    BoundingType2[BoundingType2["AABB"] = 0] = "AABB";
    BoundingType2[BoundingType2["OBB"] = 1] = "OBB";
    BoundingType2[BoundingType2["SPHERE"] = 2] = "SPHERE";
  })(exports.BoundingType || (exports.BoundingType = {}));



  (function (GLCapabilityType2) {
    GLCapabilityType2["standardDerivatives"] = "OES_standard_derivatives";
    GLCapabilityType2["shaderTextureLod"] = "EXT_shader_texture_lod";
    GLCapabilityType2["elementIndexUint"] = "OES_element_index_uint";
    GLCapabilityType2["depthTexture"] = "WEBGL_depth_texture";
    GLCapabilityType2["drawBuffers"] = "WEBGL_draw_buffers";
    GLCapabilityType2["vertexArrayObject"] = "OES_vertex_array_object";
    GLCapabilityType2["instancedArrays"] = "ANGLE_instanced_arrays";
    GLCapabilityType2["multipleSample"] = "multipleSampleOnlySupportedInWebGL2";
    GLCapabilityType2["textureFloat"] = "OES_texture_float";
    GLCapabilityType2["textureFloatLinear"] = "OES_texture_float_linear";
    GLCapabilityType2["textureHalfFloat"] = "OES_texture_half_float";
    GLCapabilityType2["textureHalfFloatLinear"] = "OES_texture_half_float_linear";
    GLCapabilityType2["WEBGL_colorBufferFloat"] = "WEBGL_color_buffer_float";
    GLCapabilityType2["colorBufferFloat"] = "EXT_color_buffer_float";
    GLCapabilityType2["colorBufferHalfFloat"] = "EXT_color_buffer_half_float";
    GLCapabilityType2["textureFilterAnisotropic"] = "EXT_texture_filter_anisotropic";
    GLCapabilityType2["astc"] = "WEBGL_compressed_texture_astc";
    GLCapabilityType2["astc_webkit"] = "WEBKIT_WEBGL_compressed_texture_astc";
    GLCapabilityType2["etc"] = "WEBGL_compressed_texture_etc";
    GLCapabilityType2["etc_webkit"] = "WEBKIT_WEBGL_compressed_texture_etc";
    GLCapabilityType2["etc1"] = "WEBGL_compressed_texture_etc1";
    GLCapabilityType2["etc1_webkit"] = "WEBKIT_WEBGL_compressed_texture_etc1";
    GLCapabilityType2["pvrtc"] = "WEBGL_compressed_texture_pvrtc";
    GLCapabilityType2["pvrtc_webkit"] = "WEBKIT_WEBGL_compressed_texture_pvrtc";
    GLCapabilityType2["s3tc"] = "WEBGL_compressed_texture_s3tc";
    GLCapabilityType2["s3tc_webkit"] = "WEBKIT_WEBGL_compressed_texture_s3tc";
  })(exports.GLCapabilityType || (exports.GLCapabilityType = {}));



  (function (OITMode2) {
    OITMode2[OITMode2["WEIGHTED_AVERAGE"] = 0] = "WEIGHTED_AVERAGE";
    OITMode2[OITMode2["DEPTH_PEEL"] = 1] = "DEPTH_PEEL";
    OITMode2[OITMode2["DUAL_DEPTH_PEEL"] = 2] = "DUAL_DEPTH_PEEL";
  })(exports.OITMode || (exports.OITMode = {}));

  var DisorderedArray = /*#__PURE__*/function () {
    function DisorderedArray() {
      var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      _classCallCheck(this, DisorderedArray);

      this.length = 0;
      this._elements = new Array(count);
    }

    _createClass(DisorderedArray, [{
      key: "add",
      value: function add(element) {
        if (this.length === this._elements.length) this._elements.push(element);else this._elements[this.length] = element;
        this.length++;
      }
    }, {
      key: "delete",
      value: function _delete(element) {
        var index = this._elements.indexOf(element);

        this.deleteByIndex(index);
      }
    }, {
      key: "deleteByIndex",
      value: function deleteByIndex(index) {
        var elements = this._elements;
        var end = null;
        var lastIndex = this.length - 1;

        if (index !== lastIndex) {
          end = elements[lastIndex];
          elements[index] = end;
        }

        this.length--;
        return end;
      }
    }, {
      key: "garbageCollection",
      value: function garbageCollection() {
        this._elements.length = this.length;
      }
    }]);

    return DisorderedArray;
  }();

  var ComponentsManager = /*#__PURE__*/function () {
    function ComponentsManager() {
      _classCallCheck(this, ComponentsManager);

      this._onStartScripts = new DisorderedArray();
      this._onUpdateScripts = new DisorderedArray();
      this._onLateUpdateScripts = new DisorderedArray();
      this._destoryComponents = [];
      this._onUpdateAnimations = new DisorderedArray();
      this._renderers = new DisorderedArray();
      this._onUpdateRenderers = new DisorderedArray();
      this._componentsContainerPool = [];
    }

    _createClass(ComponentsManager, [{
      key: "addRenderer",
      value: function addRenderer(renderer) {
        renderer._rendererIndex = this._renderers.length;

        this._renderers.add(renderer);
      }
    }, {
      key: "removeRenderer",
      value: function removeRenderer(renderer) {
        var replaced = this._renderers.deleteByIndex(renderer._rendererIndex);

        replaced && (replaced._rendererIndex = renderer._rendererIndex);
        renderer._rendererIndex = -1;
      }
    }, {
      key: "addOnStartScript",
      value: function addOnStartScript(script) {
        script._onStartIndex = this._onStartScripts.length;

        this._onStartScripts.add(script);
      }
    }, {
      key: "removeOnStartScript",
      value: function removeOnStartScript(script) {
        var replaced = this._onStartScripts.deleteByIndex(script._onStartIndex);

        replaced && (replaced._onStartIndex = script._onStartIndex);
        script._onStartIndex = -1;
      }
    }, {
      key: "addOnUpdateScript",
      value: function addOnUpdateScript(script) {
        script._onUpdateIndex = this._onUpdateScripts.length;

        this._onUpdateScripts.add(script);
      }
    }, {
      key: "removeOnUpdateScript",
      value: function removeOnUpdateScript(script) {
        var replaced = this._onUpdateScripts.deleteByIndex(script._onUpdateIndex);

        replaced && (replaced._onUpdateIndex = script._onUpdateIndex);
        script._onUpdateIndex = -1;
      }
    }, {
      key: "addOnLateUpdateScript",
      value: function addOnLateUpdateScript(script) {
        script._onLateUpdateIndex = this._onLateUpdateScripts.length;

        this._onLateUpdateScripts.add(script);
      }
    }, {
      key: "removeOnLateUpdateScript",
      value: function removeOnLateUpdateScript(script) {
        var replaced = this._onLateUpdateScripts.deleteByIndex(script._onLateUpdateIndex);

        replaced && (replaced._onLateUpdateIndex = script._onLateUpdateIndex);
        script._onLateUpdateIndex = -1;
      }
    }, {
      key: "addOnUpdateAnimations",
      value: function addOnUpdateAnimations(animation) {
        animation._onUpdateIndex = this._onUpdateAnimations.length;

        this._onUpdateAnimations.add(animation);
      }
    }, {
      key: "removeOnUpdateAnimations",
      value: function removeOnUpdateAnimations(animation) {
        var replaced = this._onUpdateAnimations.deleteByIndex(animation._onUpdateIndex);

        replaced && (replaced._onUpdateIndex = animation._onUpdateIndex);
        animation._onUpdateIndex = -1;
      }
    }, {
      key: "addOnUpdateRenderers",
      value: function addOnUpdateRenderers(renderer) {
        renderer._onUpdateIndex = this._onUpdateRenderers.length;

        this._onUpdateRenderers.add(renderer);
      }
    }, {
      key: "removeOnUpdateRenderers",
      value: function removeOnUpdateRenderers(renderer) {
        var replaced = this._onUpdateRenderers.deleteByIndex(renderer._onUpdateIndex);

        replaced && (replaced._onUpdateIndex = renderer._onUpdateIndex);
        renderer._onUpdateIndex = -1;
      }
    }, {
      key: "addDestoryComponent",
      value: function addDestoryComponent(component) {
        this._destoryComponents.push(component);
      }
    }, {
      key: "callScriptOnStart",
      value: function callScriptOnStart() {
        var onStartScripts = this._onStartScripts;

        if (onStartScripts.length > 0) {
          var elements = onStartScripts._elements;

          for (var i = 0; i < onStartScripts.length; i++) {
            var script = elements[i];
            script._started = true;
            script._onStartIndex = -1;
            script.onStart();
          }

          onStartScripts.length = 0;
        }
      }
    }, {
      key: "callScriptOnUpdate",
      value: function callScriptOnUpdate(deltaTime) {
        var elements = this._onUpdateScripts._elements;

        for (var i = this._onUpdateScripts.length - 1; i >= 0; --i) {
          var element = elements[i];

          if (element._started) {
            element.onUpdate(deltaTime);
          }
        }
      }
    }, {
      key: "callScriptOnLateUpdate",
      value: function callScriptOnLateUpdate(deltaTime) {
        var elements = this._onLateUpdateScripts._elements;

        for (var i = this._onLateUpdateScripts.length - 1; i >= 0; --i) {
          var element = elements[i];

          if (element._started) {
            element.onLateUpdate(deltaTime);
          }
        }
      }
    }, {
      key: "callAnimationUpdate",
      value: function callAnimationUpdate(deltaTime) {
        var elements = this._onUpdateAnimations._elements;

        for (var i = this._onUpdateAnimations.length - 1; i >= 0; --i) {
          elements[i].update(deltaTime);
        }
      }
    }, {
      key: "callRendererOnUpdate",
      value: function callRendererOnUpdate(deltaTime) {
        var elements = this._onUpdateRenderers._elements;

        for (var i = this._onUpdateRenderers.length - 1; i >= 0; --i) {
          elements[i].update(deltaTime);
        }
      }
    }, {
      key: "callRender",
      value: function callRender(camera) {
        var elements = this._renderers._elements;

        for (var i = this._renderers.length - 1; i >= 0; --i) {
          elements[i]._render(camera);
        }
      }
    }, {
      key: "callComponentDestory",
      value: function callComponentDestory() {
        var destoryComponents = this._destoryComponents;
        var length = destoryComponents.length;

        if (length > 0) {
          for (var i = length - 1; i >= 0; --i) {
            destoryComponents[i].onDestroy();
          }

          destoryComponents.length = 0;
        }
      }
    }, {
      key: "callCameraOnBeginRender",
      value: function callCameraOnBeginRender(camera) {
        var camComps = camera.entity._components;

        for (var i = camComps.length - 1; i >= 0; --i) {
          var camComp = camComps[i];
          camComp.onBeginRender && camComp.onBeginRender(camera);
        }
      }
    }, {
      key: "callCameraOnEndRender",
      value: function callCameraOnEndRender(camera) {
        var camComps = camera.entity._components;

        for (var i = camComps.length - 1; i >= 0; --i) {
          var camComp = camComps[i];
          camComp.onBeginRender && camComp.onEndRender(camera);
        }
      }
    }, {
      key: "getActiveChangedTempList",
      value: function getActiveChangedTempList() {
        return this._componentsContainerPool.length ? this._componentsContainerPool.pop() : [];
      }
    }, {
      key: "putActiveChangedTempList",
      value: function putActiveChangedTempList(componentContainer) {
        componentContainer.length = 0;

        this._componentsContainerPool.push(componentContainer);
      }
    }]);

    return ComponentsManager;
  }();

  var ComponentCloner = /*#__PURE__*/function () {
    function ComponentCloner() {
      _classCallCheck(this, ComponentCloner);
    }

    _createClass(ComponentCloner, null, [{
      key: "cloneComponent",
      value: function cloneComponent(source, target) {
        var cloneModes = CloneManager.getCloneModeMode(source.constructor);
        var keys = Object.keys(source);

        for (var i = 0, n = keys.length; i < n; i++) {
          var k = keys[i];
          var cloneMode = cloneModes[k];

          switch (cloneMode) {
            case void 0:
            case CloneMode.Assignment:
              target[k] = source[k];
              break;

            case CloneMode.Shallow:
              var sourcePropS = source[k];

              if (sourcePropS instanceof Object) {
                var tarProp = target[k];
                tarProp == null && (tarProp = target[k] = sourcePropS.constructor());

                _extends(tarProp, sourcePropS);
              } else {
                target[k] = sourcePropS;
              }

              break;

            case CloneMode.Deep:
              var sourcePropD = source[k];

              if (sourcePropD instanceof Object) {
                var _tarProp = target[k];
                _tarProp == null && (_tarProp = target[k] = sourcePropD.constructor());

                ComponentCloner._cloneComponentProp(sourcePropD, _tarProp);
              } else {
                target[k] = sourcePropD;
              }

              break;
          }
        }
      }
    }, {
      key: "_cloneComponentProp",
      value: function _cloneComponentProp(source, target) {
        var type = source.constructor;

        if (type === Object) {
          var keys = Object.keys(source);

          for (var i = 0, n = keys.length; i < n; i++) {
            var k = keys[i];
            var sourceItem = source[k];

            if (sourceItem instanceof Object) {
              var targetItem = target[k];
              targetItem == null && (target[k] = targetItem = sourceItem.constructor());

              ComponentCloner._cloneComponentProp(sourceItem, targetItem);
            } else {
              target[k] = sourceItem;
            }
          }
        } else if (type === Array) {
          var arraySource = source;
          var arrayTarget = target;
          var length = arraySource.length;
          arrayTarget.length = length;

          for (var _i = 0; _i < length; _i++) {
            var _sourceItem = arraySource[_i];

            if (_sourceItem instanceof Object) {
              var _targetItem = arrayTarget[_i];
              _targetItem == null && (arrayTarget[_i] = _targetItem = _sourceItem.constructor());

              ComponentCloner._cloneComponentProp(_sourceItem, _targetItem);
            } else {
              arrayTarget[_i] = _sourceItem;
            }
          }
        } else {
          source.cloneTo(target);
        }
      }
    }]);

    return ComponentCloner;
  }();

  var ComponentsDependencies = /*#__PURE__*/function () {
    _createClass(ComponentsDependencies, null, [{
      key: "register",
      value: function register(currentComponent, dependentComponent) {
        this._addDependency(currentComponent, dependentComponent, this._dependenciesMap);

        this._addDependency(dependentComponent, currentComponent, this._invDependenciesMap);
      }
    }, {
      key: "_addCheck",
      value: function _addCheck(entity, type) {
        var dependencies2 = ComponentsDependencies._dependenciesMap.get(type);

        if (dependencies2) {
          for (var i = 0, len = dependencies2.length; i < len; i++) {
            if (!entity.getComponent(dependencies2[i])) {
              throw "you should add ".concat(dependencies2[i], " before adding ").concat(type);
            }
          }
        }
      }
    }, {
      key: "_removeCheck",
      value: function _removeCheck(entity, type) {
        var invDenpendencies = ComponentsDependencies._invDependenciesMap.get(type);

        if (invDenpendencies) {
          for (var i = 0, len = invDenpendencies.length; i < len; i++) {
            if (entity.getComponent(invDenpendencies[i])) {
              throw "you should remove ".concat(invDenpendencies[i], " before adding ").concat(type);
            }
          }
        }
      }
    }, {
      key: "_addDependency",
      value: function _addDependency(currentComponent, dependentComponent, map) {
        var components = map.get(currentComponent);

        if (!components) {
          components = [];
          map.set(currentComponent, components);
        }

        if (components.indexOf(dependentComponent) === -1) {
          components.push(dependentComponent);
        }
      }
    }]);

    function ComponentsDependencies() {
      _classCallCheck(this, ComponentsDependencies);
    }

    return ComponentsDependencies;
  }();

  ComponentsDependencies._dependenciesMap = new Map();
  ComponentsDependencies._invDependenciesMap = new Map();

  function dependencies() {
    for (var _len = arguments.length, abilityClass = new Array(_len), _key = 0; _key < _len; _key++) {
      abilityClass[_key] = arguments[_key];
    }

    return function (target) {
      abilityClass.forEach(function (ability) {
        return ComponentsDependencies.register(target, ability);
      });
    };
  }



  (function (Layer2) {
    Layer2[Layer2["Layer0"] = 1] = "Layer0";
    Layer2[Layer2["Layer1"] = 2] = "Layer1";
    Layer2[Layer2["Layer2"] = 4] = "Layer2";
    Layer2[Layer2["Layer3"] = 8] = "Layer3";
    Layer2[Layer2["Layer4"] = 16] = "Layer4";
    Layer2[Layer2["Layer5"] = 32] = "Layer5";
    Layer2[Layer2["Layer6"] = 64] = "Layer6";
    Layer2[Layer2["Layer7"] = 128] = "Layer7";
    Layer2[Layer2["Layer8"] = 256] = "Layer8";
    Layer2[Layer2["Layer9"] = 512] = "Layer9";
    Layer2[Layer2["Layer10"] = 1024] = "Layer10";
    Layer2[Layer2["Layer11"] = 2048] = "Layer11";
    Layer2[Layer2["Layer12"] = 4096] = "Layer12";
    Layer2[Layer2["Layer13"] = 8192] = "Layer13";
    Layer2[Layer2["Layer14"] = 16384] = "Layer14";
    Layer2[Layer2["Layer15"] = 32768] = "Layer15";
    Layer2[Layer2["Layer16"] = 65536] = "Layer16";
    Layer2[Layer2["Layer17"] = 131072] = "Layer17";
    Layer2[Layer2["Layer18"] = 262144] = "Layer18";
    Layer2[Layer2["Layer19"] = 524288] = "Layer19";
    Layer2[Layer2["Layer20"] = 1048576] = "Layer20";
    Layer2[Layer2["Layer21"] = 2097152] = "Layer21";
    Layer2[Layer2["Layer22"] = 4194304] = "Layer22";
    Layer2[Layer2["Layer23"] = 8388608] = "Layer23";
    Layer2[Layer2["Layer24"] = 16777216] = "Layer24";
    Layer2[Layer2["Layer25"] = 33554432] = "Layer25";
    Layer2[Layer2["Layer26"] = 67108864] = "Layer26";
    Layer2[Layer2["Layer27"] = 134217728] = "Layer27";
    Layer2[Layer2["Layer28"] = 268435456] = "Layer28";
    Layer2[Layer2["Layer29"] = 536870912] = "Layer29";
    Layer2[Layer2["Layer30"] = 1073741824] = "Layer30";
    Layer2[Layer2["Layer31"] = 2147483648] = "Layer31";
    Layer2[Layer2["Everything"] = 4294967295] = "Everything";
    Layer2[Layer2["Nothing"] = 0] = "Nothing";
  })(exports.Layer || (exports.Layer = {}));

  var __defProp$2 = Object.defineProperty;
  var __getOwnPropDesc$2 = Object.getOwnPropertyDescriptor;

  var __decorate$2 = function __decorate$2(decorators, target, key, kind) {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$2(target, key) : target;

    for (var i = decorators.length - 1, decorator; i >= 0; i--) {
      if (decorator = decorators[i]) result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    }

    if (kind && result) __defProp$2(target, key, result);
    return result;
  };

  var Component = /*#__PURE__*/function (_EventDispatcher) {
    _inherits(Component, _EventDispatcher);

    var _super3 = _createSuper(Component);

    function Component(entity) {
      var _this6;

      _classCallCheck(this, Component);

      _this6 = _super3.call(this, entity.engine);
      _this6._destroyed = false;
      _this6._enabled = true;
      _this6._awaked = false;
      _this6._renderPriority = 0;
      _this6._cullDistanceSq = 0;
      _this6._entity = entity;
      _this6._renderPassFlag = exports.MaskList.EVERYTHING;
      _this6._passMasks = [exports.MaskList.EVERYTHING];
      return _this6;
    }

    _createClass(Component, [{
      key: "destroy",
      value: function destroy() {
        if (this._destroyed) return;

        this._entity._removeComponent(this);

        if (this._entity.isActiveInHierarchy) {
          this._enabled && this._onDisable();

          this._onInActive();
        }

        this._destroyed = true;

        this._onDestroy();
      }
    }, {
      key: "_onAwake",
      value: function _onAwake() {}
    }, {
      key: "_onEnable",
      value: function _onEnable() {}
    }, {
      key: "_onDisable",
      value: function _onDisable() {}
    }, {
      key: "_onDestroy",
      value: function _onDestroy() {}
    }, {
      key: "_onActive",
      value: function _onActive() {}
    }, {
      key: "_onInActive",
      value: function _onInActive() {}
    }, {
      key: "_setActive",
      value: function _setActive(value) {
        if (value) {
          if (!this._awaked) {
            this._awaked = true;

            this._onAwake();
          }

          if (this._entity._isActiveInHierarchy) {
            this._onActive();

            this._enabled && this._onEnable();
          }
        } else {
          this._enabled && this._onDisable();

          this._onInActive();
        }
      }
    }, {
      key: "setPassMasks",
      value: function setPassMasks() {
        for (var _len2 = arguments.length, masks = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          masks[_key2] = arguments[_key2];
        }

        this._passMasks = masks;
        this._renderPassFlag = masks.reduce(function (a, b) {
          return a | b;
        }, 0);
      }
    }, {
      key: "addPassMasks",
      value: function addPassMasks() {
        for (var _len3 = arguments.length, masks = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          masks[_key3] = arguments[_key3];
        }

        for (var _i2 = 0, _masks = masks; _i2 < _masks.length; _i2++) {
          var mask = _masks[_i2];

          var idx = this._passMasks.indexOf(mask);

          if (idx < 0) {
            this._passMasks.push(mask);
          }
        }

        this.setPassMasks.apply(this, _toConsumableArray(this._passMasks));
      }
    }, {
      key: "removePassMasks",
      value: function removePassMasks() {
        for (var _len4 = arguments.length, masks = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          masks[_key4] = arguments[_key4];
        }

        for (var _i3 = 0, _masks2 = masks; _i3 < _masks2.length; _i3++) {
          var mask = _masks2[_i3];

          var idx = this._passMasks.indexOf(mask);

          if (idx > -1) {
            this._passMasks.splice(idx, 1);
          }
        }

        this.setPassMasks.apply(this, _toConsumableArray(this._passMasks));
      }
    }, {
      key: "enabled",
      get: function get() {
        return this._enabled;
      },
      set: function set(value) {
        if (value === this._enabled) {
          return;
        }

        this._enabled = value;

        if (value) {
          this._entity.isActiveInHierarchy && this._onEnable();
        } else {
          this._entity.isActiveInHierarchy && this._onDisable();
        }
      }
    }, {
      key: "destroyed",
      get: function get() {
        return this._destroyed;
      }
    }, {
      key: "entity",
      get: function get() {
        return this._entity;
      }
    }, {
      key: "scene",
      get: function get() {
        return this._entity.scene;
      }
    }, {
      key: "engine",
      get: function get() {
        return this._entity.engine;
      }
    }, {
      key: "renderPriority",
      get: function get() {
        return this._renderPriority;
      },
      set: function set(val) {
        this._renderPriority = val;
      }
    }, {
      key: "cullDistanceSq",
      get: function get() {
        return this._cullDistanceSq;
      }
    }, {
      key: "cullDistance",
      get: function get() {
        return Math.sqrt(this._cullDistanceSq);
      },
      set: function set(val) {
        this._cullDistanceSq = val * val;
      }
    }, {
      key: "renderPassFlag",
      get: function get() {
        return this._renderPassFlag;
      },
      set: function set(val) {
        this._renderPassFlag = val;
      }
    }]);

    return Component;
  }(EventDispatcher);

  __decorate$2([ignoreClone], Component.prototype, "_entity", 2);

  __decorate$2([ignoreClone], Component.prototype, "_destroyed", 2);

  __decorate$2([ignoreClone], Component.prototype, "_enabled", 2);

  __decorate$2([ignoreClone], Component.prototype, "_awaked", 2);

  var UpdateFlag = /*#__PURE__*/function () {
    function UpdateFlag() {
      var _flags = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      _classCallCheck(this, UpdateFlag);

      this._flags = _flags;
      this.flag = true;
    }

    _createClass(UpdateFlag, [{
      key: "destroy",
      value: function destroy() {
        var flags = this._flags;
        removeFromArray(flags, this);
        this._flags = null;
      }
    }]);

    return UpdateFlag;
  }();

  var __defProp$3 = Object.defineProperty;
  var __getOwnPropDesc$3 = Object.getOwnPropertyDescriptor;

  var __decorate$3 = function __decorate$3(decorators, target, key, kind) {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$3(target, key) : target;

    for (var i = decorators.length - 1, decorator; i >= 0; i--) {
      if (decorator = decorators[i]) result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    }

    if (kind && result) __defProp$3(target, key, result);
    return result;
  };

  var Transform = /*#__PURE__*/function (_Component) {
    _inherits(Transform, _Component);

    var _super4 = _createSuper(Transform);

    function Transform() {
      var _this7;

      _classCallCheck(this, Transform);

      _this7 = _super4.apply(this, arguments);
      _this7._position = new Vector3();
      _this7._rotation = new Vector3();
      _this7._rotationQuaternion = new Quaternion();
      _this7._scale = new Vector3(1, 1, 1);
      _this7._worldPosition = new Vector3();
      _this7._worldRotation = new Vector3();
      _this7._worldRotationQuaternion = new Quaternion();
      _this7._lossyWorldScale = new Vector3(1, 1, 1);
      _this7._localMatrix = new Matrix();
      _this7._worldMatrix = new Matrix();
      _this7._changeFlags = [];
      _this7._isParentDirty = true;
      _this7._parentTransformCache = null;
      _this7._dirtyFlag = Transform._WM_WP_WE_WQ_WS_FLAGS;
      return _this7;
    }

    _createClass(Transform, [{
      key: "setPosition",
      value: function setPosition(x, y, z) {
        this._position.setValue(x, y, z);

        this.position = this._position;
      }
    }, {
      key: "setRotation",
      value: function setRotation(x, y, z) {
        this._rotation.setValue(x, y, z);

        this.rotation = this._rotation;
      }
    }, {
      key: "setRotationQuaternion",
      value: function setRotationQuaternion(x, y, z, w) {
        this._rotationQuaternion.setValue(x, y, z, w);

        this.rotationQuaternion = this._rotationQuaternion;
      }
    }, {
      key: "setScale",
      value: function setScale(x, y, z) {
        this._scale.setValue(x, y, z);

        this.scale = this._scale;
      }
    }, {
      key: "setWorldPosition",
      value: function setWorldPosition(x, y, z) {
        this._worldPosition.setValue(x, y, z);

        this.worldPosition = this._worldPosition;
      }
    }, {
      key: "setWorldRotation",
      value: function setWorldRotation(x, y, z) {
        this._worldRotation.setValue(x, y, z);

        this.worldRotation = this._worldRotation;
      }
    }, {
      key: "setWorldRotationQuaternion",
      value: function setWorldRotationQuaternion(x, y, z, w) {
        this._worldRotationQuaternion.setValue(x, y, z, w);

        this.worldRotationQuaternion = this._worldRotationQuaternion;
      }
    }, {
      key: "getWorldForward",
      value: function getWorldForward(forward) {
        var e = this.worldMatrix.elements;
        forward.setValue(-e[8], -e[9], -e[10]);
        return forward.normalize();
      }
    }, {
      key: "getWorldRight",
      value: function getWorldRight(right) {
        var e = this.worldMatrix.elements;
        right.setValue(e[0], e[1], e[2]);
        return right.normalize();
      }
    }, {
      key: "getWorldUp",
      value: function getWorldUp(up) {
        var e = this.worldMatrix.elements;
        up.setValue(e[4], e[5], e[6]);
        return up.normalize();
      }
    }, {
      key: "translate",
      value: function translate(translation) {
        var relativeToLocal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        if (relativeToLocal) {
          var rotationMat = Transform._tempMat40;
          Matrix.rotationQuaternion(this.rotationQuaternion, rotationMat);
          Vector3.transformCoordinate(translation, rotationMat, Transform._tempVec3);
          this.position = this._position.add(Transform._tempVec3);
        } else {
          this.worldPosition = this._worldPosition.add(translation);
        }
      }
    }, {
      key: "translateXYZ",
      value: function translateXYZ(x, y, z) {
        var relativeToLocal = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var translate = Transform._tempVec3;
        translate.setValue(x, y, z);
        this.translate(translate, relativeToLocal);
      }
    }, {
      key: "rotate",
      value: function rotate(rotation) {
        var relativeToLocal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        this.rotateXYZ(rotation.x, rotation.y, rotation.z, relativeToLocal);
      }
    }, {
      key: "rotateXYZ",
      value: function rotateXYZ(x, y, z) {
        var relativeToLocal = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var radFactor = MathUtil.degreeToRadFactor;
        var rotQuat = Transform._tempQuat0;
        Quaternion.rotationEuler(x * radFactor, y * radFactor, z * radFactor, rotQuat);

        this._rotateByQuat(rotQuat, relativeToLocal);
      }
    }, {
      key: "rotateByAxis",
      value: function rotateByAxis(axis, angle) {
        var relativeToLocal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        var rad = angle * MathUtil.degreeToRadFactor;
        Quaternion.rotationAxisAngle(axis, rad, Transform._tempQuat0);

        this._rotateByQuat(Transform._tempQuat0, relativeToLocal);
      }
    }, {
      key: "lookAt",
      value: function lookAt(worldPosition, worldUp) {
        var _worldUp;

        var position = this.worldPosition;
        var EPSILON = MathUtil.zeroTolerance;

        if (Math.abs(position.x - worldPosition.x) < EPSILON && Math.abs(position.y - worldPosition.y) < EPSILON && Math.abs(position.z - worldPosition.z) < EPSILON) {
          return;
        }

        var rotMat = Transform._tempMat43;
        var worldRotationQuaternion = this._worldRotationQuaternion;
        worldUp = (_worldUp = worldUp) !== null && _worldUp !== void 0 ? _worldUp : Transform._tempVec3.setValue(0, 1, 0);
        Matrix.lookAt(position, worldPosition, worldUp, rotMat);
        rotMat.getRotation(worldRotationQuaternion).invert();
        this.worldRotationQuaternion = worldRotationQuaternion;
      }
    }, {
      key: "registerWorldChangeFlag",
      value: function registerWorldChangeFlag() {
        var flag = new UpdateFlag(this._changeFlags);

        this._changeFlags.push(flag);

        return flag;
      }
    }, {
      key: "_parentChange",
      value: function _parentChange() {
        this._isParentDirty = true;

        this._updateAllWorldFlag();
      }
    }, {
      key: "_updateWorldPositionFlag",
      value: function _updateWorldPositionFlag() {
        if (!this._isContainDirtyFlags(Transform._WM_WP_FLAGS)) {
          this._worldAssociatedChange(Transform._WM_WP_FLAGS);

          var nodeChildren = this._entity._children;

          for (var i = 0, n = nodeChildren.length; i < n; i++) {
            var _nodeChildren$i$trans;

            (_nodeChildren$i$trans = nodeChildren[i].transform) === null || _nodeChildren$i$trans === void 0 ? void 0 : _nodeChildren$i$trans._updateWorldPositionFlag();
          }
        }
      }
    }, {
      key: "_updateWorldRotationFlag",
      value: function _updateWorldRotationFlag() {
        if (!this._isContainDirtyFlags(Transform._WM_WE_WQ_FLAGS)) {
          this._worldAssociatedChange(Transform._WM_WE_WQ_FLAGS);

          var nodeChildren = this._entity._children;

          for (var i = 0, n = nodeChildren.length; i < n; i++) {
            var _nodeChildren$i$trans2;

            (_nodeChildren$i$trans2 = nodeChildren[i].transform) === null || _nodeChildren$i$trans2 === void 0 ? void 0 : _nodeChildren$i$trans2._updateWorldPositionAndRotationFlag();
          }
        }
      }
    }, {
      key: "_updateWorldPositionAndRotationFlag",
      value: function _updateWorldPositionAndRotationFlag() {
        if (!this._isContainDirtyFlags(Transform._WM_WP_WE_WQ_FLAGS)) {
          this._worldAssociatedChange(Transform._WM_WP_WE_WQ_FLAGS);

          var nodeChildren = this._entity._children;

          for (var i = 0, n = nodeChildren.length; i < n; i++) {
            var _nodeChildren$i$trans3;

            (_nodeChildren$i$trans3 = nodeChildren[i].transform) === null || _nodeChildren$i$trans3 === void 0 ? void 0 : _nodeChildren$i$trans3._updateWorldPositionAndRotationFlag();
          }
        }
      }
    }, {
      key: "_updateWorldScaleFlag",
      value: function _updateWorldScaleFlag() {
        if (!this._isContainDirtyFlags(Transform._WM_WS_FLAGS)) {
          this._worldAssociatedChange(Transform._WM_WS_FLAGS);

          var nodeChildren = this._entity._children;

          for (var i = 0, n = nodeChildren.length; i < n; i++) {
            var _nodeChildren$i$trans4;

            (_nodeChildren$i$trans4 = nodeChildren[i].transform) === null || _nodeChildren$i$trans4 === void 0 ? void 0 : _nodeChildren$i$trans4._updateWorldPositionAndScaleFlag();
          }
        }
      }
    }, {
      key: "_updateWorldPositionAndScaleFlag",
      value: function _updateWorldPositionAndScaleFlag() {
        if (!this._isContainDirtyFlags(Transform._WM_WP_WS_FLAGS)) {
          this._worldAssociatedChange(Transform._WM_WP_WS_FLAGS);

          var nodeChildren = this._entity._children;

          for (var i = 0, n = nodeChildren.length; i < n; i++) {
            var _nodeChildren$i$trans5;

            (_nodeChildren$i$trans5 = nodeChildren[i].transform) === null || _nodeChildren$i$trans5 === void 0 ? void 0 : _nodeChildren$i$trans5._updateWorldPositionAndScaleFlag();
          }
        }
      }
    }, {
      key: "_updateAllWorldFlag",
      value: function _updateAllWorldFlag() {
        if (!this._isContainDirtyFlags(Transform._WM_WP_WE_WQ_WS_FLAGS)) {
          this._worldAssociatedChange(Transform._WM_WP_WE_WQ_WS_FLAGS);

          var nodeChildren = this._entity._children;

          for (var i = 0, n = nodeChildren.length; i < n; i++) {
            var _nodeChildren$i$trans6;

            (_nodeChildren$i$trans6 = nodeChildren[i].transform) === null || _nodeChildren$i$trans6 === void 0 ? void 0 : _nodeChildren$i$trans6._updateAllWorldFlag();
          }
        }
      }
    }, {
      key: "_getParentTransform",
      value: function _getParentTransform() {
        if (!this._isParentDirty) {
          return this._parentTransformCache;
        }

        var parentCache = null;
        var parent = this._entity.parent;

        while (parent) {
          var transform = parent.transform;

          if (transform) {
            parentCache = transform;
            break;
          } else {
            parent = parent.parent;
          }
        }

        this._parentTransformCache = parentCache;
        this._isParentDirty = false;
        return parentCache;
      }
    }, {
      key: "_getScaleMatrix",
      value: function _getScaleMatrix() {
        var invRotation = Transform._tempQuat0;
        var invRotationMat = Transform._tempMat30;
        var worldRotScaMat = Transform._tempMat31;
        var scaMat = Transform._tempMat32;
        worldRotScaMat.setValueByMatrix(this.worldMatrix);
        Quaternion.invert(this.worldRotationQuaternion, invRotation);
        Matrix3x3.rotationQuaternion(invRotation, invRotationMat);
        Matrix3x3.multiply(invRotationMat, worldRotScaMat, scaMat);
        return scaMat;
      }
    }, {
      key: "_isContainDirtyFlags",
      value: function _isContainDirtyFlags(targetDirtyFlags) {
        return (this._dirtyFlag & targetDirtyFlags) === targetDirtyFlags;
      }
    }, {
      key: "_isContainDirtyFlag",
      value: function _isContainDirtyFlag(type) {
        return (this._dirtyFlag & type) != 0;
      }
    }, {
      key: "_setDirtyFlagTrue",
      value: function _setDirtyFlagTrue(type) {
        this._dirtyFlag |= type;
      }
    }, {
      key: "_setDirtyFlagFalse",
      value: function _setDirtyFlagFalse(type) {
        this._dirtyFlag &= ~type;
      }
    }, {
      key: "_worldAssociatedChange",
      value: function _worldAssociatedChange(type) {
        this._dirtyFlag |= type;
        var len = this._changeFlags.length;

        for (var i = len - 1; i >= 0; i--) {
          this._changeFlags[i].flag = true;
        }
      }
    }, {
      key: "_rotateByQuat",
      value: function _rotateByQuat(rotateQuat, relativeToLocal) {
        if (relativeToLocal) {
          Quaternion.multiply(this.rotationQuaternion, rotateQuat, this._rotationQuaternion);
          this.rotationQuaternion = this._rotationQuaternion;
        } else {
          Quaternion.multiply(this.worldRotationQuaternion, rotateQuat, this._worldRotationQuaternion);
          this.worldRotationQuaternion = this._worldRotationQuaternion;
        }
      }
    }, {
      key: "position",
      get: function get() {
        return this._position;
      },
      set: function set(value) {
        if (this._position !== value) {
          value.cloneTo(this._position);
        }

        this._setDirtyFlagTrue(Transform._LOCAL_MATRIX_FLAG);

        this._updateWorldPositionFlag();
      }
    }, {
      key: "worldPosition",
      get: function get() {
        if (this._isContainDirtyFlag(Transform._WORLD_POSITION_FLAG)) {
          if (this._getParentTransform()) {
            this.worldMatrix.getTranslation(this._worldPosition);
          } else {
            this._position.cloneTo(this._worldPosition);
          }

          this._setDirtyFlagFalse(Transform._WORLD_POSITION_FLAG);
        }

        return this._worldPosition;
      },
      set: function set(value) {
        if (this._worldPosition !== value) {
          value.cloneTo(this._worldPosition);
        }

        var parent = this._getParentTransform();

        if (parent) {
          Matrix.invert(parent.worldMatrix, Transform._tempMat41);
          Vector3.transformCoordinate(value, Transform._tempMat41, this._position);
        } else {
          value.cloneTo(this._position);
        }

        this.position = this._position;

        this._setDirtyFlagFalse(Transform._WORLD_POSITION_FLAG);
      }
    }, {
      key: "rotation",
      get: function get() {
        if (this._isContainDirtyFlag(Transform._LOCAL_EULER_FLAG)) {
          this._rotationQuaternion.toEuler(this._rotation);

          this._rotation.scale(MathUtil.radToDegreeFactor);

          this._setDirtyFlagFalse(Transform._LOCAL_EULER_FLAG);
        }

        return this._rotation;
      },
      set: function set(value) {
        if (this._rotation !== value) {
          value.cloneTo(this._rotation);
        }

        this._setDirtyFlagTrue(Transform._LOCAL_MATRIX_FLAG | Transform._LOCAL_QUAT_FLAG);

        this._setDirtyFlagFalse(Transform._LOCAL_EULER_FLAG);

        this._updateWorldRotationFlag();
      }
    }, {
      key: "worldRotation",
      get: function get() {
        if (this._isContainDirtyFlag(Transform._WORLD_EULER_FLAG)) {
          this.worldRotationQuaternion.toEuler(this._worldRotation);

          this._worldRotation.scale(MathUtil.radToDegreeFactor);

          this._setDirtyFlagFalse(Transform._WORLD_EULER_FLAG);
        }

        return this._worldRotation;
      },
      set: function set(value) {
        if (this._worldRotation !== value) {
          value.cloneTo(this._worldRotation);
        }

        Quaternion.rotationEuler(MathUtil.degreeToRadian(value.x), MathUtil.degreeToRadian(value.y), MathUtil.degreeToRadian(value.z), this._worldRotationQuaternion);
        this.worldRotationQuaternion = this._worldRotationQuaternion;

        this._setDirtyFlagFalse(Transform._WORLD_EULER_FLAG);
      }
    }, {
      key: "rotationQuaternion",
      get: function get() {
        if (this._isContainDirtyFlag(Transform._LOCAL_QUAT_FLAG)) {
          Quaternion.rotationEuler(MathUtil.degreeToRadian(this._rotation.x), MathUtil.degreeToRadian(this._rotation.y), MathUtil.degreeToRadian(this._rotation.z), this._rotationQuaternion);

          this._setDirtyFlagFalse(Transform._LOCAL_QUAT_FLAG);
        }

        return this._rotationQuaternion;
      },
      set: function set(value) {
        if (this._rotationQuaternion !== value) {
          value.cloneTo(this._rotationQuaternion);
        }

        this._setDirtyFlagTrue(Transform._LOCAL_MATRIX_FLAG | Transform._LOCAL_EULER_FLAG);

        this._setDirtyFlagFalse(Transform._LOCAL_QUAT_FLAG);

        this._updateWorldRotationFlag();
      }
    }, {
      key: "worldRotationQuaternion",
      get: function get() {
        if (this._isContainDirtyFlag(Transform._WORLD_QUAT_FLAG)) {
          var parent = this._getParentTransform();

          if (parent != null) {
            Quaternion.multiply(parent.worldRotationQuaternion, this.rotationQuaternion, this._worldRotationQuaternion);
          } else {
            this.rotationQuaternion.cloneTo(this._worldRotationQuaternion);
          }

          this._setDirtyFlagFalse(Transform._WORLD_QUAT_FLAG);
        }

        return this._worldRotationQuaternion;
      },
      set: function set(value) {
        if (this._worldRotationQuaternion !== value) {
          value.cloneTo(this._worldRotationQuaternion);
        }

        var parent = this._getParentTransform();

        if (parent) {
          Quaternion.invert(parent.worldRotationQuaternion, Transform._tempQuat0);
          Quaternion.multiply(value, Transform._tempQuat0, this._rotationQuaternion);
        } else {
          value.cloneTo(this._rotationQuaternion);
        }

        this.rotationQuaternion = this._rotationQuaternion;

        this._setDirtyFlagFalse(Transform._WORLD_QUAT_FLAG);
      }
    }, {
      key: "scale",
      get: function get() {
        return this._scale;
      },
      set: function set(value) {
        if (this._scale !== value) {
          value.cloneTo(this._scale);
        }

        this._setDirtyFlagTrue(Transform._LOCAL_MATRIX_FLAG);

        this._updateWorldScaleFlag();
      }
    }, {
      key: "lossyWorldScale",
      get: function get() {
        if (this._isContainDirtyFlag(Transform._WORLD_SCALE_FLAG)) {
          if (this._getParentTransform()) {
            var scaleMat = this._getScaleMatrix();

            var e = scaleMat.elements;

            this._lossyWorldScale.setValue(e[0], e[4], e[8]);
          } else {
            this._scale.cloneTo(this._lossyWorldScale);
          }

          this._setDirtyFlagFalse(Transform._WORLD_SCALE_FLAG);
        }

        return this._lossyWorldScale;
      }
    }, {
      key: "localMatrix",
      get: function get() {
        if (this._isContainDirtyFlag(Transform._LOCAL_MATRIX_FLAG)) {
          Matrix.affineTransformation(this._scale, this.rotationQuaternion, this._position, this._localMatrix);

          this._setDirtyFlagFalse(Transform._LOCAL_MATRIX_FLAG);
        }

        return this._localMatrix;
      },
      set: function set(value) {
        if (this._localMatrix !== value) {
          value.cloneTo(this._localMatrix);
        }

        this._localMatrix.decompose(this._position, this._rotationQuaternion, this._scale);

        this._setDirtyFlagTrue(Transform._LOCAL_EULER_FLAG);

        this._setDirtyFlagFalse(Transform._LOCAL_MATRIX_FLAG);

        this._updateAllWorldFlag();
      }
    }, {
      key: "worldMatrix",
      get: function get() {
        if (this._isContainDirtyFlag(Transform._WORLD_MATRIX_FLAG)) {
          var parent = this._getParentTransform();

          if (parent) {
            Matrix.multiply(parent.worldMatrix, this.localMatrix, this._worldMatrix);
          } else {
            this.localMatrix.cloneTo(this._worldMatrix);
          }

          this._setDirtyFlagFalse(Transform._WORLD_MATRIX_FLAG);
        }

        return this._worldMatrix;
      },
      set: function set(value) {
        if (this._worldMatrix !== value) {
          value.cloneTo(this._worldMatrix);
        }

        var parent = this._getParentTransform();

        if (parent) {
          Matrix.invert(parent.worldMatrix, Transform._tempMat42);
          Matrix.multiply(value, Transform._tempMat42, this._localMatrix);
        } else {
          value.cloneTo(this._localMatrix);
        }

        this.localMatrix = this._localMatrix;

        this._setDirtyFlagFalse(Transform._WORLD_MATRIX_FLAG);
      }
    }]);

    return Transform;
  }(Component);

  Transform._tempQuat0 = new Quaternion();
  Transform._tempVec3 = new Vector3();
  Transform._tempMat30 = new Matrix3x3();
  Transform._tempMat31 = new Matrix3x3();
  Transform._tempMat32 = new Matrix3x3();
  Transform._tempMat40 = new Matrix();
  Transform._tempMat41 = new Matrix();
  Transform._tempMat42 = new Matrix();
  Transform._tempMat43 = new Matrix();
  Transform._LOCAL_EULER_FLAG = 1;
  Transform._LOCAL_QUAT_FLAG = 2;
  Transform._WORLD_POSITION_FLAG = 4;
  Transform._WORLD_EULER_FLAG = 8;
  Transform._WORLD_QUAT_FLAG = 16;
  Transform._WORLD_SCALE_FLAG = 32;
  Transform._LOCAL_MATRIX_FLAG = 64;
  Transform._WORLD_MATRIX_FLAG = 128;
  Transform._WM_WP_FLAGS = 132;
  Transform._WM_WE_WQ_FLAGS = 152;
  Transform._WM_WP_WE_WQ_FLAGS = 156;
  Transform._WM_WS_FLAGS = 160;
  Transform._WM_WP_WS_FLAGS = 164;
  Transform._WM_WP_WE_WQ_WS_FLAGS = 188;

  __decorate$3([deepClone], Transform.prototype, "_position", 2);

  __decorate$3([deepClone], Transform.prototype, "_rotation", 2);

  __decorate$3([deepClone], Transform.prototype, "_rotationQuaternion", 2);

  __decorate$3([deepClone], Transform.prototype, "_scale", 2);

  __decorate$3([deepClone], Transform.prototype, "_worldPosition", 2);

  __decorate$3([deepClone], Transform.prototype, "_worldRotation", 2);

  __decorate$3([deepClone], Transform.prototype, "_worldRotationQuaternion", 2);

  __decorate$3([deepClone], Transform.prototype, "_lossyWorldScale", 2);

  __decorate$3([deepClone], Transform.prototype, "_localMatrix", 2);

  __decorate$3([deepClone], Transform.prototype, "_worldMatrix", 2);

  __decorate$3([ignoreClone], Transform.prototype, "_changeFlags", 2);

  __decorate$3([ignoreClone], Transform.prototype, "_isParentDirty", 2);

  __decorate$3([ignoreClone], Transform.prototype, "_parentTransformCache", 2);

  var Entity = /*#__PURE__*/function (_EventDispatcher2) {
    _inherits(Entity, _EventDispatcher2);

    var _super5 = _createSuper(Entity);

    function Entity(engine, name) {
      var _this8;

      _classCallCheck(this, Entity);

      _this8 = _super5.call(this, engine);
      _this8.layer = exports.Layer.Layer0;
      _this8._isActiveInHierarchy = false;
      _this8._components = [];
      _this8._children = [];
      _this8._isRoot = false;
      _this8._isActive = true;
      _this8._parent = null;
      _this8._invModelMatrix = new Matrix();

      Entity._entitys.add(_assertThisInitialized(_this8));

      _this8.name = name;
      _this8.transform = _this8.addComponent(Transform);
      _this8._inverseWorldMatFlag = _this8.transform.registerWorldChangeFlag();
      return _this8;
    }

    _createClass(Entity, [{
      key: "addComponent",
      value: function addComponent(type) {
        ComponentsDependencies._addCheck(this, type);

        var component = new type(this);

        this._components.push(component);

        if (this._isActiveInHierarchy) {
          component._setActive(true);
        }

        return component;
      }
    }, {
      key: "getComponent",
      value: function getComponent(type) {
        for (var i = this._components.length - 1; i >= 0; i--) {
          var component = this._components[i];

          if (component instanceof type) {
            return component;
          }
        }
      }
    }, {
      key: "getComponents",
      value: function getComponents(type, results) {
        results.length = 0;

        for (var i = this._components.length - 1; i >= 0; i--) {
          var component = this._components[i];

          if (component instanceof type) {
            results.push(component);
          }
        }

        return results;
      }
    }, {
      key: "getComponentsIncludeChildren",
      value: function getComponentsIncludeChildren(type, results) {
        results.length = 0;

        this._getComponentsIncludeChildren(type, results);

        return results;
      }
    }, {
      key: "addChild",
      value: function addChild(child) {
        child.parent = this;
      }
    }, {
      key: "removeChild",
      value: function removeChild(child) {
        child.parent = null;
      }
    }, {
      key: "getChild",
      value: function getChild(index) {
        return this._children[index];
      }
    }, {
      key: "findByName",
      value: function findByName(name) {
        var children = this._children;

        var child = Entity._findChildByName(this, name);

        if (child) return child;

        for (var i = children.length - 1; i >= 0; i--) {
          var child2 = children[i];
          var grandson = child2.findByName(name);

          if (grandson) {
            return grandson;
          }
        }

        return null;
      }
    }, {
      key: "findByPath",
      value: function findByPath(path) {
        var splits = path.split("/");
        var entity = this;

        for (var i = 0, length = splits.length; i < length; ++i) {
          var split = splits[i];

          if (split) {
            entity = Entity._findChildByName(entity, split);

            if (!entity) {
              return null;
            }
          }
        }

        return entity;
      }
    }, {
      key: "createChild",
      value: function createChild(name) {
        var child = new Entity(this.engine, name);
        child.layer = this.layer;
        child.parent = this;
        return child;
      }
    }, {
      key: "clearChildren",
      value: function clearChildren() {
        var children = this._children;

        for (var i = children.length - 1; i >= 0; i--) {
          var child = children[i];
          child._parent = null;
          child._isActiveInHierarchy && child._processInActive();

          Entity._traverseSetOwnerScene(child, null);
        }

        children.length = 0;
      }
    }, {
      key: "clone",
      value: function clone() {
        var cloneEntity = new Entity(this._engine, this.name);
        cloneEntity._isActive = this._isActive;
        cloneEntity.transform.localMatrix = this.transform.localMatrix;
        var children = this._children;

        for (var i = 0, len = this._children.length; i < len; i++) {
          var child = children[i];
          cloneEntity.addChild(child.clone());
        }

        var components = this._components;

        for (var _i4 = 0, n = components.length; _i4 < n; _i4++) {
          var sourceComp = components[_i4];

          if (!(sourceComp instanceof Transform)) {
            var targetComp = cloneEntity.addComponent(sourceComp.constructor);
            ComponentCloner.cloneComponent(sourceComp, targetComp);
          }
        }

        return cloneEntity;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        var abilityArray = this._components;

        for (var i = abilityArray.length - 1; i >= 0; i--) {
          abilityArray[i].destroy();
        }

        this._components.length = 0;
        var children = this._children;

        for (var _i5 = children.length - 1; _i5 >= 0; _i5--) {
          children[_i5].destroy();
        }

        this._children.length = 0;

        if (this._parent != null) {
          var parentChildren = this._parent._children;
          parentChildren.splice(parentChildren.indexOf(this), 1);
        }

        this._parent = null;

        Entity._entitys["delete"](this);
      }
    }, {
      key: "_removeComponent",
      value: function _removeComponent(component) {
        ComponentsDependencies._removeCheck(this, component.constructor);

        var components = this._components;
        components.splice(components.indexOf(component), 1);
      }
    }, {
      key: "_removeFromParent",
      value: function _removeFromParent() {
        var oldParent = this._parent;

        if (oldParent != null) {
          var oldParentChildren = oldParent._children;
          oldParentChildren.splice(oldParentChildren.indexOf(this), 1);
          this._parent = null;
        }

        return oldParent;
      }
    }, {
      key: "_processActive",
      value: function _processActive() {
        if (this._activeChangedComponents) {
          throw "Note: can't set the 'main inActive entity' active in hierarchy, if the operation is in main inActive entity or it's children script's onDisable Event.";
        }

        this._activeChangedComponents = this._engine._componentsManager.getActiveChangedTempList();

        this._setActiveInHierarchy(this._activeChangedComponents);

        this._setActiveComponents(true);
      }
    }, {
      key: "_processInActive",
      value: function _processInActive() {
        if (this._activeChangedComponents) {
          throw "Note: can't set the 'main active entity' inActive in hierarchy, if the operation is in main active entity or it's children script's onEnable Event.";
        }

        this._activeChangedComponents = this._engine._componentsManager.getActiveChangedTempList();

        this._setInActiveInHierarchy(this._activeChangedComponents);

        this._setActiveComponents(false);
      }
    }, {
      key: "_getComponentsIncludeChildren",
      value: function _getComponentsIncludeChildren(type, results) {
        for (var i = this._components.length - 1; i >= 0; i--) {
          var component = this._components[i];

          if (component instanceof type) {
            results.push(component);
          }
        }

        for (var _i6 = this._children.length - 1; _i6 >= 0; _i6--) {
          this._children[_i6]._getComponentsIncludeChildren(type, results);
        }
      }
    }, {
      key: "_setActiveComponents",
      value: function _setActiveComponents(isActive) {
        var activeChangedComponents = this._activeChangedComponents;

        for (var i = 0, length = activeChangedComponents.length; i < length; ++i) {
          activeChangedComponents[i]._setActive(isActive);
        }

        this._engine._componentsManager.putActiveChangedTempList(activeChangedComponents);

        this._activeChangedComponents = null;
      }
    }, {
      key: "_setActiveInHierarchy",
      value: function _setActiveInHierarchy(activeChangedComponents) {
        this._isActiveInHierarchy = true;
        var components = this._components;

        for (var i = components.length - 1; i >= 0; i--) {
          activeChangedComponents.push(components[i]);
        }

        var children = this._children;

        for (var _i7 = children.length - 1; _i7 >= 0; _i7--) {
          var child = children[_i7];
          child.isActive && child._setActiveInHierarchy(activeChangedComponents);
        }
      }
    }, {
      key: "_setInActiveInHierarchy",
      value: function _setInActiveInHierarchy(activeChangedComponents) {
        this._isActiveInHierarchy = false;
        var components = this._components;

        for (var i = components.length - 1; i >= 0; i--) {
          activeChangedComponents.push(components[i]);
        }

        var children = this._children;

        for (var _i8 = children.length - 1; _i8 >= 0; _i8--) {
          var child = children[_i8];
          child.isActive && child._setInActiveInHierarchy(activeChangedComponents);
        }
      }
    }, {
      key: "_setTransformDirty",
      value: function _setTransformDirty() {
        if (this.transform) {
          this.transform._parentChange();
        } else {
          for (var i = 0, len = this._children.length; i < len; i++) {
            this._children[i]._setTransformDirty();
          }
        }
      }
    }, {
      key: "getInvModelMatrix",
      value: function getInvModelMatrix() {
        if (this._inverseWorldMatFlag.flag) {
          Matrix.invert(this.transform.worldMatrix, this._invModelMatrix);
          this._inverseWorldMatFlag.flag = false;
        }

        return this._invModelMatrix;
      }
    }, {
      key: "isActive",
      get: function get() {
        return this._isActive;
      },
      set: function set(value) {
        if (value !== this._isActive) {
          this._isActive = value;

          if (value) {
            var parent = this._parent;

            if (parent !== null && parent !== void 0 && parent._isActiveInHierarchy || this._isRoot && this._scene._isActiveInEngine) {
              this._processActive();
            }
          } else {
            if (this._isActiveInHierarchy) {
              this._processInActive();
            }
          }
        }
      }
    }, {
      key: "isActiveInHierarchy",
      get: function get() {
        return this._isActiveInHierarchy;
      }
    }, {
      key: "parent",
      get: function get() {
        return this._parent;
      },
      set: function set(entity) {
        if (entity !== this._parent) {
          var oldParent = this._removeFromParent();

          var newParent = this._parent = entity;

          if (newParent) {
            newParent._children.push(this);

            var parentScene = newParent._scene;

            if (this._scene !== parentScene) {
              Entity._traverseSetOwnerScene(this, parentScene);
            }

            if (newParent._isActiveInHierarchy) {
              !this._isActiveInHierarchy && this._isActive && this._processActive();
            } else {
              this._isActiveInHierarchy && this._processInActive();
            }
          } else {
            this._isActiveInHierarchy && this._processInActive();

            if (oldParent) {
              Entity._traverseSetOwnerScene(this, null);
            }
          }

          this._setTransformDirty();
        }
      }
    }, {
      key: "children",
      get: function get() {
        return this._children;
      }
    }, {
      key: "childCount",
      get: function get() {
        return this._children.length;
      }
    }, {
      key: "scene",
      get: function get() {
        return this._scene;
      }
    }, {
      key: "engine",
      get: function get() {
        return this._engine;
      }
    }, {
      key: "position",
      get: function get() {
        return this.transform.position;
      },
      set: function set(val) {
        this.transform.position = val;
      }
    }, {
      key: "worldPosition",
      get: function get() {
        return this.transform.worldPosition;
      },
      set: function set(val) {
        this.transform.worldPosition = val;
      }
    }, {
      key: "rotation",
      get: function get() {
        return this.transform.rotationQuaternion;
      },
      set: function set(val) {
        this.transform.rotationQuaternion = val;
      }
    }, {
      key: "scale",
      get: function get() {
        return this.transform.scale;
      },
      set: function set(val) {
        this.transform.scale = val;
      }
    }], [{
      key: "findByName",
      value: function findByName(name) {
        var entitys = Entity._entitys;
        var elements = entitys._elements;

        for (var i = entitys.length - 1; i >= 0; i--) {
          var entity = elements[i];

          if (entity.name === name) {
            return entity;
          }
        }

        return null;
      }
    }, {
      key: "findByPath",
      value: function findByPath(scene, path) {
        return scene.findEntityByPath(path);
      }
    }, {
      key: "_findChildByName",
      value: function _findChildByName(root, name) {
        var children = root._children;

        for (var i = children.length - 1; i >= 0; i--) {
          var child = children[i];

          if (child.name === name) {
            return child;
          }
        }

        return null;
      }
    }, {
      key: "_traverseSetOwnerScene",
      value: function _traverseSetOwnerScene(entity, scene) {
        entity._scene = scene;
        var children = entity._children;

        for (var i = entity.childCount - 1; i >= 0; i--) {
          this._traverseSetOwnerScene(children[i], scene);
        }
      }
    }]);

    return Entity;
  }(EventDispatcher);

  Entity._entitys = new DisorderedArray();

  var FeatureManager = /*#__PURE__*/function () {
    function FeatureManager() {
      _classCallCheck(this, FeatureManager);

      this._features = [];
      this._objects = [];
    }

    _createClass(FeatureManager, [{
      key: "registerFeature",
      value: function registerFeature(IFeature) {
        var featureArray = this._features;

        for (var i = 0, len = featureArray.length; i < len; i++) {
          if (featureArray[i] === IFeature) {
            return;
          }
        }

        featureArray.push(IFeature);
        var objectArray = this._objects;

        for (var _i9 = 0, _len5 = objectArray.length; _i9 < _len5; _i9++) {
          objectArray[_i9].features.push(new IFeature());
        }
      }
    }, {
      key: "addObject",
      value: function addObject(obj) {
        obj.features = [];

        for (var i = 0, len = this._features.length; i < len; i++) {
          var _obj$engine;

          obj.features.push(new this._features[i]((_obj$engine = obj.engine) !== null && _obj$engine !== void 0 ? _obj$engine : obj));
        }

        this._objects.push(obj);
      }
    }, {
      key: "callFeatureMethod",
      value: function callFeatureMethod(obj, method, args) {
        var features = obj.features;
        var count = features.length;

        for (var i = 0; i < count; i++) {
          var feature = features[i];

          if (feature[method]) {
            feature[method].apply(feature, args);
          }
        }
      }
    }, {
      key: "findFeature",
      value: function findFeature(obj, IFeature) {
        var features = obj.features;
        var count = features.length;

        for (var i = 0; i < count; i++) {
          var feature = features[i];

          if (feature.constructor === IFeature) {
            return feature;
          }
        }

        return void 0;
      }
    }]);

    return FeatureManager;
  }();

  var RenderElement = /*#__PURE__*/function () {
    function RenderElement() {
      _classCallCheck(this, RenderElement);
    }

    _createClass(RenderElement, [{
      key: "setValue",
      value: function setValue(component, primitive, subPrimitive, material) {
        this.component = component;
        this.primitive = primitive;
        this.subPrimitive = subPrimitive;
        this.material = material;
      }
    }], [{
      key: "getFromPool",
      value: function getFromPool() {
        var index = RenderElement._elementPoolIndex,
            pool = RenderElement._elementPool;
        RenderElement._elementPoolIndex++;

        if (pool.length === index) {
          var element = new RenderElement();
          pool.push(element);
          return element;
        } else {
          return pool[index];
        }
      }
    }, {
      key: "_restPool",
      value: function _restPool() {
        RenderElement._elementPoolIndex = 0;
      }
    }]);

    return RenderElement;
  }();

  RenderElement._elementPoolIndex = 0;
  RenderElement._elementPool = [];

  var Scene = /*#__PURE__*/function (_EventDispatcher3) {
    _inherits(Scene, _EventDispatcher3);

    var _super6 = _createSuper(Scene);

    function Scene(engine, name) {
      var _this9;

      _classCallCheck(this, Scene);

      _this9 = _super6.call(this, engine);
      _this9.clipPlanes = [];
      _this9._activeCameras = [];
      _this9._isActiveInEngine = false;
      _this9._destroyed = false;
      _this9._rootEntities = [];
      _this9.features = [];
      _this9.name = name || "";
      Scene.sceneFeatureManager.addObject(_assertThisInitialized(_this9));
      return _this9;
    }

    _createClass(Scene, [{
      key: "createRootEntity",
      value: function createRootEntity(name) {
        var entity = new Entity(this._engine, name);
        this.addRootEntity(entity);
        return entity;
      }
    }, {
      key: "addRootEntity",
      value: function addRootEntity(entity) {
        var isRoot = entity._isRoot;

        if (!isRoot) {
          entity._isRoot = true;

          entity._removeFromParent();
        }

        var oldScene = entity._scene;

        if (oldScene !== this) {
          if (oldScene && isRoot) {
            oldScene._removeEntity(entity);
          }

          this._rootEntities.push(entity);

          Entity._traverseSetOwnerScene(entity, this);
        } else if (!isRoot) {
          this._rootEntities.push(entity);
        }

        if (this._isActiveInEngine) {
          !entity._isActiveInHierarchy && entity._isActive && entity._processActive();
        } else {
          entity._isActiveInHierarchy && entity._processInActive();
        }
      }
    }, {
      key: "removeRootEntity",
      value: function removeRootEntity(entity) {
        if (entity._isRoot && entity._scene == this) {
          this._removeEntity(entity);

          this._isActiveInEngine && entity._processInActive();

          Entity._traverseSetOwnerScene(entity, null);
        }
      }
    }, {
      key: "getRootEntity",
      value: function getRootEntity() {
        var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        return this._rootEntities[index];
      }
    }, {
      key: "findEntityByName",
      value: function findEntityByName(name) {
        var children = this._rootEntities;

        for (var i = children.length - 1; i >= 0; i--) {
          var child = children[i];

          if (child.name === name) {
            return child;
          }
        }

        for (var _i10 = children.length - 1; _i10 >= 0; _i10--) {
          var _child = children[_i10];

          var entity = _child.findByName(name);

          if (entity) {
            return entity;
          }
        }

        return null;
      }
    }, {
      key: "findEntityByPath",
      value: function findEntityByPath(path) {
        var splits = path.split("/").filter(Boolean);

        for (var i = 0, n = this.rootEntitiesCount; i < n; i++) {
          var findEntity = this.getRootEntity(i);
          if (findEntity.name != splits[0]) continue;

          for (var j = 1, m = splits.length; j < m; ++j) {
            findEntity = Entity._findChildByName(findEntity, splits[j]);
            if (!findEntity) break;
          }

          return findEntity;
        }

        return null;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this._isActiveInEngine && (this._engine.sceneManager.activeScene = null);
        Scene.sceneFeatureManager.callFeatureMethod(this, "destroy", [this]);

        for (var i = 0, n = this.rootEntitiesCount; i < n; i++) {
          this._rootEntities[i].destroy();
        }

        this._rootEntities.length = 0;
        this._activeCameras.length = 0;
        Scene.sceneFeatureManager._objects = [];
        this._destroyed = true;
      }
    }, {
      key: "attachRenderCamera",
      value: function attachRenderCamera(camera) {
        var index = this._activeCameras.indexOf(camera);

        if (index === -1) {
          this._activeCameras.push(camera);
        } else {
          Logger.warn("Camera already attached.");
        }
      }
    }, {
      key: "detachRenderCamera",
      value: function detachRenderCamera(camera) {
        var index = this._activeCameras.indexOf(camera);

        if (index !== -1) {
          this._activeCameras.splice(index, 1);
        }
      }
    }, {
      key: "_processActive",
      value: function _processActive(active) {
        this._isActiveInEngine = active;
        var rootEntities = this._rootEntities;

        for (var i = rootEntities.length - 1; i >= 0; i--) {
          var entity = rootEntities[i];

          if (entity._isActive) {
            active ? entity._processActive() : entity._processInActive();
          }
        }
      }
    }, {
      key: "_removeEntity",
      value: function _removeEntity(entity) {
        var oldRootEntities = this._rootEntities;
        oldRootEntities.splice(oldRootEntities.indexOf(entity), 1);
      }
    }, {
      key: "findFeature",
      value: function findFeature(Feature) {
        return Scene.sceneFeatureManager.findFeature(this, Feature);
      }
    }, {
      key: "raycast",
      value: function raycast(ray, outPos, tag) {}
    }, {
      key: "engine",
      get: function get() {
        return this._engine;
      }
    }, {
      key: "rootEntitiesCount",
      get: function get() {
        return this._rootEntities.length;
      }
    }, {
      key: "rootEntities",
      get: function get() {
        return this._rootEntities;
      }
    }, {
      key: "destroyed",
      get: function get() {
        return this._destroyed;
      }
    }], [{
      key: "registerFeature",
      value: function registerFeature(Feature) {
        Scene.sceneFeatureManager.registerFeature(Feature);
      }
    }]);

    return Scene;
  }(EventDispatcher);

  Scene.sceneFeatureManager = new FeatureManager();

  var SceneManager = /*#__PURE__*/function () {
    function SceneManager(engine) {
      _classCallCheck(this, SceneManager);

      this.engine = engine;
    }

    _createClass(SceneManager, [{
      key: "loadScene",
      value: function loadScene(url) {
        var _this10 = this;

        var destroyOldScene = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var scenePromise = this.engine.resourceManager.load(url);
        scenePromise.then(function (scene) {
          var oldScene = _this10._activeScene;
          _this10.activeScene = scene;

          if (oldScene && destroyOldScene) {
            oldScene.destroy();
          }
        });
        return scenePromise;
      }
    }, {
      key: "mergeScenes",
      value: function mergeScenes(sourceScene, destScene) {
        var oldRootEntities = sourceScene.rootEntities;

        for (var i = 0, n = oldRootEntities.length; i < n; i++) {
          destScene.addRootEntity(oldRootEntities[i]);
        }
      }
    }, {
      key: "activeScene",
      get: function get() {
        return this._activeScene;
      },
      set: function set(scene) {
        var oldScene = this._activeScene;

        if (oldScene !== scene) {
          oldScene && oldScene._processActive(false);
          scene && scene._processActive(true);
          this._activeScene = scene;
        }
      }
    }]);

    return SceneManager;
  }();

  var engineFeatureManager = new FeatureManager();

  var Engine = /*#__PURE__*/function (_EventDispatcher4) {
    _inherits(Engine, _EventDispatcher4);

    var _super7 = _createSuper(Engine);

    function Engine(canvas, hardwareRenderer) {
      var _this11;

      _classCallCheck(this, Engine);

      _this11 = _super7.call(this, null);
      _this11._componentsManager = new ComponentsManager();
      _this11._resourceManager = new ResourceManager(_assertThisInitialized(_this11));
      _this11._sceneManager = new SceneManager(_assertThisInitialized(_this11));
      _this11._vSyncCount = 1;
      _this11._targetFrameRate = 60;
      _this11._time = new Time();
      _this11._isPaused = true;
      _this11._loopCounter = 0;
      _this11._targetFrameInterval = 1e3 / 60;

      _this11._animate = function () {
        if (_this11._vSyncCount) {
          _this11._requestId = requestAnimationFrame(_this11._animate);

          if (_this11._loopCounter++ % _this11._vSyncCount === 0) {
            _this11.update();

            _this11._loopCounter = 1;
          }
        } else {
          _this11._timeoutId = window.setTimeout(_this11._animate, _this11._targetFrameInterval);

          _this11.update();
        }
      };

      _this11.features = [];
      _this11._hardwareRenderer = hardwareRenderer;

      _this11._hardwareRenderer.init(canvas, _assertThisInitialized(_this11));

      _this11._canvas = canvas;
      engineFeatureManager.addObject(_assertThisInitialized(_this11));
      _this11._sceneManager.activeScene = new Scene(_assertThisInitialized(_this11), "DefaultScene");
      return _this11;
    }

    _createClass(Engine, [{
      key: "createEntity",
      value: function createEntity(name) {
        return new Entity(this, name);
      }
    }, {
      key: "pause",
      value: function pause() {
        this._isPaused = true;
        cancelAnimationFrame(this._requestId);
        clearTimeout(this._timeoutId);
      }
    }, {
      key: "resume",
      value: function resume() {
        if (!this._isPaused) return;
        this._isPaused = false;
        this.time.reset();
        requestAnimationFrame(this._animate);
      }
    }, {
      key: "update",
      value: function update() {
        var time = this._time;
        var deltaTime = time.deltaTime;
        time.tick();

        RenderElement._restPool();

        engineFeatureManager.callFeatureMethod(this, "preTick", [this, this._sceneManager._activeScene]);

        this._hardwareRenderer.beginFrame();

        var scene = this._sceneManager._activeScene;
        var componentsManager = this._componentsManager;

        if (scene) {
          componentsManager.callScriptOnStart();
          componentsManager.callScriptOnUpdate(deltaTime);
          componentsManager.callAnimationUpdate(deltaTime);
          componentsManager.callScriptOnLateUpdate(deltaTime);

          this._render(scene);
        }

        this._componentsManager.callComponentDestory();

        this._hardwareRenderer.endFrame();

        engineFeatureManager.callFeatureMethod(this, "postTick", [this, this._sceneManager._activeScene]);
      }
    }, {
      key: "run",
      value: function run() {
        engineFeatureManager.callFeatureMethod(this, "preLoad", [this]);
        this.resume();
        this.trigger(new Event("run", this));
      }
    }, {
      key: "destroy",
      value: function destroy() {
        if (this._sceneManager) {
          this.trigger(new Event("shutdown", this));
          engineFeatureManager.callFeatureMethod(this, "shutdown", [this]);
          this.pause();
          this._animate = null;

          this._sceneManager._activeScene.destroy();

          this._sceneManager = null;

          this._resourceManager.gc();

          this._resourceManager = null;
          this._canvas = null;
          this.features = [];
          this._time = null;
          engineFeatureManager._objects = [];
        }
      }
    }, {
      key: "_render",
      value: function _render(scene) {
        var cameras = scene._activeCameras;
        var componentsManager = this._componentsManager;
        var deltaTime = this.time.deltaTime;
        componentsManager.callRendererOnUpdate(deltaTime);

        if (cameras.length > 0) {
          cameras.sort(function (camera1, camera2) {
            return camera1.priority - camera2.priority;
          });

          for (var i = 0, l = cameras.length; i < l; i++) {
            var camera = cameras[i];
            var cameraEntity = camera.entity;

            if (camera.enabled && cameraEntity.isActiveInHierarchy) {
              componentsManager.callCameraOnBeginRender(camera);
              Scene.sceneFeatureManager.callFeatureMethod(scene, "preRender", [this, camera]);
              camera.render();
              Scene.sceneFeatureManager.callFeatureMethod(scene, "postRender", [this, camera]);
              componentsManager.callCameraOnEndRender(camera);
            }
          }
        } else {
          Logger.debug("NO active camera.");
        }
      }
    }, {
      key: "findFeature",
      value: function findFeature(Feature) {
        return engineFeatureManager.findFeature(this, Feature);
      }
    }, {
      key: "canvas",
      get: function get() {
        return this._canvas;
      }
    }, {
      key: "resourceManager",
      get: function get() {
        return this._resourceManager;
      }
    }, {
      key: "sceneManager",
      get: function get() {
        return this._sceneManager;
      }
    }, {
      key: "time",
      get: function get() {
        return this._time;
      }
    }, {
      key: "isPaused",
      get: function get() {
        return this._isPaused;
      }
    }, {
      key: "vSyncCount",
      get: function get() {
        return this._vSyncCount;
      },
      set: function set(value) {
        this._vSyncCount = Math.max(0, Math.floor(value));
      }
    }, {
      key: "targetFrameRate",
      get: function get() {
        return this._targetFrameRate;
      },
      set: function set(value) {
        value = Math.max(1e-6, value);
        this._targetFrameRate = value;
        this._targetFrameInterval = 1e3 / value;
      }
    }, {
      key: "renderhardware",
      get: function get() {
        return this._hardwareRenderer;
      }
    }], [{
      key: "registerFeature",
      value: function registerFeature(Feature) {
        engineFeatureManager.registerFeature(Feature);
      }
    }]);

    return Engine;
  }(EventDispatcher);

  var SystemInfo = /*#__PURE__*/function () {
    function SystemInfo() {
      _classCallCheck(this, SystemInfo);
    }

    _createClass(SystemInfo, null, [{
      key: "devicePixelRatio",
      get: function get() {
        return window.devicePixelRatio;
      }
    }]);

    return SystemInfo;
  }();

  var EngineFeature = /*#__PURE__*/function () {
    function EngineFeature() {
      _classCallCheck(this, EngineFeature);
    }

    _createClass(EngineFeature, [{
      key: "preLoad",
      value: function preLoad(engine) {}
    }, {
      key: "preTick",
      value: function preTick(engine, currentScene) {}
    }, {
      key: "postTick",
      value: function postTick(engine, currentScene) {}
    }, {
      key: "shutdown",
      value: function shutdown(engine) {}
    }]);

    return EngineFeature;
  }();

  var AssetObject = /*#__PURE__*/function (_EngineObject2) {
    _inherits(AssetObject, _EngineObject2);

    var _super8 = _createSuper(AssetObject);

    function AssetObject() {
      _classCallCheck(this, AssetObject);

      return _super8.apply(this, arguments);
    }

    return AssetObject;
  }(EngineObject);

  var SceneVisitor = function SceneVisitor() {
    _classCallCheck(this, SceneVisitor);
  };

  var SceneFeature = /*#__PURE__*/function () {
    function SceneFeature() {
      _classCallCheck(this, SceneFeature);
    }

    _createClass(SceneFeature, [{
      key: "preUpdate",
      value: function preUpdate(scene) {}
    }, {
      key: "postUpdate",
      value: function postUpdate(scene) {}
    }, {
      key: "preRender",
      value: function preRender(scene, camera) {}
    }, {
      key: "postRender",
      value: function postRender(scene, camera) {}
    }, {
      key: "destroy",
      value: function destroy(scene) {}
    }]);

    return SceneFeature;
  }();

  var __defProp$4 = Object.defineProperty;
  var __getOwnPropDesc$4 = Object.getOwnPropertyDescriptor;

  var __decorate$4 = function __decorate$4(decorators, target, key, kind) {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$4(target, key) : target;

    for (var i = decorators.length - 1, decorator; i >= 0; i--) {
      if (decorator = decorators[i]) result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    }

    if (kind && result) __defProp$4(target, key, result);
    return result;
  };

  var Script = /*#__PURE__*/function (_Component2) {
    _inherits(Script, _Component2);

    var _super9 = _createSuper(Script);

    function Script() {
      var _this12;

      _classCallCheck(this, Script);

      _this12 = _super9.apply(this, arguments);
      _this12._started = false;
      _this12._onStartIndex = -1;
      _this12._onUpdateIndex = -1;
      _this12._onLateUpdateIndex = -1;
      _this12._onPreRenderIndex = -1;
      _this12._onPostRenderIndex = -1;
      return _this12;
    }

    _createClass(Script, [{
      key: "onAwake",
      value: function onAwake() {}
    }, {
      key: "onEnable",
      value: function onEnable() {}
    }, {
      key: "onStart",
      value: function onStart() {}
    }, {
      key: "onUpdate",
      value: function onUpdate(deltaTime) {}
    }, {
      key: "onLateUpdate",
      value: function onLateUpdate(deltaTime) {}
    }, {
      key: "onBeginRender",
      value: function onBeginRender(camera) {}
    }, {
      key: "onEndRender",
      value: function onEndRender(camera) {}
    }, {
      key: "onDisable",
      value: function onDisable() {}
    }, {
      key: "onDestroy",
      value: function onDestroy() {}
    }, {
      key: "_onAwake",
      value: function _onAwake() {
        this.onAwake();
      }
    }, {
      key: "_onEnable",
      value: function _onEnable() {
        var componentsManager = this.engine._componentsManager;
        var prototype = Script.prototype;

        if (!this._started) {
          componentsManager.addOnStartScript(this);
        }

        if (this.onUpdate !== prototype.onUpdate) {
          componentsManager.addOnUpdateScript(this);
        }

        if (this.onLateUpdate !== prototype.onLateUpdate) {
          componentsManager.addOnLateUpdateScript(this);
        }

        this.onEnable();
      }
    }, {
      key: "_onDisable",
      value: function _onDisable() {
        var componentsManager = this.engine._componentsManager;

        if (this._onStartIndex !== -1) {
          componentsManager.removeOnStartScript(this);
        }

        if (this._onUpdateIndex !== -1) {
          componentsManager.removeOnUpdateScript(this);
        }

        if (this._onLateUpdateIndex !== -1) {
          componentsManager.removeOnLateUpdateScript(this);
        }

        this.onDisable();
      }
    }, {
      key: "_onDestroy",
      value: function _onDestroy() {
        this.engine._componentsManager.addDestoryComponent(this);
      }
    }]);

    return Script;
  }(Component);

  __decorate$4([ignoreClone], Script.prototype, "_started", 2);

  __decorate$4([ignoreClone], Script.prototype, "_onStartIndex", 2);

  __decorate$4([ignoreClone], Script.prototype, "_onUpdateIndex", 2);

  __decorate$4([ignoreClone], Script.prototype, "_onLateUpdateIndex", 2);

  __decorate$4([ignoreClone], Script.prototype, "_onPreRenderIndex", 2);

  __decorate$4([ignoreClone], Script.prototype, "_onPostRenderIndex", 2);

  var __defProp$5 = Object.defineProperty;
  var __getOwnPropDesc$5 = Object.getOwnPropertyDescriptor;

  var __decorate$5 = function __decorate$5(decorators, target, key, kind) {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$5(target, key) : target;

    for (var i = decorators.length - 1, decorator; i >= 0; i--) {
      if (decorator = decorators[i]) result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    }

    if (kind && result) __defProp$5(target, key, result);
    return result;
  };

  var RenderableComponent = /*#__PURE__*/function (_Component3) {
    _inherits(RenderableComponent, _Component3);

    var _super10 = _createSuper(RenderableComponent);

    function RenderableComponent(entity) {
      var _this13;

      _classCallCheck(this, RenderableComponent);

      _this13 = _super10.call(this, entity);
      _this13._onUpdateIndex = -1;
      _this13._rendererIndex = -1;
      _this13._overrideUpdate = false;
      _this13._bounds = new BoundingBox(new Vector3(), new Vector3());
      var prototype = RenderableComponent.prototype;
      _this13._overrideUpdate = _this13.update !== prototype.update;
      _this13._transformChangeFlag = _this13.entity.transform.registerWorldChangeFlag();
      return _this13;
    }

    _createClass(RenderableComponent, [{
      key: "destroy",
      value: function destroy() {
        _get(_getPrototypeOf(RenderableComponent.prototype), "destroy", this).call(this);

        var flag = this._transformChangeFlag;

        if (flag) {
          flag.destroy();
          this._transformChangeFlag = null;
        }
      }
    }, {
      key: "update",
      value: function update(deltaTime) {}
    }, {
      key: "_updateBounds",
      value: function _updateBounds(worldBounds) {}
    }, {
      key: "_onEnable",
      value: function _onEnable() {
        var componentsManager = this.engine._componentsManager;

        if (this._overrideUpdate) {
          componentsManager.addOnUpdateRenderers(this);
        }

        componentsManager.addRenderer(this);
      }
    }, {
      key: "_onDisable",
      value: function _onDisable() {
        var componentsManager = this.engine._componentsManager;

        if (this._overrideUpdate) {
          componentsManager.removeOnUpdateRenderers(this);
        }

        componentsManager.removeRenderer(this);
      }
    }, {
      key: "_render",
      value: function _render(camera) {
        var culled = false;

        if (this.cullDistanceSq > 0) {
          var distanceSq = Vector3.distanceSquared(camera._entity.transform.worldPosition, this.entity.transform.worldPosition);
          culled = this.cullDistanceSq < distanceSq;
        }

        if (!culled) {
          this.render(camera);
        }
      }
    }, {
      key: "bounds",
      get: function get() {
        var changeFlag = this._transformChangeFlag;

        if (changeFlag.flag) {
          this._updateBounds(this._bounds);

          changeFlag.flag = false;
        }

        return this._bounds;
      }
    }]);

    return RenderableComponent;
  }(Component);

  __decorate$5([ignoreClone], RenderableComponent.prototype, "_onUpdateIndex", 2);

  __decorate$5([ignoreClone], RenderableComponent.prototype, "_rendererIndex", 2);

  __decorate$5([ignoreClone], RenderableComponent.prototype, "_overrideUpdate", 2);

  __decorate$5([ignoreClone], RenderableComponent.prototype, "_transformChangeFlag", 2);

  __decorate$5([deepClone], RenderableComponent.prototype, "_bounds", 2);

  var passNum = 0;

  var RenderPass = /*#__PURE__*/function () {
    function RenderPass() {
      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "RENDER_PASS".concat(passNum++);
      var priority = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var renderTarget = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var replaceMaterial = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var mask = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      var clearParam = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new Vector4(0, 0, 0, 0);

      _classCallCheck(this, RenderPass);

      this.name = name;
      this.enabled = true;
      this.priority = priority;
      this.renderTarget = renderTarget;
      this.replaceMaterial = replaceMaterial;
      this.mask = mask || exports.MaskList.EVERYTHING;
      this.renderOverride = false;
      this.clearMode = exports.ClearMode.SOLID_COLOR;
      this._clearParam = clearParam;
    }

    _createClass(RenderPass, [{
      key: "render",
      value: function render(camera, opaqueQueue, transparentQueue) {}
    }, {
      key: "preRender",
      value: function preRender(camera, opaqueQueue, transparentQueue) {}
    }, {
      key: "postRender",
      value: function postRender(camera, opaqueQueue, transparentQueue) {}
    }, {
      key: "clearParam",
      get: function get() {
        return this._clearParam;
      },
      set: function set(v) {
        this._clearParam = v;
      }
    }]);

    return RenderPass;
  }();

  var RenderContext = /*#__PURE__*/function () {
    function RenderContext() {
      _classCallCheck(this, RenderContext);

      this.viewProjectMatrix = new Matrix();
    }

    _createClass(RenderContext, null, [{
      key: "_getRenderContext",
      value: function _getRenderContext(camera) {
        var context = RenderContext._renderContext;
        context.camera = camera;
        context.viewport = camera.viewport;
        context.cameraPosition = camera.entity.transform.worldPosition;
        context.inverseViewMatrix = camera.inverseViewMatrix;
        context.inverseProjectionMatrix = camera.inverseProjectionMatrix;
        context.viewMatrix = camera.viewMatrix;
        context.projectionMatrix = camera.projectionMatrix;
        Matrix.multiply(context.projectionMatrix, context.viewMatrix, context.viewProjectMatrix);
        return this._renderContext;
      }
    }]);

    return RenderContext;
  }();

  RenderContext._renderContext = new RenderContext();

  var RenderQueue = /*#__PURE__*/function () {
    function RenderQueue() {
      _classCallCheck(this, RenderQueue);

      this._items = [];
    }

    _createClass(RenderQueue, [{
      key: "clear",
      value: function clear() {
        this._items = [];
      }
    }, {
      key: "pushPrimitive",
      value: function pushPrimitive(element) {
        this._items.push(element);
      }
    }, {
      key: "sortByDistance",
      value: function sortByDistance(eyePos) {
        var items = this._items;

        if (items.length > 1) {
          this._items = items.sort(function (item1, item2) {
            if (item1.component.renderPriority === item2.component.renderPriority) {
              var pos1 = item1.component.entity.transform.worldPosition;
              var pos2 = item2.component.entity.transform.worldPosition;
              var dis = Vector3.distanceSquared(pos2, eyePos) - Vector3.distanceSquared(pos1, eyePos);
              return dis;
            } else {
              return item1.component.renderPriority - item2.component.renderPriority;
            }
          });
        }
      }
    }, {
      key: "sortByTechnique",
      value: function sortByTechnique() {
        var items = this._items;

        if (items.length > 1) {
          this._items = items.sort(function (item1, item2) {
            if (item1.component.renderPriority === item2.component.renderPriority) {
              var tech1 = item1.material.technique;
              var tech2 = item2.material.technique;

              if (tech1 && tech2) {
                return tech1.name.localeCompare(tech2.name);
              } else {
                return 0;
              }
            } else {
              return item1.component.renderPriority - item2.component.renderPriority;
            }
          });
        }
      }
    }, {
      key: "pushSprite",
      value: function pushSprite(component, positionQuad, uvRect, tintColor, texture, renderMode, camera) {
        var element = {
          component: component,
          positionQuad: positionQuad,
          uvRect: uvRect,
          tintColor: tintColor,
          texture: texture,
          renderMode: renderMode,
          camera: camera
        };

        this._items.push(element);
      }
    }, {
      key: "render",
      value: function render(camera, replaceMaterial, mask) {
        var rhi = camera.scene.engine._hardwareRenderer;
        var items = this._items;

        if (items.length === 0) {
          return;
        }

        this.updateMaxJointsNum(this._items, replaceMaterial);

        var context = RenderContext._getRenderContext(camera);

        var cullingMask = camera.cullingMask;

        for (var i = 0, len = items.length; i < len; i++) {
          var item = items[i];
          var component = item.component;
          if (!(cullingMask & component._entity.layer)) continue;
          var renderPassFlag = component.renderPassFlag;
          if (!(renderPassFlag & mask)) continue;

          if (this._isPrimitive(item)) {
            var _material$preRender, _material$postRender;

            var element = item;
            rhi.flushSprite();
            var material = replaceMaterial ? replaceMaterial : element.material;
            (_material$preRender = material.preRender) === null || _material$preRender === void 0 ? void 0 : _material$preRender.call(material, element.component, element.primitive);
            material.prepareDrawing(context, element.component, element.primitive, element.material);
            rhi.drawPrimitive(element.primitive, element.subPrimitive, material);
            (_material$postRender = material.postRender) === null || _material$postRender === void 0 ? void 0 : _material$postRender.call(material, element.component, element.primitive);
          } else {
            var spirteElement = item;
            rhi.drawSprite(spirteElement.positionQuad, spirteElement.uvRect, spirteElement.tintColor, spirteElement.texture, spirteElement.renderMode, spirteElement.camera);
          }
        }

        rhi.flushSprite();
      }
    }, {
      key: "updateMaxJointsNum",
      value: function updateMaxJointsNum(items, replaceMaterial) {
        for (var i = 0, len = items.length; i < len; i++) {
          var _items$i = items[i],
              component = _items$i.component,
              material = _items$i.material;
          var materialControl = replaceMaterial ? replaceMaterial : material;

          if (component.jointNodes) {
            materialControl.maxJointsNum = Math.max(materialControl.maxJointsNum, component.jointNodes.length);
          }
        }
      }
    }, {
      key: "_isPrimitive",
      value: function _isPrimitive(item) {
        return !!item.primitive;
      }
    }, {
      key: "items",
      get: function get() {
        return this._items;
      }
    }]);

    return RenderQueue;
  }();

  var SeparateSpritePass = /*#__PURE__*/function (_RenderPass) {
    _inherits(SeparateSpritePass, _RenderPass);

    var _super11 = _createSuper(SeparateSpritePass);

    function SeparateSpritePass() {
      var _this14;

      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "SeparateSprite";
      var priority = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;

      _classCallCheck(this, SeparateSpritePass);

      _this14 = _super11.call(this, name, priority);
      _this14.clearMode = exports.ClearMode.DONT_CLEAR;
      _this14.renderOverride = true;
      _this14._spriteItems = [];
      return _this14;
    }

    _createClass(SeparateSpritePass, [{
      key: "preRender",
      value: function preRender() {
        this.enabled = this.isUsed;
      }
    }, {
      key: "render",
      value: function render(camera) {
        var rhi = camera.renderHardware;

        this._sortByDistance(camera.eyePos);

        var items = this._spriteItems;

        for (var i = 0; i < items.length; i++) {
          var item = items[i];
          rhi.drawSprite(item.positionQuad, item.uvRect, item.tintColor, item.texture, item.renderMode, item.camera);
        }

        items.length = 0;
      }
    }, {
      key: "postRender",
      value: function postRender(camera) {
        if (this.enabled) {
          camera.renderHardware.flushSprite();
        }
      }
    }, {
      key: "_sortByDistance",
      value: function _sortByDistance(eyePos) {
        if (this._spriteItems.length > 1) {
          this._spriteItems = this._spriteItems.sort(function (item1, item2) {
            if (item1.component.renderPriority === item2.component.renderPriority) {
              var pos1 = item1.component.node.worldPosition;
              var pos2 = item2.component.node.worldPosition;
              var dis = Vector3.distanceSquared(pos2, eyePos) - Vector3.distanceSquared(pos1, eyePos);
              return dis;
            } else {
              return item1.component.renderPriority - item2.component.renderPriority;
            }
          });
        }
      }
    }, {
      key: "pushSprite",
      value: function pushSprite(component, positionQuad, uvRect, tintColor, texture, renderMode, camera) {
        this._spriteItems.push({
          component: component,
          positionQuad: positionQuad,
          uvRect: uvRect,
          tintColor: tintColor,
          texture: texture,
          renderMode: renderMode,
          camera: camera
        });
      }
    }, {
      key: "isUsed",
      get: function get() {
        return this._spriteItems.length > 0;
      }
    }]);

    return SeparateSpritePass;
  }(RenderPass);

  var BasicRenderPipeline = /*#__PURE__*/function (_SceneVisitor) {
    _inherits(BasicRenderPipeline, _SceneVisitor);

    var _super12 = _createSuper(BasicRenderPipeline);

    function BasicRenderPipeline(camera) {
      var _this15;

      _classCallCheck(this, BasicRenderPipeline);

      _this15 = _super12.call(this);
      _this15._camera = camera;
      _this15._opaqueQueue = new RenderQueue();
      _this15._transparentQueue = new RenderQueue();
      _this15._renderPassArray = [];
      _this15._defaultPass = new RenderPass("default", 0, null, null, 0);

      _this15.addRenderPass(_this15._defaultPass);

      return _this15;
    }

    _createClass(BasicRenderPipeline, [{
      key: "addRenderPass",
      value: function addRenderPass(nameOrPass) {
        var priority = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var renderTarget = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        var replaceMaterial = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
        var mask = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
        var clearParam = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new Vector4(0, 0, 0, 0);

        if (typeof nameOrPass === "string") {
          var renderPass = new RenderPass(nameOrPass, priority, renderTarget, replaceMaterial, mask, clearParam);

          this._renderPassArray.push(renderPass);
        } else if (nameOrPass instanceof RenderPass) {
          this._renderPassArray.push(nameOrPass);
        }

        this._renderPassArray.sort(function (p1, p2) {
          return p1.priority - p2.priority;
        });
      }
    }, {
      key: "removeRenderPass",
      value: function removeRenderPass(nameOrPass) {
        var pass;
        if (typeof nameOrPass === "string") pass = this.getRenderPass(nameOrPass);else if (nameOrPass instanceof RenderPass) pass = nameOrPass;

        if (pass) {
          var idx = this._renderPassArray.indexOf(pass);

          this._renderPassArray.splice(idx, 1);
        }
      }
    }, {
      key: "getRenderPass",
      value: function getRenderPass(name) {
        for (var i = 0, len = this._renderPassArray.length; i < len; i++) {
          var pass = this._renderPassArray[i];
          if (pass.name === name) return pass;
        }

        return null;
      }
    }, {
      key: "destroy",
      value: function destroy() {}
    }, {
      key: "render",
      value: function render() {
        var camera = this._camera;
        var opaqueQueue = this._opaqueQueue;
        var transparentQueue = this._transparentQueue;
        opaqueQueue.clear();
        transparentQueue.clear();

        camera.engine._componentsManager.callRender(camera);

        opaqueQueue.sortByTechnique();
        transparentQueue.sortByDistance(camera.entity.transform.worldPosition);
        if (this._canvasDepthPass) this._canvasDepthPass.enabled = false;

        if (this._separateSpritePass && this._separateSpritePass.isUsed) {
          if (this._defaultPass.renderTarget) {
            if (!this._canvasDepthPass) {
              this._canvasDepthPass = new RenderPass("CanvasDepthRenderPass", 0, null, null, 0);
              this._canvasDepthPass.clearMode = exports.ClearMode.DONT_CLEAR;
              this.addRenderPass(this._canvasDepthPass);
            }

            this._canvasDepthPass.enabled = true;
          }
        }

        for (var i = 0, len = this._renderPassArray.length; i < len; i++) {
          this._drawRenderPass(this._renderPassArray[i], camera);
        }
      }
    }, {
      key: "_drawRenderPass",
      value: function _drawRenderPass(pass, camera) {
        pass.preRender(camera, this.opaqueQueue, this.transparentQueue);
        var rhi = camera.scene.engine._hardwareRenderer;
        var renderTarget = camera.renderTarget || pass.renderTarget;
        rhi.activeRenderTarget(renderTarget, camera);

        if (pass.enabled) {
          rhi.clearRenderTarget(pass.clearMode, pass.clearParam);

          if (pass.renderOverride) {
            pass.render(camera, this.opaqueQueue, this.transparentQueue);
          } else {
            this.opaqueQueue.render(camera, pass.replaceMaterial, pass.mask);
            this.transparentQueue.render(camera, pass.replaceMaterial, pass.mask);
          }
        }

        rhi.blitRenderTarget(renderTarget);
        pass.postRender(camera, this.opaqueQueue, this.transparentQueue);
      }
    }, {
      key: "pushPrimitive",
      value: function pushPrimitive(element) {
        if (element.material.renderType === exports.MaterialType.TRANSPARENT) {
          this._transparentQueue.pushPrimitive(element);
        } else {
          this._opaqueQueue.pushPrimitive(element);
        }
      }
    }, {
      key: "pushSprite",
      value: function pushSprite(component, positionQuad, uvRect, tintColor, texture, renderMode, camera) {
        if (component.separateDraw) {
          if (!this._separateSpritePass) {
            this._separateSpritePass = new SeparateSpritePass();
            this.addRenderPass(this._separateSpritePass);
          }

          this._separateSpritePass.pushSprite(component, positionQuad, uvRect, tintColor, texture, renderMode, camera);

          return;
        }

        this._transparentQueue.pushSprite(component, positionQuad, uvRect, tintColor, texture, renderMode, camera);
      }
    }, {
      key: "defaultRenderPass",
      get: function get() {
        return this._defaultPass;
      }
    }, {
      key: "opaqueQueue",
      get: function get() {
        return this._opaqueQueue;
      }
    }, {
      key: "transparentQueue",
      get: function get() {
        return this._transparentQueue;
      }
    }]);

    return BasicRenderPipeline;
  }(SceneVisitor);

  var __defProp$6 = Object.defineProperty;
  var __getOwnPropDesc$6 = Object.getOwnPropertyDescriptor;

  var __decorate$6 = function __decorate$6(decorators, target, key, kind) {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$6(target, key) : target;

    for (var i = decorators.length - 1, decorator; i >= 0; i--) {
      if (decorator = decorators[i]) result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    }

    if (kind && result) __defProp$6(target, key, result);
    return result;
  };

  var MathTemp = function MathTemp() {
    _classCallCheck(this, MathTemp);
  };

  MathTemp.tempMat4 = new Matrix();
  MathTemp.tempVec4 = new Vector4();
  MathTemp.tempVec3 = new Vector3();
  var ClearFlags;

  (function (ClearFlags2) {
    ClearFlags2[ClearFlags2["DepthSky"] = 0] = "DepthSky";
    ClearFlags2[ClearFlags2["DepthColor"] = 1] = "DepthColor";
    ClearFlags2[ClearFlags2["Depth"] = 2] = "Depth";
    ClearFlags2[ClearFlags2["None"] = 3] = "None";
  })(ClearFlags || (ClearFlags = {}));

  exports.Camera = /*#__PURE__*/function (_Component4) {
    _inherits(Camera, _Component4);

    var _super13 = _createSuper(Camera);

    function Camera(entity) {
      var _this16;

      _classCallCheck(this, Camera);

      _this16 = _super13.call(this, entity);
      _this16.priority = 0;
      _this16.cullingMask = exports.Layer.Everything;
      _this16._isOrthographic = false;
      _this16._isProjMatSetting = false;
      _this16._clearMode = exports.ClearMode.SOLID_COLOR;
      _this16._nearClipPlane = 0.1;
      _this16._farClipPlane = 100;
      _this16._fieldOfView = 45;
      _this16._orthographicSize = 10;
      _this16._isProjectionDirty = true;
      _this16._isInvProjMatDirty = true;
      _this16._customAspectRatio = void 0;
      _this16._renderTarget = null;
      _this16._projectionMatrix = new Matrix();
      _this16._viewMatrix = new Matrix();
      _this16._backgroundColor = new Vector4();
      _this16._viewport = new Vector4(0, 0, 1, 1);
      _this16._inverseProjectionMatrix = new Matrix();
      _this16._inverseViewMatrix = new Matrix();
      _this16._lastAspectSize = new Vector2(0, 0);
      _this16._invViewProjMat = new Matrix();
      _this16._transform = _this16.entity.transform;
      _this16._isViewMatrixDirty = _this16._transform.registerWorldChangeFlag();
      _this16._isInvViewProjDirty = _this16._transform.registerWorldChangeFlag();
      _this16._renderPipeline = new BasicRenderPipeline(_assertThisInitialized(_this16));

      _this16.setClearMode();

      return _this16;
    }

    _createClass(Camera, [{
      key: "resetProjectionMatrix",
      value: function resetProjectionMatrix() {
        this._isProjMatSetting = false;

        this._projMatChange();
      }
    }, {
      key: "resetAspectRatio",
      value: function resetAspectRatio() {
        this._customAspectRatio = void 0;

        this._projMatChange();
      }
    }, {
      key: "worldToViewportPoint",
      value: function worldToViewportPoint(point, out) {
        Matrix.multiply(this.projectionMatrix, this.viewMatrix, MathTemp.tempMat4);
        MathTemp.tempVec4.setValue(point.x, point.y, point.z, 1);
        Vector4.transform(MathTemp.tempVec4, MathTemp.tempMat4, MathTemp.tempVec4);
        var w = MathTemp.tempVec4.w;
        var nx = MathTemp.tempVec4.x / w;
        var ny = MathTemp.tempVec4.y / w;
        var nz = MathTemp.tempVec4.z / w;
        out.x = (nx + 1) * 0.5;
        out.y = (1 - ny) * 0.5;
        out.z = nz;
        out.w = w;
        return out;
      }
    }, {
      key: "viewportToWorldPoint",
      value: function viewportToWorldPoint(point, out) {
        var invViewProjMat = this.invViewProjMat;
        return this._innerViewportToWorldPoint(point, invViewProjMat, out);
      }
    }, {
      key: "viewportPointToRay",
      value: function viewportPointToRay(point, out) {
        var clipPoint = MathTemp.tempVec3;
        clipPoint.setValue(point.x, point.y, 0);
        var origin = this.viewportToWorldPoint(clipPoint, out.origin);
        clipPoint.z = 1;

        var farPoint = this._innerViewportToWorldPoint(clipPoint, this._invViewProjMat, clipPoint);

        Vector3.subtract(farPoint, origin, out.direction);
        out.direction.normalize();
        return out;
      }
    }, {
      key: "screenToViewportPoint",
      value: function screenToViewportPoint(point, out) {
        var canvas = this.engine.canvas;
        var viewport = this.viewport;
        out.x = (point.x / canvas.width - viewport.x) / viewport.z;
        out.y = (point.y / canvas.height - viewport.y) / viewport.w;
        return out;
      }
    }, {
      key: "viewportToScreenPoint",
      value: function viewportToScreenPoint(point, out) {
        var canvas = this.engine.canvas;
        var viewport = this.viewport;
        out.x = (viewport.x + point.x * viewport.z) * canvas.width;
        out.y = (viewport.y + point.y * viewport.w) * canvas.height;
        return out;
      }
    }, {
      key: "worldToScreenPoint",
      value: function worldToScreenPoint(point, out) {
        this.worldToViewportPoint(point, out);
        return this.viewportToScreenPoint(out, out);
      }
    }, {
      key: "screenToWorldPoint",
      value: function screenToWorldPoint(point, out) {
        this.screenToViewportPoint(point, out);
        return this.viewportToWorldPoint(out, out);
      }
    }, {
      key: "render",
      value: function render(cubeFaces) {
        this._renderPipeline.render();
      }
    }, {
      key: "_onActive",
      value: function _onActive() {
        this.entity.scene.attachRenderCamera(this);
      }
    }, {
      key: "_onInActive",
      value: function _onInActive() {
        this.entity.scene.detachRenderCamera(this);
      }
    }, {
      key: "_onDestroy",
      value: function _onDestroy() {
        var _this$_renderPipeline;

        (_this$_renderPipeline = this._renderPipeline) === null || _this$_renderPipeline === void 0 ? void 0 : _this$_renderPipeline.destroy();

        this._isInvViewProjDirty.destroy();

        this._isViewMatrixDirty.destroy();
      }
    }, {
      key: "_projMatChange",
      value: function _projMatChange() {
        this._isProjectionDirty = true;
        this._isInvProjMatDirty = true;
        this._isInvViewProjDirty.flag = true;
      }
    }, {
      key: "_innerViewportToWorldPoint",
      value: function _innerViewportToWorldPoint(point, invViewProjMat, out) {
        var depth = point.z * 2 - 1;
        var clipPoint = MathTemp.tempVec4;
        clipPoint.setValue(point.x * 2 - 1, 1 - point.y * 2, depth, 1);
        Vector4.transform(clipPoint, invViewProjMat, clipPoint);
        var invW = 1 / clipPoint.w;
        out.x = clipPoint.x * invW;
        out.y = clipPoint.y * invW;
        out.z = clipPoint.z * invW;
        return out;
      }
    }, {
      key: "setClearMode",
      value: function setClearMode() {
        var clearMode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : exports.ClearMode.SOLID_COLOR;
        var backgroundColor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector4(0.25, 0.25, 0.25, 1);
        this._clearMode = clearMode;
        this._backgroundColor = backgroundColor;
        this._renderPipeline.defaultRenderPass.clearParam = backgroundColor;
        this._renderPipeline.defaultRenderPass.clearMode = clearMode;
      }
    }, {
      key: "nearClipPlane",
      get: function get() {
        return this._nearClipPlane;
      },
      set: function set(value) {
        this._nearClipPlane = value;

        this._projMatChange();
      }
    }, {
      key: "farClipPlane",
      get: function get() {
        return this._farClipPlane;
      },
      set: function set(value) {
        this._farClipPlane = value;

        this._projMatChange();
      }
    }, {
      key: "fieldOfView",
      get: function get() {
        return this._fieldOfView;
      },
      set: function set(value) {
        this._fieldOfView = value;

        this._projMatChange();
      }
    }, {
      key: "aspectRatio",
      get: function get() {
        var _this$_customAspectRa;

        var canvas = this._entity.engine.canvas;
        return (_this$_customAspectRa = this._customAspectRatio) !== null && _this$_customAspectRa !== void 0 ? _this$_customAspectRa : canvas.width * this._viewport.z / (canvas.height * this._viewport.w);
      },
      set: function set(value) {
        this._customAspectRatio = value;

        this._projMatChange();
      }
    }, {
      key: "viewport",
      get: function get() {
        return this._viewport;
      },
      set: function set(value) {
        if (value !== this._viewport) {
          value.cloneTo(this._viewport);
        }

        this._projMatChange();
      }
    }, {
      key: "isOrthographic",
      get: function get() {
        return this._isOrthographic;
      },
      set: function set(value) {
        this._isOrthographic = value;

        this._projMatChange();
      }
    }, {
      key: "orthographicSize",
      get: function get() {
        return this._orthographicSize;
      },
      set: function set(value) {
        this._orthographicSize = value;

        this._projMatChange();
      }
    }, {
      key: "clearFlags",
      get: function get() {
        throw "not implemented";
      },
      set: function set(value) {
        throw "not implemented";
      }
    }, {
      key: "backgroundColor",
      get: function get() {
        return this._backgroundColor;
      },
      set: function set(value) {
        this.setClearMode(this._clearMode, value);
      }
    }, {
      key: "backgroundSky",
      get: function get() {
        throw new Error("\u63A5\u53E3\u672A\u5B9E\u73B0");
      }
    }, {
      key: "viewMatrix",
      get: function get() {
        if (this._isViewMatrixDirty.flag) {
          this._isViewMatrixDirty.flag = false;
          Matrix.invert(this._transform.worldMatrix, this._viewMatrix);
        }

        return this._viewMatrix;
      }
    }, {
      key: "projectionMatrix",
      set: function set(value) {
        this._projectionMatrix = value;
        this._isProjMatSetting = true;

        this._projMatChange();
      },
      get: function get() {
        var canvas = this._entity.engine.canvas;

        if ((!this._isProjectionDirty || this._isProjMatSetting) && this._lastAspectSize.x === canvas.width && this._lastAspectSize.y === canvas.height) {
          return this._projectionMatrix;
        }

        this._isProjectionDirty = false;
        this._lastAspectSize.x = canvas.width;
        this._lastAspectSize.y = canvas.height;
        var aspectRatio = this.aspectRatio;

        if (!this._isOrthographic) {
          Matrix.perspective(MathUtil.degreeToRadian(this._fieldOfView), aspectRatio, this._nearClipPlane, this._farClipPlane, this._projectionMatrix);
        } else {
          var width = this._orthographicSize * aspectRatio;
          var height = this._orthographicSize;
          Matrix.ortho(-width, width, -height, height, this._nearClipPlane, this._farClipPlane, this._projectionMatrix);
        }

        return this._projectionMatrix;
      }
    }, {
      key: "enableHDR",
      get: function get() {
        console.log("not implemention");
        return false;
      },
      set: function set(value) {
        console.log("not implemention");
      }
    }, {
      key: "renderTarget",
      get: function get() {
        return this._renderTarget;
      },
      set: function set(value) {
        this._renderTarget = value;
      }
    }, {
      key: "invViewProjMat",
      get: function get() {
        if (this._isInvViewProjDirty.flag) {
          this._isInvViewProjDirty.flag = false;
          Matrix.multiply(this.inverseViewMatrix, this.inverseProjectionMatrix, this._invViewProjMat);
        }

        return this._invViewProjMat;
      }
    }, {
      key: "inverseProjectionMatrix",
      get: function get() {
        if (this._isInvProjMatDirty) {
          this._isInvProjMatDirty = false;
          Matrix.invert(this.projectionMatrix, this._inverseProjectionMatrix);
        }

        return this._inverseProjectionMatrix;
      }
    }, {
      key: "inverseViewMatrix",
      get: function get() {
        this._transform.worldMatrix.cloneTo(this._inverseViewMatrix);

        return this._inverseViewMatrix;
      }
    }]);

    return Camera;
  }(Component);

  __decorate$6([ignoreClone], exports.Camera.prototype, "_renderPipeline", 2);

  __decorate$6([ignoreClone], exports.Camera.prototype, "_transform", 2);

  __decorate$6([ignoreClone], exports.Camera.prototype, "_isViewMatrixDirty", 2);

  __decorate$6([ignoreClone], exports.Camera.prototype, "_isInvViewProjDirty", 2);

  __decorate$6([deepClone], exports.Camera.prototype, "_projectionMatrix", 2);

  __decorate$6([deepClone], exports.Camera.prototype, "_viewMatrix", 2);

  __decorate$6([deepClone], exports.Camera.prototype, "_backgroundColor", 2);

  __decorate$6([deepClone], exports.Camera.prototype, "_viewport", 2);

  __decorate$6([deepClone], exports.Camera.prototype, "_inverseProjectionMatrix", 2);

  __decorate$6([deepClone], exports.Camera.prototype, "_inverseViewMatrix", 2);

  __decorate$6([deepClone], exports.Camera.prototype, "_lastAspectSize", 2);

  __decorate$6([deepClone], exports.Camera.prototype, "_invViewProjMat", 2);

  exports.Camera = __decorate$6([dependencies(Transform)], exports.Camera);
  var mimeType = {
    json: "json",
    gltf: "json",
    mtl: "json",
    prefab: "json",
    txt: "text",
    bin: "arraybuffer",
    png: "image",
    webp: "image",
    jpg: "image"
  };
  var defaultRetryCount = 4;
  var defaultTimeout = 15e3;
  var defaultInterval = 500;

  function request(url) {
    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return new AssetPromise(function (resolve, reject, setProgress) {
      var _config$retryCount, _config$retryInterval, _config$timeout, _config$type;

      var retryCount = (_config$retryCount = config.retryCount) !== null && _config$retryCount !== void 0 ? _config$retryCount : defaultRetryCount;
      var retryInterval = (_config$retryInterval = config.retryInterval) !== null && _config$retryInterval !== void 0 ? _config$retryInterval : defaultInterval;
      config.timeout = (_config$timeout = config.timeout) !== null && _config$timeout !== void 0 ? _config$timeout : defaultTimeout;
      config.type = (_config$type = config.type) !== null && _config$type !== void 0 ? _config$type : getMimeTypeFromUrl(url);
      var realRequest = config.type === "image" ? requestImage : requestRes;
      var lastError;
      var executor = new MultiExecutor(function () {
        return realRequest(url, config).onProgress(setProgress).then(function (res) {
          resolve(res);
          executor.stop();
        })["catch"](function (err) {
          return lastError = err;
        });
      }, retryCount, retryInterval);
      executor.start(function () {
        reject(lastError);
      });
    });
  }

  function requestImage(url, config) {
    return new AssetPromise(function (resolve, reject) {
      var timeout = config.timeout;
      var img = new Image();

      var onerror = function onerror() {
        reject(new Error("request ".concat(url, " fail")));
      };

      img.onerror = onerror;
      img.onabort = onerror;
      var timeoutId = setTimeout(function () {
        reject(new Error("request ".concat(url, " timeout")));
      }, timeout);

      img.onload = function (timeoutId2) {
        return function () {
          requestAnimationFrame(function () {
            resolve(img);
          });
          clearTimeout(timeoutId2);
        };
      }(timeoutId);

      img.crossOrigin = "anonymous";
      img.src = url;
    });
  }

  function requestRes(url, config) {
    return new AssetPromise(function (resolve, reject, setProgress) {
      var _config$method;

      var xhr = new XMLHttpRequest();
      xhr.timeout = config.timeout;
      config.method = (_config$method = config.method) !== null && _config$method !== void 0 ? _config$method : "get";

      xhr.onload = function () {
        var _xhr$response;

        if (xhr.status < 200 || xhr.status >= 300) {
          reject(new Error("request failed from: ".concat(url)));
          return;
        }

        var result = (_xhr$response = xhr.response) !== null && _xhr$response !== void 0 ? _xhr$response : xhr.responseText;
        resolve(result);
      };

      xhr.onerror = function () {
        reject(new Error("request failed from: ".concat(url)));
      };

      xhr.ontimeout = function () {
        reject(new Error("request timeout from: ".concat(url)));
      };

      xhr.onprogress = function (e) {
        setProgress(e.loaded / e.total);
      };

      xhr.open(config.method, url, true);
      xhr.withCredentials = config.credentials === "include";
      xhr.responseType = config.type;
      var headers = config.headers;

      if (headers) {
        Object.keys(headers).forEach(function (name) {
          xhr.setRequestHeader(name, headers[name]);
        });
      }

      xhr.send(config.body);
    });
  }

  function getMimeTypeFromUrl(url) {
    var extname = url.substring(url.lastIndexOf(".") + 1);
    return mimeType[extname];
  }

  var MultiExecutor = /*#__PURE__*/function () {
    function MultiExecutor(execFunc, totalCount, interval) {
      _classCallCheck(this, MultiExecutor);

      this.execFunc = execFunc;
      this.totalCount = totalCount;
      this.interval = interval;
      this._timeoutId = -100;
      this._currentCount = 0;
      this.exec = this.exec.bind(this);
    }

    _createClass(MultiExecutor, [{
      key: "start",
      value: function start(done) {
        this.done = done;
        this.exec();
      }
    }, {
      key: "stop",
      value: function stop() {
        clearTimeout(this._timeoutId);
      }
    }, {
      key: "exec",
      value: function exec() {
        var _this17 = this;

        if (this._currentCount >= this.totalCount) {
          this.done && this.done();
          return;
        }

        this._currentCount++;
        this.execFunc(this._currentCount).then(function () {
          _this17._timeoutId = setTimeout(_this17.exec, _this17.interval);
        });
      }
    }]);

    return MultiExecutor;
  }();

  var Loader = function Loader(useCache) {
    _classCallCheck(this, Loader);

    this.useCache = useCache;
    this.request = request;
  };



  (function (AssetType2) {
    AssetType2[AssetType2["Text"] = 0] = "Text";
    AssetType2[AssetType2["JSON"] = 1] = "JSON";
    AssetType2[AssetType2["Buffer"] = 2] = "Buffer";
    AssetType2[AssetType2["Texture2D"] = 3] = "Texture2D";
    AssetType2[AssetType2["TextureCube"] = 4] = "TextureCube";
    AssetType2[AssetType2["Material"] = 5] = "Material";
    AssetType2[AssetType2["Mesh"] = 6] = "Mesh";
    AssetType2[AssetType2["AnimationClip"] = 7] = "AnimationClip";
    AssetType2[AssetType2["Perfab"] = 8] = "Perfab";
    AssetType2[AssetType2["KTX"] = 9] = "KTX";
    AssetType2[AssetType2["KTXCube"] = 10] = "KTXCube";
  })(exports.AssetType || (exports.AssetType = {}));

  var RefObject = /*#__PURE__*/function (_EngineObject3) {
    _inherits(RefObject, _EngineObject3);

    var _super14 = _createSuper(RefObject);

    function RefObject(engine) {
      var _this18;

      _classCallCheck(this, RefObject);

      _this18 = _super14.call(this, engine);
      _this18.isGCIgnored = false;
      _this18._refCount = 0;
      _this18._refChildren = [];
      _this18._refParent = null;
      _this18._destroyed = false;

      engine.resourceManager._addRefObject(_this18.instanceId, _assertThisInitialized(_this18));

      return _this18;
    }

    _createClass(RefObject, [{
      key: "destroy",
      value: function destroy() {
        var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        if (this._destroyed) return true;
        if (!force && this._refCount !== 0) return false;
        var resourceManager = this._engine.resourceManager;

        if (resourceManager) {
          resourceManager._deleteAsset(this);

          resourceManager._deleteRefObject(this.instanceId);
        }

        if (this._refParent) {
          removeFromArray(this._refParent._refChildren, this);
        }

        this._engine = null;

        this._onDestroy();

        this._destroyed = true;
        return true;
      }
    }, {
      key: "_addToResourceManager",
      value: function _addToResourceManager(path) {
        this._engine.resourceManager._addAsset(path, this);
      }
    }, {
      key: "_addRefCount",
      value: function _addRefCount(refCount) {
        this._refCount += refCount;
        var refChildren = this._refChildren;

        var _iterator2 = _createForOfIteratorHelper(refChildren),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var item = _step2.value;

            item._addRefCount(refCount);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
    }, {
      key: "_addRefChild",
      value: function _addRefChild(obj) {
        this._refChildren.push(obj);

        obj._refParent = this;

        obj._addRefCount(this._refCount);
      }
    }, {
      key: "_removeRefChild",
      value: function _removeRefChild(obj) {
        var refChildren = this._refChildren;

        if (removeFromArray(refChildren, obj)) {
          obj._refParent = null;

          obj._addRefCount(-this._refCount);
        }
      }
    }, {
      key: "refCount",
      get: function get() {
        return this._refCount;
      }
    }, {
      key: "destroyed",
      get: function get() {
        return this._destroyed;
      }
    }]);

    return RefObject;
  }(EngineObject);

  var _tempVec3 = new Vector3(0, 1, 0);

  var Light = /*#__PURE__*/function (_Component5) {
    _inherits(Light, _Component5);

    var _super15 = _createSuper(Light);

    _createClass(Light, null, [{
      key: "getUniformDefine",
      value: function getUniformDefine(uniformName) {
        return {};
      }
    }]);

    function Light(entity) {
      var _this19;

      _classCallCheck(this, Light);

      _this19 = _super15.call(this, entity);
      entity.addEventListener("removedFromScene", _this19._onDisable.bind(_assertThisInitialized(_this19)));
      return _this19;
    }

    _createClass(Light, [{
      key: "_onEnable",
      value: function _onEnable() {
        this.scene.findFeature(LightFeature).attachRenderLight(this);
      }
    }, {
      key: "_onDisable",
      value: function _onDisable() {
        this.scene.findFeature(LightFeature).detachRenderLight(this);
      }
    }, {
      key: "viewMatrix",
      get: function get() {
        if (!this._viewMat) this._viewMat = new Matrix();
        Matrix.invert(this.inverseViewMatrix, this._viewMat);
        return this._viewMat;
      }
    }, {
      key: "inverseViewMatrix",
      get: function get() {
        if (!this._modelMat) this._modelMat = new Matrix();
        Matrix.rotateAxisAngle(this.entity.transform.worldMatrix, _tempVec3, Math.PI, this._modelMat);
        return this._modelMat;
      }
    }]);

    return Light;
  }(Component);

  var AmbientLight = /*#__PURE__*/function (_Light) {
    _inherits(AmbientLight, _Light);

    var _super16 = _createSuper(AmbientLight);

    _createClass(AmbientLight, null, [{
      key: "getUniformDefine",
      value: function getUniformDefine(uniformName) {
        var _ref;

        return _ref = {}, _defineProperty(_ref, uniformName + ".color", {
          name: uniformName + ".color",
          type: exports.DataType.FLOAT_VEC3
        }), _defineProperty(_ref, uniformName + ".lightColor", {
          name: uniformName + ".lightColor",
          type: exports.DataType.FLOAT_VEC3
        }), _defineProperty(_ref, uniformName + ".intensity", {
          name: uniformName + ".intensity",
          type: exports.DataType.FLOAT
        }), _ref;
      }
    }]);

    function AmbientLight(entity) {
      var _this20;

      _classCallCheck(this, AmbientLight);

      _this20 = _super16.call(this, entity);
      _this20.color = new Vector3(1, 1, 1);
      _this20.intensity = 1;
      _this20._lightColor = new Vector3();
      return _this20;
    }

    _createClass(AmbientLight, [{
      key: "bindMaterialValues",
      value: function bindMaterialValues(mtl, uniformName) {
        mtl.setValue(uniformName + ".color", this.color);
        mtl.setValue(uniformName + ".lightColor", this.lightColor);
        mtl.setValue(uniformName + ".intensity", this.intensity);
      }
    }, {
      key: "lightColor",
      get: function get() {
        Vector3.scale(this.color, this.intensity, this._lightColor);
        return this._lightColor;
      }
    }]);

    return AmbientLight;
  }(Light);

  var DirectLight = /*#__PURE__*/function (_Light2) {
    _inherits(DirectLight, _Light2);

    var _super17 = _createSuper(DirectLight);

    function DirectLight(entity) {
      var _this21;

      _classCallCheck(this, DirectLight);

      _this21 = _super17.call(this, entity);
      _this21._forward = new Vector3();
      _this21.color = new Vector3(1, 1, 1);
      _this21.intensity = 1;
      _this21._lightColor = new Vector3();
      _this21._reverseDirection = new Vector3();
      return _this21;
    }

    _createClass(DirectLight, [{
      key: "bindMaterialValues",
      value: function bindMaterialValues(mtl, uniformName) {
        mtl.setValue(uniformName + ".color", this.color);
        mtl.setValue(uniformName + ".lightColor", this.lightColor);
        mtl.setValue(uniformName + ".intensity", this.intensity);
        mtl.setValue(uniformName + ".direction", this.direction);
      }
    }, {
      key: "direction",
      get: function get() {
        this.entity.transform.getWorldForward(this._forward);
        return this._forward;
      }
    }, {
      key: "lightColor",
      get: function get() {
        Vector3.scale(this.color, this.intensity, this._lightColor);
        return this._lightColor;
      }
    }, {
      key: "reverseDirection",
      get: function get() {
        Vector3.scale(this.direction, -1, this._reverseDirection);
        return this._reverseDirection;
      }
    }], [{
      key: "getUniformDefine",
      value: function getUniformDefine(uniformName) {
        var uniforms = {};
        uniforms[uniformName + ".color"] = {
          name: uniformName + ".color",
          type: exports.DataType.FLOAT_VEC3
        };
        uniforms[uniformName + ".lightColor"] = {
          name: uniformName + ".lightColor",
          type: exports.DataType.FLOAT_VEC3
        };
        uniforms[uniformName + ".intensity"] = {
          name: uniformName + ".intensity",
          type: exports.DataType.FLOAT
        };
        uniforms[uniformName + ".direction"] = {
          name: uniformName + ".direction",
          type: exports.DataType.FLOAT_VEC3
        };
        return uniforms;
      }
    }]);

    return DirectLight;
  }(Light);

  var cacheMat3 = new Matrix3x3();

  var EnvironmentMapLight = /*#__PURE__*/function (_Light3) {
    _inherits(EnvironmentMapLight, _Light3);

    var _super18 = _createSuper(EnvironmentMapLight);

    _createClass(EnvironmentMapLight, null, [{
      key: "getUniformDefine",
      value: function getUniformDefine(uniformName) {
        var uniforms = {};
        uniforms["u_env_diffuseSampler"] = {
          name: "u_env_diffuseSampler",
          type: exports.DataType.SAMPLER_CUBE
        };
        uniforms["u_env_specularSampler"] = {
          name: "u_env_specularSampler",
          type: exports.DataType.SAMPLER_CUBE
        };
        uniforms[uniformName + ".diffuse"] = {
          name: uniformName + ".diffuse",
          type: exports.DataType.FLOAT_VEC3
        };
        uniforms[uniformName + ".specular"] = {
          name: uniformName + ".specular",
          type: exports.DataType.FLOAT_VEC3
        };
        uniforms[uniformName + ".mipMapLevel"] = {
          name: uniformName + ".mipMapLevel",
          type: exports.DataType.FLOAT
        };
        uniforms[uniformName + ".transformMatrix"] = {
          name: uniformName + ".transformMatrix",
          type: exports.DataType.FLOAT_MAT3
        };
        uniforms[uniformName + ".diffuseIntensity"] = {
          name: uniformName + ".diffuseIntensity",
          type: exports.DataType.FLOAT
        };
        uniforms[uniformName + ".specularIntensity"] = {
          name: uniformName + ".specularIntensity",
          type: exports.DataType.FLOAT
        };
        return uniforms;
      }
    }]);

    function EnvironmentMapLight(entity) {
      var _this22;

      _classCallCheck(this, EnvironmentMapLight);

      _this22 = _super18.call(this, entity);
      _this22.diffuse = new Vector3(0.3, 0.3, 0.3);
      _this22.specular = new Vector3(0.5, 0.5, 0.5);
      _this22.diffuseIntensity = 1;
      _this22.specularIntensity = 1;
      return _this22;
    }

    _createClass(EnvironmentMapLight, [{
      key: "bindMaterialValues",
      value: function bindMaterialValues(mtl, uniformName) {
        mtl.setValue(uniformName + ".diffuseIntensity", this.diffuseIntensity);
        mtl.setValue(uniformName + ".specularIntensity", this.specularIntensity);

        if (this.useDiffuseMap) {
          mtl.setValue("u_env_diffuseSampler", this.diffuseMap);
        } else {
          mtl.setValue(uniformName + ".diffuse", this.diffuse);
        }

        if (this.useSpecularMap) {
          mtl.setValue("u_env_specularSampler", this.specularMap);
          mtl.setValue(uniformName + ".mipMapLevel", this.specularMap.mipmapCount);
        } else {
          mtl.setValue(uniformName + ".specular", this.specular);
        }

        var transformMatrix = this.entity.transform.worldMatrix;
        cacheMat3.setValueByMatrix(transformMatrix);
        mtl.setValue(uniformName + ".transformMatrix", cacheMat3);
      }
    }, {
      key: "useDiffuseMap",
      get: function get() {
        return !!this.diffuseMap;
      }
    }, {
      key: "useSpecularMap",
      get: function get() {
        return !!this.specularMap;
      }
    }]);

    return EnvironmentMapLight;
  }(Light);

  var PointLight = /*#__PURE__*/function (_Light4) {
    _inherits(PointLight, _Light4);

    var _super19 = _createSuper(PointLight);

    function PointLight() {
      var _this23;

      _classCallCheck(this, PointLight);

      _this23 = _super19.apply(this, arguments);
      _this23.color = new Vector3(1, 1, 1);
      _this23.intensity = 1;
      _this23.distance = 0;
      _this23.decay = 0;
      _this23._lightColor = new Vector3();
      return _this23;
    }

    _createClass(PointLight, [{
      key: "bindMaterialValues",
      value: function bindMaterialValues(mtl, uniformName) {
        mtl.setValue(uniformName + ".position", this.position);
        mtl.setValue(uniformName + ".color", this.color);
        mtl.setValue(uniformName + ".lightColor", this.lightColor);
        mtl.setValue(uniformName + ".intensity", this.intensity);
        mtl.setValue(uniformName + ".distance", this.distance);
        mtl.setValue(uniformName + ".decay", this.decay);
      }
    }, {
      key: "position",
      get: function get() {
        return this.entity.worldPosition;
      }
    }, {
      key: "lightColor",
      get: function get() {
        Vector3.scale(this.color, this.intensity, this._lightColor);
        return this._lightColor;
      }
    }], [{
      key: "getUniformDefine",
      value: function getUniformDefine(uniformName) {
        var uniforms = {};
        uniforms[uniformName + ".position"] = {
          name: uniformName + ".position",
          type: exports.DataType.FLOAT_VEC3
        };
        uniforms[uniformName + ".color"] = {
          name: uniformName + ".color",
          type: exports.DataType.FLOAT_VEC3
        };
        uniforms[uniformName + ".lightColor"] = {
          name: uniformName + ".lightColor",
          type: exports.DataType.FLOAT_VEC3
        };
        uniforms[uniformName + ".intensity"] = {
          name: uniformName + ".intensity",
          type: exports.DataType.FLOAT
        };
        uniforms[uniformName + ".distance"] = {
          name: uniformName + ".distance",
          type: exports.DataType.FLOAT
        };
        uniforms[uniformName + ".decay"] = {
          name: uniformName + ".decay",
          type: exports.DataType.FLOAT
        };
        return uniforms;
      }
    }]);

    return PointLight;
  }(Light);

  var SpotLight = /*#__PURE__*/function (_Light5) {
    _inherits(SpotLight, _Light5);

    var _super20 = _createSuper(SpotLight);

    function SpotLight(entity) {
      var _this24;

      _classCallCheck(this, SpotLight);

      _this24 = _super20.call(this, entity);
      _this24._forward = new Vector3();
      _this24.color = new Vector3(1, 1, 1);
      _this24.penumbra = 0;
      _this24.distance = 0;
      _this24.intensity = 1;
      _this24.decay = 0;
      _this24.angle = Math.PI / 6;
      _this24._lightColor = new Vector3();
      _this24._inverseDirection = new Vector3();
      return _this24;
    }

    _createClass(SpotLight, [{
      key: "bindMaterialValues",
      value: function bindMaterialValues(mtl, uniformName) {
        mtl.setValue(uniformName + ".position", this.position);
        mtl.setValue(uniformName + ".direction", this.direction);
        mtl.setValue(uniformName + ".color", this.color);
        mtl.setValue(uniformName + ".lightColor", this.lightColor);
        mtl.setValue(uniformName + ".intensity", this.intensity);
        mtl.setValue(uniformName + ".distance", this.distance);
        mtl.setValue(uniformName + ".decay", this.decay);
        mtl.setValue(uniformName + ".angle", this.angle);
        mtl.setValue(uniformName + ".penumbra", this.penumbra);
        mtl.setValue(uniformName + ".coneCos", Math.cos(this.angle));
        mtl.setValue(uniformName + ".penumbraCos", Math.cos(this.angle * (1 - this.penumbra)));
      }
    }, {
      key: "position",
      get: function get() {
        return this.entity.worldPosition;
      }
    }, {
      key: "direction",
      get: function get() {
        this.entity.transform.getWorldForward(this._forward);
        return this._forward;
      }
    }, {
      key: "reverseDirection",
      get: function get() {
        Vector3.scale(this.direction, -1, this._inverseDirection);
        return this._inverseDirection;
      }
    }, {
      key: "lightColor",
      get: function get() {
        Vector3.scale(this.color, this.intensity, this._lightColor);
        return this._lightColor;
      }
    }], [{
      key: "getUniformDefine",
      value: function getUniformDefine(uniformName) {
        var uniforms = {};
        uniforms[uniformName + ".position"] = {
          name: uniformName + ".position",
          type: exports.DataType.FLOAT_VEC3
        };
        uniforms[uniformName + ".direction"] = {
          name: uniformName + ".direction",
          type: exports.DataType.FLOAT_VEC3
        };
        uniforms[uniformName + ".color"] = {
          name: uniformName + ".color",
          type: exports.DataType.FLOAT_VEC3
        };
        uniforms[uniformName + ".lightColor"] = {
          name: uniformName + ".lightColor",
          type: exports.DataType.FLOAT_VEC3
        };
        uniforms[uniformName + ".intensity"] = {
          name: uniformName + ".intensity",
          type: exports.DataType.FLOAT
        };
        uniforms[uniformName + ".distance"] = {
          name: uniformName + ".distance",
          type: exports.DataType.FLOAT
        };
        uniforms[uniformName + ".decay"] = {
          name: uniformName + ".decay",
          type: exports.DataType.FLOAT
        };
        uniforms[uniformName + ".angle"] = {
          name: uniformName + ".angle",
          type: exports.DataType.FLOAT
        };
        uniforms[uniformName + ".penumbra"] = {
          name: uniformName + ".penumbra",
          type: exports.DataType.FLOAT
        };
        uniforms[uniformName + ".coneCos"] = {
          name: uniformName + ".coneCos",
          type: exports.DataType.FLOAT
        };
        uniforms[uniformName + ".penumbraCos"] = {
          name: uniformName + ".penumbraCos",
          type: exports.DataType.FLOAT
        };
        return uniforms;
      }
    }]);

    return SpotLight;
  }(Light);

  function hasLight() {
    return this.findFeature(LightFeature).visibleLights.length > 0;
  }

  var LightFeature = /*#__PURE__*/function (_SceneFeature) {
    _inherits(LightFeature, _SceneFeature);

    var _super21 = _createSuper(LightFeature);

    _createClass(LightFeature, [{
      key: "lightSortAmount",
      get: function get() {
        var ambientLightCount = 0;
        var directLightCount = 0;
        var pointLightCount = 0;
        var spotLightCount = 0;
        var envMapLightCount = 0;
        var useDiffuseEnv = false;
        var useSpecularEnv = false;
        var lights = this.visibleLights;

        for (var i = 0, len = lights.length; i < len; i++) {
          var light = lights[i];

          if (light instanceof AmbientLight) {
            ambientLightCount++;
          } else if (light instanceof DirectLight) {
            directLightCount++;
          } else if (light instanceof PointLight) {
            pointLightCount++;
          } else if (light instanceof SpotLight) {
            spotLightCount++;
          } else if (light instanceof EnvironmentMapLight) {
            envMapLightCount++;
            useDiffuseEnv = light.useDiffuseMap;
            useSpecularEnv = light.useSpecularMap;
          }
        }

        return {
          ambientLightCount: ambientLightCount,
          directLightCount: directLightCount,
          pointLightCount: pointLightCount,
          spotLightCount: spotLightCount,
          envMapLightCount: envMapLightCount,
          useDiffuseEnv: useDiffuseEnv,
          useSpecularEnv: useSpecularEnv
        };
      }
    }]);

    function LightFeature() {
      var _this25;

      _classCallCheck(this, LightFeature);

      _this25 = _super21.call(this);
      _this25.visibleLights = [];
      return _this25;
    }

    _createClass(LightFeature, [{
      key: "attachRenderLight",
      value: function attachRenderLight(light) {
        var index = this.visibleLights.indexOf(light);

        if (index == -1) {
          this.visibleLights.push(light);
        } else {
          Logger.warn("Light already attached.");
        }
      }
    }, {
      key: "detachRenderLight",
      value: function detachRenderLight(light) {
        var index = this.visibleLights.indexOf(light);

        if (index != -1) {
          this.visibleLights.splice(index, 1);
        }
      }
    }, {
      key: "bindMaterialValues",
      value: function bindMaterialValues(mtl) {
        var directLightCount = 0;
        var pointLightCount = 0;
        var spotLightCount = 0;
        var lights = this.visibleLights;

        for (var i = 0, len = lights.length; i < len; i++) {
          var light = lights[i];

          if (light instanceof AmbientLight) {
            light.bindMaterialValues(mtl, "u_ambientLight");
          } else if (light instanceof DirectLight) {
            light.bindMaterialValues(mtl, "u_directLights[".concat(directLightCount++, "]"));
          } else if (light instanceof PointLight) {
            light.bindMaterialValues(mtl, "u_pointLights[".concat(pointLightCount++, "]"));
          } else if (light instanceof SpotLight) {
            light.bindMaterialValues(mtl, "u_spotLights[".concat(spotLightCount++, "]"));
          } else if (light instanceof EnvironmentMapLight) {
            light.bindMaterialValues(mtl, "u_envMapLight");
          }
        }
      }
    }, {
      key: "getUniformDefine",
      value: function getUniformDefine() {
        var uniforms = {};
        var ambientLightCount = 0;
        var directLightCount = 0;
        var pointLightCount = 0;
        var spotLightCount = 0;
        var envMapLightCount = 0;
        var lights = this.visibleLights;

        for (var i = 0, len = lights.length; i < len; i++) {
          var light = lights[i];

          if (light instanceof AmbientLight && !ambientLightCount++) {
            uniforms = _objectSpread2(_objectSpread2({}, uniforms), AmbientLight.getUniformDefine("u_ambientLight"));
          } else if (light instanceof DirectLight) {
            uniforms = _objectSpread2(_objectSpread2({}, uniforms), DirectLight.getUniformDefine("u_directLights[".concat(directLightCount++, "]")));
          } else if (light instanceof PointLight) {
            uniforms = _objectSpread2(_objectSpread2({}, uniforms), PointLight.getUniformDefine("u_pointLights[".concat(pointLightCount++, "]")));
          } else if (light instanceof SpotLight) {
            uniforms = _objectSpread2(_objectSpread2({}, uniforms), SpotLight.getUniformDefine("u_spotLights[".concat(spotLightCount++, "]")));
          } else if (light instanceof EnvironmentMapLight && !envMapLightCount++) {
            uniforms = _objectSpread2(_objectSpread2({}, uniforms), EnvironmentMapLight.getUniformDefine("u_envMapLight"));
          }
        }

        return uniforms;
      }
    }]);

    return LightFeature;
  }(SceneFeature);

  var ColliderFeature = /*#__PURE__*/function (_SceneFeature2) {
    _inherits(ColliderFeature, _SceneFeature2);

    var _super22 = _createSuper(ColliderFeature);

    function ColliderFeature() {
      var _this26;

      _classCallCheck(this, ColliderFeature);

      _this26 = _super22.call(this);
      _this26.colliders = [];
      return _this26;
    }

    _createClass(ColliderFeature, [{
      key: "attachCollider",
      value: function attachCollider(collider) {
        this.colliders.push(collider);
      }
    }, {
      key: "detachCollider",
      value: function detachCollider(collider) {
        var index = this.colliders.indexOf(collider);

        if (index != -1) {
          this.colliders.splice(index, 1);
        }
      }
    }]);

    return ColliderFeature;
  }(SceneFeature);

  var Collider = /*#__PURE__*/function (_Component6) {
    _inherits(Collider, _Component6);

    var _super23 = _createSuper(Collider);

    function Collider(entity) {
      var _this27;

      _classCallCheck(this, Collider);

      _this27 = _super23.call(this, entity);
      _this27.tag = exports.MaskList.EVERYTHING;
      return _this27;
    }

    _createClass(Collider, [{
      key: "_onEnable",
      value: function _onEnable() {
        this.scene.findFeature(ColliderFeature).attachCollider(this);
      }
    }, {
      key: "_onDisable",
      value: function _onDisable() {
        this.scene.findFeature(ColliderFeature).detachCollider(this);
      }
    }]);

    return Collider;
  }(Component);

  var ABoxCollider = /*#__PURE__*/function (_Collider) {
    _inherits(ABoxCollider, _Collider);

    var _super24 = _createSuper(ABoxCollider);

    function ABoxCollider(entity) {
      var _this28;

      _classCallCheck(this, ABoxCollider);

      _this28 = _super24.call(this, entity);
      _this28._corners = [];
      _this28._cornerFlag = false;
      _this28.boxMin = new Vector3(-0.5, -0.5, -0.5);
      _this28.boxMax = new Vector3(0.5, 0.5, 0.5);
      return _this28;
    }

    _createClass(ABoxCollider, [{
      key: "setBoxMinMax",
      value: function setBoxMinMax(min, max) {
        this.boxMin = min;
        this.boxMax = max;
        this._cornerFlag = true;
      }
    }, {
      key: "setBoxCenterSize",
      value: function setBoxCenterSize(center, size) {
        var halfSize = ABoxCollider._tempVec3;
        Vector3.scale(size, 0.5, halfSize);
        Vector3.add(center, halfSize, this.boxMax);
        Vector3.subtract(center, halfSize, this.boxMin);
        this._cornerFlag = true;
      }
    }, {
      key: "getCorners",
      value: function getCorners() {
        if (this._cornerFlag) {
          var minX = this.boxMin.x;
          var minY = this.boxMin.y;
          var minZ = this.boxMin.z;
          var w = this.boxMax.x - minX;
          var h = this.boxMax.y - minY;
          var d = this.boxMax.z - minZ;

          if (this._corners.length === 0) {
            for (var i = 0; i < 8; ++i) {
              this._corners.push(new Vector3());
            }
          }

          this._corners[0].setValue(minX + w, minY + h, minZ + d);

          this._corners[1].setValue(minX, minY + h, minZ + d);

          this._corners[2].setValue(minX, minY, minZ + d);

          this._corners[3].setValue(minX + w, minY, minZ + d);

          this._corners[4].setValue(minX + w, minY + h, minZ);

          this._corners[5].setValue(minX, minY + h, minZ);

          this._corners[6].setValue(minX, minY, minZ);

          this._corners[7].setValue(minX + w, minY, minZ);

          this._cornerFlag = false;
        }

        return this._corners;
      }
    }]);

    return ABoxCollider;
  }(Collider);

  ABoxCollider._tempVec3 = new Vector3();

  var ASphereCollider = /*#__PURE__*/function (_Collider2) {
    _inherits(ASphereCollider, _Collider2);

    var _super25 = _createSuper(ASphereCollider);

    function ASphereCollider(entity) {
      var _this29;

      _classCallCheck(this, ASphereCollider);

      _this29 = _super25.call(this, entity);
      _this29.center = new Vector3();
      _this29.radius = 1;
      return _this29;
    }

    _createClass(ASphereCollider, [{
      key: "raycast",
      value: function raycast(ray, hit) {}
    }, {
      key: "setSphere",
      value: function setSphere(center, radius) {
        this.center = center;
        this.radius = radius;
      }
    }]);

    return ASphereCollider;
  }(Collider);

  var PlaneCollider = /*#__PURE__*/function (_Collider3) {
    _inherits(PlaneCollider, _Collider3);

    var _super26 = _createSuper(PlaneCollider);

    function PlaneCollider(entity) {
      var _this30;

      _classCallCheck(this, PlaneCollider);

      _this30 = _super26.call(this, entity);
      _this30.planePoint = new Vector3();
      _this30.normal = new Vector3(0, 1, 0);
      return _this30;
    }

    _createClass(PlaneCollider, [{
      key: "setPlane",
      value: function setPlane(point, normal) {
        this.planePoint = point;
        this.normal = normal;
      }
    }]);

    return PlaneCollider;
  }(Collider);

  Scene.prototype.raycast = function (_ray, _outPos) {
    var tag = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : exports.MaskList.EVERYTHING;
    var ray = new Ray(_ray.origin, _ray.direction);
    var cf = this.findFeature(ColliderFeature);
    var colliders = cf.colliders;
    var nearestHit = new RaycastHit();

    for (var i = 0, len = colliders.length; i < len; i++) {
      var collider = colliders[i];

      if (!collider.entity.isActiveInHierarchy) {
        continue;
      }

      if (!(collider.tag & tag)) {
        continue;
      }

      var hit = new RaycastHit();

      if (collider.raycast(ray, hit)) {
        if (hit.distance < nearestHit.distance) {
          nearestHit = hit;
        }
      }
    }

    if (_outPos && nearestHit.collider) {
      nearestHit.point.cloneTo(_outPos);
    }

    return nearestHit.collider;
  };

  ABoxCollider.prototype.raycast = function (ray, hit) {
    var localRay = _getLocalRay(this, ray);

    var intersect = localRay.intersectAABB(this.boxMax, this.boxMin);

    if (intersect) {
      _updateHitResult(this, localRay, intersect, hit, ray.origin);

      return true;
    } else {
      return false;
    }
  };

  ASphereCollider.prototype.raycast = function (ray, hit) {
    var localRay = _getLocalRay(this, ray);

    var intersect = localRay.intersectSphere(this.center, this.radius);

    if (intersect) {
      _updateHitResult(this, localRay, intersect, hit, ray.origin);

      return true;
    } else {
      return false;
    }
  };

  PlaneCollider.prototype.raycast = function (ray, hit) {
    var localRay = _getLocalRay(this, ray);

    var intersect = localRay.intersectPlane(this.planePoint, this.normal);

    if (intersect) {
      _updateHitResult(this, localRay, intersect, hit, ray.origin);

      return true;
    } else {
      return false;
    }
  };

  function _updateHitResult(collider, ray, distance, outHit, origin) {
    var hitPos = ray.getPoint(distance);
    Vector3.transformCoordinate(hitPos, collider.entity.transform.worldMatrix, hitPos);
    outHit.distance = Vector3.distance(origin, hitPos);
    outHit.collider = collider;
    outHit.point = hitPos;
  }

  function _getLocalRay(collider, ray) {
    var worldToLocal = collider.entity.getInvModelMatrix();
    var o = new Vector3();
    Vector3.transformCoordinate(ray.origin, worldToLocal, o);
    var d = new Vector3();

    _transformDirection(d, ray.direction, worldToLocal);

    return new Ray(o, d);
  }

  function _transformDirection(out, a, m) {
    var x = a.x;
    var y = a.y;
    var z = a.z;
    var e = m.elements;
    out.x = x * e[0] + y * e[4] + z * e[8];
    out.y = x * e[1] + y * e[5] + z * e[9];
    out.z = x * e[2] + y * e[6] + z * e[10];
    return out;
  }

  var Mesh = /*#__PURE__*/function (_EngineObject4) {
    _inherits(Mesh, _EngineObject4);

    var _super27 = _createSuper(Mesh);

    function Mesh(engine, name) {
      var _this31;

      _classCallCheck(this, Mesh);

      _this31 = _super27.call(this, engine);
      _this31.primitives = [];
      _this31.groups = [];
      _this31.bounds = new BoundingBox(new Vector3(), new Vector3());
      _this31.name = name;
      return _this31;
    }

    _createClass(Mesh, [{
      key: "updatePrimitiveWeightsIndices",
      value: function updatePrimitiveWeightsIndices(weightsIndices) {}
    }, {
      key: "destroy",
      value: function destroy() {
        this.primitives = null;
      }
    }]);

    return Mesh;
  }(EngineObject);

  var Skin = /*#__PURE__*/function (_AssetObject) {
    _inherits(Skin, _AssetObject);

    var _super28 = _createSuper(Skin);

    function Skin(name) {
      var _this32;

      _classCallCheck(this, Skin);

      _this32 = _super28.call(this, null);
      _this32.inverseBindMatrices = [];
      _this32.joints = [];
      _this32.skeleton = "none";
      return _this32;
    }

    return Skin;
  }(AssetObject);

  var __defProp$7 = Object.defineProperty;
  var __getOwnPropDesc$7 = Object.getOwnPropertyDescriptor;

  var __decorate$7 = function __decorate$7(decorators, target, key, kind) {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$7(target, key) : target;

    for (var i = decorators.length - 1, decorator; i >= 0; i--) {
      if (decorator = decorators[i]) result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    }

    if (kind && result) __defProp$7(target, key, result);
    return result;
  };

  function addPrimitivesRefCount(mesh, refCount) {
    var primitives = mesh.primitives;

    for (var i = 0, l = primitives.length; i < l; i++) {
      primitives[i]._addRefCount(refCount);
    }
  }

  var MeshRenderer = /*#__PURE__*/function (_RenderableComponent) {
    _inherits(MeshRenderer, _RenderableComponent);

    var _super29 = _createSuper(MeshRenderer);

    function MeshRenderer(entity) {
      var _this33;

      _classCallCheck(this, MeshRenderer);

      _this33 = _super29.call(this, entity);
      _this33._instanceMaterials = [];
      _this33._sharedMaterials = [];
      _this33._mesh = null;
      return _this33;
    }

    _createClass(MeshRenderer, [{
      key: "setSharedMaterial",
      value: function setSharedMaterial(primitiveIndex, material) {
        if (this._sharedMaterials[primitiveIndex]) {
          this._sharedMaterials[primitiveIndex]._addRefCount(-1);
        }

        material._addRefCount(1);

        this._sharedMaterials[primitiveIndex] = material;
      }
    }, {
      key: "setMaterial",
      value: function setMaterial(primitiveIndex, material) {
        if (this._instanceMaterials[primitiveIndex]) {
          this._instanceMaterials[primitiveIndex]._addRefCount(-1);
        }

        material._addRefCount(1);

        this._instanceMaterials[primitiveIndex] = material;
      }
    }, {
      key: "getInstanceMaterial",
      value: function getInstanceMaterial(primitiveIndex) {
        return this._instanceMaterials[primitiveIndex];
      }
    }, {
      key: "getSharedMaterial",
      value: function getSharedMaterial(primitiveIndex) {
        return this._sharedMaterials[primitiveIndex];
      }
    }, {
      key: "render",
      value: function render(camera) {
        var mesh = this._mesh;

        if (!mesh) {
          return;
        }

        var renderPipeline = camera._renderPipeline;
        var primitives = mesh.primitives,
            groups = mesh.groups;

        for (var i = 0, len = primitives.length; i < len; i++) {
          var primitive = primitives[i];
          var material = this._instanceMaterials[i] || this._sharedMaterials[i];

          if (material) {
            var element = RenderElement.getFromPool();
            element.setValue(this, primitive, groups[i], material);
            renderPipeline.pushPrimitive(element);
          } else {
            Logger.error("Primitive has no material: " + primitive.name);
          }
        }
      }
    }, {
      key: "destroy",
      value: function destroy() {
        _get(_getPrototypeOf(MeshRenderer.prototype), "destroy", this).call(this);

        this._mesh = null;
        this._instanceMaterials = [];
        this._sharedMaterials = [];

        for (var i = 0; i < this._instanceMaterials.length; i++) {
          this._instanceMaterials[i]._addRefCount(-1);
        }

        for (var _i11 = 0; _i11 < this._sharedMaterials.length; _i11++) {
          this._sharedMaterials[_i11]._addRefCount(-1);
        }

        if (this._mesh) {
          addPrimitivesRefCount(this._mesh, -1);
        }
      }
    }, {
      key: "_updateBounds",
      value: function _updateBounds(worldBounds) {
        var localBounds = this.mesh.bounds;
        var worldMatrix = this._entity.transform.worldMatrix;
        Vector3.transformCoordinate(localBounds.min, worldMatrix, worldBounds.min);
        Vector3.transformCoordinate(localBounds.max, worldMatrix, worldBounds.max);
      }
    }, {
      key: "mesh",
      get: function get() {
        return this._mesh;
      },
      set: function set(mesh) {
        if (this._mesh) {
          addPrimitivesRefCount(this._mesh, -1);
        }

        addPrimitivesRefCount(mesh, 1);
        this._mesh = mesh;
        this._sharedMaterials = [];
        this._instanceMaterials = [];
      }
    }]);

    return MeshRenderer;
  }(RenderableComponent);

  __decorate$7([ignoreClone], MeshRenderer.prototype, "_instanceMaterials", 2);

  __decorate$7([shallowClone], MeshRenderer.prototype, "_sharedMaterials", 2);



  (function (TextureFilterMode2) {
    TextureFilterMode2[TextureFilterMode2["Point"] = 0] = "Point";
    TextureFilterMode2[TextureFilterMode2["Bilinear"] = 1] = "Bilinear";
    TextureFilterMode2[TextureFilterMode2["Trilinear"] = 2] = "Trilinear";
  })(exports.TextureFilterMode || (exports.TextureFilterMode = {}));



  (function (TextureFormat2) {
    TextureFormat2[TextureFormat2["R8G8B8"] = 0] = "R8G8B8";
    TextureFormat2[TextureFormat2["R8G8B8A8"] = 1] = "R8G8B8A8";
    TextureFormat2[TextureFormat2["R4G4B4A4"] = 2] = "R4G4B4A4";
    TextureFormat2[TextureFormat2["R5G5B5A1"] = 3] = "R5G5B5A1";
    TextureFormat2[TextureFormat2["R5G6B5"] = 4] = "R5G6B5";
    TextureFormat2[TextureFormat2["Alpha8"] = 5] = "Alpha8";
    TextureFormat2[TextureFormat2["R32G32B32A32"] = 6] = "R32G32B32A32";
    TextureFormat2[TextureFormat2["DXT1"] = 7] = "DXT1";
    TextureFormat2[TextureFormat2["DXT5"] = 8] = "DXT5";
    TextureFormat2[TextureFormat2["ETC1_RGB"] = 9] = "ETC1_RGB";
    TextureFormat2[TextureFormat2["ETC2_RGB"] = 10] = "ETC2_RGB";
    TextureFormat2[TextureFormat2["ETC2_RGBA5"] = 11] = "ETC2_RGBA5";
    TextureFormat2[TextureFormat2["ETC2_RGBA8"] = 12] = "ETC2_RGBA8";
    TextureFormat2[TextureFormat2["PVRTC_RGB2"] = 13] = "PVRTC_RGB2";
    TextureFormat2[TextureFormat2["PVRTC_RGBA2"] = 14] = "PVRTC_RGBA2";
    TextureFormat2[TextureFormat2["PVRTC_RGB4"] = 15] = "PVRTC_RGB4";
    TextureFormat2[TextureFormat2["PVRTC_RGBA4"] = 16] = "PVRTC_RGBA4";
    TextureFormat2[TextureFormat2["ASTC_4x4"] = 17] = "ASTC_4x4";
    TextureFormat2[TextureFormat2["ASTC_5x5"] = 18] = "ASTC_5x5";
    TextureFormat2[TextureFormat2["ASTC_6x6"] = 19] = "ASTC_6x6";
    TextureFormat2[TextureFormat2["ASTC_8x8"] = 20] = "ASTC_8x8";
    TextureFormat2[TextureFormat2["ASTC_10x10"] = 21] = "ASTC_10x10";
    TextureFormat2[TextureFormat2["ASTC_12x12"] = 22] = "ASTC_12x12";
  })(exports.TextureFormat || (exports.TextureFormat = {}));



  (function (TextureWrapMode2) {
    TextureWrapMode2[TextureWrapMode2["Clamp"] = 0] = "Clamp";
    TextureWrapMode2[TextureWrapMode2["Repeat"] = 1] = "Repeat";
    TextureWrapMode2[TextureWrapMode2["Mirror"] = 2] = "Mirror";
  })(exports.TextureWrapMode || (exports.TextureWrapMode = {}));



  (function (GLCompressedTextureInternalFormat2) {
    GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_4X4_KHR"] = 37808] = "RGBA_ASTC_4X4_KHR";
    GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_5X4_KHR"] = 37809] = "RGBA_ASTC_5X4_KHR";
    GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_5X5_KHR"] = 37810] = "RGBA_ASTC_5X5_KHR";
    GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_6X5_KHR"] = 37811] = "RGBA_ASTC_6X5_KHR";
    GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_6X6_KHR"] = 37812] = "RGBA_ASTC_6X6_KHR";
    GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_8X5_KHR"] = 37813] = "RGBA_ASTC_8X5_KHR";
    GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_8X6_KHR"] = 37814] = "RGBA_ASTC_8X6_KHR";
    GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_8X8_KHR"] = 37815] = "RGBA_ASTC_8X8_KHR";
    GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_10X5_KHR"] = 37816] = "RGBA_ASTC_10X5_KHR";
    GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_10X6_KHR"] = 37817] = "RGBA_ASTC_10X6_KHR";
    GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_10X8_KHR"] = 37818] = "RGBA_ASTC_10X8_KHR";
    GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_10X10_KHR"] = 37819] = "RGBA_ASTC_10X10_KHR";
    GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_12X10_KHR"] = 37820] = "RGBA_ASTC_12X10_KHR";
    GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_12X12_KHR"] = 37821] = "RGBA_ASTC_12X12_KHR";
    GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_4X4_KHR"] = 37840] = "SRGB8_ALPHA8_ASTC_4X4_KHR";
    GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_5X4_KHR"] = 37841] = "SRGB8_ALPHA8_ASTC_5X4_KHR";
    GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_5X5_KHR"] = 37842] = "SRGB8_ALPHA8_ASTC_5X5_KHR";
    GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_6X5_KHR"] = 37843] = "SRGB8_ALPHA8_ASTC_6X5_KHR";
    GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_6X6_KHR"] = 37844] = "SRGB8_ALPHA8_ASTC_6X6_KHR";
    GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_8X5_KHR"] = 37845] = "SRGB8_ALPHA8_ASTC_8X5_KHR";
    GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_8X6_KHR"] = 37846] = "SRGB8_ALPHA8_ASTC_8X6_KHR";
    GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_8X8_KHR"] = 37847] = "SRGB8_ALPHA8_ASTC_8X8_KHR";
    GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_10X5_KHR"] = 37848] = "SRGB8_ALPHA8_ASTC_10X5_KHR";
    GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_10X6_KHR"] = 37849] = "SRGB8_ALPHA8_ASTC_10X6_KHR";
    GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_10X8_KHR"] = 37850] = "SRGB8_ALPHA8_ASTC_10X8_KHR";
    GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_10X10_KHR"] = 37851] = "SRGB8_ALPHA8_ASTC_10X10_KHR";
    GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_12X10_KHR"] = 37852] = "SRGB8_ALPHA8_ASTC_12X10_KHR";
    GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_12X12_KHR"] = 37853] = "SRGB8_ALPHA8_ASTC_12X12_KHR";
    GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGB_ETC1_WEBGL"] = 36196] = "RGB_ETC1_WEBGL";
    GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["R11_EAC"] = 37488] = "R11_EAC";
    GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SIGNED_R11_EAC"] = 37489] = "SIGNED_R11_EAC";
    GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RG11_EAC"] = 37490] = "RG11_EAC";
    GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SIGNED_RG11_EAC"] = 37491] = "SIGNED_RG11_EAC";
    GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGB8_ETC2"] = 37492] = "RGB8_ETC2";
    GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ETC2"] = 37493] = "SRGB8_ETC2";
    GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37494] = "RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
    GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37495] = "SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
    GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA8_ETC2_EAC"] = 37496] = "RGBA8_ETC2_EAC";
    GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ETC2_EAC"] = 37497] = "SRGB8_ALPHA8_ETC2_EAC";
    GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGB_PVRTC_4BPPV1_IMG"] = 35840] = "RGB_PVRTC_4BPPV1_IMG";
    GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGB_PVRTC_2BPPV1_IMG"] = 35841] = "RGB_PVRTC_2BPPV1_IMG";
    GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "RGBA_PVRTC_4BPPV1_IMG";
    GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "RGBA_PVRTC_2BPPV1_IMG";
    GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGB_S3TC_DXT1_EXT"] = 33776] = "RGB_S3TC_DXT1_EXT";
    GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_S3TC_DXT1_EXT"] = 33777] = "RGBA_S3TC_DXT1_EXT";
    GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_S3TC_DXT3_EXT"] = 33778] = "RGBA_S3TC_DXT3_EXT";
    GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_S3TC_DXT5_EXT"] = 33779] = "RGBA_S3TC_DXT5_EXT";
  })(exports.GLCompressedTextureInternalFormat || (exports.GLCompressedTextureInternalFormat = {}));



  (function (RenderBufferColorFormat2) {
    RenderBufferColorFormat2[RenderBufferColorFormat2["R8G8B8"] = 0] = "R8G8B8";
    RenderBufferColorFormat2[RenderBufferColorFormat2["R8G8B8A8"] = 1] = "R8G8B8A8";
    RenderBufferColorFormat2[RenderBufferColorFormat2["R4G4B4A4"] = 2] = "R4G4B4A4";
    RenderBufferColorFormat2[RenderBufferColorFormat2["R5G5B5A1"] = 3] = "R5G5B5A1";
    RenderBufferColorFormat2[RenderBufferColorFormat2["R5G6B5"] = 4] = "R5G6B5";
    RenderBufferColorFormat2[RenderBufferColorFormat2["Alpha8"] = 5] = "Alpha8";
    RenderBufferColorFormat2[RenderBufferColorFormat2["R16G16B16A16"] = 6] = "R16G16B16A16";
    RenderBufferColorFormat2[RenderBufferColorFormat2["R32G32B32A32"] = 7] = "R32G32B32A32";
  })(exports.RenderBufferColorFormat || (exports.RenderBufferColorFormat = {}));



  (function (RenderBufferDepthFormat2) {
    RenderBufferDepthFormat2[RenderBufferDepthFormat2["Depth"] = 0] = "Depth";
    RenderBufferDepthFormat2[RenderBufferDepthFormat2["DepthStencil"] = 1] = "DepthStencil";
    RenderBufferDepthFormat2[RenderBufferDepthFormat2["Stencil"] = 2] = "Stencil";
    RenderBufferDepthFormat2[RenderBufferDepthFormat2["Depth16"] = 3] = "Depth16";
    RenderBufferDepthFormat2[RenderBufferDepthFormat2["Depth24"] = 4] = "Depth24";
    RenderBufferDepthFormat2[RenderBufferDepthFormat2["Depth32"] = 5] = "Depth32";
    RenderBufferDepthFormat2[RenderBufferDepthFormat2["Depth24Stencil8"] = 6] = "Depth24Stencil8";
    RenderBufferDepthFormat2[RenderBufferDepthFormat2["Depth32Stencil8"] = 7] = "Depth32Stencil8";
  })(exports.RenderBufferDepthFormat || (exports.RenderBufferDepthFormat = {}));

  var Texture = /*#__PURE__*/function (_RefObject) {
    _inherits(Texture, _RefObject);

    var _super30 = _createSuper(Texture);

    function Texture(engine) {
      var _this34;

      _classCallCheck(this, Texture);

      _this34 = _super30.call(this, engine);
      _this34._anisoLevel = 1;
      return _this34;
    }

    _createClass(Texture, [{
      key: "generateMipmaps",
      value: function generateMipmaps() {
        if (!this._mipmap) return;
        var gl = this._rhi.gl;

        this._bind();

        gl.generateMipmap(this._target);

        this._unbind();
      }
    }, {
      key: "_onDestroy",
      value: function _onDestroy() {
        var gl = this._rhi.gl;
        gl.deleteTexture(this._glTexture);
        this._glTexture = null;
        this._formatDetail = null;
        this._rhi = null;
      }
    }, {
      key: "_bind",
      value: function _bind() {
        var gl = this._rhi.gl;
        gl.bindTexture(this._target, this._glTexture);
      }
    }, {
      key: "_unbind",
      value: function _unbind() {
        var gl = this._rhi.gl;
        gl.bindTexture(this._target, null);
      }
    }, {
      key: "_getPixelBuffer",
      value: function _getPixelBuffer(face, x, y, width, height, out) {
        var gl = this._rhi.gl;
        var _this$_formatDetail = this._formatDetail,
            baseFormat = _this$_formatDetail.baseFormat,
            dataType = _this$_formatDetail.dataType;

        if (!Texture._readFrameBuffer) {
          Texture._readFrameBuffer = gl.createFramebuffer();
        }

        gl.bindFramebuffer(gl.FRAMEBUFFER, Texture._readFrameBuffer);

        if (face != null) {
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, this._glTexture, 0);
        } else {
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._glTexture, 0);
        }

        gl.readPixels(x, y, width, height, baseFormat, dataType, out);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      }
    }, {
      key: "_initMipmap",
      value: function _initMipmap(isCube) {
        var gl = this._rhi.gl;
        var isWebGL2 = this._rhi.isWebGL2;
        var _this$_formatDetail2 = this._formatDetail,
            internalFormat = _this$_formatDetail2.internalFormat,
            baseFormat = _this$_formatDetail2.baseFormat,
            dataType = _this$_formatDetail2.dataType;

        this._bind();

        if (isWebGL2) {
          gl.texStorage2D(this._target, this._mipmapCount, internalFormat, this._width, this._height);
        } else {
          if (baseFormat !== internalFormat) {
            internalFormat = baseFormat;
          }

          if (!isCube) {
            for (var i = 0; i < this._mipmapCount; i++) {
              var width = Math.max(1, this._width >> i);
              var height = Math.max(1, this._height >> i);
              gl.texImage2D(this._target, i, internalFormat, width, height, 0, baseFormat, dataType, null);
            }
          } else {
            for (var _i12 = 0; _i12 < this._mipmapCount; _i12++) {
              var size = Math.max(1, this._width >> _i12);

              for (var faceIndex = 0; faceIndex < 6; faceIndex++) {
                gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, _i12, internalFormat, size, size, 0, baseFormat, dataType, null);
              }
            }
          }
        }

        this._unbind();
      }
    }, {
      key: "_getMaxMiplevel",
      value: function _getMaxMiplevel(size) {
        return Math.floor(Math.log2(size));
      }
    }, {
      key: "_getMipmapCount",
      value: function _getMipmapCount() {
        return this._mipmap ? Math.floor(Math.log2(Math.max(this._width, this._height))) + 1 : 1;
      }
    }, {
      key: "_setWrapMode",
      value: function _setWrapMode(value, pname) {
        var gl = this._rhi.gl;
        var isWebGL2 = this._rhi.isWebGL2;

        if (!isWebGL2 && value !== exports.TextureWrapMode.Clamp && (!Texture._isPowerOf2(this._width) || !Texture._isPowerOf2(this._height))) {
          Logger.warn("non-power-2 texture is not supported for REPEAT or MIRRORED_REPEAT in WebGL1,and has automatically downgraded to CLAMP_TO_EDGE");
          value = exports.TextureWrapMode.Clamp;
        }

        switch (value) {
          case exports.TextureWrapMode.Clamp:
            gl.texParameteri(this._target, pname, gl.CLAMP_TO_EDGE);
            break;

          case exports.TextureWrapMode.Repeat:
            gl.texParameteri(this._target, pname, gl.REPEAT);
            break;

          case exports.TextureWrapMode.Mirror:
            gl.texParameteri(this._target, pname, gl.MIRRORED_REPEAT);
            break;
        }
      }
    }, {
      key: "width",
      get: function get() {
        return this._width;
      }
    }, {
      key: "height",
      get: function get() {
        return this._height;
      }
    }, {
      key: "wrapModeU",
      get: function get() {
        return this._wrapModeU;
      },
      set: function set(value) {
        if (value === this._wrapModeU) return;
        var gl = this._rhi.gl;
        this._wrapModeU = value;

        this._bind();

        this._setWrapMode(value, gl.TEXTURE_WRAP_S);

        this._unbind();
      }
    }, {
      key: "wrapModeV",
      get: function get() {
        return this._wrapModeV;
      },
      set: function set(value) {
        if (value === this._wrapModeV) return;
        var gl = this._rhi.gl;
        this._wrapModeV = value;

        this._bind();

        this._setWrapMode(value, gl.TEXTURE_WRAP_T);

        this._unbind();
      }
    }, {
      key: "mipmapCount",
      get: function get() {
        return this._mipmapCount;
      }
    }, {
      key: "filterMode",
      get: function get() {
        return this._filterMode;
      },
      set: function set(value) {
        if (value === this._filterMode) return;
        var gl = this._rhi.gl;
        this._filterMode = value;

        this._bind();

        switch (value) {
          case exports.TextureFilterMode.Point:
            gl.texParameteri(this._target, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(this._target, gl.TEXTURE_MIN_FILTER, this._mipmap ? gl.NEAREST_MIPMAP_NEAREST : gl.NEAREST);
            break;

          case exports.TextureFilterMode.Bilinear:
            gl.texParameteri(this._target, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(this._target, gl.TEXTURE_MIN_FILTER, this._mipmap ? gl.LINEAR_MIPMAP_NEAREST : gl.LINEAR);
            break;

          case exports.TextureFilterMode.Trilinear:
            gl.texParameteri(this._target, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(this._target, gl.TEXTURE_MIN_FILTER, this._mipmap ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);
            break;
        }

        this._unbind();
      }
    }, {
      key: "anisoLevel",
      get: function get() {
        return this._anisoLevel;
      },
      set: function set(value) {
        var max = this._rhi.capability.maxAnisoLevel;

        if (value > max) {
          Logger.warn("anisoLevel:".concat(value, ", exceeds the limit and is automatically downgraded to:").concat(max));
          value = max;
        }

        if (value < 1) {
          Logger.warn("anisoLevel:".concat(value, ", must be greater than 0, and is automatically downgraded to 1"));
          value = 1;
        }

        if (value === this._anisoLevel) return;
        var gl = this._rhi.gl;
        this._anisoLevel = value;

        this._bind();

        gl.texParameterf(this._target, gl.TEXTURE_MAX_ANISOTROPY_EXT, value);

        this._unbind();
      }
    }], [{
      key: "_isPowerOf2",
      value: function _isPowerOf2(v) {
        return (v & v - 1) === 0;
      }
    }, {
      key: "_getFormatDetail",
      value: function _getFormatDetail(format, gl, isWebGL2) {
        switch (format) {
          case exports.TextureFormat.R8G8B8:
            return {
              internalFormat: isWebGL2 ? gl.RGB8 : gl.RGB,
              baseFormat: gl.RGB,
              dataType: gl.UNSIGNED_BYTE,
              isCompressed: false
            };

          case exports.TextureFormat.R8G8B8A8:
            return {
              internalFormat: isWebGL2 ? gl.RGBA8 : gl.RGBA,
              baseFormat: gl.RGBA,
              dataType: gl.UNSIGNED_BYTE,
              isCompressed: false
            };

          case exports.TextureFormat.R4G4B4A4:
            return {
              internalFormat: isWebGL2 ? gl.RGBA4 : gl.RGBA,
              baseFormat: gl.RGBA,
              dataType: gl.UNSIGNED_SHORT_4_4_4_4,
              isCompressed: false
            };

          case exports.TextureFormat.R5G5B5A1:
            return {
              internalFormat: isWebGL2 ? gl.RGB5_A1 : gl.RGBA,
              baseFormat: gl.RGBA,
              dataType: gl.UNSIGNED_SHORT_5_5_5_1,
              isCompressed: false
            };

          case exports.TextureFormat.R5G6B5:
            return {
              internalFormat: isWebGL2 ? gl.RGB565 : gl.RGB,
              baseFormat: gl.RGB,
              dataType: gl.UNSIGNED_SHORT_5_6_5,
              isCompressed: false
            };

          case exports.TextureFormat.Alpha8:
            return {
              internalFormat: gl.ALPHA,
              baseFormat: gl.ALPHA,
              dataType: gl.UNSIGNED_BYTE,
              isCompressed: false
            };

          case exports.TextureFormat.R32G32B32A32:
            return {
              internalFormat: gl.RGBA32F,
              baseFormat: gl.RGBA,
              dataType: gl.FLOAT,
              isCompressed: false
            };

          case exports.TextureFormat.DXT1:
            return {
              internalFormat: exports.GLCompressedTextureInternalFormat.RGB_S3TC_DXT1_EXT,
              isCompressed: true
            };

          case exports.TextureFormat.DXT5:
            return {
              internalFormat: exports.GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT,
              isCompressed: true
            };

          case exports.TextureFormat.ETC1_RGB:
            return {
              internalFormat: exports.GLCompressedTextureInternalFormat.RGB_ETC1_WEBGL,
              isCompressed: true
            };

          case exports.TextureFormat.ETC2_RGB:
            return {
              internalFormat: exports.GLCompressedTextureInternalFormat.RGB8_ETC2,
              isCompressed: true
            };

          case exports.TextureFormat.ETC2_RGBA5:
            return {
              internalFormat: exports.GLCompressedTextureInternalFormat.RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
              isCompressed: true
            };

          case exports.TextureFormat.ETC2_RGBA8:
            return {
              internalFormat: exports.GLCompressedTextureInternalFormat.RGBA8_ETC2_EAC,
              isCompressed: true
            };

          case exports.TextureFormat.PVRTC_RGB2:
            return {
              internalFormat: exports.GLCompressedTextureInternalFormat.RGB_PVRTC_2BPPV1_IMG,
              isCompressed: true
            };

          case exports.TextureFormat.PVRTC_RGBA2:
            return {
              internalFormat: exports.GLCompressedTextureInternalFormat.RGBA_PVRTC_2BPPV1_IMG,
              isCompressed: true
            };

          case exports.TextureFormat.PVRTC_RGB4:
            return {
              internalFormat: exports.GLCompressedTextureInternalFormat.RGB_PVRTC_4BPPV1_IMG,
              isCompressed: true
            };

          case exports.TextureFormat.PVRTC_RGBA4:
            return {
              internalFormat: exports.GLCompressedTextureInternalFormat.RGBA_PVRTC_4BPPV1_IMG,
              isCompressed: true
            };

          case exports.TextureFormat.ASTC_4x4:
            return {
              internalFormat: exports.GLCompressedTextureInternalFormat.RGBA_ASTC_4X4_KHR,
              isCompressed: true
            };

          case exports.TextureFormat.ASTC_5x5:
            return {
              internalFormat: exports.GLCompressedTextureInternalFormat.RGBA_ASTC_5X5_KHR,
              isCompressed: true
            };

          case exports.TextureFormat.ASTC_6x6:
            return {
              internalFormat: exports.GLCompressedTextureInternalFormat.RGBA_ASTC_6X6_KHR,
              isCompressed: true
            };

          case exports.TextureFormat.ASTC_8x8:
            return {
              internalFormat: exports.GLCompressedTextureInternalFormat.RGBA_ASTC_8X8_KHR,
              isCompressed: true
            };

          case exports.TextureFormat.ASTC_10x10:
            return {
              internalFormat: exports.GLCompressedTextureInternalFormat.RGBA_ASTC_10X10_KHR,
              isCompressed: true
            };

          case exports.TextureFormat.ASTC_12x12:
            return {
              internalFormat: exports.GLCompressedTextureInternalFormat.RGBA_ASTC_12X12_KHR,
              isCompressed: true
            };

          default:
            throw new Error("this TextureFormat is not supported in Oasis Engine: ".concat(format));
        }
      }
    }, {
      key: "_getRenderBufferColorFormatDetail",
      value: function _getRenderBufferColorFormatDetail(format, gl, isWebGL2) {
        switch (format) {
          case exports.RenderBufferColorFormat.R8G8B8:
            return {
              internalFormat: isWebGL2 ? gl.RGB8 : gl.RGB,
              baseFormat: gl.RGB,
              dataType: gl.UNSIGNED_BYTE,
              isCompressed: false
            };

          case exports.RenderBufferColorFormat.R8G8B8A8:
            return {
              internalFormat: isWebGL2 ? gl.RGBA8 : gl.RGBA,
              baseFormat: gl.RGBA,
              dataType: gl.UNSIGNED_BYTE,
              isCompressed: false
            };

          case exports.RenderBufferColorFormat.R4G4B4A4:
            return {
              internalFormat: isWebGL2 ? gl.RGBA4 : gl.RGBA,
              baseFormat: gl.RGBA,
              dataType: gl.UNSIGNED_SHORT_4_4_4_4,
              isCompressed: false
            };

          case exports.RenderBufferColorFormat.R5G5B5A1:
            return {
              internalFormat: isWebGL2 ? gl.RGB5_A1 : gl.RGBA,
              baseFormat: gl.RGBA,
              dataType: gl.UNSIGNED_SHORT_5_5_5_1,
              isCompressed: false
            };

          case exports.RenderBufferColorFormat.R5G6B5:
            return {
              internalFormat: isWebGL2 ? gl.RGB565 : gl.RGB,
              baseFormat: gl.RGB,
              dataType: gl.UNSIGNED_SHORT_5_6_5,
              isCompressed: false
            };

          case exports.RenderBufferColorFormat.Alpha8:
            return {
              internalFormat: gl.ALPHA,
              baseFormat: gl.ALPHA,
              dataType: gl.UNSIGNED_BYTE,
              isCompressed: false
            };

          case exports.RenderBufferColorFormat.R16G16B16A16:
            return {
              internalFormat: gl.RGBA16F,
              baseFormat: gl.RGBA,
              dataType: gl.HALF_FLOAT,
              isCompressed: false
            };

          case exports.RenderBufferColorFormat.R32G32B32A32:
            return {
              internalFormat: gl.RGBA32F,
              baseFormat: gl.RGBA,
              dataType: gl.FLOAT,
              isCompressed: false
            };

          default:
            throw new Error("this RenderBufferColorFormat is not supported in Oasis Engine: ".concat(format));
        }
      }
    }, {
      key: "_getRenderBufferDepthFormatDetail",
      value: function _getRenderBufferDepthFormatDetail(format, gl, isWebGL2) {
        switch (format) {
          case exports.RenderBufferDepthFormat.Depth:
            return {
              internalFormat: isWebGL2 ? gl.DEPTH_COMPONENT32F : gl.DEPTH_COMPONENT16,
              baseFormat: gl.DEPTH_COMPONENT,
              dataType: isWebGL2 ? gl.FLOAT : gl.UNSIGNED_INT,
              isCompressed: false,
              attachment: gl.DEPTH_ATTACHMENT
            };

          case exports.RenderBufferDepthFormat.DepthStencil:
            return {
              internalFormat: isWebGL2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL,
              baseFormat: gl.DEPTH_STENCIL,
              dataType: gl.UNSIGNED_INT_24_8,
              isCompressed: false,
              attachment: gl.DEPTH_STENCIL_ATTACHMENT
            };

          case exports.RenderBufferDepthFormat.Stencil:
            return {
              internalFormat: gl.STENCIL_INDEX8,
              baseFormat: gl.STENCIL_ATTACHMENT,
              dataType: gl.UNSIGNED_BYTE,
              isCompressed: false,
              attachment: gl.STENCIL_ATTACHMENT
            };

          case exports.RenderBufferDepthFormat.Depth16:
            return {
              internalFormat: isWebGL2 ? gl.DEPTH_COMPONENT16 : gl.DEPTH_COMPONENT16,
              baseFormat: gl.DEPTH_COMPONENT,
              dataType: gl.UNSIGNED_INT,
              isCompressed: false,
              attachment: gl.DEPTH_ATTACHMENT
            };

          case exports.RenderBufferDepthFormat.Depth24:
            return {
              internalFormat: gl.DEPTH_COMPONENT24,
              baseFormat: gl.DEPTH_COMPONENT,
              dataType: gl.UNSIGNED_INT,
              isCompressed: false,
              attachment: gl.DEPTH_ATTACHMENT
            };

          case exports.RenderBufferDepthFormat.Depth32:
            return {
              internalFormat: gl.DEPTH_COMPONENT32F,
              baseFormat: gl.DEPTH_COMPONENT,
              dataType: gl.FLOAT,
              isCompressed: false,
              attachment: gl.DEPTH_ATTACHMENT
            };

          case exports.RenderBufferDepthFormat.Depth24Stencil8:
            return {
              internalFormat: isWebGL2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL,
              baseFormat: gl.DEPTH_STENCIL,
              dataType: gl.UNSIGNED_INT_24_8,
              isCompressed: false,
              attachment: gl.DEPTH_STENCIL_ATTACHMENT
            };

          case exports.RenderBufferDepthFormat.Depth32Stencil8:
            return {
              internalFormat: gl.DEPTH32F_STENCIL8,
              baseFormat: gl.DEPTH_STENCIL,
              dataType: gl.FLOAT_32_UNSIGNED_INT_24_8_REV,
              isCompressed: false,
              attachment: gl.DEPTH_STENCIL_ATTACHMENT
            };

          default:
            throw new Error("this RenderBufferDepthFormat is not supported in Oasis Engine: ".concat(format));
        }
      }
    }, {
      key: "_supportTextureFormat",
      value: function _supportTextureFormat(format, rhi) {
        var isSupported = true;

        switch (format) {
          case exports.TextureFormat.R32G32B32A32:
            {
              if (!rhi.canIUse(exports.GLCapabilityType.textureFloat)) {
                isSupported = false;
              }
            }
            break;
        }

        return isSupported;
      }
    }, {
      key: "_supportRenderBufferColorFormat",
      value: function _supportRenderBufferColorFormat(format, rhi) {
        var isSupported = true;

        switch (format) {
          case exports.RenderBufferColorFormat.R32G32B32A32:
            {
              if (!rhi.canIUse(exports.GLCapabilityType.colorBufferFloat) || !rhi.canIUse(exports.GLCapabilityType.textureFloat)) {
                isSupported = false;
              }
            }
            break;

          case exports.RenderBufferColorFormat.R16G16B16A16:
            {
              if (!rhi.canIUse(exports.GLCapabilityType.colorBufferHalfFloat) || !rhi.canIUse(exports.GLCapabilityType.textureHalfFloat)) {
                isSupported = false;
              }
            }
            break;
        }

        return isSupported;
      }
    }, {
      key: "_supportRenderBufferDepthFormat",
      value: function _supportRenderBufferDepthFormat(format, rhi, isTexture) {
        var isWebGL2 = rhi.isWebGL2;
        var isSupported = true;

        if (isTexture && !rhi.canIUse(exports.GLCapabilityType.depthTexture)) {
          return false;
        }

        switch (format) {
          case exports.RenderBufferDepthFormat.Stencil:
            {
              isSupported = false;
            }
            break;

          case exports.RenderBufferDepthFormat.Depth24:
          case exports.RenderBufferDepthFormat.Depth32:
          case exports.RenderBufferDepthFormat.Depth32Stencil8:
            {
              if (!isWebGL2) {
                isSupported = false;
              }
            }
            break;
        }

        return isSupported;
      }
    }]);

    return Texture;
  }(RefObject);

  Texture._readFrameBuffer = null;

  var Texture2D = /*#__PURE__*/function (_Texture) {
    _inherits(Texture2D, _Texture);

    var _super31 = _createSuper(Texture2D);

    function Texture2D(engine, width, height) {
      var _this35;

      var format = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : exports.TextureFormat.R8G8B8A8;
      var mipmap = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;

      _classCallCheck(this, Texture2D);

      _this35 = _super31.call(this, engine);
      _this35._compressedMipFilled = 0;
      var rhi = engine._hardwareRenderer;
      var gl = rhi.gl;
      var isWebGL2 = rhi.isWebGL2;

      if (!Texture._supportTextureFormat(format, rhi)) {
        throw new Error("Texture format is not supported:".concat(exports.TextureFormat[format]));
      }

      if (mipmap && !isWebGL2 && (!Texture._isPowerOf2(width) || !Texture._isPowerOf2(height))) {
        Logger.warn("non-power-2 texture is not supported for mipmap in WebGL1,and has automatically downgraded to non-mipmap");
        mipmap = false;
      }

      var formatDetail = Texture._getFormatDetail(format, gl, isWebGL2);

      _this35._glTexture = gl.createTexture();
      _this35._formatDetail = formatDetail;
      _this35._rhi = rhi;
      _this35._target = gl.TEXTURE_2D;
      _this35._mipmap = mipmap;
      _this35._width = width;
      _this35._height = height;
      _this35._format = format;
      _this35._mipmapCount = _this35._getMipmapCount();
      formatDetail.isCompressed && !isWebGL2 || _this35._initMipmap(false);
      _this35.filterMode = exports.TextureFilterMode.Bilinear;
      _this35.wrapModeU = _this35.wrapModeV = exports.TextureWrapMode.Repeat;
      return _this35;
    }

    _createClass(Texture2D, [{
      key: "setPixelBuffer",
      value: function setPixelBuffer(colorBuffer) {
        var mipLevel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var x = arguments.length > 2 ? arguments[2] : undefined;
        var y = arguments.length > 3 ? arguments[3] : undefined;
        var width = arguments.length > 4 ? arguments[4] : undefined;
        var height = arguments.length > 5 ? arguments[5] : undefined;
        var gl = this._rhi.gl;
        var isWebGL2 = this._rhi.isWebGL2;
        var _this$_formatDetail3 = this._formatDetail,
            internalFormat = _this$_formatDetail3.internalFormat,
            baseFormat = _this$_formatDetail3.baseFormat,
            dataType = _this$_formatDetail3.dataType,
            isCompressed = _this$_formatDetail3.isCompressed;
        var mipWidth = Math.max(1, this._width >> mipLevel);
        var mipHeight = Math.max(1, this._height >> mipLevel);
        x = x || 0;
        y = y || 0;
        width = width || mipWidth - x;
        height = height || mipHeight - y;

        this._bind();

        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);

        if (isCompressed) {
          var mipBit = 1 << mipLevel;

          if (isWebGL2 || this._compressedMipFilled & mipBit) {
            gl.compressedTexSubImage2D(this._target, mipLevel, x, y, width, height, internalFormat, colorBuffer);
          } else {
            gl.compressedTexImage2D(this._target, mipLevel, internalFormat, width, height, 0, colorBuffer);
            this._compressedMipFilled |= mipBit;
          }
        } else {
          gl.texSubImage2D(this._target, mipLevel, x, y, width, height, baseFormat, dataType, colorBuffer);
        }

        this._unbind();
      }
    }, {
      key: "setImageSource",
      value: function setImageSource(imageSource) {
        var mipLevel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var flipY = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var premultiplyAlpha = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
        var x = arguments.length > 4 ? arguments[4] : undefined;
        var y = arguments.length > 5 ? arguments[5] : undefined;
        var gl = this._rhi.gl;
        var _this$_formatDetail4 = this._formatDetail,
            baseFormat = _this$_formatDetail4.baseFormat,
            dataType = _this$_formatDetail4.dataType;

        this._bind();

        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, +flipY);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, +premultiplyAlpha);
        gl.texSubImage2D(this._target, mipLevel, x || 0, y || 0, baseFormat, dataType, imageSource);

        this._unbind();
      }
    }, {
      key: "getPixelBuffer",
      value: function getPixelBuffer(x, y, width, height, out) {
        if (this._formatDetail.isCompressed) {
          throw new Error("Unable to read compressed texture");
        }

        _get(_getPrototypeOf(Texture2D.prototype), "_getPixelBuffer", this).call(this, null, x, y, width, height, out);
      }
    }, {
      key: "format",
      get: function get() {
        return this._format;
      }
    }]);

    return Texture2D;
  }(Texture);

  var __defProp$8 = Object.defineProperty;
  var __getOwnPropDesc$8 = Object.getOwnPropertyDescriptor;

  var __decorate$8 = function __decorate$8(decorators, target, key, kind) {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$8(target, key) : target;

    for (var i = decorators.length - 1, decorator; i >= 0; i--) {
      if (decorator = decorators[i]) result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    }

    if (kind && result) __defProp$8(target, key, result);
    return result;
  };

  var SkinnedMeshRenderer = /*#__PURE__*/function (_MeshRenderer) {
    _inherits(SkinnedMeshRenderer, _MeshRenderer);

    var _super32 = _createSuper(SkinnedMeshRenderer);

    function SkinnedMeshRenderer(entity) {
      var _this36;

      _classCallCheck(this, SkinnedMeshRenderer);

      _this36 = _super32.call(this, entity);
      _this36._hasInitJoints = false;
      _this36.weightsIndices = [];
      _this36._useJointTexture = false;
      _this36._mat = new Matrix();
      _this36._weights = null;
      _this36._skin = null;
      return _this36;
    }

    _createClass(SkinnedMeshRenderer, [{
      key: "setWeights",
      value: function setWeights(weights) {
        this._weights = weights;

        if (!weights) {
          return;
        }

        var len = weights.length;

        for (var i = 0; i < len; i++) {
          this.weightsIndices[i] = i;
        }

        var weightsIndices = this.weightsIndices;

        for (var _i13 = 0; _i13 < len - 1; _i13++) {
          for (var j = _i13 + 1; j < len; j++) {
            if (weights[j] > weights[_i13]) {
              var t = weights[_i13];
              weights[_i13] = weights[j];
              weights[j] = t;
              t = weightsIndices[_i13];
              weightsIndices[_i13] = weightsIndices[j];
              weightsIndices[j] = t;
            }
          }
        }

        this.mesh.updatePrimitiveWeightsIndices(weightsIndices);
      }
    }, {
      key: "_initJoints",
      value: function _initJoints() {
        if (!this._skin) return;
        var skin = this._skin;
        var joints = skin.joints;
        var jointNodes = [];

        for (var i = joints.length - 1; i >= 0; i--) {
          jointNodes[i] = this.findByNodeName(this.entity, joints[i]);
        }

        this.matrixPalette = new Float32Array(jointNodes.length * 16);
        this.jointNodes = jointNodes;
        var rhi = this.entity.engine._hardwareRenderer;
        if (!rhi) return;
        var maxAttribUniformVec4 = rhi.renderStates.getParameter(rhi.gl.MAX_VERTEX_UNIFORM_VECTORS);
        var maxJoints = Math.floor((maxAttribUniformVec4 - 20) / 4);

        if (joints.length > maxJoints && rhi.canIUseMoreJoints) {
          this._useJointTexture = true;
        }
      }
    }, {
      key: "findByNodeName",
      value: function findByNodeName(entity, nodeName) {
        if (!entity) return null;
        var n = entity.findByName(nodeName);
        if (n) return n;
        return this.findByNodeName(entity.parent, nodeName);
      }
    }, {
      key: "_findParent",
      value: function _findParent(entity, nodeName) {
        if (entity) {
          var parent = entity.parent;
          if (!parent) return null;
          if (parent.name === nodeName) return parent;
          var brother = parent.findByName(nodeName);
          if (brother) return brother;
          return this._findParent(parent, nodeName);
        }

        return null;
      }
    }, {
      key: "update",
      value: function update() {
        if (!this._hasInitJoints) {
          this._initJoints();

          this._hasInitJoints = true;
        }

        if (this._skin) {
          var joints = this.jointNodes;
          var ibms = this._skin.inverseBindMatrices;
          var matrixPalette = this.matrixPalette;
          var worldToLocal = this.entity.getInvModelMatrix();
          var mat = this._mat;

          for (var i = joints.length - 1; i >= 0; i--) {
            mat.identity();

            if (joints[i]) {
              Matrix.multiply(joints[i].transform.worldMatrix, ibms[i], mat);
            } else {
              ibms[i].cloneTo(mat);
            }

            Matrix.multiply(worldToLocal, mat, mat);
            matrixPalette.set(mat.elements, i * 16);
          }

          if (this._useJointTexture) {
            this.createJointTexture();
          }
        }
      }
    }, {
      key: "createJointTexture",
      value: function createJointTexture() {
        if (!this.jointTexture) {
          var engine = this.engine;
          var rhi = engine._hardwareRenderer;
          if (!rhi) return;
          this.jointTexture = new Texture2D(engine, 4, this.jointNodes.length, exports.TextureFormat.R32G32B32A32, false);
          this.jointTexture.filterMode = exports.TextureFilterMode.Point;
        }

        this.jointTexture.setPixelBuffer(this.matrixPalette);
      }
    }, {
      key: "skin",
      get: function get() {
        return this._skin;
      },
      set: function set(skin) {
        this._skin = skin;
      }
    }, {
      key: "weights",
      get: function get() {
        return this._weights;
      }
    }]);

    return SkinnedMeshRenderer;
  }(MeshRenderer);

  __decorate$8([ignoreClone], SkinnedMeshRenderer.prototype, "matrixPalette", 2);

  __decorate$8([ignoreClone], SkinnedMeshRenderer.prototype, "jointNodes", 2);

  __decorate$8([ignoreClone], SkinnedMeshRenderer.prototype, "jointTexture", 2);

  __decorate$8([ignoreClone], SkinnedMeshRenderer.prototype, "_hasInitJoints", 2);

  __decorate$8([ignoreClone], SkinnedMeshRenderer.prototype, "_mat", 2);

  __decorate$8([ignoreClone], SkinnedMeshRenderer.prototype, "_weights", 2);

  __decorate$8([ignoreClone], SkinnedMeshRenderer.prototype, "weightsIndices", 2);

  __decorate$8([ignoreClone], SkinnedMeshRenderer.prototype, "_useJointTexture", 2);

  var LODGroup = /*#__PURE__*/function (_RenderableComponent2) {
    _inherits(LODGroup, _RenderableComponent2);

    var _super33 = _createSuper(LODGroup);

    function LODGroup() {
      var _this37;

      _classCallCheck(this, LODGroup);

      _this37 = _super33.apply(this, arguments);
      _this37._lods = [];
      return _this37;
    }

    _createClass(LODGroup, [{
      key: "addLod",
      value: function addLod(distance, rendererAbility) {
        rendererAbility.enabled = false;

        this._lods.push({
          distance: distance,
          rendererAbility: rendererAbility
        });

        this._lods.sort(function (a, b) {
          return b.distance - a.distance;
        });
      }
    }, {
      key: "render",
      value: function render(camera) {
        if (this._lods.length <= 0) return;
        var dist = Vector3.distance(camera.eyePos, this.entity.worldPosition);
        var lods = this._lods;
        var activeLevel = 0;

        for (var i = lods.length - 1; i >= 0; i--) {
          var lod2 = lods[i];

          if (dist < lod2.distance) {
            activeLevel = i;
            break;
          }
        }

        var lod = lods[activeLevel];
        lod.rendererAbility.render(camera);
      }
    }]);

    return LODGroup;
  }(RenderableComponent);

  var Material = /*#__PURE__*/function (_RefObject2) {
    _inherits(Material, _RefObject2);

    var _super34 = _createSuper(Material);

    function Material(engine, name) {
      var _this38;

      _classCallCheck(this, Material);

      _this38 = _super34.call(this, engine);
      _this38.name = name;
      _this38.renderType = exports.MaterialType.OPAQUE;
      _this38.useFog = true;
      _this38.maxJointsNum = 0;
      _this38._technique = null;
      _this38._values = {};
      return _this38;
    }

    _createClass(Material, [{
      key: "clone",
      value: function clone() {
        var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.name;
        var newMtl = new this.constructor(name);
        newMtl.renderType = this.renderType;
        newMtl.useFog = this.useFog;

        for (var name2 in this._values) {
          if (this._values.hasOwnProperty(name2)) {
            var val = this._values[name2];

            if (val instanceof Texture) {
              newMtl.setValue(name2, val);
            } else {
              newMtl.setValue(name2, Util.clone(val));
            }
          }
        }

        return newMtl;
      }
    }, {
      key: "setValue",
      value: function setValue(name, value) {
        var oriValue = this.getValue(name);
        var oriIsTexture = oriValue instanceof Texture;
        var curIsTexture = value instanceof Texture;

        if (oriIsTexture) {
          this._removeRefChild(oriValue);
        }

        if (curIsTexture) {
          this._addRefChild(value);
        }

        if (this._generateTechnique && oriIsTexture !== curIsTexture) {
          this._technique = null;
        }

        if (value != null) {
          this._values[name] = value;
        } else {
          this.delValue(name);
        }
      }
    }, {
      key: "delValue",
      value: function delValue(name) {
        delete this._values[name];
      }
    }, {
      key: "getValue",
      value: function getValue(name) {
        return this._values[name];
      }
    }, {
      key: "prepareDrawing",
      value: function prepareDrawing(context, component, primitive, originalMaterial) {
        var camera = context.camera;
        var uniforms = this._technique.uniforms;

        for (var name in uniforms) {
          var uniform = uniforms[name];

          this._updateValueBySemantic(uniform, context, component);
        }

        var scene = camera.scene;

        if (scene.hasFogFeature) {
          scene.bindFogToMaterial(this);
        }

        this._technique.compile(camera, component, primitive, this);
      }
    }, {
      key: "preCompile",
      value: function preCompile(tech) {}
    }, {
      key: "postCompile",
      value: function postCompile(tech) {}
    }, {
      key: "preRender",
      value: function preRender(component, primitive) {}
    }, {
      key: "postRender",
      value: function postRender(component, primitive) {}
    }, {
      key: "_updateValueBySemantic",
      value: function _updateValueBySemantic(uniform, context, component) {
        var _component$jointNodes;

        var values = this._values;

        switch (uniform.semantic) {
          case exports.UniformSemantic.LOCAL:
            {
              values[uniform.name] = component._entity.transform.localMatrix;
              break;
            }

          case exports.UniformSemantic.MODEL:
            values[uniform.name] = component._entity.transform.worldMatrix;
            break;

          case exports.UniformSemantic.VIEW:
            values[uniform.name] = context.viewMatrix;
            break;

          case exports.UniformSemantic.PROJECTION:
            values[uniform.name] = context.projectionMatrix;
            break;

          case exports.UniformSemantic.MODELVIEW:
            {
              var view = context.viewMatrix;
              var model = component._entity.transform.worldMatrix;
              var modelView = values[uniform.name];
              if (!modelView) modelView = new Matrix();
              Matrix.multiply(view, model, modelView);
              values[uniform.name] = modelView;
              break;
            }

          case exports.UniformSemantic.VIEWPROJECTION:
            {
              var viewProj = context.viewProjectMatrix;
              values[uniform.name] = viewProj;
              break;
            }

          case exports.UniformSemantic.MODELVIEWPROJECTION:
            {
              var _viewProj = context.viewProjectMatrix;
              var _model = component._entity.transform.worldMatrix;
              var MVP = values[uniform.name];
              if (!MVP) MVP = new Matrix();
              Matrix.multiply(_viewProj, _model, MVP);
              values[uniform.name] = MVP;
              break;
            }

          case exports.UniformSemantic.MODELINVERSE:
            values[uniform.name] = component.invModelMatrixs;
            break;

          case exports.UniformSemantic.VIEWINVERSE:
            values[uniform.name] = context.inverseViewMatrix;
            break;

          case exports.UniformSemantic.PROJECTIONINVERSE:
            values[uniform.name] = context.inverseProjectionMatrix;
            break;

          case exports.UniformSemantic.MODELVIEWINVERSE:
            {
              var _view = context.viewMatrix;
              var _model2 = component._entity.transform.worldMatrix;
              var invMV = values[uniform.name];
              if (!invMV) invMV = new Matrix();
              Matrix.multiply(_view, _model2, invMV);
              Matrix.invert(invMV, invMV);
              values[uniform.name] = invMV;
              break;
            }

          case exports.UniformSemantic.MODELVIEWPROJECTIONINVERSE:
            {
              var _viewProj2 = context.viewProjectMatrix;
              var _model3 = component._entity.transform.worldMatrix;
              var invMVP = values[uniform.name];
              if (!invMVP) invMVP = new Matrix();
              Matrix.multiply(_viewProj2, _model3, invMVP);
              Matrix.invert(invMVP, invMVP);
              values[uniform.name] = invMVP;
              break;
            }

          case exports.UniformSemantic.MODELINVERSETRANSPOSE:
            {
              var modelIT = values[uniform.name];
              if (!modelIT) modelIT = new Matrix3x3();
              Matrix3x3.normalMatrix(component._entity.transform.worldMatrix, modelIT);
              values[uniform.name] = modelIT;
              break;
            }

          case exports.UniformSemantic.MODELVIEWINVERSETRANSPOSE:
            {
              var modelViewIT = values[uniform.name];
              if (!modelViewIT) modelViewIT = new Matrix();
              Matrix.multiply(context.viewMatrix, component._entity.transform.worldMatrix, modelViewIT);
              Matrix.invert(modelViewIT, modelViewIT);
              Matrix.transpose(modelViewIT, modelViewIT);
              values[uniform.name] = modelViewIT;
              break;
            }

          case exports.UniformSemantic.VIEWPORT:
            values[uniform.name] = context.viewport;
            break;

          case exports.UniformSemantic.JOINTMATRIX:
            values[uniform.name] = component.matrixPalette;
            break;

          case exports.UniformSemantic.JOINTTEXTURE:
            values[uniform.name] = component.jointTexture;
            break;

          case exports.UniformSemantic.JOINTCOUNT:
            values[uniform.name] = (_component$jointNodes = component.jointNodes) === null || _component$jointNodes === void 0 ? void 0 : _component$jointNodes.length;
            break;

          case exports.UniformSemantic.MORPHWEIGHTS:
            values[uniform.name] = component.weights;
            break;

          case exports.UniformSemantic.EYEPOS:
            values[uniform.name] = context.cameraPosition;
            break;

          case exports.UniformSemantic.TIME:
            values[uniform.name] = component.engine.time.timeSinceStartup * 1e-3;
            break;
        }
      }
    }, {
      key: "_onDestroy",
      value: function _onDestroy() {
        if (this._technique) {
          var values = ObjectValues(this._values);

          for (var i = 0, len = values.length; i < len; i++) {
            var value = values[i];

            if (value instanceof Texture) {
              value._addRefCount(-1);
            }
          }

          this._technique._finalize();

          this._technique = null;
        }
      }
    }, {
      key: "transparent",
      get: function get() {
        return this.renderType === exports.MaterialType.TRANSPARENT;
      },
      set: function set(val) {
        this.renderType = val ? exports.MaterialType.TRANSPARENT : exports.MaterialType.OPAQUE;
      }
    }, {
      key: "technique",
      get: function get() {
        return this._technique;
      },
      set: function set(tech) {
        this._technique = tech;
        this._values = {};
      }
    }]);

    return Material;
  }(RefObject);

  var ComplexMaterial = /*#__PURE__*/function (_Material) {
    _inherits(ComplexMaterial, _Material);

    var _super35 = _createSuper(ComplexMaterial);

    function ComplexMaterial(engine, name) {
      var _this39;

      _classCallCheck(this, ComplexMaterial);

      _this39 = _super35.call(this, engine, name);
      _this39._techniquePool = {};
      return _this39;
    }

    _createClass(ComplexMaterial, [{
      key: "prepareDrawing",
      value: function prepareDrawing(context, component, primitive) {
        var camera = context.camera;

        var tech = this._requireTechnique(camera, component, primitive);

        if (tech) {
          this._technique = tech;

          _get(_getPrototypeOf(ComplexMaterial.prototype), "prepareDrawing", this).call(this, context, component, primitive);
        }
      }
    }, {
      key: "clearTechniques",
      value: function clearTechniques() {
        this._techniquePool = {};
      }
    }, {
      key: "_requireTechnique",
      value: function _requireTechnique(camera, component, primitive) {
        var key = this._getTechniqueKey(camera, component, primitive);

        var tech = this._techniquePool[key];

        if (!tech) {
          tech = this._generateTechnique(camera, component, primitive);
          this._techniquePool[key] = tech;
        }

        return tech;
      }
    }, {
      key: "_generateTechnique",
      value: function _generateTechnique(camera, component, primitive) {}
    }, {
      key: "_getTechniqueKey",
      value: function _getTechniqueKey(camera, component, primitive) {
        var isSkin = component.skin != null;
        var jontCount = isSkin ? component.skin.joints.length : 0;
        var key = isSkin ? "skin_" : "static_";

        if (isSkin) {
          key += "jont" + jontCount;
        }

        return key;
      }
    }]);

    return ComplexMaterial;
  }(Material);



  (function (BufferUsage2) {
    BufferUsage2[BufferUsage2["Static"] = 0] = "Static";
    BufferUsage2[BufferUsage2["Dynamic"] = 1] = "Dynamic";
    BufferUsage2[BufferUsage2["Stream"] = 2] = "Stream";
  })(exports.BufferUsage || (exports.BufferUsage = {}));



  (function (VertexElementFormat2) {
    VertexElementFormat2[VertexElementFormat2["Float"] = 0] = "Float";
    VertexElementFormat2[VertexElementFormat2["Vector2"] = 1] = "Vector2";
    VertexElementFormat2[VertexElementFormat2["Vector3"] = 2] = "Vector3";
    VertexElementFormat2[VertexElementFormat2["Vector4"] = 3] = "Vector4";
    VertexElementFormat2[VertexElementFormat2["Byte4"] = 4] = "Byte4";
    VertexElementFormat2[VertexElementFormat2["UByte4"] = 5] = "UByte4";
    VertexElementFormat2[VertexElementFormat2["NormalizedByte4"] = 6] = "NormalizedByte4";
    VertexElementFormat2[VertexElementFormat2["NormalizedUByte4"] = 7] = "NormalizedUByte4";
    VertexElementFormat2[VertexElementFormat2["Short2"] = 8] = "Short2";
    VertexElementFormat2[VertexElementFormat2["UShort2"] = 9] = "UShort2";
    VertexElementFormat2[VertexElementFormat2["NormalizedShort2"] = 10] = "NormalizedShort2";
    VertexElementFormat2[VertexElementFormat2["NormalizedUShort2"] = 11] = "NormalizedUShort2";
    VertexElementFormat2[VertexElementFormat2["Short4"] = 12] = "Short4";
    VertexElementFormat2[VertexElementFormat2["UShort4"] = 13] = "UShort4";
    VertexElementFormat2[VertexElementFormat2["NormalizedShort4"] = 14] = "NormalizedShort4";
    VertexElementFormat2[VertexElementFormat2["NormalizedUShort4"] = 15] = "NormalizedUShort4";
  })(exports.VertexElementFormat || (exports.VertexElementFormat = {}));



  (function (IndexFormat2) {
    IndexFormat2[IndexFormat2["UInt8"] = 0] = "UInt8";
    IndexFormat2[IndexFormat2["UInt16"] = 1] = "UInt16";
    IndexFormat2[IndexFormat2["UInt32"] = 2] = "UInt32";
  })(exports.IndexFormat || (exports.IndexFormat = {}));

  var BufferUtil = /*#__PURE__*/function () {
    function BufferUtil() {
      _classCallCheck(this, BufferUtil);
    }

    _createClass(BufferUtil, null, [{
      key: "_getGLBufferUsage",
      value: function _getGLBufferUsage(gl, bufferUsage) {
        switch (bufferUsage) {
          case exports.BufferUsage.Static:
            return gl.STATIC_DRAW;

          case exports.BufferUsage.Dynamic:
            return gl.DYNAMIC_DRAW;

          case exports.BufferUsage.Stream:
            return gl.STREAM_DRAW;
        }
      }
    }, {
      key: "_getGLIndexType",
      value: function _getGLIndexType(indexFormat) {
        switch (indexFormat) {
          case exports.IndexFormat.UInt8:
            return exports.DataType.UNSIGNED_BYTE;

          case exports.IndexFormat.UInt16:
            return exports.DataType.UNSIGNED_SHORT;

          case exports.IndexFormat.UInt32:
            return exports.DataType.UNSIGNED_INT;
        }
      }
    }, {
      key: "_getElementInfo",
      value: function _getElementInfo(format) {
        var size;
        var type;

        switch (format) {
          case exports.VertexElementFormat.Float:
            size = 1;
            type = exports.DataType.FLOAT;
            break;

          case exports.VertexElementFormat.Vector2:
            size = 2;
            type = exports.DataType.FLOAT;
            break;

          case exports.VertexElementFormat.Vector3:
            size = 3;
            type = exports.DataType.FLOAT;
            break;

          case exports.VertexElementFormat.Vector4:
            size = 4;
            type = exports.DataType.FLOAT;
            break;

          case exports.VertexElementFormat.Byte4:
            size = 4;
            type = exports.DataType.UNSIGNED_BYTE;
            break;

          case exports.VertexElementFormat.Short2:
            size = 2;
            type = exports.DataType.SHORT;
            break;

          case exports.VertexElementFormat.Short4:
            size = 4;
            type = exports.DataType.SHORT;
            break;

          case exports.VertexElementFormat.UShort2:
            size = 2;
            type = exports.DataType.UNSIGNED_SHORT;
            break;

          case exports.VertexElementFormat.UShort4:
            size = 4;
            type = exports.DataType.UNSIGNED_SHORT;
            break;
        }

        return {
          size: size,
          type: type
        };
      }
    }]);

    return BufferUtil;
  }();



  (function (BufferBindFlag2) {
    BufferBindFlag2[BufferBindFlag2["VertexBuffer"] = 0] = "VertexBuffer";
    BufferBindFlag2[BufferBindFlag2["IndexBuffer"] = 1] = "IndexBuffer";
  })(exports.BufferBindFlag || (exports.BufferBindFlag = {}));



  (function (SetDataOptions2) {
    SetDataOptions2[SetDataOptions2["None"] = 0] = "None";
    SetDataOptions2[SetDataOptions2["Discard"] = 1] = "Discard";
  })(exports.SetDataOptions || (exports.SetDataOptions = {}));

  var Buffer = /*#__PURE__*/function (_RefObject3) {
    _inherits(Buffer, _RefObject3);

    var _super36 = _createSuper(Buffer);

    _createClass(Buffer, [{
      key: "engine",
      get: function get() {
        return this._engine;
      }
    }, {
      key: "type",
      get: function get() {
        return this._type;
      }
    }, {
      key: "byteLength",
      get: function get() {
        return this._byteLength;
      }
    }, {
      key: "bufferUsage",
      get: function get() {
        return this._bufferUsage;
      }
    }]);

    function Buffer(engine, type, byteLengthOrData) {
      var _this40;

      var bufferUsage = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : exports.BufferUsage.Static;

      _classCallCheck(this, Buffer);

      _this40 = _super36.call(this, engine);
      _this40._engine = engine;
      _this40._type = type;
      _this40._bufferUsage = bufferUsage;
      var hardwareRenderer = engine._hardwareRenderer;
      var gl = hardwareRenderer.gl;

      var glBufferUsage = BufferUtil._getGLBufferUsage(gl, bufferUsage);

      var glBindTarget = type === exports.BufferBindFlag.VertexBuffer ? gl.ARRAY_BUFFER : gl.ELEMENT_ARRAY_BUFFER;
      _this40._nativeBuffer = gl.createBuffer();
      _this40._hardwareRenderer = hardwareRenderer;
      _this40._glBufferUsage = glBufferUsage;
      _this40._glBindTarget = glBindTarget;

      _this40.bind();

      if (typeof byteLengthOrData === "number") {
        _this40._byteLength = byteLengthOrData;
        gl.bufferData(glBindTarget, byteLengthOrData, glBufferUsage);
      } else {
        _this40._byteLength = byteLengthOrData.byteLength;
        gl.bufferData(glBindTarget, byteLengthOrData, glBufferUsage);
      }

      gl.bindBuffer(glBindTarget, null);
      return _this40;
    }

    _createClass(Buffer, [{
      key: "bind",
      value: function bind() {
        var gl = this._hardwareRenderer.gl;
        gl.bindBuffer(this._glBindTarget, this._nativeBuffer);
      }
    }, {
      key: "setData",
      value: function setData(data) {
        var bufferByteOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var dataOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var dataLength = arguments.length > 3 ? arguments[3] : undefined;
        var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : exports.SetDataOptions.None;
        var gl = this._hardwareRenderer.gl;
        var isWebGL2 = this._hardwareRenderer.isWebGL2;
        var glBindTarget = this._glBindTarget;
        this.bind();

        if (options === exports.SetDataOptions.Discard) {
          gl.bufferData(glBindTarget, this._byteLength, this._glBufferUsage);
        }

        var byteSize = data.BYTES_PER_ELEMENT || 1;
        var dataByteLength = dataLength ? byteSize * dataLength : data.byteLength;

        if (dataOffset !== 0 || dataByteLength < data.byteLength) {
          var isArrayBufferView = data.byteOffset !== void 0;

          if (isWebGL2 && isArrayBufferView) {
            gl.bufferSubData(glBindTarget, bufferByteOffset, data, dataOffset, dataByteLength / byteSize);
          } else {
            var subData = new Uint8Array(isArrayBufferView ? data.buffer : data, dataOffset * byteSize, dataByteLength);
            gl.bufferSubData(glBindTarget, bufferByteOffset, subData);
          }
        } else {
          gl.bufferSubData(glBindTarget, bufferByteOffset, data);
        }

        gl.bindBuffer(glBindTarget, null);
      }
    }, {
      key: "getData",
      value: function getData(data) {
        var bufferByteOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var dataOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var dataLength = arguments.length > 3 ? arguments[3] : undefined;
        var isWebGL2 = this._hardwareRenderer.isWebGL2;

        if (isWebGL2) {
          var gl = this._hardwareRenderer.gl;
          this.bind();
          gl.getBufferSubData(this._glBindTarget, bufferByteOffset, data, dataOffset, dataLength);
        } else {
          throw "Buffer is write-only on WebGL1.0 platforms.";
        }
      }
    }, {
      key: "_onDestroy",
      value: function _onDestroy() {
        var gl = this._hardwareRenderer.gl;
        gl.deleteBuffer(this._nativeBuffer);
        this._nativeBuffer = null;
        this._hardwareRenderer = null;
      }
    }, {
      key: "resize",
      value: function resize(dataLength) {
        this.bind();
        var gl = this._hardwareRenderer.gl;
        gl.bufferData(this._glBindTarget, dataLength, this._glBufferUsage);
        this._byteLength = dataLength;
      }
    }]);

    return Buffer;
  }(RefObject);



  (function (PrimitiveTopology2) {
    PrimitiveTopology2[PrimitiveTopology2["Points"] = 0] = "Points";
    PrimitiveTopology2[PrimitiveTopology2["Lines"] = 1] = "Lines";
    PrimitiveTopology2[PrimitiveTopology2["LineLoop"] = 2] = "LineLoop";
    PrimitiveTopology2[PrimitiveTopology2["LineStrip"] = 3] = "LineStrip";
    PrimitiveTopology2[PrimitiveTopology2["Triangles"] = 4] = "Triangles";
    PrimitiveTopology2[PrimitiveTopology2["TriangleStrip"] = 5] = "TriangleStrip";
    PrimitiveTopology2[PrimitiveTopology2["TriangleFan"] = 6] = "TriangleFan";
  })(exports.PrimitiveTopology || (exports.PrimitiveTopology = {}));

  var IndexBufferBinding = /*#__PURE__*/function () {
    _createClass(IndexBufferBinding, [{
      key: "buffer",
      get: function get() {
        return this._buffer;
      }
    }, {
      key: "format",
      get: function get() {
        return this._format;
      }
    }]);

    function IndexBufferBinding(buffer, format) {
      _classCallCheck(this, IndexBufferBinding);

      this._buffer = buffer;
      this._format = format;
    }

    return IndexBufferBinding;
  }();

  var VertexBufferBinding = /*#__PURE__*/function () {
    _createClass(VertexBufferBinding, [{
      key: "buffer",
      get: function get() {
        return this._buffer;
      }
    }, {
      key: "stride",
      get: function get() {
        return this._stride;
      }
    }]);

    function VertexBufferBinding(buffer, stride) {
      _classCallCheck(this, VertexBufferBinding);

      this._buffer = buffer;
      this._stride = stride;
    }

    return VertexBufferBinding;
  }();

  var Primitive = /*#__PURE__*/function (_RefObject4) {
    _inherits(Primitive, _RefObject4);

    var _super37 = _createSuper(Primitive);

    function Primitive(engine, name) {
      var _this41;

      _classCallCheck(this, Primitive);

      _this41 = _super37.call(this, engine);
      _this41.instanceCount = 0;
      _this41._vertexElementMap = {};
      _this41._vertexBufferBindings = [];
      _this41._indexBufferBinding = null;
      _this41._vertexElements = [];
      _this41.targets = [];
      _this41.boundingBox = null;
      _this41.boundingSphere = null;
      _this41.isInFrustum = true;
      _this41.name = name;
      _this41._platformPrimitive = _this41._engine._hardwareRenderer.createPlatformPrimitive(_assertThisInitialized(_this41));
      return _this41;
    }

    _createClass(Primitive, [{
      key: "setVertexBufferBinding",
      value: function setVertexBufferBinding(bufferOrBinding) {
        var strideOrFirstIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var firstIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var binding = bufferOrBinding;
        var isBinding = binding.buffer !== void 0;
        isBinding || (binding = new VertexBufferBinding(bufferOrBinding, strideOrFirstIndex));
        var bindings = this._vertexBufferBindings;
        bindings.length <= firstIndex && (bindings.length = firstIndex + 1);

        this._setVertexBufferBinding(isBinding ? strideOrFirstIndex : firstIndex, binding);
      }
    }, {
      key: "setVertexBufferBindings",
      value: function setVertexBufferBindings(bufferBindings) {
        var firstIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var bindings = this._vertexBufferBindings;
        var multiBindings = bufferBindings;
        var count = multiBindings.length;
        var needLength = firstIndex + count;
        bindings.length < needLength && (bindings.length = needLength);

        for (var i = 0; i < count; i++) {
          this._setVertexBufferBinding(firstIndex + i, multiBindings[i]);
        }
      }
    }, {
      key: "setIndexBufferBinding",
      value: function setIndexBufferBinding(bufferOrBinding, format) {
        var binding = bufferOrBinding;
        var isBinding = binding.buffer !== void 0;
        isBinding || (binding = new IndexBufferBinding(bufferOrBinding, format));
        this._indexBufferBinding = binding;
        this._glIndexType = BufferUtil._getGLIndexType(binding.format);
      }
    }, {
      key: "setVertexElements",
      value: function setVertexElements(elements) {
        this._clearVertexElements();

        for (var i = 0, n = elements.length; i < n; i++) {
          this._addVertexElement(elements[i]);
        }
      }
    }, {
      key: "draw",
      value: function draw(tech, subPrimitive) {
        this._platformPrimitive.draw(tech, subPrimitive);
      }
    }, {
      key: "_onDestroy",
      value: function _onDestroy() {
        this._vertexBufferBindings = null;
        this._indexBufferBinding = null;
        this._vertexElements = null;
        this._vertexElementMap = null;

        this._platformPrimitive.destroy();
      }
    }, {
      key: "_clearVertexElements",
      value: function _clearVertexElements() {
        this._vertexElements.length = 0;
        var vertexElementMap = this._vertexElementMap;

        for (var k in vertexElementMap) {
          delete vertexElementMap[k];
        }
      }
    }, {
      key: "_addVertexElement",
      value: function _addVertexElement(element) {
        this._vertexElementMap[element.semantic] = element;

        this._vertexElements.push(element);
      }
    }, {
      key: "_setVertexBufferBinding",
      value: function _setVertexBufferBinding(index, buffer) {
        var originBufferBinding = this._vertexBufferBindings[index];

        if (originBufferBinding) {
          this._removeRefChild(originBufferBinding._buffer);
        }

        this._addRefChild(buffer._buffer);

        this._vertexBufferBindings[index] = buffer;
      }
    }, {
      key: "vertexBufferBindings",
      get: function get() {
        return this._vertexBufferBindings;
      }
    }, {
      key: "vertexElements",
      get: function get() {
        return this._vertexElements;
      }
    }, {
      key: "indexBufferBinding",
      get: function get() {
        return this._indexBufferBinding;
      }
    }]);

    return Primitive;
  }(RefObject);

  var VertexElement = /*#__PURE__*/function () {
    function VertexElement(semantic, offset, format, bindingIndex) {
      var instanceStepRate = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;

      _classCallCheck(this, VertexElement);

      this.normalized = false;
      this._semantic = semantic;
      this._offset = offset;
      this._format = format;
      this._bindingIndex = bindingIndex;
      this._glElementInfo = BufferUtil._getElementInfo(this.format);
      this._instanceStepRate = Math.floor(instanceStepRate);
    }

    _createClass(VertexElement, [{
      key: "semantic",
      get: function get() {
        return this._semantic;
      }
    }, {
      key: "offset",
      get: function get() {
        return this._offset;
      }
    }, {
      key: "format",
      get: function get() {
        return this._format;
      }
    }, {
      key: "bindingIndex",
      get: function get() {
        return this._bindingIndex;
      }
    }, {
      key: "instanceStepRate",
      get: function get() {
        return this._instanceStepRate;
      }
    }, {
      key: "elementInfo",
      get: function get() {
        return this._glElementInfo;
      }
    }]);

    return VertexElement;
  }();

  var SubPrimitive = function SubPrimitive() {
    var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var topology = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : exports.PrimitiveTopology.Triangles;

    _classCallCheck(this, SubPrimitive);

    this.start = start;
    this.count = count;
    this.topology = topology;
  };

  var common2 = "#define PI 3.14159265359\n#define LOG2 1.442695\n\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\n\n// nosie common\n#include <noise_common>\n";
  var common_vert2 = "attribute vec3 a_position;\n\n#ifdef O3_HAS_UV\n\nattribute vec2 a_uv;\n\n#endif\n\n#ifdef O3_HAS_NORMAL\n\nattribute vec3 a_normal;\n\n#endif\n\n#ifdef O3_HAS_TANGENT\n\nattribute vec4 a_tangent;\n\n#endif\n\n#ifdef O3_HAS_VERTEXCOLOR\n\nattribute vec4 a_color;\n\n#endif\n\n#if defined( O3_HAS_SKIN ) && ( defined( O3_JOINTS_NUM ) || defined( O3_USE_JOINT_TEXTURE ) )\n    attribute vec4 a_joint;\n    attribute vec4 a_weight;\n\n    #ifdef O3_USE_JOINT_TEXTURE\n        uniform sampler2D u_jointSampler;\n        uniform float u_jointCount;\n\n        mat4 getJointMatrix(sampler2D smp, float index)\n        {\n            float base = index / u_jointCount;\n            float hf = 0.5 / u_jointCount;\n            float v = base + hf;\n\n            vec4 m0 = texture2D(smp, vec2(0.125, v ));\n            vec4 m1 = texture2D(smp, vec2(0.375, v ));\n            vec4 m2 = texture2D(smp, vec2(0.625, v ));\n            vec4 m3 = texture2D(smp, vec2(0.875, v ));\n\n            return mat4(m0, m1, m2, m3);\n\n        }\n\n    #elif defined( O3_JOINTS_NUM )\n        uniform mat4 u_jointMatrix[ O3_JOINTS_NUM ];\n    #endif\n#endif\n\nuniform mat4 u_localMat;\nuniform mat4 u_modelMat;\nuniform mat4 u_viewMat;\nuniform mat4 u_projMat;\nuniform mat4 u_MVMat;\nuniform mat4 u_MVPMat;\nuniform mat3 u_normalMat;\nuniform vec3 u_cameraPos;\nuniform float u_time;\n";
  var common_frag2 = "uniform O3_VERTEX_PRECISION mat4 u_localMat;\nuniform O3_VERTEX_PRECISION mat4 u_modelMat;\nuniform O3_VERTEX_PRECISION mat4 u_viewMat;\nuniform O3_VERTEX_PRECISION mat4 u_projMat;\nuniform O3_VERTEX_PRECISION mat4 u_MVMat;\nuniform O3_VERTEX_PRECISION mat4 u_MVPMat;\nuniform O3_VERTEX_PRECISION mat3 u_normalMat;\nuniform O3_VERTEX_PRECISION vec3 u_cameraPos;\nuniform O3_VERTEX_PRECISION float u_time;\n";
  var color_share2 = "#ifdef O3_HAS_VERTEXCOLOR\n\nvarying vec4 v_color;\n\n#endif\n";
  var normal_share2 = "#ifdef O3_HAS_NORMAL\n\n    #if defined( O3_HAS_TANGENT ) && defined( O3_HAS_NORMALMAP )\n\n    varying mat3 v_TBN;\n\n    #else\n\n    varying vec3 v_normal;\n\n    #endif\n\n#endif\n";
  var uv_share2 = "varying vec2 v_uv;\n";
  var worldpos_share2 = "#if defined( O3_NEED_WORLDPOS ) || defined( O3_HAS_ENVMAP ) || defined( O3_HAS_LIGHTMAP ) || defined(O3_CLIPPLANE_NUM)\n\nvarying vec3 v_pos;\n\n#endif\n";
  var shadow_share2 = "#ifdef O3_GENERATE_SHADOW_MAP\n\nuniform mat4 u_viewMatFromLight;\nuniform mat4 u_projMatFromLight;\n\n#endif\n\n#ifdef O3_SHADOW_MAP_COUNT\n\nuniform mat4 u_viewMatFromLight[O3_SHADOW_MAP_COUNT];\nuniform mat4 u_projMatFromLight[O3_SHADOW_MAP_COUNT];\nvarying vec4 v_PositionFromLight[O3_SHADOW_MAP_COUNT];\n\n#endif\n";
  var fog_share2 = "#ifdef O3_HAS_FOG\n\nvarying vec3 v_fogDepth;\n\nuniform O3_VERTEX_PRECISION vec3 u_fogColor;\n\n    #ifdef O3_FOG_EXP2\n\n        uniform O3_VERTEX_PRECISION float u_fogDensity;\n\n    #else\n\n        uniform O3_VERTEX_PRECISION float u_fogNear;\n        uniform O3_VERTEX_PRECISION float u_fogFar;\n\n    #endif\n\n#endif\n";
  var begin_normal_vert2 = "    #ifdef O3_HAS_NORMAL\n\n    vec3 normal = vec3( a_normal );\n\n        #if defined( O3_HAS_TANGENT ) && defined( O3_HAS_NORMALMAP )\n\n        vec4 tangent = vec4( a_tangent );\n\n        #endif\n\n    #endif\n";
  var begin_position_vert2 = "    vec4 position = vec4( a_position , 1.0 );\n";
  var morph_target_vert2 = "#ifdef O3_HAS_MORPH\n\n    uniform float u_morphWeights[ O3_MORPH_NUM ];\n\n    #ifdef O3_MORPH_POSITION\n\n    attribute vec3 a_position0;\n\n    #endif\n\n    #ifdef O3_MORPH_NORMAL\n\n    attribute vec3 a_normal0;\n\n    #endif\n\n    #ifdef O3_MORPH_TANGENT\n\n    attribute vec3 a_tangent0;\n\n    #endif\n\n    #if O3_MORPH_NUM > 1\n\n        #ifdef O3_MORPH_POSITION\n\n        attribute vec3 a_position1;\n\n        #endif\n\n        #ifdef O3_MORPH_NORMAL\n\n        attribute vec3 a_normal1;\n\n        #endif\n\n        #ifdef O3_MORPH_TANGENT\n\n        attribute vec3 a_tangent1;\n\n        #endif\n\n    #endif\n\n    #if O3_MORPH_NUM > 2\n\n        #ifdef O3_MORPH_POSITION\n\n        attribute vec3 a_position2;\n\n        #endif\n\n        #ifdef O3_MORPH_NORMAL\n\n        attribute vec3 a_normal2;\n\n        #endif\n\n        #ifdef O3_MORPH_TANGENT\n\n        attribute vec3 a_tangent2;\n\n        #endif\n\n    #endif\n\n    #if O3_MORPH_NUM > 3\n\n        #ifdef O3_MORPH_POSITION\n\n        attribute vec3 a_position3;\n\n        #endif\n\n        #ifdef O3_MORPH_NORMAL\n\n        attribute vec3 a_normal3;\n\n        #endif\n\n        #ifdef O3_MORPH_TANGENT\n\n        attribute vec3 a_tangent3;\n\n        #endif\n\n    #endif\n\n    #if O3_MORPH_NUM > 4\n\n        #ifdef O3_MORPH_POSITION\n\n        attribute vec3 a_position4;\n\n        #endif\n\n        #ifdef O3_MORPH_NORMAL\n\n        attribute vec3 a_normal4;\n\n        #endif\n\n        #ifdef O3_MORPH_TANGENT\n\n        attribute vec3 a_tangent4;\n\n        #endif\n\n    #endif\n\n    #if O3_MORPH_NUM > 5\n\n        #ifdef O3_MORPH_POSITION\n\n        attribute vec3 a_position5;\n\n        #endif\n\n        #ifdef O3_MORPH_NORMAL\n\n        attribute vec3 a_normal5;\n\n        #endif\n\n        #ifdef O3_MORPH_TANGENT\n\n        attribute vec3 a_tangent5;\n\n        #endif\n\n    #endif\n\n    #if O3_MORPH_NUM > 6\n\n        #ifdef O3_MORPH_POSITION\n\n        attribute vec3 a_position6;\n\n        #endif\n\n        #ifdef O3_MORPH_NORMAL\n\n        attribute vec3 a_normal6;\n\n        #endif\n\n        #ifdef O3_MORPH_TANGENT\n\n        attribute vec3 a_tangent6;\n\n        #endif\n\n    #endif\n\n    #if O3_MORPH_NUM > 7\n\n        #ifdef O3_MORPH_POSITION\n\n        attribute vec3 a_position7;\n\n        #endif\n\n        #ifdef O3_MORPH_NORMAL\n\n        attribute vec3 a_normal7;\n\n        #endif\n\n        #ifdef O3_MORPH_TANGENT\n\n        attribute vec3 a_tangent7;\n\n        #endif\n\n    #endif\n\n#endif\n";
  var position_vert2 = "    #ifndef O3_GENERATE_SHADOW_MAP\n\n    gl_Position = u_MVPMat * position;\n\n    #endif\n";
  var color_vert2 = "    #ifdef O3_HAS_VERTEXCOLOR\n\n    v_color = a_color;\n\n    #endif\n";
  var normal_vert2 = "    #ifdef O3_HAS_NORMAL\n\n        #if defined( O3_HAS_TANGENT ) && defined( O3_HAS_NORMALMAP )\n\n        vec3 normalW = normalize( u_normalMat * normal.xyz );\n        vec3 tangentW = normalize( u_normalMat * tangent.xyz );\n        vec3 bitangentW = cross( normalW, tangentW ) * tangent.w;\n        v_TBN = mat3( tangentW, bitangentW, normalW );\n\n        #else\n\n        v_normal = normalize( u_normalMat * normal );\n\n        #endif\n\n    #endif\n";
  var skinning_vert2 = "#if defined( O3_HAS_SKIN ) && ( defined( O3_JOINTS_NUM ) || defined( O3_USE_JOINT_TEXTURE ) )\n\n        #ifdef O3_USE_JOINT_TEXTURE\n            mat4 skinMatrix =\n                a_weight.x * getJointMatrix(u_jointSampler, a_joint.x ) +\n                a_weight.y * getJointMatrix(u_jointSampler, a_joint.y ) +\n                a_weight.z * getJointMatrix(u_jointSampler, a_joint.z ) +\n                a_weight.w * getJointMatrix(u_jointSampler, a_joint.w );\n\n        #elif defined( O3_JOINTS_NUM )\n            mat4 skinMatrix =\n                a_weight.x * u_jointMatrix[ int( a_joint.x ) ] +\n                a_weight.y * u_jointMatrix[ int( a_joint.y ) ] +\n                a_weight.z * u_jointMatrix[ int( a_joint.z ) ] +\n                a_weight.w * u_jointMatrix[ int( a_joint.w ) ];\n        #endif\n\n        position = skinMatrix * position;\n\n        #ifdef O3_HAS_NORMAL\n            normal = vec4( skinMatrix * vec4( normal, 0.0 ) ).xyz;\n            #if defined( O3_HAS_TANGENT ) && defined( O3_HAS_NORMALMAP )\n                tangent.xyz = vec4( skinMatrix * vec4( tangent.xyz, 0.0 ) ).xyz;\n            #endif\n\n        #endif\n\n#endif\n";
  var uv_vert2 = "    #ifdef O3_HAS_UV\n\n    v_uv = a_uv;\n\n    #else\n\n    // may need this calculate normal\n    v_uv = vec2( 0., 0. );\n\n    #endif\n";
  var worldpos_vert2 = "    #if defined( O3_NEED_WORLDPOS ) || defined( O3_HAS_ENVMAP ) || defined( O3_HAS_LIGHTMAP ) || defined(O3_CLIPPLANE_NUM)\n\n    vec4 temp_pos = u_modelMat * position;\n    v_pos = temp_pos.xyz / temp_pos.w;\n\n    #endif\n";
  var shadow_vert2 = "    #ifdef O3_GENERATE_SHADOW_MAP\n\n    gl_Position = u_projMatFromLight * u_viewMatFromLight * u_modelMat * position;\n\n    #endif\n\n    #ifdef O3_SHADOW_MAP_COUNT\n\n    for (int i = 0; i < O3_SHADOW_MAP_COUNT; i++) {\n\n        v_PositionFromLight[i] = u_projMatFromLight[i] * u_viewMatFromLight[i] * u_modelMat * vec4( a_position, 1.0 );\n\n    }\n\n    #endif\n";
  var morph_vert2 = "    #ifdef O3_HAS_MORPH\n\n        #if defined( O3_MORPH_POSITION )\n\n        position.xyz += u_morphWeights[ 0 ] * a_position0;\n\n            #if O3_MORPH_NUM > 1\n\n            position.xyz += u_morphWeights[ 1 ] * a_position1;\n\n            #endif\n\n            #if O3_MORPH_NUM > 2\n\n            position.xyz += u_morphWeights[ 2 ] * a_position2;\n\n            #endif\n\n            #if O3_MORPH_NUM > 3\n\n            position.xyz += u_morphWeights[ 3 ] * a_position3;\n\n            #endif\n\n            #if O3_MORPH_NUM > 4\n\n            position.xyz += u_morphWeights[ 4 ] * a_position4;\n\n            #endif\n\n            #if O3_MORPH_NUM > 5\n\n            position.xyz += u_morphWeights[ 5 ] * a_position5;\n\n            #endif\n\n            #if O3_MORPH_NUM > 6\n\n            position.xyz += u_morphWeights[ 6 ] * a_position6;\n\n            #endif\n\n            #if O3_MORPH_NUM > 7\n\n            position.xyz += u_morphWeights[ 7 ] * a_position7;\n\n            #endif\n\n        #endif\n\n        #if defined( O3_HAS_NORMAL ) && defined( O3_MORPH_NORMAL )\n\n        normal.xyz += u_morphWeights[ 0 ] * a_normal0;\n\n            #if O3_MORPH_NUM > 1\n\n            normal.xyz += u_morphWeights[ 1 ] * a_normal1;\n\n            #endif\n\n            #if O3_MORPH_NUM > 2\n\n            normal.xyz += u_morphWeights[ 2 ] * a_normal2;\n\n            #endif\n\n            #if O3_MORPH_NUM > 3\n\n            normal.xyz += u_morphWeights[ 3 ] * a_normal3;\n\n            #endif\n\n            #if O3_MORPH_NUM > 4\n\n            normal.xyz += u_morphWeights[ 4 ] * a_normal4;\n\n            #endif\n\n            #if O3_MORPH_NUM > 5\n\n            normal.xyz += u_morphWeights[ 5 ] * a_normal5;\n\n            #endif\n\n            #if O3_MORPH_NUM > 6\n\n            normal.xyz += u_morphWeights[ 6 ] * a_normal6;\n\n            #endif\n\n            #if O3_MORPH_NUM > 7\n\n            normal.xyz += u_morphWeights[ 7 ] * a_normal7;\n\n            #endif\n\n        #endif\n\n        #if defined( O3_HAS_TANGENT ) && defined( O3_MORPH_TANGENT ) && defined( O3_HAS_NORMALMAP )\n\n        tangent.xyz += u_morphWeights[ 0 ] * a_tangent0;\n\n            #if O3_MORPH_NUM > 1\n\n            tangent.xyz += u_morphWeights[ 1 ] * a_tangent1;\n\n            #endif\n\n            #if O3_MORPH_NUM > 2\n\n            tangent.xyz += u_morphWeights[ 2 ] * a_tangent2;\n\n            #endif\n\n            #if O3_MORPH_NUM > 3\n\n            tangent.xyz += u_morphWeights[ 3 ] * a_tangent3;\n\n            #endif\n\n            #if O3_MORPH_NUM > 4\n\n            tangent.xyz += u_morphWeights[ 4 ] * a_tangent4;\n\n            #endif\n\n            #if O3_MORPH_NUM > 5\n\n            tangent.xyz += u_morphWeights[ 5 ] * a_tangent5;\n\n            #endif\n\n            #if O3_MORPH_NUM > 6\n\n            tangent.xyz += u_morphWeights[ 6 ] * a_tangent6;\n\n            #endif\n\n            #if O3_MORPH_NUM > 7\n\n            tangent.xyz += u_morphWeights[ 7 ] * a_tangent7;\n\n            #endif\n\n        #endif\n\n    #endif\n";
  var fog_vert2 = "    #ifdef O3_HAS_FOG\n\n    v_fogDepth = ( u_MVMat * position ).xyz;\n\n    #endif\n";
  var ambient_light_frag2 = "#ifdef O3_HAS_AMBIENT_LIGHT\n\nstruct AmbientLight {\n    vec3 color;\n    vec3 lightColor;\n    float intensity;\n};\nuniform AmbientLight u_ambientLight;\n\n#endif\n";
  var direct_light_frag2 = "#ifdef O3_DIRECT_LIGHT_COUNT\n\nstruct DirectLight {\n    vec3 color;\n    vec3 lightColor;\n    float intensity;\n    vec3 direction;\n};\nuniform DirectLight u_directLights[ O3_DIRECT_LIGHT_COUNT ];\n\n#endif\n";
  var point_light_frag2 = "#ifdef O3_POINT_LIGHT_COUNT\n\nstruct PointLight {\n    vec3 color;\n    vec3 lightColor;\n    vec3 position;\n    float intensity;\n    float distance;\n    float decay;\n};\nuniform PointLight u_pointLights[ O3_POINT_LIGHT_COUNT ];\n\n#endif\n";
  var spot_light_frag2 = "#ifdef O3_SPOT_LIGHT_COUNT\n\nstruct SpotLight {\n    vec3 color;\n    vec3 lightColor;\n    vec3 position;\n    vec3 direction;\n    float intensity;\n    float distance;\n    float decay;\n    float angle;\n    float penumbra;\n    float coneCos;\n    float penumbraCos;\n};\nuniform SpotLight u_spotLights[ O3_SPOT_LIGHT_COUNT ];\n\n#endif\n";
  var mobile_material_frag2 = "uniform float u_shininess;\n\n#ifdef O3_EMISSION_TEXTURE\n\nuniform sampler2D u_emission;\n\n#else\n\nuniform vec4 u_emission;\n\n#endif\n\n#ifdef O3_AMBIENT_TEXTURE\n\nuniform sampler2D u_ambient;\n\n#else\n\nuniform vec4 u_ambient;\n\n#endif\n\n#ifdef O3_DIFFUSE_TEXTURE\n\nuniform sampler2D u_diffuse;\n\n#else\n\nuniform vec4 u_diffuse;\n\n#endif\n\n#ifdef O3_SPECULAR_TEXTURE\n\nuniform sampler2D u_specular;\n\n#else\n\nuniform vec4 u_specular;\n\n#endif\n";
  var fog_frag2 = "    #ifdef O3_HAS_FOG\n\n    float fogDepth = length( v_fogDepth );\n\n        #ifdef O3_FOG_EXP2\n\n            float fogFactor = whiteCompliment( exp2( - u_fogDensity * u_fogDensity * fogDepth * fogDepth * LOG2 ) );\n\n        #else\n\n            float fogFactor = smoothstep( u_fogNear, u_fogFar, fogDepth );\n\n        #endif\n\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, u_fogColor, fogFactor );\n\n    #endif\n";
  var begin_mobile_frag2 = "    #ifdef O3_EMISSION_TEXTURE\n\n    vec4 emission = texture2D(u_emission, v_uv);\n\n    #else\n\n    vec4 emission = u_emission;\n\n    #endif\n\n    vec4 ambient = vec4(0);\n    #ifdef O3_HAS_AMBIENT_LIGHT\n        #ifdef O3_AMBIENT_TEXTURE\n            ambient = texture2D(u_ambient, v_uv) * vec4(u_ambientLight.lightColor, 1.0);\n         #else\n            ambient = u_ambient * vec4(u_ambientLight.lightColor, 1.0);\n         #endif\n    #endif\n\n    #ifdef O3_DIFFUSE_TEXTURE\n\n    vec4 diffuse = texture2D(u_diffuse, v_uv);\n\n    #else\n\n    vec4 diffuse = u_diffuse;\n\n    #endif\n\n    #ifdef O3_SPECULAR_TEXTURE\n\n    vec4 specular = texture2D(u_specular, v_uv);\n\n    #else\n\n    vec4 specular = u_specular;\n\n    #endif\n";
  var begin_normal_frag2 = "    #ifdef O3_HAS_NORMAL\n\n        #if defined( O3_HAS_TANGENT ) && defined( O3_HAS_NORMALMAP )\n\n        vec3 N = normalize( v_TBN[ 2 ] );\n\n        #else\n\n        vec3 N = normalize( v_normal );\n\n        #endif\n\n    #endif\n";
  var begin_viewdir_frag2 = "    #if defined( O3_NEED_WORLDPOS ) || defined( O3_HAS_ENVMAP ) || defined( O3_HAS_LIGHTMAP )\n\n    vec3 V =  normalize( u_cameraPos - v_pos );\n\n    #endif\n";
  var mobile_blinnphong_frag2 = "    #ifdef O3_HAS_NORMAL\n         N *= float( gl_FrontFacing ) * 2.0 - 1.0;\n    #else\n         vec3 N = vec3(0, 0, 1);\n    #endif\n\n\n    vec3 lightDiffuse = vec3( 0.0, 0.0, 0.0 );\n    vec3 lightSpecular = vec3( 0.0, 0.0, 0.0 );\n\n    #ifdef O3_DIRECT_LIGHT_COUNT\n\n    for( int i = 0; i < O3_DIRECT_LIGHT_COUNT; i++ ) {\n        DirectLight lgt = u_directLights[ i ];\n\n        float d = max(dot(N, -lgt.direction), 0.0)*lgt.intensity;\n        lightDiffuse += lgt.color*d;\n\n        vec3 halfDir = normalize( V - lgt.direction );\n        float s = pow( clamp( dot( N, halfDir ), 0.0, 1.0 ), u_shininess ) * lgt.intensity;\n        lightSpecular += lgt.color * s;\n    }\n\n    #endif\n\n    #ifdef O3_POINT_LIGHT_COUNT\n\n    for( int i = 0; i < O3_POINT_LIGHT_COUNT; i++ ) {\n        PointLight lgt = u_pointLights[ i ];\n        vec3 direction = v_pos - lgt.position;\n        float dist = length( direction );\n        direction /= dist;\n        float decay = pow( max( 0.0, 1.0-dist/lgt.distance ), 2.0 );\n\n        float d =  max( dot( N, -direction ), 0.0 )*lgt.intensity*decay;\n        lightDiffuse += lgt.color*d;\n\n        vec3 halfDir = normalize( V - direction );\n        float s = pow( clamp( dot( N, halfDir ), 0.0, 1.0 ), u_shininess ) * lgt.intensity * decay;\n        lightSpecular += lgt.color * s;\n\n    }\n\n    #endif\n\n    #ifdef O3_SPOT_LIGHT_COUNT\n\n    for( int i = 0; i < O3_SPOT_LIGHT_COUNT; i++) {\n        SpotLight lgt = u_spotLights[ i ];\n        vec3 direction = v_pos - lgt.position;\n        float angle = acos( dot( normalize( direction ), normalize( lgt.direction ) ) );\n        float dist = length( direction );\n        direction /= dist;\n        float decay = pow( max( 0.0, 1.0 - dist / lgt.distance ), 2.0 );\n\n        float hasLight = step( angle, lgt.angle );\n        float hasPenumbra = step( lgt.angle, angle ) * step( angle, lgt.angle * ( 1.0 + lgt.penumbra ) );\n        float penumbra = hasPenumbra * ( 1.0 - ( angle - lgt.angle ) / ( lgt.angle * lgt.penumbra ) );\n        float d = max( dot( N, -direction ), 0.0 ) * lgt.intensity * decay * ( penumbra + hasLight );\n        lightDiffuse += lgt.color * d;\n\n        vec3 halfDir = normalize( V - direction );\n        float s = pow( clamp( dot( N, halfDir ), 0.0, 1.0 ), u_shininess ) * lgt.intensity * decay * ( penumbra + hasLight );\n        lightSpecular += lgt.color * s;\n\n    }\n\n    #endif\n\n    diffuse *= vec4( lightDiffuse, 1.0 );\n    specular *= vec4( lightSpecular, 1.0 );\n";
  var mobile_lambert_frag2 = "    vec3 totalLight = vec3(0.0, 0.0, 0.0);\n    #ifdef O3_DIRECT_LIGHT_COUNT\n    for( int i = 0; i < O3_DIRECT_LIGHT_COUNT; i++ ){\n        vec3 lightColor = u_directLights[ i ].color * u_directLights[ i ].intensity;\n        lightColor *= max( dot( N, -u_directLights[ i ].direction ), 0.0 );\n\n        totalLight += lightColor;\n    }\n    #endif\n    diffuse *= vec4( totalLight, 1.0 );\n";
  var noise_common2 = "// Modulo 289 without a division (only multiplications)\nvec4 mod289( vec4 x ) {\n\n    return x - floor( x * ( 1.0 / 289.0 ) ) * 289.0;\n\n}\n\nvec3 mod289( vec3 x ) {\n\n    return x - floor( x * ( 1.0 / 289.0 ) ) * 289.0;\n\n}\n\nvec2 mod289( vec2 x ) {\n\n    return x - floor( x * ( 1.0 / 289.0 ) ) * 289.0;\n\n}\n\nfloat mod289( float x ) {\n\n    return x - floor( x * ( 1.0 / 289.0 ) ) * 289.0;\n\n}\n\n// Modulo 7 without a division\nvec4 mod7( vec4 x ) {\n\n    return x - floor( x * ( 1.0 / 7.0 ) ) * 7.0;\n\n}\n\nvec3 mod7( vec3 x ) {\n\n    return x - floor( x * ( 1.0 / 7.0 ) ) * 7.0;\n\n}\n\n// Permutation polynomial: (34x^2 + x) mod 289\nvec4 permute( vec4 x ) {\n\n    return mod289( ( 34.0 * x + 1.0 ) * x);\n\n}\n\nvec3 permute( vec3 x ) {\n\n    return mod289( ( 34.0 * x + 1.0 ) * x );\n\n}\n\nfloat permute( float x ) {\n\n  return mod289( ( ( x * 34.0 ) + 1.0 ) * x );\n\n}\n\nvec4 taylorInvSqrt( vec4 r ) {\n\n    return 1.79284291400159 - 0.85373472095314 * r;\n\n}\n\nfloat taylorInvSqrt( float r ) {\n\n    return 1.79284291400159 - 0.85373472095314 * r;\n\n}\n\nvec4 fade( vec4 t ) {\n\n    return t * t * t * ( t * ( t * 6.0 - 15.0 ) + 10.0 );\n\n}\n\nvec3 fade( vec3 t ) {\n\n    return t * t * t * ( t * ( t * 6.0 - 15.0 ) + 10.0 );\n\n}\n\nvec2 fade( vec2 t ) {\n\n    return t * t * t * ( t * ( t * 6.0 - 15.0 ) + 10.0 );\n\n}\n\n#define K 0.142857142857 // 1/7\n#define Ko 0.428571428571 // 1/2-K/2\n#define K2 0.020408163265306 // 1/(7*7)\n#define Kd2 0.0714285714285 // K/2\n#define Kz 0.166666666667 // 1/6\n#define Kzo 0.416666666667 // 1/2-1/6*2\n#define jitter 1.0 // smaller jitter gives more regular pattern\n#define jitter1 0.8 // smaller jitter gives less errors in F1 F2\n";
  var noise_cellular_2D2 = "\n// Cellular noise (\"Worley noise\") in 2D in GLSL.\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n// This code is released under the conditions of the MIT license.\n// See LICENSE file for details.\n// https://github.com/stegu/webgl-noise\n\n// Cellular noise, returning F1 and F2 in a vec2.\n// Standard 3x3 search window for good F1 and F2 values\nvec2 cellular( vec2 P ) {\n\n\tvec2 Pi = mod289( floor( P ) );\n \tvec2 Pf = fract( P );\n\tvec3 oi = vec3( -1.0, 0.0, 1.0);\n\tvec3 of = vec3( -0.5, 0.5, 1.5);\n\tvec3 px = permute( Pi.x + oi );\n\tvec3 p = permute( px.x + Pi.y + oi ); // p11, p12, p13\n\tvec3 ox = fract( p * K ) - Ko;\n\tvec3 oy = mod7( floor( p * K ) ) * K - Ko;\n\tvec3 dx = Pf.x + 0.5 + jitter * ox;\n\tvec3 dy = Pf.y - of + jitter * oy;\n\tvec3 d1 = dx * dx + dy * dy; // d11, d12 and d13, squared\n\tp = permute( px.y + Pi.y + oi ); // p21, p22, p23\n\tox = fract( p * K ) - Ko;\n\toy = mod7( floor( p * K ) ) * K - Ko;\n\tdx = Pf.x - 0.5 + jitter * ox;\n\tdy = Pf.y - of + jitter * oy;\n\tvec3 d2 = dx * dx + dy * dy; // d21, d22 and d23, squared\n\tp = permute( px.z + Pi.y + oi ); // p31, p32, p33\n\tox = fract( p * K ) - Ko;\n\toy = mod7( floor( p * K ) ) * K - Ko;\n\tdx = Pf.x - 1.5 + jitter * ox;\n\tdy = Pf.y - of + jitter * oy;\n\tvec3 d3 = dx * dx + dy * dy; // d31, d32 and d33, squared\n\t// Sort out the two smallest distances (F1, F2)\n\tvec3 d1a = min( d1, d2 );\n\td2 = max( d1, d2 ); // Swap to keep candidates for F2\n\td2 = min( d2, d3 ); // neither F1 nor F2 are now in d3\n\td1 = min( d1a, d2 ); // F1 is now in d1\n\td2 = max( d1a, d2 ); // Swap to keep candidates for F2\n\td1.xy = ( d1.x < d1.y ) ? d1.xy : d1.yx; // Swap if smaller\n\td1.xz = ( d1.x < d1.z ) ? d1.xz : d1.zx; // F1 is in d1.x\n\td1.yz = min( d1.yz, d2.yz ); // F2 is now not in d2.yz\n\td1.y = min( d1.y, d1.z ); // nor in  d1.z\n\td1.y = min( d1.y, d2.x ); // F2 is in d1.y, we're done.\n\treturn sqrt( d1.xy );\n\n}\n";
  var noise_cellular_2x22 = "\n// Cellular noise (\"Worley noise\") in 2D in GLSL.\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n// This code is released under the conditions of the MIT license.\n// See LICENSE file for details.\n// https://github.com/stegu/webgl-noise\n\n// Cellular noise, returning F1 and F2 in a vec2.\n// Speeded up by using 2x2 search window instead of 3x3,\n// at the expense of some strong pattern artifacts.\n// F2 is often wrong and has sharp discontinuities.\n// If you need a smooth F2, use the slower 3x3 version.\n// F1 is sometimes wrong, too, but OK for most purposes.\nvec2 cellular2x2( vec2 P ) {\n\n\tvec2 Pi = mod289( floor( P ) );\n \tvec2 Pf = fract( P );\n\tvec4 Pfx = Pf.x + vec4( -0.5, -1.5, -0.5, -1.5 );\n\tvec4 Pfy = Pf.y + vec4( -0.5, -0.5, -1.5, -1.5 );\n\tvec4 p = permute( Pi.x + vec4( 0.0, 1.0, 0.0, 1.0 ) );\n\tp = permute( p + Pi.y + vec4( 0.0, 0.0, 1.0, 1.0 ) );\n\tvec4 ox = mod7( p ) * K + Kd2;\n\tvec4 oy = mod7( floor( p * K ) ) * K + Kd2;\n\tvec4 dx = Pfx + jitter1 * ox;\n\tvec4 dy = Pfy + jitter1 * oy;\n\tvec4 d = dx * dx + dy * dy; // d11, d12, d21 and d22, squared\n\n\t// Do it right and find both F1 and F2\n\td.xy = ( d.x < d.y ) ? d.xy : d.yx; // Swap if smaller\n\td.xz = ( d.x < d.z ) ? d.xz : d.zx;\n\td.xw = ( d.x < d.w ) ? d.xw : d.wx;\n\td.y = min( d.y, d.z );\n\td.y = min( d.y, d.w );\n\treturn sqrt( d.xy );\n\n}\n";
  var noise_cellular_2x2x22 = "\n// Cellular noise (\"Worley noise\") in 3D in GLSL.\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n// This code is released under the conditions of the MIT license.\n// See LICENSE file for details.\n// https://github.com/stegu/webgl-noise\n\n// Cellular noise, returning F1 and F2 in a vec2.\n// Speeded up by using 2x2x2 search window instead of 3x3x3,\n// at the expense of some pattern artifacts.\n// F2 is often wrong and has sharp discontinuities.\n// If you need a good F2, use the slower 3x3x3 version.\nvec2 cellular2x2x2(vec3 P) {\n\n\tvec3 Pi = mod289( floor( P ) );\n \tvec3 Pf = fract( P );\n\tvec4 Pfx = Pf.x + vec4( 0.0, -1.0, 0.0, -1.0 );\n\tvec4 Pfy = Pf.y + vec4( 0.0, 0.0, -1.0, -1.0 );\n\tvec4 p = permute( Pi.x + vec4( 0.0, 1.0, 0.0, 1.0 ) );\n\tp = permute( p + Pi.y + vec4( 0.0, 0.0, 1.0, 1.0 ) );\n\tvec4 p1 = permute( p + Pi.z ); // z+0\n\tvec4 p2 = permute( p + Pi.z + vec4( 1.0 ) ); // z+1\n\tvec4 ox1 = fract( p1 * K ) - Ko;\n\tvec4 oy1 = mod7( floor( p1 * K ) ) * K - Ko;\n\tvec4 oz1 = floor( p1 * K2 ) * Kz - Kzo; // p1 < 289 guaranteed\n\tvec4 ox2 = fract( p2 * K ) - Ko;\n\tvec4 oy2 = mod7( floor( p2 * K ) ) * K - Ko;\n\tvec4 oz2 = floor( p2 * K2 ) * Kz - Kzo;\n\tvec4 dx1 = Pfx + jitter1 * ox1;\n\tvec4 dy1 = Pfy + jitter1 * oy1;\n\tvec4 dz1 = Pf.z + jitter1 * oz1;\n\tvec4 dx2 = Pfx + jitter1 * ox2;\n\tvec4 dy2 = Pfy + jitter1 * oy2;\n\tvec4 dz2 = Pf.z - 1.0 + jitter1 * oz2;\n\tvec4 d1 = dx1 * dx1 + dy1 * dy1 + dz1 * dz1; // z+0\n\tvec4 d2 = dx2 * dx2 + dy2 * dy2 + dz2 * dz2; // z+1\n\n\t// Do it right and sort out both F1 and F2\n\tvec4 d = min( d1, d2 ); // F1 is now in d\n\td2 = max( d1, d2 ); // Make sure we keep all candidates for F2\n\td.xy = ( d.x < d.y ) ? d.xy : d.yx; // Swap smallest to d.x\n\td.xz = ( d.x < d.z ) ? d.xz : d.zx;\n\td.xw = ( d.x < d.w ) ? d.xw : d.wx; // F1 is now in d.x\n\td.yzw = min( d.yzw, d2.yzw ); // F2 now not in d2.yzw\n\td.y = min( d.y, d.z ); // nor in d.z\n\td.y = min( d.y, d.w ); // nor in d.w\n\td.y = min( d.y, d2.x ); // F2 is now in d.y\n\treturn sqrt( d.xy ); // F1 and F2\n\n}\n";
  var noise_cellular_3D2 = "\n// Cellular noise (\"Worley noise\") in 3D in GLSL.\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n// This code is released under the conditions of the MIT license.\n// See LICENSE file for details.\n// https://github.com/stegu/webgl-noise\n\n// Cellular noise, returning F1 and F2 in a vec2.\n// 3x3x3 search region for good F2 everywhere, but a lot\n// slower than the 2x2x2 version.\n// The code below is a bit scary even to its author,\n// but it has at least half decent performance on a\n// modern GPU. In any case, it beats any software\n// implementation of Worley noise hands down.\n\nvec2 cellular( vec3 P ) {\n\n\tvec3 Pi = mod289( floor( P ) );\n \tvec3 Pf = fract( P ) - 0.5;\n\n\tvec3 Pfx = Pf.x + vec3( 1.0, 0.0, -1.0 );\n\tvec3 Pfy = Pf.y + vec3( 1.0, 0.0, -1.0 );\n\tvec3 Pfz = Pf.z + vec3( 1.0, 0.0, -1.0 );\n\n\tvec3 p = permute( Pi.x + vec3( -1.0, 0.0, 1.0 ) );\n\tvec3 p1 = permute( p + Pi.y - 1.0 );\n\tvec3 p2 = permute( p + Pi.y );\n\tvec3 p3 = permute( p + Pi.y + 1.0 );\n\n\tvec3 p11 = permute( p1 + Pi.z - 1.0 );\n\tvec3 p12 = permute( p1 + Pi.z );\n\tvec3 p13 = permute( p1 + Pi.z + 1.0 );\n\n\tvec3 p21 = permute( p2 + Pi.z - 1.0 );\n\tvec3 p22 = permute( p2 + Pi.z );\n\tvec3 p23 = permute( p2 + Pi.z + 1.0 );\n\n\tvec3 p31 = permute( p3 + Pi.z - 1.0 );\n\tvec3 p32 = permute( p3 + Pi.z );\n\tvec3 p33 = permute( p3 + Pi.z + 1.0 );\n\n\tvec3 ox11 = fract( p11 * K ) - Ko;\n\tvec3 oy11 = mod7( floor( p11 * K ) ) * K - Ko;\n\tvec3 oz11 = floor( p11 * K2 ) * Kz - Kzo; // p11 < 289 guaranteed\n\n\tvec3 ox12 = fract( p12 * K ) - Ko;\n\tvec3 oy12 = mod7( floor( p12 * K ) ) * K - Ko;\n\tvec3 oz12 = floor( p12 * K2 ) * Kz - Kzo;\n\n\tvec3 ox13 = fract( p13 * K ) - Ko;\n\tvec3 oy13 = mod7( floor( p13 * K ) ) * K - Ko;\n\tvec3 oz13 = floor( p13 * K2 ) * Kz - Kzo;\n\n\tvec3 ox21 = fract( p21 * K ) - Ko;\n\tvec3 oy21 = mod7( floor( p21 * K ) ) * K - Ko;\n\tvec3 oz21 = floor( p21 * K2 ) * Kz - Kzo;\n\n\tvec3 ox22 = fract( p22 * K ) - Ko;\n\tvec3 oy22 = mod7( floor( p22 * K ) ) * K - Ko;\n\tvec3 oz22 = floor( p22 * K2 ) * Kz - Kzo;\n\n\tvec3 ox23 = fract( p23 * K ) - Ko;\n\tvec3 oy23 = mod7( floor( p23 * K ) ) * K - Ko;\n\tvec3 oz23 = floor( p23 * K2 ) * Kz - Kzo;\n\n\tvec3 ox31 = fract( p31 * K ) - Ko;\n\tvec3 oy31 = mod7( floor( p31 * K ) ) * K - Ko;\n\tvec3 oz31 = floor( p31 * K2 ) * Kz - Kzo;\n\n\tvec3 ox32 = fract( p32 * K ) - Ko;\n\tvec3 oy32 = mod7( floor( p32 * K ) ) * K - Ko;\n\tvec3 oz32 = floor( p32 * K2 ) * Kz - Kzo;\n\n\tvec3 ox33 = fract( p33 * K ) - Ko;\n\tvec3 oy33 = mod7( floor( p33 * K ) ) * K - Ko;\n\tvec3 oz33 = floor( p33 * K2 ) * Kz - Kzo;\n\n\tvec3 dx11 = Pfx + jitter * ox11;\n\tvec3 dy11 = Pfy.x + jitter * oy11;\n\tvec3 dz11 = Pfz.x + jitter * oz11;\n\n\tvec3 dx12 = Pfx + jitter * ox12;\n\tvec3 dy12 = Pfy.x + jitter * oy12;\n\tvec3 dz12 = Pfz.y + jitter * oz12;\n\n\tvec3 dx13 = Pfx + jitter * ox13;\n\tvec3 dy13 = Pfy.x + jitter * oy13;\n\tvec3 dz13 = Pfz.z + jitter * oz13;\n\n\tvec3 dx21 = Pfx + jitter * ox21;\n\tvec3 dy21 = Pfy.y + jitter * oy21;\n\tvec3 dz21 = Pfz.x + jitter * oz21;\n\n\tvec3 dx22 = Pfx + jitter * ox22;\n\tvec3 dy22 = Pfy.y + jitter * oy22;\n\tvec3 dz22 = Pfz.y + jitter * oz22;\n\n\tvec3 dx23 = Pfx + jitter * ox23;\n\tvec3 dy23 = Pfy.y + jitter * oy23;\n\tvec3 dz23 = Pfz.z + jitter * oz23;\n\n\tvec3 dx31 = Pfx + jitter * ox31;\n\tvec3 dy31 = Pfy.z + jitter * oy31;\n\tvec3 dz31 = Pfz.x + jitter * oz31;\n\n\tvec3 dx32 = Pfx + jitter * ox32;\n\tvec3 dy32 = Pfy.z + jitter * oy32;\n\tvec3 dz32 = Pfz.y + jitter * oz32;\n\n\tvec3 dx33 = Pfx + jitter * ox33;\n\tvec3 dy33 = Pfy.z + jitter * oy33;\n\tvec3 dz33 = Pfz.z + jitter * oz33;\n\n\tvec3 d11 = dx11 * dx11 + dy11 * dy11 + dz11 * dz11;\n\tvec3 d12 = dx12 * dx12 + dy12 * dy12 + dz12 * dz12;\n\tvec3 d13 = dx13 * dx13 + dy13 * dy13 + dz13 * dz13;\n\tvec3 d21 = dx21 * dx21 + dy21 * dy21 + dz21 * dz21;\n\tvec3 d22 = dx22 * dx22 + dy22 * dy22 + dz22 * dz22;\n\tvec3 d23 = dx23 * dx23 + dy23 * dy23 + dz23 * dz23;\n\tvec3 d31 = dx31 * dx31 + dy31 * dy31 + dz31 * dz31;\n\tvec3 d32 = dx32 * dx32 + dy32 * dy32 + dz32 * dz32;\n\tvec3 d33 = dx33 * dx33 + dy33 * dy33 + dz33 * dz33;\n\n\t// Do it right and sort out both F1 and F2\n\tvec3 d1a = min( d11, d12 );\n\td12 = max( d11, d12 );\n\td11 = min( d1a, d13 ); // Smallest now not in d12 or d13\n\td13 = max( d1a, d13 );\n\td12 = min( d12, d13 ); // 2nd smallest now not in d13\n\tvec3 d2a = min( d21, d22 );\n\td22 = max( d21, d22 );\n\td21 = min( d2a, d23 ); // Smallest now not in d22 or d23\n\td23 = max( d2a, d23 );\n\td22 = min( d22, d23 ); // 2nd smallest now not in d23\n\tvec3 d3a = min( d31, d32 );\n\td32 = max( d31, d32 );\n\td31 = min( d3a, d33 ); // Smallest now not in d32 or d33\n\td33 = max( d3a, d33 );\n\td32 = min( d32, d33 ); // 2nd smallest now not in d33\n\tvec3 da = min( d11, d21 );\n\td21 = max( d11, d21 );\n\td11 = min( da, d31 ); // Smallest now in d11\n\td31 = max( da, d31 ); // 2nd smallest now not in d31\n\td11.xy = ( d11.x < d11.y ) ? d11.xy : d11.yx;\n\td11.xz = ( d11.x < d11.z ) ? d11.xz : d11.zx; // d11.x now smallest\n\td12 = min( d12, d21 ); // 2nd smallest now not in d21\n\td12 = min( d12, d22 ); // nor in d22\n\td12 = min( d12, d31 ); // nor in d31\n\td12 = min( d12, d32 ); // nor in d32\n\td11.yz = min( d11.yz, d12.xy ); // nor in d12.yz\n\td11.y = min( d11.y, d12.z ); // Only two more to go\n\td11.y = min( d11.y, d11.z ); // Done! (Phew! )\n\treturn sqrt( d11.xy ); // F1, F2\n\n}\n";
  var noise_cellular2 = "#include <noise_cellular_2D>\n#include <noise_cellular_3D>\n#include <noise_cellular_2x2>\n#include <noise_cellular_2x2x2>\n";
  var noise_perlin_2D2 = "//\n// GLSL textureless classic 2D noise \"cnoise\",\n// with an RSL-style periodic variant \"pnoise\".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/stegu/webgl-noise\n//\n\n// Classic Perlin noise\nfloat perlin( vec2 P ) {\n\n    vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n    Pi = mod289(Pi); // To avoid truncation effects in permutation\n    vec4 ix = Pi.xzxz;\n    vec4 iy = Pi.yyww;\n    vec4 fx = Pf.xzxz;\n    vec4 fy = Pf.yyww;\n\n    vec4 i = permute(permute(ix) + iy);\n\n    vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n    vec4 gy = abs(gx) - 0.5 ;\n    vec4 tx = floor(gx + 0.5);\n    gx = gx - tx;\n\n    vec2 g00 = vec2(gx.x,gy.x);\n    vec2 g10 = vec2(gx.y,gy.y);\n    vec2 g01 = vec2(gx.z,gy.z);\n    vec2 g11 = vec2(gx.w,gy.w);\n\n    vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n    g00 *= norm.x;\n    g01 *= norm.y;\n    g10 *= norm.z;\n    g11 *= norm.w;\n\n    float n00 = dot(g00, vec2(fx.x, fy.x));\n    float n10 = dot(g10, vec2(fx.y, fy.y));\n    float n01 = dot(g01, vec2(fx.z, fy.z));\n    float n11 = dot(g11, vec2(fx.w, fy.w));\n\n    vec2 fade_xy = fade(Pf.xy);\n    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n    return 2.3 * n_xy;\n\n}\n\n// Classic Perlin noise, periodic variant\nfloat perlin( vec2 P, vec2 rep ) {\n\n    vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n    Pi = mod(Pi, rep.xyxy); // To create noise with explicit period\n    Pi = mod289(Pi);        // To avoid truncation effects in permutation\n    vec4 ix = Pi.xzxz;\n    vec4 iy = Pi.yyww;\n    vec4 fx = Pf.xzxz;\n    vec4 fy = Pf.yyww;\n\n    vec4 i = permute(permute(ix) + iy);\n\n    vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n    vec4 gy = abs(gx) - 0.5 ;\n    vec4 tx = floor(gx + 0.5);\n    gx = gx - tx;\n\n    vec2 g00 = vec2(gx.x,gy.x);\n    vec2 g10 = vec2(gx.y,gy.y);\n    vec2 g01 = vec2(gx.z,gy.z);\n    vec2 g11 = vec2(gx.w,gy.w);\n\n    vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n    g00 *= norm.x;\n    g01 *= norm.y;\n    g10 *= norm.z;\n    g11 *= norm.w;\n\n    float n00 = dot(g00, vec2(fx.x, fy.x));\n    float n10 = dot(g10, vec2(fx.y, fy.y));\n    float n01 = dot(g01, vec2(fx.z, fy.z));\n    float n11 = dot(g11, vec2(fx.w, fy.w));\n\n    vec2 fade_xy = fade(Pf.xy);\n    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n    return 2.3 * n_xy;\n\n}\n";
  var noise_perlin_3D2 = "//\n// GLSL textureless classic 3D noise \"cnoise\",\n// with an RSL-style periodic variant \"pnoise\".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/stegu/webgl-noise\n//\n\n// Classic Perlin noise\nfloat perlin( vec3 P ) {\n\n    vec3 Pi0 = floor(P); // Integer part for indexing\n    vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 2.2 * n_xyz;\n\n}\n\n// Classic Perlin noise, periodic variant\nfloat perlin( vec3 P, vec3 rep ) {\n\n    vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n    vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 2.2 * n_xyz;\n\n}\n";
  var noise_perlin_4D2 = "//\n// GLSL textureless classic 4D noise \"cnoise\",\n// with an RSL-style periodic variant \"pnoise\".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/stegu/webgl-noise\n//\n\n// Classic Perlin noise\nfloat perlin( vec4 P ) {\n\n    vec4 Pi0 = floor(P); // Integer part for indexing\n    vec4 Pi1 = Pi0 + 1.0; // Integer part + 1\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec4 Pf0 = fract(P); // Fractional part for interpolation\n    vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = vec4(Pi0.zzzz);\n    vec4 iz1 = vec4(Pi1.zzzz);\n    vec4 iw0 = vec4(Pi0.wwww);\n    vec4 iw1 = vec4(Pi1.wwww);\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n    vec4 ixy00 = permute(ixy0 + iw0);\n    vec4 ixy01 = permute(ixy0 + iw1);\n    vec4 ixy10 = permute(ixy1 + iw0);\n    vec4 ixy11 = permute(ixy1 + iw1);\n\n    vec4 gx00 = ixy00 * (1.0 / 7.0);\n    vec4 gy00 = floor(gx00) * (1.0 / 7.0);\n    vec4 gz00 = floor(gy00) * (1.0 / 6.0);\n    gx00 = fract(gx00) - 0.5;\n    gy00 = fract(gy00) - 0.5;\n    gz00 = fract(gz00) - 0.5;\n    vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\n    vec4 sw00 = step(gw00, vec4(0.0));\n    gx00 -= sw00 * (step(0.0, gx00) - 0.5);\n    gy00 -= sw00 * (step(0.0, gy00) - 0.5);\n\n    vec4 gx01 = ixy01 * (1.0 / 7.0);\n    vec4 gy01 = floor(gx01) * (1.0 / 7.0);\n    vec4 gz01 = floor(gy01) * (1.0 / 6.0);\n    gx01 = fract(gx01) - 0.5;\n    gy01 = fract(gy01) - 0.5;\n    gz01 = fract(gz01) - 0.5;\n    vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\n    vec4 sw01 = step(gw01, vec4(0.0));\n    gx01 -= sw01 * (step(0.0, gx01) - 0.5);\n    gy01 -= sw01 * (step(0.0, gy01) - 0.5);\n\n    vec4 gx10 = ixy10 * (1.0 / 7.0);\n    vec4 gy10 = floor(gx10) * (1.0 / 7.0);\n    vec4 gz10 = floor(gy10) * (1.0 / 6.0);\n    gx10 = fract(gx10) - 0.5;\n    gy10 = fract(gy10) - 0.5;\n    gz10 = fract(gz10) - 0.5;\n    vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\n    vec4 sw10 = step(gw10, vec4(0.0));\n    gx10 -= sw10 * (step(0.0, gx10) - 0.5);\n    gy10 -= sw10 * (step(0.0, gy10) - 0.5);\n\n    vec4 gx11 = ixy11 * (1.0 / 7.0);\n    vec4 gy11 = floor(gx11) * (1.0 / 7.0);\n    vec4 gz11 = floor(gy11) * (1.0 / 6.0);\n    gx11 = fract(gx11) - 0.5;\n    gy11 = fract(gy11) - 0.5;\n    gz11 = fract(gz11) - 0.5;\n    vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\n    vec4 sw11 = step(gw11, vec4(0.0));\n    gx11 -= sw11 * (step(0.0, gx11) - 0.5);\n    gy11 -= sw11 * (step(0.0, gy11) - 0.5);\n\n    vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);\n    vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);\n    vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);\n    vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);\n    vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);\n    vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);\n    vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);\n    vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);\n    vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);\n    vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);\n    vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);\n    vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);\n    vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);\n    vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);\n    vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);\n    vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);\n\n    vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\n    g0000 *= norm00.x;\n    g0100 *= norm00.y;\n    g1000 *= norm00.z;\n    g1100 *= norm00.w;\n\n    vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\n    g0001 *= norm01.x;\n    g0101 *= norm01.y;\n    g1001 *= norm01.z;\n    g1101 *= norm01.w;\n\n    vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\n    g0010 *= norm10.x;\n    g0110 *= norm10.y;\n    g1010 *= norm10.z;\n    g1110 *= norm10.w;\n\n    vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\n    g0011 *= norm11.x;\n    g0111 *= norm11.y;\n    g1011 *= norm11.z;\n    g1111 *= norm11.w;\n\n    float n0000 = dot(g0000, Pf0);\n    float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));\n    float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));\n    float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));\n    float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));\n    float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\n    float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));\n    float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));\n    float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));\n    float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));\n    float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\n    float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));\n    float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));\n    float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));\n    float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));\n    float n1111 = dot(g1111, Pf1);\n\n    vec4 fade_xyzw = fade(Pf0);\n    vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\n    vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\n    vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);\n    vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);\n    float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\n    return 2.2 * n_xyzw;\n\n}\n\n// Classic Perlin noise, periodic version\nfloat perlin( vec4 P, vec4 rep ) {\n\n    vec4 Pi0 = mod(floor(P), rep); // Integer part modulo rep\n    vec4 Pi1 = mod(Pi0 + 1.0, rep); // Integer part + 1 mod rep\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec4 Pf0 = fract(P); // Fractional part for interpolation\n    vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = vec4(Pi0.zzzz);\n    vec4 iz1 = vec4(Pi1.zzzz);\n    vec4 iw0 = vec4(Pi0.wwww);\n    vec4 iw1 = vec4(Pi1.wwww);\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n    vec4 ixy00 = permute(ixy0 + iw0);\n    vec4 ixy01 = permute(ixy0 + iw1);\n    vec4 ixy10 = permute(ixy1 + iw0);\n    vec4 ixy11 = permute(ixy1 + iw1);\n\n    vec4 gx00 = ixy00 * (1.0 / 7.0);\n    vec4 gy00 = floor(gx00) * (1.0 / 7.0);\n    vec4 gz00 = floor(gy00) * (1.0 / 6.0);\n    gx00 = fract(gx00) - 0.5;\n    gy00 = fract(gy00) - 0.5;\n    gz00 = fract(gz00) - 0.5;\n    vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\n    vec4 sw00 = step(gw00, vec4(0.0));\n    gx00 -= sw00 * (step(0.0, gx00) - 0.5);\n    gy00 -= sw00 * (step(0.0, gy00) - 0.5);\n\n    vec4 gx01 = ixy01 * (1.0 / 7.0);\n    vec4 gy01 = floor(gx01) * (1.0 / 7.0);\n    vec4 gz01 = floor(gy01) * (1.0 / 6.0);\n    gx01 = fract(gx01) - 0.5;\n    gy01 = fract(gy01) - 0.5;\n    gz01 = fract(gz01) - 0.5;\n    vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\n    vec4 sw01 = step(gw01, vec4(0.0));\n    gx01 -= sw01 * (step(0.0, gx01) - 0.5);\n    gy01 -= sw01 * (step(0.0, gy01) - 0.5);\n\n    vec4 gx10 = ixy10 * (1.0 / 7.0);\n    vec4 gy10 = floor(gx10) * (1.0 / 7.0);\n    vec4 gz10 = floor(gy10) * (1.0 / 6.0);\n    gx10 = fract(gx10) - 0.5;\n    gy10 = fract(gy10) - 0.5;\n    gz10 = fract(gz10) - 0.5;\n    vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\n    vec4 sw10 = step(gw10, vec4(0.0));\n    gx10 -= sw10 * (step(0.0, gx10) - 0.5);\n    gy10 -= sw10 * (step(0.0, gy10) - 0.5);\n\n    vec4 gx11 = ixy11 * (1.0 / 7.0);\n    vec4 gy11 = floor(gx11) * (1.0 / 7.0);\n    vec4 gz11 = floor(gy11) * (1.0 / 6.0);\n    gx11 = fract(gx11) - 0.5;\n    gy11 = fract(gy11) - 0.5;\n    gz11 = fract(gz11) - 0.5;\n    vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\n    vec4 sw11 = step(gw11, vec4(0.0));\n    gx11 -= sw11 * (step(0.0, gx11) - 0.5);\n    gy11 -= sw11 * (step(0.0, gy11) - 0.5);\n\n    vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);\n    vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);\n    vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);\n    vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);\n    vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);\n    vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);\n    vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);\n    vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);\n    vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);\n    vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);\n    vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);\n    vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);\n    vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);\n    vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);\n    vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);\n    vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);\n\n    vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\n    g0000 *= norm00.x;\n    g0100 *= norm00.y;\n    g1000 *= norm00.z;\n    g1100 *= norm00.w;\n\n    vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\n    g0001 *= norm01.x;\n    g0101 *= norm01.y;\n    g1001 *= norm01.z;\n    g1101 *= norm01.w;\n\n    vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\n    g0010 *= norm10.x;\n    g0110 *= norm10.y;\n    g1010 *= norm10.z;\n    g1110 *= norm10.w;\n\n    vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\n    g0011 *= norm11.x;\n    g0111 *= norm11.y;\n    g1011 *= norm11.z;\n    g1111 *= norm11.w;\n\n    float n0000 = dot(g0000, Pf0);\n    float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));\n    float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));\n    float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));\n    float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));\n    float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\n    float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));\n    float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));\n    float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));\n    float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));\n    float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\n    float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));\n    float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));\n    float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));\n    float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));\n    float n1111 = dot(g1111, Pf1);\n\n    vec4 fade_xyzw = fade(Pf0);\n    vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\n    vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\n    vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);\n    vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);\n    float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\n    return 2.2 * n_xyzw;\n\n}\n";
  var noise_perlin2 = "#include <noise_perlin_2D>\n#include <noise_perlin_3D>\n#include <noise_perlin_4D>\n";
  var noise_psrd_2D2 = "// Periodic (tiling) 2-D simplex noise (hexagonal lattice gradient noise)\n// with rotating gradients and analytic derivatives.\n// Variants also without the derivative (no \"d\" in the name), without\n// the tiling property (no \"p\" in the name) and without the rotating\n// gradients (no \"r\" in the name).\n//\n// This is (yet) another variation on simplex noise. It's similar to the\n// version presented by Ken Perlin, but the grid is axis-aligned and\n// slightly stretched in the y direction to permit rectangular tiling.\n//\n// The noise can be made to tile seamlessly to any integer period in x and\n// any even integer period in y. Odd periods may be specified for y, but\n// then the actual tiling period will be twice that number.\n//\n// The rotating gradients give the appearance of a swirling motion, and can\n// serve a similar purpose for animation as motion along z in 3-D noise.\n// The rotating gradients in conjunction with the analytic derivatives\n// can make \"flow noise\" effects as presented by Perlin and Neyret.\n//\n// vec3 {p}s{r}dnoise(vec2 pos {, vec2 per} {, float rot})\n// \"pos\" is the input (x,y) coordinate\n// \"per\" is the x and y period, where per.x is a positive integer\n//    and per.y is a positive even integer\n// \"rot\" is the angle to rotate the gradients (any float value,\n//    where 0.0 is no rotation and 1.0 is one full turn)\n// The first component of the 3-element return vector is the noise value.\n// The second and third components are the x and y partial derivatives.\n//\n// float {p}s{r}noise(vec2 pos {, vec2 per} {, float rot})\n// \"pos\" is the input (x,y) coordinate\n// \"per\" is the x and y period, where per.x is a positive integer\n//    and per.y is a positive even integer\n// \"rot\" is the angle to rotate the gradients (any float value,\n//    where 0.0 is no rotation and 1.0 is one full turn)\n// The return value is the noise value.\n// Partial derivatives are not computed, making these functions faster.\n//\n// Author: Stefan Gustavson (stefan.gustavson@gmail.com)\n// Version 2016-05-10.\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// idea of using a permutation polynomial.\n//\n// Copyright (c) 2016 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/stegu/webgl-noise\n//\n\n// Hashed 2-D gradients with an extra rotation.\n// (The constant 0.0243902439 is 1/41)\nvec2 rgrad2( vec2 p, float rot ) {\n\n    // For more isotropic gradients, sin/cos can be used instead.\n    float u = permute( permute( p.x ) + p.y ) * 0.0243902439 + rot; // Rotate by shift\n    u = fract( u ) * 6.28318530718; // 2*pi\n    return vec2( cos( u ), sin( u ));\n\n}\n\n//\n// 2-D tiling simplex noise with rotating gradients and analytical derivative.\n// The first component of the 3-element return vector is the noise value,\n// and the second and third components are the x and y partial derivatives.\n//\nvec3 psrdnoise(vec2 pos, vec2 per, float rot) {\n  // Hack: offset y slightly to hide some rare artifacts\n  pos.y += 0.01;\n  // Skew to hexagonal grid\n  vec2 uv = vec2(pos.x + pos.y*0.5, pos.y);\n\n  vec2 i0 = floor(uv);\n  vec2 f0 = fract(uv);\n  // Traversal order\n  vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\n  // Unskewed grid points in (x,y) space\n  vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y);\n  vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y);\n  vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);\n\n  // Integer grid point indices in (u,v) space\n  i1 = i0 + i1;\n  vec2 i2 = i0 + vec2(1.0, 1.0);\n\n  // Vectors in unskewed (x,y) coordinates from\n  // each of the simplex corners to the evaluation point\n  vec2 d0 = pos - p0;\n  vec2 d1 = pos - p1;\n  vec2 d2 = pos - p2;\n\n  // Wrap i0, i1 and i2 to the desired period before gradient hashing:\n  // wrap points in (x,y), map to (u,v)\n  vec3 xw = mod(vec3(p0.x, p1.x, p2.x), per.x);\n  vec3 yw = mod(vec3(p0.y, p1.y, p2.y), per.y);\n  vec3 iuw = xw + 0.5 * yw;\n  vec3 ivw = yw;\n\n  // Create gradients from indices\n  vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), rot);\n  vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), rot);\n  vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), rot);\n\n  // Gradients dot vectors to corresponding corners\n  // (The derivatives of this are simply the gradients)\n  vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2));\n\n  // Radial weights from corners\n  // 0.8 is the square of 2/sqrt(5), the distance from\n  // a grid point to the nearest simplex boundary\n  vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2));\n\n  // Partial derivatives for analytical gradient computation\n  vec3 dtdx = -2.0 * vec3(d0.x, d1.x, d2.x);\n  vec3 dtdy = -2.0 * vec3(d0.y, d1.y, d2.y);\n\n  // Set influence of each surflet to zero outside radius sqrt(0.8)\n  if (t.x < 0.0) {\n    dtdx.x = 0.0;\n    dtdy.x = 0.0;\n\tt.x = 0.0;\n  }\n  if (t.y < 0.0) {\n    dtdx.y = 0.0;\n    dtdy.y = 0.0;\n\tt.y = 0.0;\n  }\n  if (t.z < 0.0) {\n    dtdx.z = 0.0;\n    dtdy.z = 0.0;\n\tt.z = 0.0;\n  }\n\n  // Fourth power of t (and third power for derivative)\n  vec3 t2 = t * t;\n  vec3 t4 = t2 * t2;\n  vec3 t3 = t2 * t;\n\n  // Final noise value is:\n  // sum of ((radial weights) times (gradient dot vector from corner))\n  float n = dot(t4, w);\n\n  // Final analytical derivative (gradient of a sum of scalar products)\n  vec2 dt0 = vec2(dtdx.x, dtdy.x) * 4.0 * t3.x;\n  vec2 dn0 = t4.x * g0 + dt0 * w.x;\n  vec2 dt1 = vec2(dtdx.y, dtdy.y) * 4.0 * t3.y;\n  vec2 dn1 = t4.y * g1 + dt1 * w.y;\n  vec2 dt2 = vec2(dtdx.z, dtdy.z) * 4.0 * t3.z;\n  vec2 dn2 = t4.z * g2 + dt2 * w.z;\n\n  return 11.0*vec3(n, dn0 + dn1 + dn2);\n}\n\n//\n// 2-D tiling simplex noise with fixed gradients\n// and analytical derivative.\n// This function is implemented as a wrapper to \"psrdnoise\",\n// at the minimal cost of three extra additions.\n//\nvec3 psdnoise(vec2 pos, vec2 per) {\n  return psrdnoise(pos, per, 0.0);\n}\n\n//\n// 2-D tiling simplex noise with rotating gradients,\n// but without the analytical derivative.\n//\nfloat psrnoise(vec2 pos, vec2 per, float rot) {\n  // Offset y slightly to hide some rare artifacts\n  pos.y += 0.001;\n  // Skew to hexagonal grid\n  vec2 uv = vec2(pos.x + pos.y*0.5, pos.y);\n\n  vec2 i0 = floor(uv);\n  vec2 f0 = fract(uv);\n  // Traversal order\n  vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\n  // Unskewed grid points in (x,y) space\n  vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y);\n  vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y);\n  vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);\n\n  // Integer grid point indices in (u,v) space\n  i1 = i0 + i1;\n  vec2 i2 = i0 + vec2(1.0, 1.0);\n\n  // Vectors in unskewed (x,y) coordinates from\n  // each of the simplex corners to the evaluation point\n  vec2 d0 = pos - p0;\n  vec2 d1 = pos - p1;\n  vec2 d2 = pos - p2;\n\n  // Wrap i0, i1 and i2 to the desired period before gradient hashing:\n  // wrap points in (x,y), map to (u,v)\n  vec3 xw = mod(vec3(p0.x, p1.x, p2.x), per.x);\n  vec3 yw = mod(vec3(p0.y, p1.y, p2.y), per.y);\n  vec3 iuw = xw + 0.5 * yw;\n  vec3 ivw = yw;\n\n  // Create gradients from indices\n  vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), rot);\n  vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), rot);\n  vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), rot);\n\n  // Gradients dot vectors to corresponding corners\n  // (The derivatives of this are simply the gradients)\n  vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2));\n\n  // Radial weights from corners\n  // 0.8 is the square of 2/sqrt(5), the distance from\n  // a grid point to the nearest simplex boundary\n  vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2));\n\n  // Set influence of each surflet to zero outside radius sqrt(0.8)\n  t = max(t, 0.0);\n\n  // Fourth power of t\n  vec3 t2 = t * t;\n  vec3 t4 = t2 * t2;\n\n  // Final noise value is:\n  // sum of ((radial weights) times (gradient dot vector from corner))\n  float n = dot(t4, w);\n\n  // Rescale to cover the range [-1,1] reasonably well\n  return 11.0*n;\n}\n\n//\n// 2-D tiling simplex noise with fixed gradients,\n// without the analytical derivative.\n// This function is implemented as a wrapper to \"psrnoise\",\n// at the minimal cost of three extra additions.\n//\nfloat psnoise(vec2 pos, vec2 per) {\n  return psrnoise(pos, per, 0.0);\n}\n\n//\n// 2-D non-tiling simplex noise with rotating gradients and analytical derivative.\n// The first component of the 3-element return vector is the noise value,\n// and the second and third components are the x and y partial derivatives.\n//\nvec3 srdnoise(vec2 pos, float rot) {\n  // Offset y slightly to hide some rare artifacts\n  pos.y += 0.001;\n  // Skew to hexagonal grid\n  vec2 uv = vec2(pos.x + pos.y*0.5, pos.y);\n\n  vec2 i0 = floor(uv);\n  vec2 f0 = fract(uv);\n  // Traversal order\n  vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\n  // Unskewed grid points in (x,y) space\n  vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y);\n  vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y);\n  vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);\n\n  // Integer grid point indices in (u,v) space\n  i1 = i0 + i1;\n  vec2 i2 = i0 + vec2(1.0, 1.0);\n\n  // Vectors in unskewed (x,y) coordinates from\n  // each of the simplex corners to the evaluation point\n  vec2 d0 = pos - p0;\n  vec2 d1 = pos - p1;\n  vec2 d2 = pos - p2;\n\n  vec3 x = vec3(p0.x, p1.x, p2.x);\n  vec3 y = vec3(p0.y, p1.y, p2.y);\n  vec3 iuw = x + 0.5 * y;\n  vec3 ivw = y;\n\n  // Avoid precision issues in permutation\n  iuw = mod289(iuw);\n  ivw = mod289(ivw);\n\n  // Create gradients from indices\n  vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), rot);\n  vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), rot);\n  vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), rot);\n\n  // Gradients dot vectors to corresponding corners\n  // (The derivatives of this are simply the gradients)\n  vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2));\n\n  // Radial weights from corners\n  // 0.8 is the square of 2/sqrt(5), the distance from\n  // a grid point to the nearest simplex boundary\n  vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2));\n\n  // Partial derivatives for analytical gradient computation\n  vec3 dtdx = -2.0 * vec3(d0.x, d1.x, d2.x);\n  vec3 dtdy = -2.0 * vec3(d0.y, d1.y, d2.y);\n\n  // Set influence of each surflet to zero outside radius sqrt(0.8)\n  if (t.x < 0.0) {\n    dtdx.x = 0.0;\n    dtdy.x = 0.0;\n\tt.x = 0.0;\n  }\n  if (t.y < 0.0) {\n    dtdx.y = 0.0;\n    dtdy.y = 0.0;\n\tt.y = 0.0;\n  }\n  if (t.z < 0.0) {\n    dtdx.z = 0.0;\n    dtdy.z = 0.0;\n\tt.z = 0.0;\n  }\n\n  // Fourth power of t (and third power for derivative)\n  vec3 t2 = t * t;\n  vec3 t4 = t2 * t2;\n  vec3 t3 = t2 * t;\n\n  // Final noise value is:\n  // sum of ((radial weights) times (gradient dot vector from corner))\n  float n = dot(t4, w);\n\n  // Final analytical derivative (gradient of a sum of scalar products)\n  vec2 dt0 = vec2(dtdx.x, dtdy.x) * 4.0 * t3.x;\n  vec2 dn0 = t4.x * g0 + dt0 * w.x;\n  vec2 dt1 = vec2(dtdx.y, dtdy.y) * 4.0 * t3.y;\n  vec2 dn1 = t4.y * g1 + dt1 * w.y;\n  vec2 dt2 = vec2(dtdx.z, dtdy.z) * 4.0 * t3.z;\n  vec2 dn2 = t4.z * g2 + dt2 * w.z;\n\n  return 11.0*vec3(n, dn0 + dn1 + dn2);\n}\n\n//\n// 2-D non-tiling simplex noise with fixed gradients and analytical derivative.\n// This function is implemented as a wrapper to \"srdnoise\",\n// at the minimal cost of three extra additions.\n//\nvec3 sdnoise(vec2 pos) {\n  return srdnoise(pos, 0.0);\n}\n\n//\n// 2-D non-tiling simplex noise with rotating gradients,\n// without the analytical derivative.\n//\nfloat srnoise(vec2 pos, float rot) {\n  // Offset y slightly to hide some rare artifacts\n  pos.y += 0.001;\n  // Skew to hexagonal grid\n  vec2 uv = vec2(pos.x + pos.y*0.5, pos.y);\n\n  vec2 i0 = floor(uv);\n  vec2 f0 = fract(uv);\n  // Traversal order\n  vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\n  // Unskewed grid points in (x,y) space\n  vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y);\n  vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y);\n  vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);\n\n  // Integer grid point indices in (u,v) space\n  i1 = i0 + i1;\n  vec2 i2 = i0 + vec2(1.0, 1.0);\n\n  // Vectors in unskewed (x,y) coordinates from\n  // each of the simplex corners to the evaluation point\n  vec2 d0 = pos - p0;\n  vec2 d1 = pos - p1;\n  vec2 d2 = pos - p2;\n\n  // Wrap i0, i1 and i2 to the desired period before gradient hashing:\n  // wrap points in (x,y), map to (u,v)\n  vec3 x = vec3(p0.x, p1.x, p2.x);\n  vec3 y = vec3(p0.y, p1.y, p2.y);\n  vec3 iuw = x + 0.5 * y;\n  vec3 ivw = y;\n\n  // Avoid precision issues in permutation\n  iuw = mod289(iuw);\n  ivw = mod289(ivw);\n\n  // Create gradients from indices\n  vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), rot);\n  vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), rot);\n  vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), rot);\n\n  // Gradients dot vectors to corresponding corners\n  // (The derivatives of this are simply the gradients)\n  vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2));\n\n  // Radial weights from corners\n  // 0.8 is the square of 2/sqrt(5), the distance from\n  // a grid point to the nearest simplex boundary\n  vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2));\n\n  // Set influence of each surflet to zero outside radius sqrt(0.8)\n  t = max(t, 0.0);\n\n  // Fourth power of t\n  vec3 t2 = t * t;\n  vec3 t4 = t2 * t2;\n\n  // Final noise value is:\n  // sum of ((radial weights) times (gradient dot vector from corner))\n  float n = dot(t4, w);\n\n  // Rescale to cover the range [-1,1] reasonably well\n  return 11.0*n;\n}\n\n//\n// 2-D non-tiling simplex noise with fixed gradients,\n// without the analytical derivative.\n// This function is implemented as a wrapper to \"srnoise\",\n// at the minimal cost of three extra additions.\n// Note: if this kind of noise is all you want, there are faster\n// GLSL implementations of non-tiling simplex noise out there.\n// This one is included mainly for completeness and compatibility\n// with the other functions in the file.\n//\nfloat snoise(vec2 pos) {\n  return srnoise(pos, 0.0);\n}\n";
  var noise_simplex_2D2 = "//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n//\n\nfloat simplex( vec2 v ) {\n\n    const vec4 C = vec4( 0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439 ); // 1.0 / 41.0\n    // First corner\n    vec2 i  = floor( v + dot( v, C.yy ) );\n    vec2 x0 = v - i + dot( i, C.xx );\n\n    // Other corners\n    vec2 i1;\n    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n    //i1.y = 1.0 - i1.x;\n    i1 = ( x0.x > x0.y ) ? vec2( 1.0, 0.0 ) : vec2( 0.0, 1.0 );\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\n    // x1 = x0 - i1 + 1.0 * C.xx ;\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod289( i ); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3( 0.0, i1.y, 1.0 ) )\n        + i.x + vec3( 0.0, i1.x, 1.0 ) );\n\n    vec3 m = max( 0.5 - vec3( dot( x0, x0 ), dot( x12.xy, x12.xy ), dot( x12.zw, x12.zw ) ), 0.0 );\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract( p * C.www ) - 1.0;\n    vec3 h = abs( x ) - 0.5;\n    vec3 ox = floor( x + 0.5 );\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0 * a0 + h * h );\n\n    // Compute final noise value at P\n    vec3 g;\n    g.x  = a0.x * x0.x + h.x * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot( m, g );\n\n}\n";
  var noise_simplex_3D_grad2 = "//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20150104 (JcBernack)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n//\n\nfloat simplex( vec3 v, out vec3 gradient ) {\n\n    const vec2  C = vec2( 1.0 / 6.0, 1.0 / 3.0 );\n    const vec4  D = vec4( 0.0, 0.5, 1.0, 2.0 );\n\n    // First corner\n    vec3 i  = floor( v + dot( v, C.yyy ) );\n    vec3 x0 = v - i + dot( i, C.xxx ) ;\n\n    // Other corners\n    vec3 g = step( x0.yzx, x0.xyz );\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n    // Permutations\n    i = mod289( i );\n    vec4 p = permute( permute( permute(\n                i.z + vec4( 0.0, i1.z, i2.z, 1.0 ) )\n            + i.y + vec4( 0.0, i1.y, i2.y, 1.0 ) )\n            + i.x + vec4( 0.0, i1.x, i2.x, 1.0 ) );\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3 ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ * ns.x + ns.yyyy;\n    vec4 y = y_ * ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs( x ) - abs( y );\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    vec4 s0 = floor( b0 ) * 2.0 + 1.0;\n    vec4 s1 = floor( b1 ) * 2.0 + 1.0;\n    vec4 sh = - step( h, vec4( 0.0 ) );\n\n    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww ;\n\n    vec3 p0 = vec3( a0.xy, h.x );\n    vec3 p1 = vec3( a0.zw, h.y );\n    vec3 p2 = vec3( a1.xy, h.z );\n    vec3 p3 = vec3( a1.zw, h.w );\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt( vec4( dot( p0, p0 ), dot( p1, p1 ), dot( p2, p2 ), dot( p3, p3 ) ) );\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max( 0.6 - vec4( dot( x0, x0 ), dot( x1, x1 ), dot( x2, x2 ), dot( x3, x3 ) ), 0.0 );\n    vec4 m2 = m * m;\n    vec4 m4 = m2 * m2;\n    vec4 pdotx = vec4( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 ), dot( p3, x3 ) );\n\n    // Determine noise gradient\n    vec4 temp = m2 * m * pdotx;\n    gradient = - 8.0 * ( temp.x * x0 + temp.y * x1 + temp.z * x2 + temp.w * x3 );\n    gradient += m4.x * p0 + m4.y * p1 + m4.z * p2 + m4.w * p3;\n    gradient *= 42.0;\n\n    return 42.0 * dot( m4, pdotx );\n\n}\n";
  var noise_simplex_3D2 = "//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n//\n\nfloat simplex( vec3 v ) {\n\n    const vec2 C = vec2( 1.0 / 6.0, 1.0 / 3.0 );\n    const vec4 D = vec4( 0.0, 0.5, 1.0, 2.0 );\n\n    // First corner\n    vec3 i  = floor( v + dot( v, C.yyy ) );\n    vec3 x0 = v - i + dot( i, C.xxx );\n\n    // Other corners\n    vec3 g = step( x0.yzx, x0.xyz );\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n    // Permutations\n    i = mod289( i );\n    vec4 p = permute( permute( permute(\n                i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n            + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n            + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3 ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor( p * ns.z * ns.z );  //  mod(p,7*7)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs( x ) - abs( y );\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    vec4 s0 = floor( b0 ) * 2.0 + 1.0;\n    vec4 s1 = floor( b1 ) * 2.0 + 1.0;\n    vec4 sh = - step( h, vec4( 0.0 ) );\n\n    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww ;\n\n    vec3 p0 = vec3( a0.xy, h.x );\n    vec3 p1 = vec3( a0.zw, h.y );\n    vec3 p2 = vec3( a1.xy, h.z );\n    vec3 p3 = vec3( a1.zw, h.w );\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt( vec4( dot( p0, p0 ), dot( p1, p1 ), dot( p2, p2 ), dot( p3, p3 ) ) );\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max( 0.6 - vec4( dot( x0, x0 ), dot( x1, x1 ), dot( x2, x2 ), dot( x3, x3 ) ), 0.0 );\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot( p0, x0 ), dot( p1, x1 ),\n                                dot( p2, x2 ), dot( p3, x3 ) ) );\n\n}\n";
  var noise_simplex_4D2 = "//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n//\n\nvec4 grad4( float j, vec4 ip ) {\n\n    const vec4 ones = vec4( 1.0, 1.0, 1.0, -1.0 );\n    vec4 p, s;\n\n    p.xyz = floor( fract( vec3( j ) * ip.xyz ) * 7.0 ) * ip.z - 1.0;\n    p.w = 1.5 - dot( abs( p.xyz ), ones.xyz );\n    s = vec4( lessThan( p, vec4( 0.0 ) ) );\n    p.xyz = p.xyz + ( s.xyz * 2.0 - 1.0 ) * s.www;\n\n    return p;\n\n}\n\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\n\nfloat simplex(vec4 v) {\n\n    const vec4 C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                        -0.447213595499958); // -1 + 4 * G4\n\n    // First corner\n    vec4 i  = floor( v + dot( v, vec4( F4 ) ) );\n    vec4 x0 = v - i + dot( i, C.xxxx );\n\n    // Other corners\n\n    // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n    vec4 i0;\n    vec3 isX = step( x0.yzw, x0.xxx );\n    vec3 isYZ = step( x0.zww, x0.yyz );\n    i0.x = isX.x + isX.y + isX.z;\n    i0.yzw = 1.0 - isX;\n    i0.y += isYZ.x + isYZ.y;\n    i0.zw += 1.0 - isYZ.xy;\n    i0.z += isYZ.z;\n    i0.w += 1.0 - isYZ.z;\n\n    vec4 i3 = clamp( i0, 0.0, 1.0 );\n    vec4 i2 = clamp( i0 - 1.0, 0.0, 1.0 );\n    vec4 i1 = clamp( i0 - 2.0, 0.0, 1.0 );\n\n    vec4 x1 = x0 - i1 + C.xxxx;\n    vec4 x2 = x0 - i2 + C.yyyy;\n    vec4 x3 = x0 - i3 + C.zzzz;\n    vec4 x4 = x0 + C.wwww;\n\n    // Permutations\n    i = mod289( i );\n    float j0 = permute( permute( permute( permute( i.w ) + i.z ) + i.y ) + i.x );\n    vec4 j1 = permute( permute( permute( permute (\n                i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n            + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n            + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n            + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n    // Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n    // 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n    vec4 ip = vec4( 1.0 / 294.0, 1.0 / 49.0, 1.0 / 7.0, 0.0 );\n\n    vec4 p0 = grad4(j0,   ip);\n    vec4 p1 = grad4(j1.x, ip);\n    vec4 p2 = grad4(j1.y, ip);\n    vec4 p3 = grad4(j1.z, ip);\n    vec4 p4 = grad4(j1.w, ip);\n\n    // Normalise gradients\n    vec4 norm = taylorInvSqrt( vec4( dot( p0, p0 ), dot( p1, p1 ), dot( p2, p2 ), dot( p3, p3 ) ) );\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    p4 *= taylorInvSqrt( dot( p4, p4 ) );\n\n    // Mix contributions from the five corners\n    vec3 m0 = max( 0.6 - vec3( dot( x0, x0 ), dot( x1, x1 ), dot( x2, x2 ) ), 0.0 );\n    vec2 m1 = max( 0.6 - vec2( dot( x3, x3 ), dot( x4, x4 ) ), 0.0 );\n    m0 = m0 * m0;\n    m1 = m1 * m1;\n    return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n                + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n}\n";
  var noise_simplex2 = "#include <noise_simplex_2D>\n#include <noise_simplex_3D>\n#include <noise_simplex_3D_grad>\n#include <noise_simplex_4D>\n";
  var perturbation_share2 = "#ifdef HAS_PERTURBATIONMAP\n  uniform sampler2D u_perturbationSampler;\n  uniform float u_perturbationUOffset;\n  uniform float u_perturbationVOffset;\n#endif\n";
  var perturbation_frag2 = "#ifdef HAS_PERTURBATIONMAP\n  vec2 getScreenUv(){\n    return gl_FragCoord.xy / u_resolution;\n  }\n\n  vec4 screenColor = texture2D(u_perturbationSampler, getScreenUv() + normalize(u_viewMat * vec4(normal, 1.)).xy * vec2(u_perturbationUOffset, u_perturbationVOffset));\n  gl_FragColor = mix(screenColor, gl_FragColor, gl_FragColor.a);\n\n#endif\n";
  var refraction_share2 = "#ifdef HAS_REFRACTIONMAP\n\n    uniform sampler2D u_refractionSampler;\n    uniform mat4 u_PTMMatrix;\n    uniform float u_refractionDepth;\n\n#endif\n";
  var refraction_frag2 = "#ifdef HAS_REFRACTIONMAP\n  vec4 refractionColor = vec4(0.);\n  vec3 refractDir = normalize(refract(-geometry.viewDir, geometry.normal, u_refractionRatio));\n  vec3 newPos = v_pos + refractDir * u_refractionDepth;\n  vec4 projectionPos = u_PTMMatrix * u_projMat * u_viewMat * vec4(newPos, 1.0);\n  vec2 projectionUv = projectionPos.xy / projectionPos.w;\n  refractionColor = texture2D(u_refractionSampler, projectionUv);\n  gl_FragColor = mix(refractionColor, gl_FragColor, gl_FragColor.a);\n\n#endif\n";
  var clipPlane_vert_define2 = "#ifdef O3_CLIPPLANE_NUM\n    uniform vec4 u_clipPlanes[O3_CLIPPLANE_NUM];\n    varying float v_clipDistances[O3_CLIPPLANE_NUM];\n#endif\n";
  var clipPlane_vert2 = "#ifdef O3_CLIPPLANE_NUM\n    for(int i = 0; i < O3_CLIPPLANE_NUM; i++){\n        v_clipDistances[i] = dot(vec4(v_pos,1.0), u_clipPlanes[i]);\n    }\n#endif\n";
  var clipPlane_frag_define2 = "#ifdef O3_CLIPPLANE_NUM\n    varying float v_clipDistances[O3_CLIPPLANE_NUM];\n#endif\n";
  var clipPlane_frag2 = "#ifdef O3_CLIPPLANE_NUM\n    for(int i = 0; i < O3_CLIPPLANE_NUM; i++){\n        if(v_clipDistances[i] < 0.0){\n            discard;\n        }\n    }\n#endif\n";
  var gamma_frag2 = "#ifdef GAMMA\n    float gamma = 2.2;\n    gl_FragColor.rgb = pow(gl_FragColor.rgb, vec3(1.0 / gamma));\n#endif\n";
  var pbr_common_frag_define = "#ifndef EPSILON\n#define EPSILON 1e-6\n#endif\n\n#ifndef RECIPROCAL_PI\n    #define RECIPROCAL_PI 0.31830988618\n#endif\n\n\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\n\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n";
  var pbr_util_frag_define = "vec4 SRGBtoLINEAR(vec4 srgbIn)\n{\n    #ifdef MANUAL_SRGB\n\n        #ifdef SRGB_FAST_APPROXIMATION\n\n            vec3 linOut = pow(srgbIn.xyz, vec3(2.2));\n        #else\n\n         vec3 bLess = step(vec3(0.04045), srgbIn.xyz);\n         vec3 linOut = mix(srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055), vec3(2.4)), bLess);\n\n        #endif\n\n    return vec4(linOut, srgbIn.w);;\n\n    #else\n\n    return srgbIn;\n\n    #endif\n}\n\nfloat pow2( const in float x ) {\n    return x * x;\n}\n\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n    return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\n\n// todo: enhance\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\n    if( decayExponent > 0.0 ) {\n\n        #if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\n        // based upon Frostbite 3 Moving to Physically-based Rendering\n        // page 32, equation 26: E[window1]\n        // https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n        // this is intended to be used on spot and point lights who are represented as luminous intensity\n        // but who must be converted to luminous irradiance for surface lighting calculation\n        float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n        float maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n        return distanceFalloff * maxDistanceCutoffFactor;\n\n        #else\n\n        return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\n        #endif\n\n    }\n\n    return 1.0;\n\n}\n\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\n\treturn RECIPROCAL_PI * diffuseColor;\n\n}\n\n// source: http://simonstechblog.blogspot.ca/2011/12/microfacet-brdf.html\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n    return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\n\n\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\n    return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n\n}\n\n// \nfloat getLuminance(vec3 color)\n{\n    return dot(color, vec3(0.2126, 0.7152, 0.0722));\n}\n";
  var pbr_envmap_light_frag_define = "#ifdef O3_HAS_ENVMAP_LIGHT\n\nstruct EnvMapLight {\n    vec3 diffuse;\n    vec3 specular;\n    float mipMapLevel;\n    float diffuseIntensity;\n    float specularIntensity;\n    mat3 transformMatrix;\n};\n\n\nuniform EnvMapLight u_envMapLight;\n\n#ifdef O3_USE_DIFFUSE_ENV\n    uniform samplerCube u_env_diffuseSampler;\n#endif\n\n#ifdef O3_USE_SPECULAR_ENV\n    uniform samplerCube u_env_specularSampler;\n#endif\n\n#endif\n";
  var pbr_base_frag_define = "#ifdef ALPHA_MASK\nuniform float u_alphaCutoff;\n#endif\n\nuniform vec4 u_baseColorFactor;\nuniform vec2 u_metallicRoughnessValue;\nuniform vec3 u_specularFactor;\nuniform float u_glossinessFactor;\n\nuniform float u_envMapIntensity;\nuniform float u_refractionRatio;\n\nuniform vec2 u_resolution;\n\n// todo: delete\nuniform float u_normalScale;\nuniform float u_occlusionStrength;\n\n";
  var pbr_texture_frag_define = "#ifdef HAS_BASECOLORMAP\n\nuniform sampler2D u_baseColorSampler;\n\n#endif\n\n#ifdef O3_HAS_NORMALMAP\n\nuniform sampler2D u_normalSampler;\n\n#endif\n\n#ifdef HAS_EMISSIVEMAP\n\nuniform sampler2D u_emissiveSampler;\nuniform vec3 u_emissiveFactor;\n\n#endif\n\n#ifdef HAS_METALMAP\n\nuniform sampler2D u_metallicSampler;\n\n#endif\n\n#ifdef HAS_ROUGHNESSMAP\n\nuniform sampler2D u_roughnessSampler;\n\n#endif\n\n#ifdef HAS_METALROUGHNESSMAP\n\nuniform sampler2D u_metallicRoughnessSampler;\n\n#endif\n\n\n#ifdef HAS_SPECULARGLOSSINESSMAP\n\nuniform sampler2D u_specularGlossinessSampler;\n\n#endif\n\n#ifdef HAS_OCCLUSIONMAP\n\nuniform sampler2D u_occlusionSampler;\n\n#endif\n\n#ifdef HAS_OPACITYMAP\n\nuniform sampler2D u_opacitySampler;\n\n#endif\n\n#ifdef HAS_REFLECTIONMAP\n\nuniform samplerCube u_reflectionSampler;\n\n#endif\n";
  var pbr_runtime_frag_define = "struct IncidentLight {\n    vec3 color;\n    vec3 direction;\n    bool visible;\n};\nstruct ReflectedLight {\n    vec3 directDiffuse;\n    vec3 directSpecular;\n    vec3 indirectDiffuse;\n    vec3 indirectSpecular;\n};\nstruct GeometricContext {\n    vec3 position;\n    vec3 normal;\n    vec3 viewDir;\n};\nstruct PhysicalMaterial {\n    vec3    diffuseColor;\n    float   specularRoughness;\n    vec3    specularColor;\n};\n";
  var pbr_normal_frag_define = "vec3 getNormal()\n{\n  #ifdef O3_HAS_NORMALMAP\n    #ifndef O3_HAS_TANGENT\n        #ifdef HAS_DERIVATIVES\n            vec3 pos_dx = dFdx(v_pos);\n            vec3 pos_dy = dFdy(v_pos);\n            vec3 tex_dx = dFdx(vec3(v_uv, 0.0));\n            vec3 tex_dy = dFdy(vec3(v_uv, 0.0));\n            vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n            #ifdef O3_HAS_NORMAL\n                vec3 ng = normalize(v_normal);\n            #else\n                vec3 ng = normalize( cross(pos_dx, pos_dy) );\n            #endif\n            t = normalize(t - ng * dot(ng, t));\n            vec3 b = normalize(cross(ng, t));\n            mat3 tbn = mat3(t, b, ng);\n        #else\n            #ifdef O3_HAS_NORMAL\n                vec3 ng = normalize(v_normal);\n            #else\n                vec3 ng = vec3(0.0, 0.0, 1.0);\n            #endif\n            mat3 tbn = mat3(vec3(0.0), vec3(0.0), ng);\n        #endif\n    #else\n        mat3 tbn = v_TBN;\n    #endif\n        vec3 n = texture2D(u_normalSampler, v_uv ).rgb;\n        n = normalize(tbn * ((2.0 * n - 1.0) * vec3(u_normalScale, u_normalScale, 1.0)));\n  #else\n    #ifdef O3_HAS_NORMAL\n        vec3 n = normalize(v_normal);\n    #elif defined(HAS_DERIVATIVES)\n        vec3 pos_dx = dFdx(v_pos);\n        vec3 pos_dy = dFdy(v_pos);\n        vec3 n = normalize( cross(pos_dx, pos_dy) );\n    #else\n        vec3 n= vec3(0.0,0.0,1.0);\n    #endif\n  #endif\n\n  n *= float( gl_FrontFacing ) * 2.0 - 1.0;\n\n  return n;\n}\n";
  var pbr_brdf_cook_torrance_frag_define = "vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\n\t// Original approximation by Christophe Schlick '94\n\t// float fresnel = pow( 1.0 - dotLH, 5.0 );\n\n\t// Optimized variant (presented by Epic at SIGGRAPH '13)\n\t// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n\n} // validated\n\n// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\n// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\n\tfloat a2 = pow2( alpha );\n\n\t// dotNL and dotNV are explicitly swapped. This is not a mistake.\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\n\treturn 0.5 / max( gv + gl, EPSILON );\n\n}\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is \"roughness squared\" in Disneys reparameterization\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\n\tfloat a2 = pow2( alpha );\n\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1\n\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n\n}\n\n// GGX Distribution, Schlick Fresnel, GGX-Smith Visibility\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\n\tfloat alpha = pow2( roughness ); // UE4's roughness\n\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\n\tfloat D = D_GGX( alpha, dotNH );\n\n\treturn F * ( G * D );\n\n} // validated\n";
  var pbr_direct_irradiance_frag_define = "void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n    float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\n    vec3 irradiance = dotNL * directLight.color;\n\n    #ifndef PHYSICALLY_CORRECT_LIGHTS\n\n        irradiance *= PI; // punctual light\n\n    #endif\n\n\n\n    reflectedLight.directSpecular += irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\n    reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n}\n\n\n\n#ifdef O3_DIRECT_LIGHT_COUNT\n\n    void getDirectionalDirectLightIrradiance( const in DirectLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n        directLight.color = directionalLight.lightColor;\n        directLight.direction = -directionalLight.direction;\n        directLight.visible = true;\n    }\n\n#endif\n\n#ifdef O3_POINT_LIGHT_COUNT\n\n\t// directLight is an out parameter as having it as a return value caused compiler errors on some devices\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\n\t\tfloat lightDistance = length( lVector );\n\n\t\tdirectLight.color = pointLight.lightColor;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\n\t}\n\n#endif\n\n#ifdef O3_SPOT_LIGHT_COUNT\n\n\t// directLight is an out parameter as having it as a return value caused compiler errors on some devices\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\n\t\tif ( angleCos > spotLight.coneCos ) {\n\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\n\t\t\tdirectLight.color = spotLight.lightColor;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\n\t\t} else {\n\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\n\t\t}\n\t}\n\n\n#endif\n";
  var pbr_ibl_specular_frag_define = "// ref: https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\n    float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\n    const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\n    const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\n    vec4 r = roughness * c0 + c1;\n\n    float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\n    vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\n    return specularColor * AB.x + AB.y;\n\n} // validated\n\n\n// taken from here: http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html\nfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\n    //float envMapWidth = pow( 2.0, maxMIPLevelScalar );\n    //float desiredMIPLevel = log2( envMapWidth * sqrt( 3.0 ) ) - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\n    float maxMIPLevelScalar = float( maxMIPLevel );\n    float desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\n    // clamp to allowable LOD ranges.\n    return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\n}\n\n#ifdef O3_HAS_ENVMAP_LIGHT\n\nvec3 getLightProbeIndirectRadiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\n    #if !defined(O3_USE_SPECULAR_ENV) && !defined(HAS_REFLECTIONMAP)\n\n        return u_envMapLight.specular * u_envMapLight.specularIntensity * u_envMapIntensity;\n\n    #else\n\n    #ifdef ENVMAPMODE_REFRACT\n\n        vec3 reflectVec = refract( -geometry.viewDir, geometry.normal, u_refractionRatio );\n\n    #else\n\n        vec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\n    #endif\n//        reflectVec = inverseTransformDirection( reflectVec, u_viewMat );\n\n        reflectVec =  u_envMapLight.transformMatrix * reflectVec;\n\n        float specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\n        #ifdef HAS_TEX_LOD\n            #ifdef HAS_REFLECTIONMAP\n                 vec4 envMapColor = textureCubeLodEXT( u_reflectionSampler, reflectVec, specularMIPLevel );\n            #else\n                vec4 envMapColor = textureCubeLodEXT( u_env_specularSampler, reflectVec, specularMIPLevel );\n            #endif\n\n        #else\n            #ifdef HAS_REFLECTIONMAP\n                 vec4 envMapColor = textureCube( u_reflectionSampler, reflectVec, specularMIPLevel );\n            #else\n                 vec4 envMapColor = textureCube( u_env_specularSampler, reflectVec, specularMIPLevel );\n            #endif\n        #endif\n\n        envMapColor.rgb = SRGBtoLINEAR( envMapColor * u_envMapLight.specularIntensity * u_envMapIntensity).rgb;\n\n        return envMapColor.rgb;\n\n    #endif\n\n}\n#endif\n\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n    float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n    float dotNL = dotNV;\n\n\treflectedLight.indirectSpecular += radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\n}\n";
  var pbr_ibl_diffuse_frag_define = "void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n    reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n}\n\n#ifdef O3_HAS_AMBIENT_LIGHT\n\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\n    vec3 irradiance = ambientLightColor;\n\n    #ifndef PHYSICALLY_CORRECT_LIGHTS\n\n        irradiance *= PI;\n\n    #endif\n\n    return irradiance;\n\n}\n\n#endif\n";
  var pbr_begin_frag = "    vec3 normal = getNormal();\n    vec4 diffuseColor = u_baseColorFactor;\n    vec3 totalEmissiveRadiance = vec3(0.0);\n    float metalnessFactor = u_metallicRoughnessValue.r;\n    float roughnessFactor = u_metallicRoughnessValue.g;\n    vec3 specularFactor = u_specularFactor;\n    float glossinessFactor = u_glossinessFactor;\n\n    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n    PhysicalMaterial material;\n    GeometricContext geometry;\n    IncidentLight directLight;\n\n    #ifdef HAS_BASECOLORMAP\n\n        vec4 baseMapColor = texture2D( u_baseColorSampler, v_uv );\n        baseMapColor = SRGBtoLINEAR( baseMapColor );\n        diffuseColor *= baseMapColor;\n\n    #endif\n\n    #ifdef O3_HAS_VERTEXCOLOR\n\n        diffuseColor.rgb *= v_color.rgb;\n\n        #ifdef O3_HAS_VERTEXALPHA\n\n            diffuseColor.a *= v_color.a;\n\n        #endif\n\n    #endif\n\n    #ifdef ALPHA_MASK\n\n        if( diffuseColor.a < u_alphaCutoff ) {\n            discard;\n        }\n\n    #endif\n\n\n    #if defined(ALPHA_BLEND) && defined(HAS_OPACITYMAP)\n\n        #ifdef GETOPACITYFROMRGB\n            diffuseColor.a *= getLuminance(texture2D( u_opacitySampler, v_uv ).rgb);\n        #else\n            diffuseColor.a *= texture2D( u_opacitySampler, v_uv ).a;\n        #endif\n\n    #endif\n\n    #ifdef UNLIT\n\n        gl_FragColor = vec4( diffuseColor.rgb, diffuseColor.a );\n\n    #else\n\n\n\n        #ifdef HAS_METALROUGHNESSMAP\n\n            vec4 metalRoughMapColor = texture2D( u_metallicRoughnessSampler, v_uv );\n            metalnessFactor *= metalRoughMapColor.b;\n            roughnessFactor *= metalRoughMapColor.g;\n\n        #else\n            #ifdef HAS_METALMAP\n\n            vec4 metalMapColor = texture2D( u_metallicSampler, v_uv );\n            metalnessFactor *= metalMapColor.b;\n\n            #endif\n\n            #ifdef HAS_ROUGHNESSMAP\n\n            vec4 roughMapColor = texture2D( u_roughnessSampler, v_uv );\n            roughnessFactor *= roughMapColor.g;\n\n            #endif\n        #endif\n\n        #ifdef HAS_SPECULARGLOSSINESSMAP\n\n            vec4 specularGlossinessColor = texture2D(u_specularGlossinessSampler, v_uv );\n            specularFactor *= specularGlossinessColor.rgb;\n            glossinessFactor *= specularGlossinessColor.a;\n\n        #endif\n\n\n        #ifdef IS_METALLIC_WORKFLOW\n            material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\n            material.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n//          material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n            material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT /* pow2( reflectivity )*/ ), diffuseColor.rgb, metalnessFactor );\n        #else\n            float specularStrength = max( max( specularFactor.r, specularFactor.g ), specularFactor.b );\n            material.diffuseColor = diffuseColor.rgb * ( 1.0 - specularStrength );\n            material.specularRoughness = clamp( 1.0 - glossinessFactor, 0.04, 1.0 );\n            material.specularColor = specularFactor;\n        #endif\n\n        geometry.position = v_pos;\n        geometry.normal = normal;\n        geometry.viewDir = normalize( u_cameraPos - v_pos );\n";
  var pbr_direct_irradiance_frag = "        #if defined( O3_DIRECT_LIGHT_COUNT ) && defined( RE_Direct )\n\n            DirectLight directionalLight;\n\n            for ( int i = 0; i < O3_DIRECT_LIGHT_COUNT; i ++ ) {\n\n                directionalLight = u_directLights[ i ];\n\n                getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\n                RE_Direct( directLight, geometry, material, reflectedLight );\n\n            }\n\n        #endif\n\n        #if defined( O3_POINT_LIGHT_COUNT ) && defined( RE_Direct )\n\n            PointLight pointLight;\n\n            for ( int i = 0; i < O3_POINT_LIGHT_COUNT; i ++ ) {\n\n                pointLight = u_pointLights[ i ];\n\n                getPointDirectLightIrradiance( pointLight, geometry, directLight );\n\n                RE_Direct( directLight, geometry, material, reflectedLight );\n\n            }\n\n        #endif\n\n        #if defined( O3_SPOT_LIGHT_COUNT ) && defined( RE_Direct )\n\n            SpotLight spotLight;\n\n            for ( int i = 0; i < O3_SPOT_LIGHT_COUNT; i ++ ) {\n\n                spotLight = u_spotLights[ i ];\n\n                getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\n                RE_Direct( directLight, geometry, material, reflectedLight );\n\n            }\n\n        #endif\n";
  var pbr_ibl_diffuse_frag = "#if defined(RE_IndirectDiffuse)\n\n    vec3 irradiance = vec3(0);\n\n    #if defined(O3_HAS_AMBIENT_LIGHT)\n        irradiance += getAmbientLightIrradiance(u_ambientLight.lightColor);\n    #endif\n\n    #if defined(O3_HAS_ENVMAP_LIGHT)\n\n        #ifdef O3_USE_DIFFUSE_ENV\n            vec3 lightMapIrradiance = textureCube(u_env_diffuseSampler, geometry.normal).rgb * u_envMapLight.diffuseIntensity;\n        #else\n            vec3 lightMapIrradiance = u_envMapLight.diffuse * u_envMapLight.diffuseIntensity;\n        #endif\n\n        #ifndef PHYSICALLY_CORRECT_LIGHTS\n            lightMapIrradiance *= PI;\n        #endif\n\n        irradiance += lightMapIrradiance;\n\n    #endif\n\n    RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n\n#endif\n\n\n";
  var pbr_ibl_specular_frag = "#if defined( RE_IndirectSpecular )\n\n    vec3 radiance = vec3( 0.0 );\n\n#endif\n\n\n\n#if defined( O3_HAS_ENVMAP_LIGHT ) && defined( RE_IndirectSpecular )\n\n    radiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), int(u_envMapLight.mipMapLevel) );\n\n#endif\n\n\n#if defined( RE_IndirectSpecular )\n\n    RE_IndirectSpecular( radiance, geometry, material, reflectedLight );\n\n#endif\n";
  var pbr_end_frag = "#ifdef HAS_OCCLUSIONMAP\n\n    float ambientOcclusion = (texture2D(u_occlusionSampler, v_uv).r - 1.0) * u_occlusionStrength + 1.0;\n    reflectedLight.indirectDiffuse *= ambientOcclusion;\n\n    #if defined(O3_USE_SPECULAR_ENV)\n\n        float dotNV = saturate(dot(geometry.normal, geometry.viewDir));\n        reflectedLight.indirectSpecular *= computeSpecularOcclusion(dotNV, ambientOcclusion, material.specularRoughness);\n\n    #endif\n\n#endif\n\n#ifdef HAS_EMISSIVEMAP\n\n    vec4 emissiveMapColor = texture2D(u_emissiveSampler, v_uv);\n    emissiveMapColor = SRGBtoLINEAR(emissiveMapColor);\n    totalEmissiveRadiance += u_emissiveFactor * emissiveMapColor.rgb;\n\n#endif\n\nvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\ngl_FragColor = vec4(outgoingLight, diffuseColor.a);\n\n#endif\n";
  var PBRShaderLib = {
    pbr_common_frag_define: pbr_common_frag_define,
    pbr_util_frag_define: pbr_util_frag_define,
    pbr_envmap_light_frag_define: pbr_envmap_light_frag_define,
    pbr_base_frag_define: pbr_base_frag_define,
    pbr_texture_frag_define: pbr_texture_frag_define,
    pbr_runtime_frag_define: pbr_runtime_frag_define,
    pbr_normal_frag_define: pbr_normal_frag_define,
    pbr_brdf_cook_torrance_frag_define: pbr_brdf_cook_torrance_frag_define,
    pbr_direct_irradiance_frag_define: pbr_direct_irradiance_frag_define,
    pbr_ibl_specular_frag_define: pbr_ibl_specular_frag_define,
    pbr_ibl_diffuse_frag_define: pbr_ibl_diffuse_frag_define,
    pbr_begin_frag: pbr_begin_frag,
    pbr_direct_irradiance_frag: pbr_direct_irradiance_frag,
    pbr_ibl_diffuse_frag: pbr_ibl_diffuse_frag,
    pbr_ibl_specular_frag: pbr_ibl_specular_frag,
    pbr_end_frag: pbr_end_frag
  };
  var oit_frag2 = "#if defined(ALPHA_BLEND) && defined(OIT_ENABLE)\n    if(gl_FragCoord.z > texture2D(u_depthSampler, gl_FragCoord.xy / u_resolution).r){\n        discard;\n    }\n    vec4 oitColor = gl_FragColor;\n\n    // Bavoil and Myers Method\n    gl_FragData[0]= vec4(oitColor.rgb * oitColor.a, oitColor.a);\n    gl_FragData[1]= vec4(1)/ 255.0; // \n\n\n    // Depth Weights Improve Occlusion\n//    float w = weight(gl_FragCoord.z, oitColor.a);\n//    gl_FragData[0] = vec4(oitColor.rgb * oitColor.a * w, oitColor.a);\n//    gl_FragData[1].r =oitColor.a * w;\n#endif\n";
  var oit_frag_define2 = "#if defined(ALPHA_BLEND) && defined(OIT_ENABLE)\n\n    uniform sampler2D u_depthSampler;\n\n    float weight(float z, float a) {\n        return a * clamp(3e3 * pow(1.0 - z, 3.0), 1e-2, 3e3);\n//          return pow(z,-5.0);\n    }\n#endif\n";

  var ShaderLib = _objectSpread2({
    common: common2,
    common_vert: common_vert2,
    common_frag: common_frag2,
    color_share: color_share2,
    normal_share: normal_share2,
    uv_share: uv_share2,
    worldpos_share: worldpos_share2,
    shadow_share: shadow_share2,
    fog_share: fog_share2,
    begin_normal_vert: begin_normal_vert2,
    begin_position_vert: begin_position_vert2,
    morph_target_vert: morph_target_vert2,
    position_vert: position_vert2,
    color_vert: color_vert2,
    normal_vert: normal_vert2,
    skinning_vert: skinning_vert2,
    uv_vert: uv_vert2,
    worldpos_vert: worldpos_vert2,
    shadow_vert: shadow_vert2,
    morph_vert: morph_vert2,
    fog_vert: fog_vert2,
    ambient_light_frag: ambient_light_frag2,
    direct_light_frag: direct_light_frag2,
    point_light_frag: point_light_frag2,
    spot_light_frag: spot_light_frag2,
    mobile_material_frag: mobile_material_frag2,
    fog_frag: fog_frag2,
    begin_mobile_frag: begin_mobile_frag2,
    begin_normal_frag: begin_normal_frag2,
    begin_viewdir_frag: begin_viewdir_frag2,
    mobile_blinnphong_frag: mobile_blinnphong_frag2,
    mobile_lambert_frag: mobile_lambert_frag2,
    noise_common: noise_common2,
    noise_cellular_2D: noise_cellular_2D2,
    noise_cellular_2x2: noise_cellular_2x22,
    noise_cellular_2x2x2: noise_cellular_2x2x22,
    noise_cellular_3D: noise_cellular_3D2,
    noise_cellular: noise_cellular2,
    noise_perlin_2D: noise_perlin_2D2,
    noise_perlin_3D: noise_perlin_3D2,
    noise_perlin_4D: noise_perlin_4D2,
    noise_perlin: noise_perlin2,
    noise_psrd_2D: noise_psrd_2D2,
    noise_simplex_2D: noise_simplex_2D2,
    noise_simplex_3D_grad: noise_simplex_3D_grad2,
    noise_simplex_3D: noise_simplex_3D2,
    noise_simplex_4D: noise_simplex_4D2,
    noise_simplex: noise_simplex2,
    perturbation_share: perturbation_share2,
    perturbation_frag: perturbation_frag2,
    refraction_share: refraction_share2,
    refraction_frag: refraction_frag2,
    clipPlane_vert_define: clipPlane_vert_define2,
    clipPlane_vert: clipPlane_vert2,
    clipPlane_frag_define: clipPlane_frag_define2,
    clipPlane_frag: clipPlane_frag2,
    gamma_frag: gamma_frag2,
    oit_frag: oit_frag2,
    oit_frag_define: oit_frag_define2
  }, PBRShaderLib);

  function _InjectShaderSlices(obj) {
    _extends(ShaderLib, obj);
  }

  var ShaderFactory = /*#__PURE__*/function () {
    function ShaderFactory() {
      _classCallCheck(this, ShaderFactory);
    }

    _createClass(ShaderFactory, null, [{
      key: "parseVersion",
      value: function parseVersion() {
        var version = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "100";
        return "#version ".concat(version, "\n");
      }
    }, {
      key: "parsePrecision",
      value: function parsePrecision(vertP, fragP, compileVert) {
        var downgrade = "mediump";
        return "\n        #ifdef GL_FRAGMENT_PRECISION_HIGH\n          precision ".concat(compileVert ? vertP : fragP, " float;\n          precision ").concat(compileVert ? vertP : fragP, " int;\n\n          #define O3_VERTEX_PRECISION ").concat(vertP, "\n          #define O3_FRAGMENT_PRECISION ").concat(fragP, "\n        #else\n          precision ").concat(downgrade, " float;\n          precision ").concat(downgrade, " int;\n\n          #define O3_VERTEX_PRECISION ").concat(downgrade, "\n          #define O3_FRAGMENT_PRECISION ").concat(downgrade, "\n        #endif\n      ");
      }
    }, {
      key: "parseShaderName",
      value: function parseShaderName(name) {
        return "#define O3_SHADER_NAME ".concat(name, "\n");
      }
    }, {
      key: "parseAttributeMacros",
      value: function parseAttributeMacros(macros) {
        return "#define O3_ATTRIBUTE_MACROS_START\n" + macros.map(function (m) {
          return "#define ".concat(m, "\n");
        }).join("") + "#define O3_ATTRIBUTE_MACROS_END\n";
      }
    }, {
      key: "parseCustomMacros",
      value: function parseCustomMacros(macros) {
        return "#define O3_CUSTOM_MACROS_START\n" + macros.map(function (m) {
          return "#define ".concat(m, "\n");
        }).join("") + "#define O3_CUSTOM_MACROS_END\n";
      }
    }, {
      key: "parseShader",
      value: function parseShader(src) {
        return ShaderFactory.parseIncludes(src);
      }
    }, {
      key: "parseIncludes",
      value: function parseIncludes(src) {
        var regex = /^[ \t]*#include +<([\w\d.]+)>/gm;

        function replace(match, slice) {
          var replace2 = ShaderLib[slice];

          if (replace2 === void 0) {
            Logger.error("Shader slice \"".concat(match.trim(), "\" not founded."));
            return "";
          }

          return ShaderFactory.parseIncludes(replace2);
        }

        return src.replace(regex, replace);
      }
    }, {
      key: "InjectShaderSlices",
      value: function InjectShaderSlices(slices) {
        _InjectShaderSlices(slices);
      }
    }, {
      key: "parseExtension",
      value: function parseExtension(extensions) {
        return "#define O3_EXTENSION_START\n" + extensions.map(function (e) {
          return "#extension ".concat(e, " : enable\n");
        }).join("") + "#define O3_EXTENSION_END\n";
      }
    }, {
      key: "convertTo300",
      value: function convertTo300(shader, isFrag) {
        var isGLSL300 = shader.includes("#version 300 es");
        if (isGLSL300) return shader;
        shader = shader.replace(/#version 100/, "#version 300 es");
        shader = shader.replace(/\battribute\b/g, "in");
        shader = shader.replace(/\bvarying\b/g, isFrag ? "in" : "out");
        shader = shader.replace(/\btexture(2D|Cube)\s*\(/g, "texture(");
        shader = shader.replace(/\btexture(2D|Cube)LodEXT\s*\(/g, "textureLod(");

        if (isFrag) {
          var isMRT = /\bgl_FragData\[.+?\]/g.test(shader);

          if (isMRT) {
            shader = shader.replace(/\bgl_FragColor\b/g, "gl_FragData[0]");
            var result = shader.match(/\bgl_FragData\[.+?\]/g);
            shader = this.replaceMRTShader(shader, result);
          } else {
            shader = shader.replace(/void\s+?main\s*\(/g, "out vec4 glFragColor;\nvoid main(");
            shader = shader.replace(/\bgl_FragColor\b/g, "glFragColor");
          }
        }

        return shader;
      }
    }, {
      key: "getMaxDrawBuffers",
      value: function getMaxDrawBuffers(shader) {
        var mrtIndexSet = new Set();
        var result = shader.match(/\bgl_FragData\[.+?\]/g) || [];

        for (var i = 0; i < result.length; i++) {
          var res = result[i].match(/\bgl_FragData\[(.+?)\]/);
          mrtIndexSet.add(res[1]);
        }

        return mrtIndexSet.size;
      }
    }, {
      key: "compatible",
      value: function compatible(fragmentShader) {
        var hasFragData = /\bgl_FragData\[.+?\]/g.test(fragmentShader);

        if (hasFragData) {
          fragmentShader = fragmentShader.replace(/\bgl_FragColor\b/g, "gl_FragData[0]");
        }

        return fragmentShader;
      }
    }, {
      key: "replaceMRTShader",
      value: function replaceMRTShader(shader, result) {
        var declaration = "";
        var mrtIndexSet = new Set();

        for (var i = 0; i < result.length; i++) {
          var res = result[i].match(/\bgl_FragData\[(.+?)\]/);
          mrtIndexSet.add(res[1]);
        }

        mrtIndexSet.forEach(function (index) {
          declaration += "layout(location=".concat(index, ") out vec4 fragOutColor").concat(index, ";\n");
        });
        declaration += "void main(";
        shader = shader.replace(/\bgl_FragData\[(.+?)\]/g, "fragOutColor$1");
        shader = shader.replace(/void\s+?main\s*\(/g, declaration);
        return shader;
      }
    }]);

    return ShaderFactory;
  }();

  var RenderTechnique = /*#__PURE__*/function (_AssetObject2) {
    _inherits(RenderTechnique, _AssetObject2);

    var _super38 = _createSuper(RenderTechnique);

    function RenderTechnique(name) {
      var _this42;

      _classCallCheck(this, RenderTechnique);

      _this42 = _super38.call(this, null);
      _this42.name = name;
      _this42.isValid = false;
      _this42._uniforms = RenderTechnique.commonUniforms;
      _this42._attributes = RenderTechnique.commonAttributes;
      _this42.states = null;
      _this42.vertexShader = "";
      _this42.fragmentShader = "";
      _this42.version = "100";
      _this42.autoConvert = true;
      _this42.vertexPrecision = "highp";
      _this42.fragmentPrecision = "mediump";
      _this42.customMacros = [];
      _this42.shaderExtension100 = ["GL_EXT_shader_texture_lod", "GL_OES_standard_derivatives", "GL_EXT_draw_buffers"];
      _this42.shaderExtension300 = [];
      _this42._needCompile = true;
      return _this42;
    }

    _createClass(RenderTechnique, [{
      key: "compile",
      value: function compile(camera, component, primitive, material) {
        this.parseFog(camera);

        if (this._needCompile) {
          var _material$preCompile, _material$postCompile;

          var rhi = camera.engine._hardwareRenderer;
          var isWebGL2 = rhi === null || rhi === void 0 ? void 0 : rhi.isWebGL2;
          (_material$preCompile = material.preCompile) === null || _material$preCompile === void 0 ? void 0 : _material$preCompile.call(material, this);
          var attribMacros = this.getAttributeDefines(camera, component, primitive, material);

          if (this._recreateHeader) {
            this.attributes = this.attributes;
            this.uniforms = this.uniforms;
          }

          if (!this._vsHeader || this._recreateHeader) this._vsHeader = ShaderFactory.parseVersion(this.version) + ShaderFactory.parseShaderName((this.name || "VOID").toUpperCase() + "_VERT") + "\n" + ShaderFactory.parsePrecision(this.vertexPrecision, this.fragmentPrecision, true) + "\n" + ShaderFactory.parseAttributeMacros(attribMacros) + "\n" + ShaderFactory.parseCustomMacros(this.customMacros) + "\n";
          if (!this._vsCode) this._vsCode = ShaderFactory.parseShader(this.vertexShader);
          this.vertexShader = this._vsHeader + this._vsCode;
          if (!this._fsHeader || this._recreateHeader) this._fsHeader = ShaderFactory.parseVersion(this.version) + ShaderFactory.parseShaderName((this.name || "VOID").toUpperCase() + "_FRAG") + "\n" + ShaderFactory.parseExtension(isWebGL2 ? this.shaderExtension300 : this.shaderExtension100) + ShaderFactory.parsePrecision(this.vertexPrecision, this.fragmentPrecision) + "\n" + ShaderFactory.parseAttributeMacros(attribMacros) + "\n" + ShaderFactory.parseCustomMacros(this.customMacros) + "\n";
          if (!this._fsCode) this._fsCode = ShaderFactory.parseShader(this.fragmentShader);
          this.fragmentShader = this._fsHeader + this._fsCode;

          if (this.autoConvert && isWebGL2 && this.version !== "300 es") {
            var maxDrawBuffers = rhi.capability.maxDrawBuffers;
            var shaderMaxDrawBuffers = ShaderFactory.getMaxDrawBuffers(this.fragmentShader);

            if (shaderMaxDrawBuffers <= maxDrawBuffers) {
              this.vertexShader = ShaderFactory.convertTo300(this.vertexShader);
              this.fragmentShader = ShaderFactory.convertTo300(this.fragmentShader, true);
            }
          } else if (!isWebGL2 && this.version !== "300es") {
            this.fragmentShader = ShaderFactory.compatible(this.fragmentShader);
          }

          this._needCompile = false;
          this._recreateHeader = false;
          (_material$postCompile = material.postCompile) === null || _material$postCompile === void 0 ? void 0 : _material$postCompile.call(material, this);
        }
      }
    }, {
      key: "getAttributeDefines",
      value: function getAttributeDefines(camera, component, primitive, material) {
        var rhi = camera.scene.engine._hardwareRenderer;
        var gl = rhi.gl;
        var _macros = [];
        if (!primitive) return _macros;
        var attribNames = Object.keys(primitive._vertexElementMap);
        if (attribNames.indexOf("TEXCOORD_0") > -1) _macros.push("O3_HAS_UV");
        if (attribNames.indexOf("NORMAL") > -1) _macros.push("O3_HAS_NORMAL");
        if (attribNames.indexOf("TANGENT") > -1) _macros.push("O3_HAS_TANGENT");

        if (attribNames.indexOf("JOINTS_0") > -1) {
          var _component$jointNodes2;

          _macros.push("O3_HAS_SKIN");

          if ((_component$jointNodes2 = component.jointNodes) !== null && _component$jointNodes2 !== void 0 && _component$jointNodes2.length) {
            var maxAttribUniformVec4 = rhi.renderStates.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
            var maxJoints = Math.floor((maxAttribUniformVec4 - 20) / 4);
            var joints = component.jointNodes.length;

            if (joints > maxJoints) {
              if (rhi.canIUseMoreJoints) {
                _macros.push("O3_USE_JOINT_TEXTURE");
              } else {
                Logger.error("component's joints count(".concat(joints, ") greater than device's MAX_VERTEX_UNIFORM_VECTORS number ").concat(maxAttribUniformVec4, ", suggest joint count less than ").concat(maxJoints, "."), component);
              }
            } else if (material.maxJointsNum > 0) {
              _macros.push("O3_JOINTS_NUM ".concat(material.maxJointsNum));
            }
          }
        }

        if (attribNames.indexOf("COLOR_0") > -1) {
          _macros.push("O3_HAS_VERTEXCOLOR");

          if (primitive._vertexElementMap["COLOR_0"].format === exports.VertexElementFormat.Vector4) _macros.push("O3_HAS_VERTEXALPHA");
        }

        var scene = camera.scene;

        if (scene.hasFogFeature) {
          _macros.push.apply(_macros, _toConsumableArray(scene.getFogMacro()));
        }

        return _macros;
      }
    }, {
      key: "parseFog",
      value: function parseFog(camera) {
        var scene = camera.scene;

        if (scene.hasFogFeature) {
          var fogMacro = scene.getFogMacro();

          if (this._fogMacro !== fogMacro) {
            this._needCompile = true;
            this._recreateHeader = true;
            this._fogMacro = fogMacro;
          }
        }
      }
    }, {
      key: "createMorphConfig",
      value: function createMorphConfig(primitive, targetNum) {
        var attributes = Object.keys(primitive._vertexElementMap);
        var morphConfig = {};

        for (var i = 0; i < targetNum; i++) {
          if (attributes.indexOf("POSITION_".concat(i)) > -1) morphConfig["a_position".concat(i)] = {
            name: "a_position".concat(i),
            semantic: "POSITION_".concat(i),
            type: exports.DataType.FLOAT_VEC3
          };
          if (attributes.indexOf("NORMAL_".concat(i)) > -1) morphConfig["a_normal".concat(i)] = {
            name: "a_normal".concat(i),
            semantic: "NORMAL_".concat(i),
            type: exports.DataType.FLOAT_VEC3
          };
          if (attributes.indexOf("TANGENT_".concat(i)) > -1) morphConfig["a_tangent".concat(i)] = {
            name: "a_tangent".concat(i),
            semantic: "TANGENT_".concat(i),
            type: exports.DataType.FLOAT_VEC3
          };
        }

        return morphConfig;
      }
    }, {
      key: "_finalize",
      value: function _finalize() {
        if (this._glTechnique) {
          this._glTechnique.finalize(true);

          this._glTechnique = null;
        }
      }
    }, {
      key: "attributes",
      get: function get() {
        return this._attributes;
      },
      set: function set(v) {
        this._attributes = _extends({}, RenderTechnique.commonAttributes, v);
      }
    }, {
      key: "uniforms",
      get: function get() {
        return this._uniforms;
      },
      set: function set(v) {
        this._uniforms = _extends({}, RenderTechnique.commonUniforms, v);
      }
    }]);

    return RenderTechnique;
  }(AssetObject);

  RenderTechnique.commonAttributes = {
    a_position: {
      name: "a_position",
      semantic: "POSITION",
      type: exports.DataType.FLOAT_VEC3
    },
    a_uv: {
      name: "a_uv",
      semantic: "TEXCOORD_0",
      type: exports.DataType.FLOAT_VEC2
    },
    a_normal: {
      name: "a_noraml",
      semantic: "NORMAL",
      type: exports.DataType.FLOAT_VEC3
    },
    a_tangent: {
      name: "a_tangent",
      semantic: "TANGENT",
      type: exports.DataType.FLOAT_VEC4
    },
    a_color: {
      name: "a_color",
      semantic: "COLOR_0",
      type: exports.DataType.FLOAT_VEC4
    },
    a_joint: {
      name: "a_joint",
      semantic: "JOINTS_0",
      type: exports.DataType.FLOAT_VEC4
    },
    a_weight: {
      name: "a_weight",
      semantic: "WEIGHTS_0",
      type: exports.DataType.FLOAT_VEC4
    }
  };
  RenderTechnique.commonUniforms = {
    u_localMat: {
      name: "u_localMat",
      semantic: exports.UniformSemantic.LOCAL,
      type: exports.DataType.FLOAT_MAT4
    },
    u_modelMat: {
      name: "u_modelMat",
      semantic: exports.UniformSemantic.MODEL,
      type: exports.DataType.FLOAT_MAT4
    },
    u_viewMat: {
      name: "u_viewMat",
      semantic: exports.UniformSemantic.VIEW,
      type: exports.DataType.FLOAT_MAT4
    },
    u_projMat: {
      name: "u_projMat",
      semantic: exports.UniformSemantic.PROJECTION,
      type: exports.DataType.FLOAT_MAT4
    },
    u_MVMat: {
      name: "u_MVMat",
      semantic: exports.UniformSemantic.MODELVIEW,
      type: exports.DataType.FLOAT_MAT4
    },
    u_MVPMat: {
      name: "u_MVPMat",
      semantic: exports.UniformSemantic.MODELVIEWPROJECTION,
      type: exports.DataType.FLOAT_MAT4
    },
    u_normalMat: {
      name: "u_normalMat",
      semantic: exports.UniformSemantic.MODELINVERSETRANSPOSE,
      type: exports.DataType.FLOAT_MAT3
    },
    u_cameraPos: {
      name: "u_cameraPos",
      type: exports.DataType.FLOAT_VEC3,
      semantic: exports.UniformSemantic.EYEPOS
    },
    u_time: {
      name: "u_time",
      type: exports.DataType.FLOAT,
      semantic: exports.UniformSemantic.TIME
    },
    u_jointMatrix: {
      name: "u_jointMatrix",
      semantic: exports.UniformSemantic.JOINTMATRIX,
      type: exports.DataType.FLOAT_MAT4_ARRAY
    },
    u_jointSampler: {
      name: "u_jointSampler",
      semantic: exports.UniformSemantic.JOINTTEXTURE,
      type: exports.DataType.SAMPLER_2D
    },
    u_jointCount: {
      name: "u_jointCount",
      semantic: exports.UniformSemantic.JOINTCOUNT,
      type: exports.DataType.FLOAT
    },
    u_fogColor: {
      name: "u_fogColor",
      type: exports.DataType.FLOAT_VEC3
    },
    u_fogDensity: {
      name: "u_fogDensity",
      type: exports.DataType.FLOAT
    },
    u_fogNear: {
      name: "u_fogNear",
      type: exports.DataType.FLOAT
    },
    u_fogFar: {
      name: "u_fogFar",
      type: exports.DataType.FLOAT
    }
  };


  (function (TextureCubeFace2) {
    TextureCubeFace2[TextureCubeFace2["PositiveX"] = 0] = "PositiveX";
    TextureCubeFace2[TextureCubeFace2["NegativeX"] = 1] = "NegativeX";
    TextureCubeFace2[TextureCubeFace2["PositiveY"] = 2] = "PositiveY";
    TextureCubeFace2[TextureCubeFace2["NegativeY"] = 3] = "NegativeY";
    TextureCubeFace2[TextureCubeFace2["PositiveZ"] = 4] = "PositiveZ";
    TextureCubeFace2[TextureCubeFace2["NegativeZ"] = 5] = "NegativeZ";
  })(exports.TextureCubeFace || (exports.TextureCubeFace = {}));

  var TextureCubeMap = /*#__PURE__*/function (_Texture2) {
    _inherits(TextureCubeMap, _Texture2);

    var _super39 = _createSuper(TextureCubeMap);

    function TextureCubeMap(engine, size) {
      var _this43;

      var format = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : exports.TextureFormat.R8G8B8A8;
      var mipmap = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

      _classCallCheck(this, TextureCubeMap);

      _this43 = _super39.call(this, engine);
      _this43._compressedFaceFilled = [0, 0, 0, 0, 0, 0];
      var rhi = engine._hardwareRenderer;
      var gl = rhi.gl;
      var isWebGL2 = rhi.isWebGL2;

      if (!Texture._supportTextureFormat(format, rhi)) {
        throw new Error("Texture format is not supported:".concat(exports.TextureFormat[format]));
      }

      if (mipmap && !isWebGL2 && !Texture._isPowerOf2(size)) {
        Logger.warn("non-power-2 texture is not supported for mipmap in WebGL1,and has automatically downgraded to non-mipmap");
        mipmap = false;
      }

      var formatDetail = Texture._getFormatDetail(format, gl, isWebGL2);

      _this43._glTexture = gl.createTexture();
      _this43._formatDetail = formatDetail;
      _this43._rhi = rhi;
      _this43._target = gl.TEXTURE_CUBE_MAP;
      _this43._mipmap = mipmap;
      _this43._width = size;
      _this43._height = size;
      _this43._format = format;
      _this43._mipmapCount = _this43._getMipmapCount();
      formatDetail.isCompressed && !isWebGL2 || _this43._initMipmap(true);
      _this43.filterMode = exports.TextureFilterMode.Bilinear;
      _this43.wrapModeU = _this43.wrapModeV = exports.TextureWrapMode.Clamp;
      return _this43;
    }

    _createClass(TextureCubeMap, [{
      key: "setPixelBuffer",
      value: function setPixelBuffer(face, colorBuffer) {
        var mipLevel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var x = arguments.length > 3 ? arguments[3] : undefined;
        var y = arguments.length > 4 ? arguments[4] : undefined;
        var width = arguments.length > 5 ? arguments[5] : undefined;
        var height = arguments.length > 6 ? arguments[6] : undefined;
        var gl = this._rhi.gl;
        var isWebGL2 = this._rhi.isWebGL2;
        var _this$_formatDetail5 = this._formatDetail,
            internalFormat = _this$_formatDetail5.internalFormat,
            baseFormat = _this$_formatDetail5.baseFormat,
            dataType = _this$_formatDetail5.dataType,
            isCompressed = _this$_formatDetail5.isCompressed;
        var mipSize = Math.max(1, this._width >> mipLevel);
        x = x || 0;
        y = y || 0;
        width = width || mipSize - x;
        height = height || mipSize - y;

        this._bind();

        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);

        if (isCompressed) {
          var mipBit = 1 << mipLevel;

          if (isWebGL2 || this._compressedFaceFilled[face] & mipBit) {
            gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, x, y, width, height, internalFormat, colorBuffer);
          } else {
            gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, internalFormat, width, height, 0, colorBuffer);
            this._compressedFaceFilled[face] |= mipBit;
          }
        } else {
          gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, x, y, width, height, baseFormat, dataType, colorBuffer);
        }

        this._unbind();
      }
    }, {
      key: "setImageSource",
      value: function setImageSource(face, imageSource) {
        var mipLevel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var flipY = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
        var premultiplyAlpha = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
        var x = arguments.length > 5 ? arguments[5] : undefined;
        var y = arguments.length > 6 ? arguments[6] : undefined;
        var gl = this._rhi.gl;
        var _this$_formatDetail6 = this._formatDetail,
            baseFormat = _this$_formatDetail6.baseFormat,
            dataType = _this$_formatDetail6.dataType;

        this._bind();

        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, +flipY);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, +premultiplyAlpha);
        gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, x || 0, y || 0, baseFormat, dataType, imageSource);

        this._unbind();
      }
    }, {
      key: "getPixelBuffer",
      value: function getPixelBuffer(face, x, y, width, height, out) {
        if (this._formatDetail.isCompressed) {
          throw new Error("Unable to read compressed texture");
        }

        _get(_getPrototypeOf(TextureCubeMap.prototype), "_getPixelBuffer", this).call(this, face, x, y, width, height, out);
      }
    }, {
      key: "format",
      get: function get() {
        return this._format;
      }
    }]);

    return TextureCubeMap;
  }(Texture);

  var RenderDepthTexture = /*#__PURE__*/function (_Texture3) {
    _inherits(RenderDepthTexture, _Texture3);

    var _super40 = _createSuper(RenderDepthTexture);

    function RenderDepthTexture(engine, width, height) {
      var _this44;

      var format = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : exports.RenderBufferDepthFormat.Depth;
      var mipmap = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
      var isCube = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;

      _classCallCheck(this, RenderDepthTexture);

      _this44 = _super40.call(this, engine);
      _this44._isCube = false;
      _this44._autoMipmap = false;
      var rhi = engine._hardwareRenderer;
      var gl = rhi.gl;
      var isWebGL2 = rhi.isWebGL2;

      if (!Texture._supportRenderBufferDepthFormat(format, rhi, true)) {
        throw new Error("RenderBufferDepthFormat is not supported:".concat(exports.RenderBufferDepthFormat[format]));
      }

      if (isCube && width !== height) {
        throw new Error("The cube texture must have the same width and height");
      }

      if (mipmap && !isWebGL2 && (!Texture._isPowerOf2(width) || !Texture._isPowerOf2(height))) {
        Logger.warn("non-power-2 texture is not supported for mipmap in WebGL1,and has automatically downgraded to non-mipmap");
        mipmap = false;
      }

      _this44._glTexture = gl.createTexture();
      _this44._formatDetail = Texture._getRenderBufferDepthFormatDetail(format, gl, isWebGL2);
      _this44._isCube = isCube;
      _this44._rhi = rhi;
      _this44._target = isCube ? gl.TEXTURE_CUBE_MAP : gl.TEXTURE_2D;
      _this44._mipmap = mipmap;
      _this44._width = width;
      _this44._height = height;
      _this44._format = format;
      _this44._mipmapCount = _this44._getMipmapCount();

      _this44._initMipmap(isCube);

      _this44.filterMode = exports.TextureFilterMode.Bilinear;
      _this44.wrapModeU = _this44.wrapModeV = exports.TextureWrapMode.Clamp;
      return _this44;
    }

    _createClass(RenderDepthTexture, [{
      key: "format",
      get: function get() {
        return this._format;
      }
    }, {
      key: "autoGenerateMipmaps",
      get: function get() {
        return this._autoMipmap;
      },
      set: function set(value) {
        this._autoMipmap = value;
      }
    }]);

    return RenderDepthTexture;
  }(Texture);

  var RenderTarget = /*#__PURE__*/function (_EngineObject5) {
    _inherits(RenderTarget, _EngineObject5);

    var _super41 = _createSuper(RenderTarget);

    function RenderTarget(engine, width, height, renderTexture) {
      var _this45;

      var depth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : exports.RenderBufferDepthFormat.Depth;
      var antiAliasing = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;

      _classCallCheck(this, RenderTarget);

      _this45 = _super41.call(this, engine);
      _this45._MSAAColorRenderBuffers = [];
      var rhi = engine._hardwareRenderer;
      var gl = rhi.gl;

      if (!(depth instanceof RenderDepthTexture) && !Texture._supportRenderBufferDepthFormat(depth, rhi, false)) {
        throw new Error("RenderBufferDepthFormat is not supported:".concat(exports.RenderBufferDepthFormat[depth]));
      }

      if ((renderTexture === null || renderTexture === void 0 ? void 0 : renderTexture.length) > 1 && !rhi.canIUse(exports.GLCapabilityType.drawBuffers)) {
        throw new Error("MRT is not supported");
      }

      if (renderTexture) {
        _this45._colorTextures = renderTexture instanceof Array ? renderTexture.slice() : [renderTexture];
      } else {
        _this45._colorTextures = [];
      }

      if (_this45._colorTextures.some(function (v) {
        return v.width !== width || v.height !== height;
      })) {
        throw new Error("RenderColorTexture's size must as same as RenderTarget");
      }

      if (depth instanceof RenderDepthTexture && (depth.width !== width || depth.height !== height)) {
        throw new Error("RenderDepthTexture's size must as same as RenderTarget");
      }

      if (_this45._colorTextures.length > 1 && _this45._colorTextures.some(function (v) {
        return v._isCube;
      })) {
        throw new Error("MRT+Cube+[,MSAA] is not supported");
      }

      var maxAntiAliasing = rhi.capability.maxAntiAliasing;

      if (antiAliasing > maxAntiAliasing) {
        Logger.warn("MSAA antiAliasing exceeds the limit and is automatically downgraded to:".concat(maxAntiAliasing));
        antiAliasing = maxAntiAliasing;
      }

      _this45._rhi = rhi;
      _this45._width = width;
      _this45._height = height;
      _this45._frameBuffer = gl.createFramebuffer();
      _this45._antiAliasing = antiAliasing;

      if (depth instanceof RenderDepthTexture) {
        _this45._depthTexture = depth;
      }

      _this45._bindMainFBO(depth);

      if (antiAliasing > 1) {
        _this45._MSAAFrameBuffer = gl.createFramebuffer();

        _this45._bindMSAAFBO(depth);
      }

      return _this45;
    }

    _createClass(RenderTarget, [{
      key: "getColorTexture",
      value: function getColorTexture() {
        var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        return this._colorTextures[index];
      }
    }, {
      key: "destroy",
      value: function destroy() {
        var gl = this._rhi.gl;
        gl.deleteFramebuffer(this._frameBuffer);
        this._depthRenderBuffer && gl.deleteRenderbuffer(this._depthRenderBuffer);
        this._MSAAFrameBuffer && gl.deleteFramebuffer(this._MSAAFrameBuffer);
        this._MSAADepthRenderBuffer && gl.deleteRenderbuffer(this._MSAADepthRenderBuffer);

        for (var i = 0; i < this._colorTextures.length; i++) {
          this._colorTextures[i].destroy();
        }

        for (var _i14 = 0; _i14 < this._MSAAColorRenderBuffers.length; _i14++) {
          gl.deleteRenderbuffer(this._MSAAColorRenderBuffers[_i14]);
        }

        this._depthTexture && this._depthTexture.destroy();
        this._frameBuffer = null;
        this._colorTextures.length = 0;
        this._depthTexture = null;
        this._depthRenderBuffer = null;
        this._MSAAFrameBuffer = null;
        this._MSAAColorRenderBuffers.length = 0;
        this._MSAADepthRenderBuffer = null;
      }
    }, {
      key: "_activeRenderTarget",
      value: function _activeRenderTarget() {
        var gl = this._rhi.gl;

        if (this._MSAAFrameBuffer) {
          gl.bindFramebuffer(gl.FRAMEBUFFER, this._MSAAFrameBuffer);
        } else {
          gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);
        }
      }
    }, {
      key: "_setRenderTargetFace",
      value: function _setRenderTargetFace(faceIndex) {
        var gl = this._rhi.gl;
        var colorTexture = this._colorTextures[0];
        var depthTexture = this._depthTexture;
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);

        if (colorTexture !== null && colorTexture !== void 0 && colorTexture._isCube) {
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, colorTexture._glTexture, 0);
        }

        if (depthTexture !== null && depthTexture !== void 0 && depthTexture._isCube) {
          gl.framebufferTexture2D(gl.FRAMEBUFFER, depthTexture._formatDetail.attachment, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, depthTexture._glTexture, 0);
        }

        this._activeRenderTarget();
      }
    }, {
      key: "_blitRenderTarget",
      value: function _blitRenderTarget() {
        var gl = this._rhi.gl;
        var mask = gl.COLOR_BUFFER_BIT | (this._depthTexture ? gl.DEPTH_BUFFER_BIT : 0);
        var colorTextureLength = this._colorTextures.length;
        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this._MSAAFrameBuffer);
        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this._frameBuffer);

        for (var textureIndex = 0; textureIndex < colorTextureLength; textureIndex++) {
          var attachment = gl.COLOR_ATTACHMENT0 + textureIndex;
          this._blitDrawBuffers[textureIndex] = attachment;
          gl.readBuffer(attachment);
          gl.drawBuffers(this._blitDrawBuffers);
          gl.blitFramebuffer(0, 0, this._width, this._height, 0, 0, this._width, this._height, mask, gl.NEAREST);
          this._blitDrawBuffers[textureIndex] = gl.NONE;
        }

        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      }
    }, {
      key: "_bindMainFBO",
      value: function _bindMainFBO(renderDepth) {
        var gl = this._rhi.gl;
        var isWebGL2 = this._rhi.isWebGL2;
        var colorTextureLength = this._colorTextures.length;
        var drawBuffers = new Array(colorTextureLength);
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);

        for (var i = 0; i < colorTextureLength; i++) {
          var colorTexture = this._colorTextures[i];
          var attachment = gl.COLOR_ATTACHMENT0 + i;
          drawBuffers[i] = attachment;

          if (!colorTexture._isCube) {
            gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, colorTexture._glTexture, 0);
          }
        }

        if (colorTextureLength > 1) {
          gl.drawBuffers(drawBuffers);
        }

        this._oriDrawBuffers = drawBuffers;

        if (renderDepth !== null) {
          if (renderDepth instanceof RenderDepthTexture) {
            if (!renderDepth._isCube) {
              gl.framebufferTexture2D(gl.FRAMEBUFFER, renderDepth._formatDetail.attachment, gl.TEXTURE_2D, renderDepth._glTexture, 0);
            }
          } else if (this._antiAliasing <= 1) {
            var _Texture$_getRenderBu = Texture._getRenderBufferDepthFormatDetail(renderDepth, gl, isWebGL2),
                internalFormat = _Texture$_getRenderBu.internalFormat,
                _attachment = _Texture$_getRenderBu.attachment;

            var depthRenderBuffer = gl.createRenderbuffer();
            this._depthRenderBuffer = depthRenderBuffer;
            gl.bindRenderbuffer(gl.RENDERBUFFER, depthRenderBuffer);
            gl.renderbufferStorage(gl.RENDERBUFFER, internalFormat, this._width, this._height);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, _attachment, gl.RENDERBUFFER, depthRenderBuffer);
          }
        }

        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
      }
    }, {
      key: "_bindMSAAFBO",
      value: function _bindMSAAFBO(renderDepth) {
        var gl = this._rhi.gl;
        var isWebGL2 = this._rhi.isWebGL2;
        var MSAADepthRenderBuffer = gl.createRenderbuffer();
        var colorTextureLength = this._colorTextures.length;
        this._blitDrawBuffers = new Array(colorTextureLength);
        this._MSAADepthRenderBuffer = MSAADepthRenderBuffer;
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._MSAAFrameBuffer);

        for (var i = 0; i < colorTextureLength; i++) {
          var MSAAColorRenderBuffer = gl.createRenderbuffer();
          this._MSAAColorRenderBuffers[i] = MSAAColorRenderBuffer;
          this._blitDrawBuffers[i] = gl.NONE;
          gl.bindRenderbuffer(gl.RENDERBUFFER, MSAAColorRenderBuffer);
          gl.renderbufferStorageMultisample(gl.RENDERBUFFER, this._antiAliasing, this._colorTextures[i]._formatDetail.internalFormat, this._width, this._height);
          gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, MSAAColorRenderBuffer);
        }

        gl.drawBuffers(this._oriDrawBuffers);

        if (renderDepth !== null) {
          var _ref2 = renderDepth instanceof RenderDepthTexture ? renderDepth._formatDetail : Texture._getRenderBufferDepthFormatDetail(renderDepth, gl, isWebGL2),
              internalFormat = _ref2.internalFormat,
              attachment = _ref2.attachment;

          gl.bindRenderbuffer(gl.RENDERBUFFER, MSAADepthRenderBuffer);
          gl.renderbufferStorageMultisample(gl.RENDERBUFFER, this._antiAliasing, internalFormat, this._width, this._height);
          gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, MSAADepthRenderBuffer);
        }

        this._checkFrameBuffer();

        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
      }
    }, {
      key: "_checkFrameBuffer",
      value: function _checkFrameBuffer() {
        var gl = this._rhi.gl;
        var isWebGL2 = this._rhi.isWebGL2;
        var e = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

        switch (e) {
          case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
            throw new Error("The attachment types are mismatched or not all framebuffer attachment points are framebuffer attachment complete");

          case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
            throw new Error("There is no attachment");

          case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
            throw new Error(" Height and width of the attachment are not the same.");

          case gl.FRAMEBUFFER_UNSUPPORTED:
            throw new Error("The format of the attachment is not supported or if depth and stencil attachments are not the same renderbuffer");
        }

        if (isWebGL2 && e === gl.FRAMEBUFFER_INCOMPLETE_MULTISAMPLE) {
          throw new Error("The values of gl.RENDERBUFFER_SAMPLES are different among attached renderbuffers, or are non-zero if the attached images are a mix of renderbuffers and textures.");
        }
      }
    }, {
      key: "width",
      get: function get() {
        return this._width;
      }
    }, {
      key: "height",
      get: function get() {
        return this._height;
      }
    }, {
      key: "colorTextureCount",
      get: function get() {
        return this._colorTextures.length;
      }
    }, {
      key: "depthTexture",
      get: function get() {
        return this._depthTexture;
      }
    }, {
      key: "antiAliasing",
      get: function get() {
        return this._antiAliasing;
      }
    }]);

    return RenderTarget;
  }(EngineObject);

  var RenderColorTexture = /*#__PURE__*/function (_Texture4) {
    _inherits(RenderColorTexture, _Texture4);

    var _super42 = _createSuper(RenderColorTexture);

    function RenderColorTexture(engine, width, height) {
      var _this46;

      var format = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : exports.RenderBufferColorFormat.R8G8B8A8;
      var mipmap = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
      var isCube = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;

      _classCallCheck(this, RenderColorTexture);

      _this46 = _super42.call(this, engine);
      _this46._isCube = false;
      _this46._autoMipmap = false;
      var rhi = engine._hardwareRenderer;
      var gl = rhi.gl;
      var isWebGL2 = rhi.isWebGL2;

      if (!Texture._supportRenderBufferColorFormat(format, rhi)) {
        throw new Error("RenderBufferColorFormat is not supported:".concat(exports.RenderBufferColorFormat[format]));
      }

      if (isCube && width !== height) {
        throw new Error("The cube texture must have the same width and height");
      }

      if (mipmap && !isWebGL2 && (!Texture._isPowerOf2(width) || !Texture._isPowerOf2(height))) {
        Logger.warn("non-power-2 texture is not supported for mipmap in WebGL1,and has automatically downgraded to non-mipmap");
        mipmap = false;
      }

      _this46._glTexture = gl.createTexture();
      _this46._formatDetail = Texture._getRenderBufferColorFormatDetail(format, gl, isWebGL2);
      _this46._isCube = isCube;
      _this46._rhi = rhi;
      _this46._target = isCube ? gl.TEXTURE_CUBE_MAP : gl.TEXTURE_2D;
      _this46._mipmap = mipmap;
      _this46._width = width;
      _this46._height = height;
      _this46._format = format;
      _this46._mipmapCount = _this46._getMipmapCount();

      _this46._initMipmap(isCube);

      _this46.filterMode = exports.TextureFilterMode.Bilinear;
      _this46.wrapModeU = _this46.wrapModeV = exports.TextureWrapMode.Clamp;
      return _this46;
    }

    _createClass(RenderColorTexture, [{
      key: "getPixelBuffer",
      value: function getPixelBuffer(face, x, y, width, height, out) {
        _get(_getPrototypeOf(RenderColorTexture.prototype), "_getPixelBuffer", this).call(this, face, x, y, width, height, out);
      }
    }, {
      key: "format",
      get: function get() {
        return this._format;
      }
    }, {
      key: "autoGenerateMipmaps",
      get: function get() {
        return this._autoMipmap;
      },
      set: function set(value) {
        this._autoMipmap = value;
      }
    }]);

    return RenderColorTexture;
  }(Texture);

  var SpriteRenderer = /*#__PURE__*/function (_RenderableComponent3) {
    _inherits(SpriteRenderer, _RenderableComponent3);

    var _super43 = _createSuper(SpriteRenderer);

    function SpriteRenderer(entity) {
      var _this47;

      _classCallCheck(this, SpriteRenderer);

      _this47 = _super43.call(this, entity);
      _this47._worldSize = [];
      _this47._rotationAngle = 0;
      _this47.renderMode = "2D";
      _this47.tintColor = new Vector4(1, 1, 1, 1);
      _this47._worldSizeFactor = 100;

      _this47.setTexture(void 0);

      _this47.setRect(void 0);

      _this47.setAnchor(void 0);

      _this47.setUvRect();

      _this47.setWorldSize();

      _this47._positionQuad = {
        leftTop: new Vector3(),
        leftBottom: new Vector3(),
        rightTop: new Vector3(),
        rightBottom: new Vector3()
      };
      return _this47;
    }

    _createClass(SpriteRenderer, [{
      key: "setTexture",
      value: function setTexture(texture) {
        if (texture && texture.asset) {
          texture = texture.asset;
        }

        this._texture = texture;
      }
    }, {
      key: "setRect",
      value: function setRect(rect) {
        var _this$_texture$width, _this$_texture, _this$_texture$height, _this$_texture2;

        var rectObject;

        try {
          if (rect) {
            rectObject = JSON.parse(rect);
          }
        } catch (error) {
          Logger.warn("Rect is not valid JSON format");
        }

        this._rect = rect || {
          x: 0,
          y: 0,
          width: (_this$_texture$width = (_this$_texture = this._texture) === null || _this$_texture === void 0 ? void 0 : _this$_texture.width) !== null && _this$_texture$width !== void 0 ? _this$_texture$width : 0,
          height: (_this$_texture$height = (_this$_texture2 = this._texture) === null || _this$_texture2 === void 0 ? void 0 : _this$_texture2.height) !== null && _this$_texture$height !== void 0 ? _this$_texture$height : 0
        };
      }
    }, {
      key: "setAnchor",
      value: function setAnchor(anchor) {
        this._anchor = anchor || [0.5, 0.5];
      }
    }, {
      key: "setWorldSize",
      value: function setWorldSize() {
        var _worldSizeFactor = this._worldSizeFactor;
        this._worldSize = [this._rect.width / _worldSizeFactor, this._rect.height / _worldSizeFactor];
      }
    }, {
      key: "setUvRect",
      value: function setUvRect() {
        var w, h;

        if (this._texture) {
          w = this._texture.width;
          h = this._texture.height;
        } else {
          w = this._rect.width;
          h = this._rect.height;
        }

        this._uvRect = {
          u: this._rect.x / w,
          v: this._rect.y / h,
          width: this._rect.width / w,
          height: this._rect.height / h
        };
      }
    }, {
      key: "render",
      value: function render(camera) {
        this._updatePositionQuad(camera);

        this._transformByMatrix();

        camera._renderPipeline.pushSprite(this, this._positionQuad, this._uvRect, this.tintColor, this.texture, this.renderMode, camera);
      }
    }, {
      key: "_transformByMatrix",
      value: function _transformByMatrix() {
        if (!this.transformMatrix) return;
        var matrix = this.transformMatrix;
        var temp = this._positionQuad.leftTop;
        var leftTop = SpriteRenderer._tempVec40;
        leftTop.setValue(temp.x, temp.y, temp.z, 1);
        temp = this._positionQuad.leftBottom;
        var leftBottom = SpriteRenderer._tempVec41;
        leftBottom.setValue(temp.x, temp.y, temp.z, 1);
        temp = this._positionQuad.rightTop;
        var rightTop = SpriteRenderer._tempVec42;
        rightTop.setValue(temp.x, temp.y, temp.z, 1);
        temp = this._positionQuad.rightBottom;
        var rightBottom = SpriteRenderer._tempVec43;
        rightBottom.setValue(temp.x, temp.y, temp.z, 1);
        Vector4.transform(leftTop, matrix, leftTop);
        Vector4.transform(leftBottom, matrix, leftBottom);
        Vector4.transform(rightTop, matrix, rightTop);
        Vector4.transform(rightBottom, matrix, rightBottom);

        this._positionQuad.leftTop.setValue(leftTop.x, leftTop.y, leftTop.z);

        this._positionQuad.leftBottom.setValue(leftBottom.x, leftBottom.y, leftBottom.z);

        this._positionQuad.rightTop.setValue(rightTop.x, rightTop.y, rightTop.z);

        this._positionQuad.rightBottom.setValue(rightBottom.x, rightBottom.y, rightBottom.z);
      }
    }, {
      key: "_updatePositionQuad",
      value: function _updatePositionQuad(camera) {
        if (this.renderMode === "2D") {
          var m = camera.viewMatrix.elements;
          var vx = new Vector3(m[0], m[4], m[8]);
          var vy = new Vector3(m[1], m[5], m[9]);
          var c = this.entity.worldPosition.clone();
          var s = this._worldSize;
          var ns = this.entity.scale;
          vx.scale(s[0] * ns.x);
          vy.scale(s[1] * ns.y);

          if (this._rotationAngle !== 0) {
            var vz = new Vector3(m[2], m[6], m[10]);
            var rotation = new Quaternion();
            Quaternion.rotationAxisAngle(vz, this._rotationAngle, rotation);
            Vector3.transformByQuat(vx, rotation, vx);
            Vector3.transformByQuat(vy, rotation, vy);
          }

          var cx = new Vector3();
          var cy = new Vector3();
          Vector3.scale(vx, (this.anchor[0] - 0.5) * 2, cx);
          Vector3.scale(vy, (this.anchor[1] - 0.5) * 2, cy);
          c.subtract(cx).add(cy);
          var leftTop = this._positionQuad.leftTop;
          Vector3.subtract(c, vx, leftTop);
          leftTop.add(vy);
          var leftBottom = this._positionQuad.leftBottom;
          Vector3.subtract(c, vx, leftBottom);
          leftBottom.subtract(vy);
          var rightBottom = this._positionQuad.rightBottom;
          Vector3.add(c, vx, rightBottom);
          rightBottom.subtract(vy);
          var rightTop = this._positionQuad.rightTop;
          Vector3.add(c, vx, rightTop);
          rightTop.add(vy);
        }
      }
    }, {
      key: "texture",
      set: function set(v) {
        this.setTexture(v);
        this.setRect();
        this.setUvRect();
        this.setWorldSize();
      },
      get: function get() {
        return this._texture;
      }
    }, {
      key: "anchor",
      set: function set(v) {
        this._anchor = v || [0.5, 0.5];
      },
      get: function get() {
        return this._anchor;
      }
    }, {
      key: "rect",
      set: function set(v) {
        this.setRect(v);
        this.setUvRect();
        this.setWorldSize();
      },
      get: function get() {
        return this._rect;
      }
    }, {
      key: "rotationAngle",
      get: function get() {
        return this._rotationAngle;
      },
      set: function set(v) {
        this._rotationAngle = v;
      }
    }]);

    return SpriteRenderer;
  }(RenderableComponent);

  SpriteRenderer._tempVec40 = new Vector4();
  SpriteRenderer._tempVec41 = new Vector4();
  SpriteRenderer._tempVec42 = new Vector4();
  SpriteRenderer._tempVec43 = new Vector4();


  (function (WrapMode2) {
    WrapMode2[WrapMode2["ONCE"] = 0] = "ONCE";
    WrapMode2[WrapMode2["LOOP"] = 1] = "LOOP";
  })(exports.WrapMode || (exports.WrapMode = {}));



  (function (AnimationEventType2) {
    AnimationEventType2[AnimationEventType2["FINISHED"] = 0] = "FINISHED";
    AnimationEventType2[AnimationEventType2["LOOP_END"] = 1] = "LOOP_END";
    AnimationEventType2[AnimationEventType2["FRAME_EVENT"] = 2] = "FRAME_EVENT";
  })(exports.AnimationEvent || (exports.AnimationEvent = {}));



  (function (InterpolationType2) {
    InterpolationType2[InterpolationType2["LINEAR"] = 0] = "LINEAR";
    InterpolationType2[InterpolationType2["CUBICSPLINE"] = 1] = "CUBICSPLINE";
    InterpolationType2[InterpolationType2["STEP"] = 2] = "STEP";
  })(exports.InterpolationType || (exports.InterpolationType = {}));

  var TagetType;

  (function (TagetType2) {
    TagetType2[TagetType2["position"] = 0] = "position";
    TagetType2[TagetType2["rotation"] = 1] = "rotation";
    TagetType2[TagetType2["scale"] = 2] = "scale";
    TagetType2[TagetType2["other"] = 3] = "other";
  })(TagetType || (TagetType = {}));

  var AnimationClip = /*#__PURE__*/function (_AssetObject3) {
    _inherits(AnimationClip, _AssetObject3);

    var _super44 = _createSuper(AnimationClip);

    function AnimationClip(name) {
      var _this48;

      _classCallCheck(this, AnimationClip);

      _this48 = _super44.call(this, null);
      _this48.name = name;
      _this48.samplers = [];
      _this48.channels = [];
      return _this48;
    }

    _createClass(AnimationClip, [{
      key: "addSampler",
      value: function addSampler(_input, _output, _outputSize) {
        var _interpolation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : exports.InterpolationType.LINEAR;

        if (_interpolation === exports.InterpolationType.CUBICSPLINE) {
          if (_outputSize <= 4) {
            _interpolation = exports.InterpolationType.LINEAR;
          } else {
            _outputSize /= 3;
          }
        }

        var sampler = {
          input: _input,
          output: _output,
          outputSize: _outputSize,
          interpolation: _interpolation
        };
        this.samplers.push(sampler);
      }
    }, {
      key: "addChannel",
      value: function addChannel(samplerIndex, targetID, targetPath) {
        var bindSampler = this.samplers[samplerIndex];
        var tagetType = AnimationClip._tagetTypeMap[targetPath];
        var channel = {
          sampler: bindSampler,
          target: {
            id: targetID,
            path: targetPath,
            pathType: tagetType !== null && tagetType !== void 0 ? tagetType : 3
          }
        };
        this.channels.push(channel);
      }
    }, {
      key: "getChannelCount",
      value: function getChannelCount() {
        return this.channels.length;
      }
    }, {
      key: "getChannelObject",
      value: function getChannelObject(channelIndex) {
        return this.channels[channelIndex];
      }
    }, {
      key: "getFrameCount",
      value: function getFrameCount(channelIndex) {
        var sampler = this.channels[channelIndex].sampler;
        return sampler.input.length;
      }
    }, {
      key: "getFrameTime",
      value: function getFrameTime(channelIndex, frameIndex) {
        var sampler = this.channels[channelIndex].sampler;
        return sampler.input[frameIndex];
      }
    }, {
      key: "getChannelTimeLength",
      value: function getChannelTimeLength(channelIndex) {
        var sampler = this.channels[channelIndex].sampler;
        var frameCount = sampler.input.length;
        return sampler.input[frameCount - 1];
      }
    }, {
      key: "createChannelValue",
      value: function createChannelValue(channelIndex) {
        var sampler = this.channels[channelIndex].sampler;
        return new Float32Array(sampler.outputSize);
      }
    }, {
      key: "evaluate",
      value: function evaluate(outValue, channelIndex, frameIndex, nextFrameIndex, alpha) {
        var channel = this.channels[channelIndex];
        var output = channel.sampler.output;
        var outputSize = channel.sampler.outputSize;

        switch (channel.sampler.interpolation) {
          case exports.InterpolationType.CUBICSPLINE:
            this.evaluateCubicSpline(outValue, output, outputSize, frameIndex, nextFrameIndex, alpha);
            break;

          case exports.InterpolationType.LINEAR:
            this.evaluateLinear(outValue, output, outputSize, frameIndex, nextFrameIndex, alpha);
            break;
        }

        return outValue;
      }
    }, {
      key: "evaluateCubicSpline",
      value: function evaluateCubicSpline(outValue, output, outputSize, frameIndex, nextFrameIndex, alpha) {
        var squared = alpha * alpha;
        var cubed = alpha * squared;
        var part1 = 2 * cubed - 3 * squared + 1;
        var part2 = -2 * cubed + 3 * squared;
        var part3 = cubed - 2 * squared + alpha;
        var part4 = cubed - squared;

        for (var i = outputSize; i >= 0; i--) {
          var t1 = output[frameIndex * outputSize * 3 + i];
          var v1 = output[frameIndex * outputSize * 3 + outputSize + i];
          var t2 = output[frameIndex * outputSize * 3 + outputSize * 2 + i];
          var v2 = output[nextFrameIndex * outputSize * 3 + outputSize + i];
          outValue[i] = v1 * part1 + v2 * part2 + t1 * part3 + t2 * part4;
        }
      }
    }, {
      key: "evaluateLinear",
      value: function evaluateLinear(outValue, output, outputSize, frameIndex, nextFrameIndex, alpha) {
        switch (outputSize) {
          case 1:
            outValue[0] = output[frameIndex] * (1 - alpha) + output[nextFrameIndex] * alpha;
            break;

          case 4:
            this._quaSlerp(outValue, output, frameIndex * outputSize, output, nextFrameIndex * outputSize, alpha);

            break;

          default:
            for (var i = outputSize; i >= 0; i--) {
              outValue[i] = output[frameIndex * outputSize + i] * (1 - alpha) + output[nextFrameIndex * outputSize + i] * alpha;
            }

            break;
        }
      }
    }, {
      key: "_quaSlerp",
      value: function _quaSlerp(out, a, aIndex, b, bIndex, t) {
        var ax = a[0 + aIndex],
            ay = a[1 + aIndex],
            az = a[2 + aIndex],
            aw = a[3 + aIndex];
        var bx = b[0 + bIndex],
            by = b[1 + bIndex],
            bz = b[2 + bIndex],
            bw = b[3 + bIndex];
        var omega, cosom, sinom, scale0, scale1;
        cosom = ax * bx + ay * by + az * bz + aw * bw;

        if (cosom < 0) {
          cosom = -cosom;
          bx = -bx;
          by = -by;
          bz = -bz;
          bw = -bw;
        }

        if (1 - cosom > 1e-6) {
          omega = Math.acos(cosom);
          sinom = Math.sin(omega);
          scale0 = Math.sin((1 - t) * omega) / sinom;
          scale1 = Math.sin(t * omega) / sinom;
        } else {
          scale0 = 1 - t;
          scale1 = t;
        }

        out[0] = scale0 * ax + scale1 * bx;
        out[1] = scale0 * ay + scale1 * by;
        out[2] = scale0 * az + scale1 * bz;
        out[3] = scale0 * aw + scale1 * bw;
        return out;
      }
    }]);

    return AnimationClip;
  }(AssetObject);

  AnimationClip._tagetTypeMap = {
    position: 0,
    rotation: 1,
    scale: 2
  };

  var AnimationLayer = /*#__PURE__*/function (_EventDispatcher5) {
    _inherits(AnimationLayer, _EventDispatcher5);

    var _super45 = _createSuper(AnimationLayer);

    _createClass(AnimationLayer, [{
      key: "isPlaying",
      get: function get() {
        return this._animClip && this._isPlaying;
      }
    }]);

    function AnimationLayer() {
      var _this49;

      _classCallCheck(this, AnimationLayer);

      _this49 = _super45.call(this, null);
      _this49.layerWeight = 1;
      _this49._activedEvents = [];
      return _this49;
    }

    _createClass(AnimationLayer, [{
      key: "canMix",
      value: function canMix(nextAnimClip, rootEntity) {
        if (!this._animClip || !this._isPlaying || this.isMixLayer || this.isFading) {
          return false;
        }

        if (this._animClip.getChannelCount() !== nextAnimClip.getChannelCount()) {
          return false;
        }

        var count = this._animClip.getChannelCount();

        for (var i = count - 1; i >= 0; i--) {
          var curChannel = this._animClip.getChannelObject(i);

          var curTargetObject = this._findChannelTarget(rootEntity, curChannel.target);

          var nextChannel = nextAnimClip.getChannelObject(i);

          var nextTargetObject = this._findChannelTarget(rootEntity, nextChannel.target);

          if (curTargetObject !== nextTargetObject) {
            return false;
          }
        }

        return true;
      }
    }, {
      key: "mix",
      value: function mix(animClip, targetLayer, rootEntity, mixEntity) {
        var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
        this._isPlaying = targetLayer.isPlaying;
        this._animClip = animClip;
        this._wrapMode = typeof options.wrapMode !== "undefined" ? options.wrapMode : targetLayer._wrapMode;

        this._addEvents(options);

        this._channelStates = [];
        this._animClipLength = 0;

        if (this._isPlaying) {
          var targetChannelStates = targetLayer._channelStates;

          var count = this._animClip.getChannelCount();

          for (var i = count - 1; i >= 0; i--) {
            var channel = this._animClip.getChannelObject(i);

            var targetObject = this._findChannelTarget(mixEntity, channel.target);

            this._channelStates[i] = {
              frameTime: 0,
              currentFrame: 0,
              currentValue: this._animClip.createChannelValue(i),
              mixWeight: targetObject ? 1 : 0
            };
            targetChannelStates[i].mixWeight = targetChannelStates[i].mixWeight === void 0 ? 1 : targetChannelStates[i].mixWeight;

            if (targetChannelStates[i].mixWeight === 1) {
              targetChannelStates[i].mixWeight = targetObject ? 0 : 1;
            }

            var channelTimeLength = this._animClip.getChannelTimeLength(i);

            this._animClipLength = this._animClipLength > channelTimeLength ? this._animClipLength : channelTimeLength;
          }

          return true;
        }

        return false;
      }
    }, {
      key: "removeMixWeight",
      value: function removeMixWeight() {
        var count = this._channelStates.length;

        for (var i = count - 1; i >= 0; i--) {
          if (this._channelStates[i].mixWeight === 1) {
            this.mixTagetLayer._channelStates[i].mixWeight = 1;
          }
        }
      }
    }, {
      key: "play",
      value: function play(animClip, rootEntity) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
          wrapMode: exports.WrapMode.LOOP
        };
        this._isPlaying = !!animClip;
        this._animClip = animClip;
        this._wrapMode = typeof options.wrapMode !== "undefined" ? options.wrapMode : exports.WrapMode.LOOP;

        this._addEvents(options);

        this._channelStates = [];
        this._animClipLength = 0;

        if (this._isPlaying) {
          var count = this._animClip.getChannelCount();

          var channelTargets = [];

          for (var i = count - 1; i >= 0; i--) {
            var channel = this._animClip.getChannelObject(i);

            var targetObject = this._findChannelTarget(rootEntity, channel.target);

            if (!targetObject) {
              Logger.warn("Can not find channel target:" + channel.target.id);
            }

            this._channelStates[i] = {
              frameTime: 0,
              currentFrame: 0,
              currentValue: this._animClip.createChannelValue(i)
            };
            channelTargets[i] = {
              targetObject: targetObject,
              path: channel.target.path,
              pathType: channel.target.pathType,
              outputSize: channel.sampler.outputSize
            };

            var channelTimeLength = this._animClip.getChannelTimeLength(i);

            this._animClipLength = this._animClipLength > channelTimeLength ? this._animClipLength : channelTimeLength;
          }

          return channelTargets;
        }

        return false;
      }
    }, {
      key: "stop",
      value: function stop(rightnow) {
        if (!this._animClip || !this._isPlaying) {
          return;
        }

        if (rightnow) {
          this._isPlaying = false;
        } else {
          this._wrapMode = exports.WrapMode.ONCE;
        }
      }
    }, {
      key: "updateState",
      value: function updateState(deltaTime) {
        if (!this._animClip || !this._isPlaying) {
          return;
        }

        if (this.isFading) {
          this.fadeDeltaTime += deltaTime;
          this.layerWeight = 1 - this.fadeDeltaTime / this.fadeDuration;

          if (this.layerWeight <= 0) {
            this._isPlaying = false;
          }
        } else if (this.crossFadeDuration) {
          this.crossFadeDeltaTime += deltaTime;
          this.layerWeight = this.crossFadeDeltaTime / this.crossFadeDuration;

          if (this.layerWeight >= 1) {
            this.layerWeight = 1;
            delete this.crossFadeDuration;
          }
        }

        deltaTime = deltaTime / 1e3;

        this._activeEvents(deltaTime);

        var count = this._animClip.getChannelCount();

        var playingCount = 0;

        for (var i = count - 1; i >= 0; i--) {
          if (this._updateChannelState(deltaTime, i)) {
            playingCount++;
          }
        }

        if (playingCount === 0) {
          this._isPlaying = false;

          if (this.isMixLayer) {
            this.removeMixWeight();
          }
        }
      }
    }, {
      key: "getChannelLayerWeight",
      value: function getChannelLayerWeight(channelIndex) {
        if ((this.hasMixLayer || this.isMixLayer) && channelIndex < this._channelStates.length) {
          var mixWeight = this._channelStates[channelIndex].mixWeight;
          var layerWeight = this.isMixLayer ? this.mixTagetLayer.layerWeight : this.layerWeight;
          return mixWeight * layerWeight;
        }

        return this.layerWeight;
      }
    }, {
      key: "getChannelValue",
      value: function getChannelValue(channelIndex) {
        return this._channelStates[channelIndex].currentValue;
      }
    }, {
      key: "triggerEvents",
      value: function triggerEvents() {
        var _this50 = this;

        this._activedEvents && this._activedEvents.forEach(function (event) {
          _this50.trigger(event);
        });
        this._activedEvents.length = 0;
      }
    }, {
      key: "jumpToFrame",
      value: function jumpToFrame(frameTime) {
        var count = this._animClip.getChannelCount();

        for (var i = count - 1; i >= 0; i--) {
          var channelState = this._channelStates[i];
          channelState.frameTime = 0;

          this._updateChannelState(frameTime, i);
        }
      }
    }, {
      key: "_updateChannelState",
      value: function _updateChannelState(deltaTime, channelIndex) {
        var animClip = this._animClip;
        var channelState = this._channelStates[channelIndex];
        var animClipLength = animClip.getChannelTimeLength(channelIndex);
        channelState.frameTime += deltaTime;

        if (channelState.frameTime > animClipLength) {
          switch (this._wrapMode) {
            case exports.WrapMode.ONCE:
              channelState.frameTime = animClipLength;
              break;

            case exports.WrapMode.LOOP:
              channelState.frameTime = channelState.frameTime % this._animClipLength;
              break;

            default:
              Logger.error("Unknown Anim wrap Mode: " + this._wrapMode);
          }
        }

        if (channelState.mixWeight && channelState.mixWeight === 0) {
          return true;
        }

        var frameTime = Math.min(channelState.frameTime, animClipLength);

        var lerpState = this._getKeyAndAlpha(animClip.getChannelObject(channelIndex), frameTime);

        channelState.currentValue = animClip.evaluate(channelState.currentValue, channelIndex, lerpState.currentKey, lerpState.nextKey, lerpState.alpha);

        if (this._wrapMode === exports.WrapMode.ONCE && channelState.frameTime >= animClipLength) {
          return false;
        }

        return true;
      }
    }, {
      key: "_addEvents",
      value: function _addEvents(options) {
        var _this51 = this;

        this.removeAllEventListeners();
        this._frameEvents = [];

        if (options.events) {
          var frameEventIndex = 0;

          var _loop = function _loop(i) {
            var event = options.events[i];
            var eventType = event.type;

            if (event.type === exports.AnimationEvent.FRAME_EVENT) {
              eventType = "frameEvent" + frameEventIndex;
              frameEventIndex++;

              _this51._frameEvents.push({
                eventType: eventType,
                triggerTime: event.triggerTime,
                triggered: false
              });
            }

            _this51.addEventListener(eventType, function (e) {
              event.callback();
            });
          };

          for (var i = options.events.length - 1; i >= 0; i--) {
            _loop(i);
          }
        }
      }
    }, {
      key: "_activeEvents",
      value: function _activeEvents(deltaTime) {
        var index = this._animClip.durationIndex;

        if (this._frameEvents.length > 0 && this._channelStates.length > 0) {
          var curFrameTime = this._channelStates[index].frameTime + deltaTime;

          for (var i = this._frameEvents.length - 1; i >= 0; i--) {
            var frameEvent = this._frameEvents[i];

            if (!frameEvent.triggered && curFrameTime > frameEvent.triggerTime) {
              this._activedEvents.push(new Event(frameEvent.eventType, this));

              frameEvent.triggered = true;
            }
          }
        }

        if (this._channelStates.length > 0 && this._channelStates[index].frameTime + deltaTime >= this._animClip.duration) {
          if (this._wrapMode === exports.WrapMode.LOOP) {
            if (this._frameEvents.length > 0) {
              for (var _i15 = this._frameEvents.length - 1; _i15 >= 0; _i15--) {
                this._frameEvents[_i15].triggered = false;
              }
            }

            if (this.hasEvent(exports.AnimationEvent.LOOP_END)) {
              this._activedEvents.push(new Event(exports.AnimationEvent.LOOP_END, this));
            }
          } else if (this.hasEvent(exports.AnimationEvent.FINISHED)) {
            this._activedEvents.push(new Event(exports.AnimationEvent.FINISHED, this));
          }
        }
      }
    }, {
      key: "_findChannelTarget",
      value: function _findChannelTarget(rootNode, target) {
        var targetID = target.id;
        var targetSceneObject = null;

        if (rootNode.name === targetID) {
          targetSceneObject = rootNode;
        } else {
          targetSceneObject = rootNode.findByName(targetID);
        }

        if (target.path === "weights") {
          return targetSceneObject.getComponent(SkinnedMeshRenderer);
        } else {
          return targetSceneObject;
        }
      }
    }, {
      key: "_getKeyAndAlpha",
      value: function _getKeyAndAlpha(channel, time) {
        var keyTime = 0;
        var currentKey = 0;
        var nextKey = 0;
        var timeKeys = channel.sampler.input;
        var numKeys = timeKeys.length;

        for (var i = numKeys - 1; i >= 0; i--) {
          if (time > timeKeys[i]) {
            keyTime = time - timeKeys[i];
            currentKey = i;
            break;
          }
        }

        nextKey = currentKey + 1;

        if (nextKey >= numKeys) {
          switch (this._wrapMode) {
            case exports.WrapMode.ONCE:
              nextKey = numKeys - 1;
              break;

            case exports.WrapMode.LOOP:
              nextKey = 0;
              break;
          }
        }

        var keyLength = timeKeys[nextKey] - timeKeys[currentKey];
        var alpha = nextKey === currentKey || keyLength < 1e-5 ? 1 : keyTime / keyLength;
        return {
          currentKey: currentKey,
          nextKey: nextKey,
          alpha: alpha
        };
      }
    }]);

    return AnimationLayer;
  }(EventDispatcher);

  var __defProp$9 = Object.defineProperty;
  var __getOwnPropDesc$9 = Object.getOwnPropertyDescriptor;

  var __decorate$9 = function __decorate$9(decorators, target, key, kind) {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$9(target, key) : target;

    for (var i = decorators.length - 1, decorator; i >= 0; i--) {
      if (decorator = decorators[i]) result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    }

    if (kind && result) __defProp$9(target, key, result);
    return result;
  };

  var Animation = /*#__PURE__*/function (_Component7) {
    _inherits(Animation, _Component7);

    var _super46 = _createSuper(Animation);

    function Animation(entity) {
      var _this52;

      _classCallCheck(this, Animation);

      _this52 = _super46.call(this, entity);
      _this52._onUpdateIndex = -1;
      _this52._animSet = {};
      _this52._animLayers = [new AnimationLayer()];
      _this52._timeScale = 1;
      return _this52;
    }

    _createClass(Animation, [{
      key: "update",
      value: function update(deltaTime) {
        if (!this.isPlaying()) {
          return;
        }

        deltaTime = deltaTime * this._timeScale;

        for (var i = this._animLayers.length - 1; i >= 0; i--) {
          var animLayer = this._animLayers[i];
          animLayer.updateState(deltaTime);
        }

        this._updateValues();

        for (var _i16 = this._animLayers.length - 1; _i16 >= 0; _i16--) {
          var _animLayer = this._animLayers[_i16];

          _animLayer.triggerEvents();

          if (!_animLayer.isPlaying && (_animLayer.isFading || _animLayer.isMixLayer)) {
            this._animLayers.splice(_i16, 1);

            this._removeRefMixLayers(_animLayer);
          }
        }
      }
    }, {
      key: "addAnimationClip",
      value: function addAnimationClip(animClip, name) {
        this._animSet[name] = animClip;
      }
    }, {
      key: "removeAnimationClip",
      value: function removeAnimationClip(name) {
        var animClip = this._animSet[name];

        if (animClip) {
          delete this._animSet[name];
        }
      }
    }, {
      key: "getAnimationClipLength",
      value: function getAnimationClipLength(name) {
        var animClip = this._animSet[name];

        if (animClip) {
          return animClip.getChannelTimeLength(0);
        } else {
          return 0;
        }
      }
    }, {
      key: "getAnimationClip",
      value: function getAnimationClip(name) {
        return this._animSet[name] || null;
      }
    }, {
      key: "isPlaying",
      value: function isPlaying() {
        for (var i = this._animLayers.length - 1; i >= 0; i--) {
          if (this._animLayers[i].isPlaying) {
            return true;
          }
        }

        return false;
      }
    }, {
      key: "playAnimationClip",
      value: function playAnimationClip(name, options) {
        var animClip = this._animSet[name];

        if (!animClip) {
          Logger.error("can not find anim clip: " + name);
          return;
        }

        var animLayer = null;

        for (var i = this._animLayers.length - 1; i >= 0; i--) {
          if (!this._animLayers[i].isFading && !this._animLayers[i].isMixLayer) {
            animLayer = this._animLayers[i];
            break;
          }
        }

        if (!animLayer) {
          animLayer = new AnimationLayer();

          this._animLayers.push(animLayer);
        }

        this._removeRefMixLayers(animLayer);

        this._channelTargets = animLayer.play(animClip, this.entity, options);
      }
    }, {
      key: "crossFade",
      value: function crossFade(name, crossFadeDuration, options) {
        var animClip = this._animSet[name];

        if (!animClip) {
          Logger.error("can not find anim clip: " + name);
          return;
        }

        if (!crossFadeDuration || crossFadeDuration < 0) {
          Logger.error("crossFadeDuration can not less than 0!");
          return;
        }

        var targetAnimLayer = null;

        for (var i = this._animLayers.length - 1; i >= 0; i--) {
          if (this._animLayers[i].canMix(animClip, this.entity)) {
            targetAnimLayer = this._animLayers[i];
            break;
          }
        }

        if (targetAnimLayer) {
          for (var _i17 = this._animLayers.length - 1; _i17 >= 0; _i17--) {
            if (this._animLayers[_i17].isFading) {
              this._animLayers.splice(_i17, 1);
            }
          }

          targetAnimLayer.isFading = true;
          targetAnimLayer.fadeDuration = crossFadeDuration;
          targetAnimLayer.fadeDeltaTime = 0;
          var animLayer = new AnimationLayer();
          animLayer.crossFadeDuration = crossFadeDuration;
          animLayer.crossFadeDeltaTime = 0;
          animLayer.play(animClip, this.entity, options);

          this._animLayers.push(animLayer);
        } else {
          this.playAnimationClip(name, options);
        }
      }
    }, {
      key: "mix",
      value: function mix(name, mixBoneName, options) {
        var animClip = this._animSet[name];

        if (!animClip) {
          Logger.error("can not find anim clip: " + name);
          return;
        }

        var mixNode = this.entity.findByName(mixBoneName);

        if (!mixNode) {
          Logger.error("can not find mix bone!");
          return;
        }

        var targetAnimLayer = null;

        for (var i = this._animLayers.length - 1; i >= 0; i--) {
          if (this._animLayers[i].canMix(animClip, this.entity)) {
            targetAnimLayer = this._animLayers[i];
            break;
          }
        }

        if (targetAnimLayer) {
          this._removeRefMixLayers(null, mixNode);

          targetAnimLayer.hasMixLayer = true;
          var animLayer = new AnimationLayer();
          animLayer.isMixLayer = true;
          animLayer.mixTagetLayer = targetAnimLayer;
          animLayer.mixEntity = mixNode;
          animLayer.mix(animClip, targetAnimLayer, this.entity, mixNode, options);

          this._animLayers.push(animLayer);
        }
      }
    }, {
      key: "stop",
      value: function stop(rightnow) {
        for (var i = this._animLayers.length - 1; i >= 0; i--) {
          if (this._animLayers[i].isFading) {
            this._animLayers.splice(i, 1);
          } else {
            this._animLayers[i].stop(rightnow);
          }
        }
      }
    }, {
      key: "jumpToFrame",
      value: function jumpToFrame(frameTime) {
        frameTime = frameTime / 1e3;

        for (var i = this._animLayers.length - 1; i >= 0; i--) {
          this._animLayers[i].jumpToFrame(frameTime);
        }

        this._updateValues();
      }
    }, {
      key: "_removeRefMixLayers",
      value: function _removeRefMixLayers(targetLayer, mixNode) {
        if (targetLayer && targetLayer.hasMixLayer) {
          for (var i = this._animLayers.length - 1; i >= 0; i--) {
            var animLayer = this._animLayers[i];

            if (animLayer.isMixLayer && animLayer.mixTagetLayer === targetLayer) {
              animLayer.removeMixWeight();

              this._animLayers.splice(i, 1);
            }
          }
        }

        if (mixNode) {
          for (var _i18 = this._animLayers.length - 1; _i18 >= 0; _i18--) {
            var _animLayer2 = this._animLayers[_i18];

            if (_animLayer2.isMixLayer && (_animLayer2.mixEntity === mixNode || _animLayer2.mixEntity.findByName(mixNode) || mixNode.findByName(_animLayer2.mixEntity))) {
              _animLayer2.removeMixWeight();

              this._animLayers.splice(_i18, 1);
            }
          }
        }
      }
    }, {
      key: "_updateValues",
      value: function _updateValues() {
        if (this._animLayers.length === 0 || !this._channelTargets) {
          return;
        }

        for (var i = this._channelTargets.length - 1; i >= 0; i--) {
          var channelTarget = this._channelTargets[i];

          var val = this._getChannelValue(i, channelTarget.outputSize);

          var targetObject = channelTarget.targetObject;
          var path = channelTarget.path;

          if (path === "weights") {
            targetObject.setWeights(val);
          } else {
            var v = val;
            var transform = targetObject.transform;

            switch (channelTarget.pathType) {
              case TagetType.position:
                var position = transform.position;
                position.setValue(v[0], v[1], v[2]);
                transform.position = position;
                break;

              case TagetType.rotation:
                var rotation = transform.rotationQuaternion;
                rotation.setValue(v[0], v[1], v[2], v[3]);
                transform.rotationQuaternion = rotation;
                break;

              case TagetType.scale:
                var scale = transform.scale;
                scale.setValue(v[0], v[1], v[2]);
                transform.scale = scale;
                break;

              default:
                targetObject[path] = val;
            }
          }
        }
      }
    }, {
      key: "_getChannelValue",
      value: function _getChannelValue(channelIndex, outputSize) {
        var weights = [];
        var values = [];

        for (var i = this._animLayers.length - 1; i >= 0; i--) {
          var weight = this._animLayers[i].getChannelLayerWeight(channelIndex);

          if (weight > 0) {
            weights.push(weight);
            values.push(this._animLayers[i].getChannelValue(channelIndex));
          }
        }

        if (values.length === 1) {
          return values[0];
        } else if (values.length === 2) {
          return Animation.lerp(values[0], values[0], values[1], weights[1], outputSize);
        }

        Logger.error("Can not get channel value!");
        return false;
      }
    }, {
      key: "_onEnable",
      value: function _onEnable() {
        this.engine._componentsManager.addOnUpdateAnimations(this);
      }
    }, {
      key: "_onDisable",
      value: function _onDisable() {
        this.engine._componentsManager.removeOnUpdateAnimations(this);
      }
    }, {
      key: "timeScale",
      get: function get() {
        return this._timeScale;
      },
      set: function set(val) {
        if (val > 0) {
          this._timeScale = val;
        }
      }
    }], [{
      key: "lerp",
      value: function lerp(outValue, startValue, endValue, alpha, outputSize) {
        switch (outputSize) {
          case 1:
            outValue = startValue * (1 - alpha) + endValue * alpha;
            break;

          case 4:
            var start = _construct(Quaternion, _toConsumableArray(startValue));

            var end = _construct(Quaternion, _toConsumableArray(endValue));

            var quat = new Quaternion();
            Quaternion.slerp(start, end, alpha, quat);
            outValue[0] = quat.x;
            outValue[1] = quat.y;
            outValue[2] = quat.z;
            outValue[3] = quat.w;
            break;

          default:
            for (var i = outputSize; i >= 0; i--) {
              outValue[i] = startValue[i] * (1 - alpha) + endValue[i] * alpha;
            }

            break;
        }

        return outValue;
      }
    }]);

    return Animation;
  }(Component);

  __decorate$9([ignoreClone], Animation.prototype, "_onUpdateIndex", 2);

  __decorate$9([shallowClone], Animation.prototype, "_animSet", 2);

  __decorate$9([ignoreClone], Animation.prototype, "_animLayers", 2);

  __decorate$9([ignoreClone], Animation.prototype, "_timeScale", 2);

  __decorate$9([ignoreClone], Animation.prototype, "_channelTargets", 2);

  var VertexShader = "#include <common>\n#include <common_vert>\n#include <uv_share>\n#include <normal_share>\n#include <worldpos_share>\n#include <shadow_share>\n#include <morph_target_vert>\n\n#include <fog_share>\n\nvoid main() {\n\n    #include <begin_position_vert>\n    #include <begin_normal_vert>\n\n    #include <morph_vert>\n    #include <skinning_vert>\n    #include <uv_vert>\n    #include <normal_vert>\n    #include <worldpos_vert>\n    #include <shadow_vert>\n    #include <position_vert>\n\n    #include <fog_vert>\n\n}\n";

  var CommonMaterial = /*#__PURE__*/function (_Material2) {
    _inherits(CommonMaterial, _Material2);

    var _super47 = _createSuper(CommonMaterial);

    function CommonMaterial(engine, name) {
      var _this53;

      _classCallCheck(this, CommonMaterial);

      _this53 = _super47.call(this, engine, name);
      _this53.renderStates = {
        enable: [],
        disable: [],
        functions: {}
      };
      _this53.emission = new Vector4(0, 0, 0, 1);
      _this53.ambient = new Vector4(0, 0, 0, 1);
      _this53.renderStates = {};
      return _this53;
    }

    _createClass(CommonMaterial, [{
      key: "prepareDrawing",
      value: function prepareDrawing(context, component, primitive) {
        var camera = context.camera;
        var lightMgr = camera.scene.findFeature(LightFeature);
        lightMgr.bindMaterialValues(this);
        var ambientLightCount = lightMgr.lightSortAmount.ambientLightCount;

        if (!this._technique || this._ambientLightCount !== ambientLightCount) {
          this._ambientLightCount = ambientLightCount;

          this._generateTechnique();

          this.bindLightUniformDefine(camera);
        }

        _get(_getPrototypeOf(CommonMaterial.prototype), "prepareDrawing", this).call(this, context, component, primitive);
      }
    }, {
      key: "bindLightUniformDefine",
      value: function bindLightUniformDefine(camera) {
        var lightMgr = camera.scene.findFeature(LightFeature);
        this._technique.uniforms = _objectSpread2(_objectSpread2({}, lightMgr.getUniformDefine()), this._technique.uniforms);
      }
    }, {
      key: "_internalGenerate",
      value: function _internalGenerate(name, fragmentShader) {
        var customMacros = this._generateMacros();

        var uniforms = this._generateFragmentUniform();

        var tech = new RenderTechnique(name);
        tech.isValid = true;
        tech.uniforms = uniforms;
        tech.attributes = {};
        tech.states = this.renderStates;
        tech.customMacros = customMacros;
        tech.vertexShader = VertexShader;
        tech.fragmentShader = fragmentShader;
        this._technique = tech;
      }
    }, {
      key: "_generateMacros",
      value: function _generateMacros() {
        var macros = [];
        if (this.emission instanceof Texture2D) macros.push("O3_EMISSION_TEXTURE");
        if (this.ambient instanceof Texture2D) macros.push("O3_AMBIENT_TEXTURE");

        if (this._ambientLightCount) {
          macros.push("O3_HAS_AMBIENT_LIGHT");
        }

        return macros;
      }
    }, {
      key: "_generateFragmentUniform",
      value: function _generateFragmentUniform() {
        var fragmentUniform = {
          u_emission: {
            name: "u_emission",
            type: exports.DataType.FLOAT_VEC4
          },
          u_ambient: {
            name: "u_ambient",
            type: exports.DataType.FLOAT_VEC4
          }
        };

        if (this.emission instanceof Texture2D) {
          fragmentUniform.u_emission.type = exports.DataType.SAMPLER_2D;
        }

        if (this.ambient instanceof Texture2D) {
          fragmentUniform.u_ambient.type = exports.DataType.SAMPLER_2D;
        }

        return fragmentUniform;
      }
    }, {
      key: "emission",
      get: function get() {
        return this.getValue("u_emission");
      },
      set: function set(val) {
        this.setValue("u_emission", val);
      }
    }, {
      key: "ambient",
      get: function get() {
        return this.getValue("u_ambient");
      },
      set: function set(val) {
        this.setValue("u_ambient", val);
      }
    }]);

    return CommonMaterial;
  }(Material);

  var ConstantShader = "#include <common>\n#include <common_frag>\n#include <uv_share>\n#include <mobile_material_frag>\n\n#include <fog_share>\n#include <ambient_light_frag>\n\nvoid main() {\n\n    #include <begin_mobile_frag>\n\n    gl_FragColor = emission + ambient;\n\n    #include <fog_frag>\n\n}\n";

  var ConstantMaterial = /*#__PURE__*/function (_CommonMaterial) {
    _inherits(ConstantMaterial, _CommonMaterial);

    var _super48 = _createSuper(ConstantMaterial);

    function ConstantMaterial() {
      _classCallCheck(this, ConstantMaterial);

      return _super48.apply(this, arguments);
    }

    _createClass(ConstantMaterial, [{
      key: "_generateTechnique",
      value: function _generateTechnique() {
        this._internalGenerate("ConstantMaterial", ConstantShader);
      }
    }]);

    return ConstantMaterial;
  }(CommonMaterial);

  var LambertShader = "#include <common>\n#include <common_frag>\n#include <uv_share>\n#include <normal_share>\n\n#include <ambient_light_frag>\n#include <direct_light_frag>\n#include <mobile_material_frag>\n\n#include <fog_share>\n\nvoid main() {\n\n    #include <begin_mobile_frag>\n    #include <begin_normal_frag>\n    #include <mobile_lambert_frag>\n\n    gl_FragColor = emission + ambient + diffuse;\n\n    #include <fog_frag>\n\n}\n";

  var LambertMaterial = /*#__PURE__*/function (_CommonMaterial2) {
    _inherits(LambertMaterial, _CommonMaterial2);

    var _super49 = _createSuper(LambertMaterial);

    function LambertMaterial(engine, name) {
      var _this54;

      _classCallCheck(this, LambertMaterial);

      _this54 = _super49.call(this, engine, name);
      _this54._directLightCount = 0;
      _this54.diffuse = new Vector4(1, 1, 1, 1);
      return _this54;
    }

    _createClass(LambertMaterial, [{
      key: "_generateTechnique",
      value: function _generateTechnique() {
        this._internalGenerate("LambertMaterial", LambertShader);
      }
    }, {
      key: "prepareDrawing",
      value: function prepareDrawing(context, component, primitive) {
        var camera = context.camera;
        var scene = camera.scene;
        var lightMgr = scene.findFeature(LightFeature);
        var directLightCount = lightMgr.lightSortAmount.directLightCount;

        if (this._technique === null || this._directLightCount != directLightCount) {
          this._directLightCount = directLightCount;

          this._generateTechnique();

          this.bindLightUniformDefine(camera);
        }

        _get(_getPrototypeOf(LambertMaterial.prototype), "prepareDrawing", this).call(this, context, component, primitive);
      }
    }, {
      key: "_generateFragmentUniform",
      value: function _generateFragmentUniform() {
        var uniforms = {};

        if (this.diffuse instanceof Texture2D) {
          uniforms.u_diffuse = {
            name: "u_diffuse",
            type: exports.DataType.SAMPLER_2D
          };
        } else {
          uniforms.u_diffuse = {
            name: "u_diffuse",
            type: exports.DataType.FLOAT_VEC4
          };
        }

        var baseUniforms = _get(_getPrototypeOf(LambertMaterial.prototype), "_generateFragmentUniform", this).call(this);

        return _extends(baseUniforms, uniforms);
      }
    }, {
      key: "_generateMacros",
      value: function _generateMacros() {
        var macros = _get(_getPrototypeOf(LambertMaterial.prototype), "_generateMacros", this).call(this);

        macros.push("O3_NEED_WORLDPOS");
        if (this._directLightCount > 0) macros.push("O3_DIRECT_LIGHT_COUNT ".concat(this._directLightCount));
        if (this.diffuse instanceof Texture2D) macros.push("O3_DIFFUSE_TEXTURE");
        return macros;
      }
    }, {
      key: "diffuse",
      get: function get() {
        return this.getValue("u_diffuse");
      },
      set: function set(val) {
        this.setValue("u_diffuse", val);
      }
    }]);

    return LambertMaterial;
  }(CommonMaterial);

  var BlinnPhongShader = "#include <common>\n#include <common_frag>\n\n#include <uv_share>\n#include <normal_share>\n#include <worldpos_share>\n\n#include <ambient_light_frag>\n#include <direct_light_frag>\n#include <point_light_frag>\n#include <spot_light_frag>\n#include <mobile_material_frag>\n\n#include <fog_share>\n\nvoid main() {\n\n    #include <begin_mobile_frag>\n    #include <begin_normal_frag>\n    #include <begin_viewdir_frag>\n    #include <mobile_blinnphong_frag>\n\n    gl_FragColor = emission + ambient + diffuse + specular;\n\n    #include <fog_frag>\n\n}\n";

  var BlinnPhongMaterial = /*#__PURE__*/function (_CommonMaterial3) {
    _inherits(BlinnPhongMaterial, _CommonMaterial3);

    var _super50 = _createSuper(BlinnPhongMaterial);

    function BlinnPhongMaterial(engine, name) {
      var _this55;

      _classCallCheck(this, BlinnPhongMaterial);

      _this55 = _super50.call(this, engine, name);
      _this55._directLightCount = 0;
      _this55._pointLightCount = 0;
      _this55._spotLightCount = 0;
      _this55.diffuse = new Vector4(1, 1, 1, 1);
      _this55.specular = new Vector4(1, 1, 1, 1);
      _this55.shininess = 16;
      return _this55;
    }

    _createClass(BlinnPhongMaterial, [{
      key: "_generateTechnique",
      value: function _generateTechnique() {
        this._internalGenerate("BlinnPhongMaterial", BlinnPhongShader);
      }
    }, {
      key: "_generateMacros",
      value: function _generateMacros() {
        var macros = _get(_getPrototypeOf(BlinnPhongMaterial.prototype), "_generateMacros", this).call(this);

        macros.push("O3_NEED_WORLDPOS");
        if (this.diffuse instanceof Texture2D) macros.push("O3_DIFFUSE_TEXTURE");
        if (this.specular instanceof Texture2D) macros.push("O3_SPECULAR_TEXTURE");
        if (this._directLightCount > 0) macros.push("O3_DIRECT_LIGHT_COUNT ".concat(this._directLightCount));
        if (this._pointLightCount > 0) macros.push("O3_POINT_LIGHT_COUNT ".concat(this._pointLightCount));
        if (this._spotLightCount > 0) macros.push("O3_SPOT_LIGHT_COUNT ".concat(this._spotLightCount));
        return macros;
      }
    }, {
      key: "prepareDrawing",
      value: function prepareDrawing(context, component, primitive) {
        var camera = context.camera;
        var scene = camera.scene;
        var lightMgr = scene.findFeature(LightFeature);
        var _lightMgr$lightSortAm = lightMgr.lightSortAmount,
            directLightCount = _lightMgr$lightSortAm.directLightCount,
            pointLightCount = _lightMgr$lightSortAm.pointLightCount,
            spotLightCount = _lightMgr$lightSortAm.spotLightCount;

        if (this._technique === null || this._directLightCount != directLightCount || this._pointLightCount != pointLightCount || this._spotLightCount != spotLightCount) {
          this._directLightCount = directLightCount;
          this._pointLightCount = pointLightCount;
          this._spotLightCount = spotLightCount;

          this._generateTechnique();

          this.bindLightUniformDefine(camera);
        }

        _get(_getPrototypeOf(BlinnPhongMaterial.prototype), "prepareDrawing", this).call(this, context, component, primitive);
      }
    }, {
      key: "_generateFragmentUniform",
      value: function _generateFragmentUniform() {
        var uniforms = {};

        if (this.diffuse instanceof Texture2D) {
          uniforms.u_diffuse = {
            name: "u_diffuse",
            type: exports.DataType.SAMPLER_2D
          };
        } else {
          uniforms.u_diffuse = {
            name: "u_diffuse",
            type: exports.DataType.FLOAT_VEC4
          };
        }

        if (this.specular instanceof Texture2D) {
          uniforms.u_specular = {
            name: "u_specular",
            type: exports.DataType.SAMPLER_2D
          };
        } else {
          uniforms.u_specular = {
            name: "u_specular",
            type: exports.DataType.FLOAT_VEC4
          };
        }

        uniforms.u_shininess = {
          name: "u_shininess",
          type: exports.DataType.FLOAT
        };

        var baseUniforms = _get(_getPrototypeOf(BlinnPhongMaterial.prototype), "_generateFragmentUniform", this).call(this);

        return _extends(baseUniforms, uniforms);
      }
    }, {
      key: "diffuse",
      get: function get() {
        return this.getValue("u_diffuse");
      },
      set: function set(val) {
        this.setValue("u_diffuse", val);
      }
    }, {
      key: "specular",
      get: function get() {
        return this.getValue("u_specular");
      },
      set: function set(val) {
        this.setValue("u_specular", val);
      }
    }, {
      key: "shininess",
      get: function get() {
        return this.getValue("u_shininess");
      },
      set: function set(val) {
        this.setValue("u_shininess", val);
      }
    }]);

    return BlinnPhongMaterial;
  }(CommonMaterial);

  var FRAG_SHADER = "#include <common>\n#include <common_frag>\n\nuniform sampler2D u_diffuse;\nvarying vec3 v_pos;\nuniform vec4 u_tintColor;\nuniform float u_opacity;\n\nvoid main()\n{\n  #ifdef O3_DIFFUSE_TEXTURE\n    gl_FragColor = texture2D(u_diffuse, v_uv);\n  #else\n    gl_FragColor = vec4(1);\n  #endif\n}\n";

  var TextureMaterial = /*#__PURE__*/function (_CommonMaterial4) {
    _inherits(TextureMaterial, _CommonMaterial4);

    var _super51 = _createSuper(TextureMaterial);

    function TextureMaterial(engine, name) {
      _classCallCheck(this, TextureMaterial);

      return _super51.call(this, engine, name || "TextureMaterial");
    }

    _createClass(TextureMaterial, [{
      key: "_generateTechnique",
      value: function _generateTechnique() {
        this._internalGenerate("Texture", FRAG_SHADER);
      }
    }, {
      key: "setValue",
      value: function setValue(name, value) {
        if (name === "doubleSided") {
          this._setDoubleSidedDisplay(value);
        }

        _get(_getPrototypeOf(TextureMaterial.prototype), "setValue", this).call(this, name, value);
      }
    }, {
      key: "_generateFragmentUniform",
      value: function _generateFragmentUniform() {
        var uniforms = {};

        if (this.texture instanceof Texture2D) {
          uniforms.u_diffuse = {
            name: "u_diffuse",
            paramName: "_MainTex",
            type: exports.DataType.SAMPLER_2D
          };
        }

        return _objectSpread2(_objectSpread2({}, _get(_getPrototypeOf(TextureMaterial.prototype), "_generateFragmentUniform", this).call(this)), uniforms);
      }
    }, {
      key: "_generateMacros",
      value: function _generateMacros() {
        var macros = _get(_getPrototypeOf(TextureMaterial.prototype), "_generateMacros", this).call(this);

        if (this.texture instanceof Texture2D) macros.push("O3_DIFFUSE_TEXTURE");
        return macros;
      }
    }, {
      key: "_setDoubleSidedDisplay",
      value: function _setDoubleSidedDisplay(value) {
        this._technique.states.disable = [];

        if (value) {
          this._technique.states.disable.push(exports.RenderState.CULL_FACE);
        }
      }
    }, {
      key: "texture",
      set: function set(v) {
        this.setValue("u_diffuse", v);
      },
      get: function get() {
        return this.getValue("u_diffuse");
      }
    }, {
      key: "doubleSided",
      set: function set(v) {
        this.setValue("doubleSided", v);
      },
      get: function get() {
        return this.getValue("doubleSided");
      }
    }]);

    return TextureMaterial;
  }(CommonMaterial);

  TextureMaterial.TECH_NAME = "Texture";

  var TransparentMaterial = /*#__PURE__*/function (_CommonMaterial5) {
    _inherits(TransparentMaterial, _CommonMaterial5);

    var _super52 = _createSuper(TransparentMaterial);

    function TransparentMaterial(engine, name) {
      _classCallCheck(this, TransparentMaterial);

      return _super52.call(this, engine, name || "TransparentMaterial");
    }

    _createClass(TransparentMaterial, [{
      key: "_generateTechnique",
      value: function _generateTechnique() {
        this.renderStates = {
          enable: [exports.RenderState.BLEND],
          disable: [exports.RenderState.CULL_FACE],
          functions: {
            blendFunc: [exports.BlendFunc.SRC_ALPHA, exports.BlendFunc.ONE_MINUS_SRC_ALPHA],
            depthMask: [false]
          }
        };
        this.renderType = exports.MaterialType.TRANSPARENT;

        this._internalGenerate("Transparent", FRAG_SHADER);
      }
    }, {
      key: "_generateFragmentUniform",
      value: function _generateFragmentUniform() {
        var uniforms = {};

        if (this.texture instanceof Texture2D) {
          uniforms.u_diffuse = {
            name: "u_diffuse",
            paramName: "_MainTex",
            type: exports.DataType.SAMPLER_2D
          };
        }

        return _objectSpread2(_objectSpread2({}, _get(_getPrototypeOf(TransparentMaterial.prototype), "_generateFragmentUniform", this).call(this)), uniforms);
      }
    }, {
      key: "_generateMacros",
      value: function _generateMacros() {
        var macros = _get(_getPrototypeOf(TransparentMaterial.prototype), "_generateMacros", this).call(this);

        if (this.texture instanceof Texture2D) macros.push("O3_DIFFUSE_TEXTURE");
        return macros;
      }
    }, {
      key: "texture",
      set: function set(v) {
        this.setValue("u_diffuse", v);
      },
      get: function get() {
        return this.getValue("u_diffuse");
      }
    }]);

    return TransparentMaterial;
  }(CommonMaterial);

  TransparentMaterial.TECH_NAME = "Transparent";

  var ShaderMaterial = /*#__PURE__*/function (_Material3) {
    _inherits(ShaderMaterial, _Material3);

    var _super53 = _createSuper(ShaderMaterial);

    function ShaderMaterial(engine, name) {
      var _this56;

      _classCallCheck(this, ShaderMaterial);

      _this56 = _super53.call(this, engine, name);
      _this56.vertexShader = "";
      _this56.fragmentShader = "";
      _this56.isValid = true;
      _this56.attributes = {};
      _this56._uniforms = ShaderMaterial.commonUniforms;
      _this56._renderStates = {
        enable: [],
        disable: [],
        functions: {}
      };
      _this56._enableConfig = [];
      _this56._disableConfig = [];
      _this56._functionsConfig = {
        blendFunc: [exports.BlendFunc.SRC_ALPHA, exports.BlendFunc.ONE_MINUS_SRC_ALPHA]
      };
      return _this56;
    }

    _createClass(ShaderMaterial, [{
      key: "prepareDrawing",
      value: function prepareDrawing(context, component, primitive) {
        var camera = context.camera;

        if (!this._technique) {
          var tech = this._generateTechnique(camera, component, primitive);

          this._technique = tech;
        }

        _get(_getPrototypeOf(ShaderMaterial.prototype), "prepareDrawing", this).call(this, context, component, primitive);
      }
    }, {
      key: "updateTechnique",
      value: function updateTechnique() {
        this._technique = null;
      }
    }, {
      key: "_generateTechnique",
      value: function _generateTechnique(camera, component, primitive) {
        var tech = new RenderTechnique("ShaderMaterial");
        tech.isValid = this.isValid;
        tech.uniforms = this.uniforms;
        tech.attributes = this.attributes;
        tech.states = this.renderStates;
        tech.vertexShader = this.vertexShader;
        tech.fragmentShader = this.fragmentShader;
        return tech;
      }
    }, {
      key: "addState",
      value: function addState(key, state) {
        this.renderStates[key] = union(this.renderStates[key], state);
      }
    }, {
      key: "removeState",
      value: function removeState(key, state) {
        this.renderStates[key] = this.renderStates[key].filter(function (value) {
          return value !== state;
        });
      }
    }, {
      key: "renderStates",
      get: function get() {
        return this._renderStates;
      },
      set: function set(value) {
        var _value$enable = value.enable,
            enable = _value$enable === void 0 ? [] : _value$enable,
            _value$disable = value.disable,
            disable = _value$disable === void 0 ? [] : _value$disable,
            _value$functions = value.functions,
            functions = _value$functions === void 0 ? {} : _value$functions;
        var enableState = enable.filter(function (value2) {
          return ShaderMaterial.commonEnable.indexOf(value2) < 0;
        });
        var disableState = disable.filter(function (value2) {
          return ShaderMaterial.commonDisable.indexOf(value2) < 0;
        });
        this._renderStates.enable = union(enableState, this._enableConfig);
        this._renderStates.disable = union(disableState, this._disableConfig);
        this._renderStates.functions = _extends({}, functions, this._functionsConfig);
      }
    }, {
      key: "uniforms",
      get: function get() {
        return this._uniforms;
      },
      set: function set(value) {
        this._uniforms = _extends({}, ShaderMaterial.commonUniforms, value);
      }
    }, {
      key: "blend",
      set: function set(value) {
        if (value) {
          this._enableConfig = union(this._enableConfig, [exports.RenderState.BLEND]);
        } else {
          this._enableConfig = this._enableConfig.filter(function (state) {
            return state !== exports.RenderState.BLEND;
          });
          this.removeState("enable", exports.RenderState.BLEND);
        }

        this.renderStates = this._renderStates;
      }
    }, {
      key: "blendSrcFactor",
      set: function set(value) {
        this._functionsConfig.blendFunc[0] = value;
        this.renderStates = this._renderStates;
      }
    }, {
      key: "blendDstFactor",
      set: function set(value) {
        this._functionsConfig.blendFunc[1] = value;
        this.renderStates = this._renderStates;
      }
    }, {
      key: "doubleSide",
      set: function set(value) {
        if (value) {
          this._disableConfig = union(this._disableConfig, [exports.RenderState.CULL_FACE]);
        } else {
          this._disableConfig = this._disableConfig.filter(function (state) {
            return state !== exports.RenderState.CULL_FACE;
          });
          this.removeState("disable", exports.RenderState.CULL_FACE);
        }

        this.renderStates = this._renderStates;
      }
    }, {
      key: "depthTest",
      set: function set(value) {
        if (!value) {
          this._disableConfig = union(this._disableConfig, [exports.RenderState.DEPTH_TEST]);
        } else {
          this._disableConfig = this._disableConfig.filter(function (state) {
            return state !== exports.RenderState.DEPTH_TEST;
          });
          this.removeState("disable", exports.RenderState.DEPTH_TEST);
        }

        this.renderStates = this._renderStates;
      }
    }]);

    return ShaderMaterial;
  }(Material);

  ShaderMaterial.commonUniforms = {
    matModelViewProjection: {
      name: "matModelViewProjection",
      semantic: exports.UniformSemantic.MODELVIEWPROJECTION,
      type: exports.DataType.FLOAT_MAT4
    },
    matModelView: {
      name: "matModelView",
      semantic: exports.UniformSemantic.MODELVIEW,
      type: exports.DataType.FLOAT_MAT4
    }
  };
  ShaderMaterial.commonEnable = [exports.RenderState.BLEND];
  ShaderMaterial.commonDisable = [exports.RenderState.CULL_FACE, exports.RenderState.DEPTH_TEST];

  function union(arr1, arr2) {
    return arr1.concat(arr2.filter(function (v) {
      return !(arr1.indexOf(v) > -1);
    }));
  }

  var BufferGeometry = /*#__PURE__*/function (_EngineObject6) {
    _inherits(BufferGeometry, _EngineObject6);

    var _super54 = _createSuper(BufferGeometry);

    function BufferGeometry(engine, name) {
      var _this57;

      _classCallCheck(this, BufferGeometry);

      _this57 = _super54.call(this, engine);
      _this57._subGeometries = [];
      _this57._primitive = new Primitive(engine);
      _this57.name = name;
      return _this57;
    }

    _createClass(BufferGeometry, [{
      key: "setVertexBufferBinding",
      value: function setVertexBufferBinding(bufferOrBinding) {
        var stride = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var firstIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

        this._primitive.setVertexBufferBinding(bufferOrBinding, stride, firstIndex);
      }
    }, {
      key: "setVertexBufferBindings",
      value: function setVertexBufferBindings(vertexBufferBindings) {
        var firstIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        this._primitive.setVertexBufferBindings(vertexBufferBindings, firstIndex);
      }
    }, {
      key: "setIndexBufferBinding",
      value: function setIndexBufferBinding(bufferOrBinding, format) {
        this._primitive.setIndexBufferBinding(bufferOrBinding, format);
      }
    }, {
      key: "setVertexElements",
      value: function setVertexElements(elements) {
        this._primitive.setVertexElements(elements);
      }
    }, {
      key: "addSubGeometry",
      value: function addSubGeometry(start, count) {
        var topology = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : exports.PrimitiveTopology.Triangles;
        var subGeometry = new SubPrimitive(start, count, topology);

        this._subGeometries.push(subGeometry);

        return subGeometry;
      }
    }, {
      key: "removeSubGeometry",
      value: function removeSubGeometry(subGeometry) {
        var subGeometries = this._subGeometries;
        var index = subGeometries.indexOf(subGeometry);

        if (index !== -1) {
          subGeometries.splice(index, 1);
        }
      }
    }, {
      key: "clearSubGeometry",
      value: function clearSubGeometry() {
        this._subGeometries.length = 0;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        if (this._primitive) {
          this._primitive.destroy();

          this._primitive = null;
        }
      }
    }, {
      key: "vertexBufferBindings",
      get: function get() {
        return this._primitive.vertexBufferBindings;
      }
    }, {
      key: "indexBufferBinding",
      get: function get() {
        return this._primitive.indexBufferBinding;
      }
    }, {
      key: "vertexElements",
      get: function get() {
        return this._primitive.vertexElements;
      }
    }, {
      key: "subGeometry",
      get: function get() {
        return this._subGeometries[0] || null;
      }
    }, {
      key: "subGeometries",
      get: function get() {
        return this._subGeometries;
      }
    }, {
      key: "instanceCount",
      get: function get() {
        return this._primitive.instanceCount;
      },
      set: function set(count) {
        this._primitive.instanceCount = count;
      }
    }, {
      key: "bounds",
      get: function get() {
        return this._bounds;
      },
      set: function set(value) {
        this._bounds = value;
      }
    }]);

    return BufferGeometry;
  }(EngineObject);

  var GeometryRenderer = /*#__PURE__*/function (_RenderableComponent4) {
    _inherits(GeometryRenderer, _RenderableComponent4);

    var _super55 = _createSuper(GeometryRenderer);

    function GeometryRenderer() {
      _classCallCheck(this, GeometryRenderer);

      return _super55.apply(this, arguments);
    }

    _createClass(GeometryRenderer, [{
      key: "render",
      value: function render(camera) {
        var geometry = this.geometry;

        if (geometry) {
          var subGeometries = geometry.subGeometries;
          var renderPipeline = camera._renderPipeline;
          var material = this._material;

          for (var i = 0, n = subGeometries.length; i < n; i++) {
            if (material) {
              var element = RenderElement.getFromPool();
              element.setValue(this, geometry._primitive, subGeometries[i], material);
              renderPipeline.pushPrimitive(element);
            }
          }
        } else {
          Logger.error("geometry is null.");
        }
      }
    }, {
      key: "_updateBounds",
      value: function _updateBounds(worldBounds) {
        var localBounds = this._geometry.bounds;

        if (localBounds) {
          var worldMatrix = this._entity.transform.worldMatrix;
          Vector3.transformCoordinate(localBounds.min, worldMatrix, worldBounds.min);
          Vector3.transformCoordinate(localBounds.max, worldMatrix, worldBounds.max);
        } else {
          worldBounds.min.setValue(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);
          worldBounds.max.setValue(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);
        }
      }
    }, {
      key: "geometry",
      set: function set(value) {
        if (this._geometry) {
          this._geometry._primitive._addRefCount(-1);
        }

        value._primitive._addRefCount(1);

        this._geometry = value;
      },
      get: function get() {
        return this._geometry;
      }
    }, {
      key: "material",
      set: function set(value) {
        if (this._material) {
          this._material._addRefCount(-1);
        }

        value._addRefCount(1);

        this._material = value;
      },
      get: function get() {
        return this._material;
      }
    }]);

    return GeometryRenderer;
  }(RenderableComponent);

  var ShapeGeometry = /*#__PURE__*/function (_BufferGeometry) {
    _inherits(ShapeGeometry, _BufferGeometry);

    var _super56 = _createSuper(ShapeGeometry);

    function ShapeGeometry() {
      _classCallCheck(this, ShapeGeometry);

      return _super56.apply(this, arguments);
    }

    _createClass(ShapeGeometry, [{
      key: "_initialize",
      value: function _initialize(engine, vertices, indices) {
        var vertexStride = 32;
        var vertexElements = [new VertexElement("POSITION", 0, exports.VertexElementFormat.Vector3, 0), new VertexElement("NORMAL", 12, exports.VertexElementFormat.Vector3, 0), new VertexElement("TEXCOORD_0", 24, exports.VertexElementFormat.Vector2, 0)];

        this._initBuffer(engine, vertices, indices, vertexStride, vertexElements);
      }
    }, {
      key: "_initBuffer",
      value: function _initBuffer(engine, vertices, indices, vertexStride, vertexElements) {
        var positionElement = vertexElements[0];
        var vertexBuffer = new Buffer(engine, exports.BufferBindFlag.VertexBuffer, vertices, exports.BufferUsage.Static);
        var indexBuffer = new Buffer(engine, exports.BufferBindFlag.IndexBuffer, indices, exports.BufferUsage.Static);
        this.setVertexBufferBinding(vertexBuffer, vertexStride);
        this.setIndexBufferBinding(indexBuffer, exports.IndexFormat.UInt16);
        this.setVertexElements(vertexElements);
        this.addSubGeometry(0, indices.length);

        this._computeBounds(positionElement, vertices);
      }
    }, {
      key: "_computeBounds",
      value: function _computeBounds(positionElement, vertices) {
        var vertexElement = positionElement;
        var bufferIndex = vertexElement.bindingIndex;
        var vertexBufferBinding = this._primitive.vertexBufferBindings[bufferIndex];
        var stride = vertexBufferBinding.stride;
        var offset = vertexElement.offset;
        var vertexCount = vertexBufferBinding.buffer.byteLength / stride;
        var arrayBuffer = vertices;

        if (!(arrayBuffer instanceof ArrayBuffer)) {
          arrayBuffer = arrayBuffer.buffer;
        }

        var dataView = new DataView(arrayBuffer, offset);
        var min = new Vector3(Infinity, Infinity, Infinity);
        var max = new Vector3(-Infinity, -Infinity, -Infinity);

        for (var i = 0; i < vertexCount; i++) {
          var base = offset + stride * i;
          var position = new Vector3(dataView.getFloat32(base, true), dataView.getFloat32(base + 4, true), dataView.getFloat32(base + 8, true));
          Vector3.min(min, position, min);
          Vector3.max(max, position, max);
        }

        var bounds = this.bounds;

        if (bounds) {
          min.cloneTo(bounds.min);
          max.cloneTo(bounds.max);
        } else {
          bounds = {
            min: min,
            max: max
          };
          this.bounds = bounds;
        }
      }
    }]);

    return ShapeGeometry;
  }(BufferGeometry);

  var CuboidGeometry = /*#__PURE__*/function (_ShapeGeometry) {
    _inherits(CuboidGeometry, _ShapeGeometry);

    var _super57 = _createSuper(CuboidGeometry);

    function CuboidGeometry(engine) {
      var _this58;

      var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      var depth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

      _classCallCheck(this, CuboidGeometry);

      _this58 = _super57.call(this, engine);
      var halfWidth = width / 2;
      var halfHeight = height / 2;
      var halfDepth = depth / 2;
      var vertices = new Float32Array([-halfWidth, halfHeight, -halfDepth, 0, 1, 0, 0, 0, halfWidth, halfHeight, -halfDepth, 0, 1, 0, 1, 0, halfWidth, halfHeight, halfDepth, 0, 1, 0, 1, 1, -halfWidth, halfHeight, halfDepth, 0, 1, 0, 0, 1, -halfWidth, -halfHeight, -halfDepth, 0, -1, 0, 0, 1, halfWidth, -halfHeight, -halfDepth, 0, -1, 0, 1, 1, halfWidth, -halfHeight, halfDepth, 0, -1, 0, 1, 0, -halfWidth, -halfHeight, halfDepth, 0, -1, 0, 0, 0, -halfWidth, halfHeight, -halfDepth, -1, 0, 0, 0, 0, -halfWidth, halfHeight, halfDepth, -1, 0, 0, 1, 0, -halfWidth, -halfHeight, halfDepth, -1, 0, 0, 1, 1, -halfWidth, -halfHeight, -halfDepth, -1, 0, 0, 0, 1, halfWidth, halfHeight, -halfDepth, 1, 0, 0, 1, 0, halfWidth, halfHeight, halfDepth, 1, 0, 0, 0, 0, halfWidth, -halfHeight, halfDepth, 1, 0, 0, 0, 1, halfWidth, -halfHeight, -halfDepth, 1, 0, 0, 1, 1, -halfWidth, halfHeight, halfDepth, 0, 0, 1, 0, 0, halfWidth, halfHeight, halfDepth, 0, 0, 1, 1, 0, halfWidth, -halfHeight, halfDepth, 0, 0, 1, 1, 1, -halfWidth, -halfHeight, halfDepth, 0, 0, 1, 0, 1, -halfWidth, halfHeight, -halfDepth, 0, 0, -1, 1, 0, halfWidth, halfHeight, -halfDepth, 0, 0, -1, 0, 0, halfWidth, -halfHeight, -halfDepth, 0, 0, -1, 0, 1, -halfWidth, -halfHeight, -halfDepth, 0, 0, -1, 1, 1]);
      var indices = new Uint16Array([0, 2, 1, 2, 0, 3, 4, 6, 7, 6, 4, 5, 8, 10, 9, 10, 8, 11, 12, 14, 15, 14, 12, 13, 16, 18, 17, 18, 16, 19, 20, 22, 23, 22, 20, 21]);

      _this58._initialize(engine, vertices, indices);

      return _this58;
    }

    return CuboidGeometry;
  }(ShapeGeometry);

  var SphereGeometry = /*#__PURE__*/function (_ShapeGeometry2) {
    _inherits(SphereGeometry, _ShapeGeometry2);

    var _super58 = _createSuper(SphereGeometry);

    function SphereGeometry(engine) {
      var _this59;

      var radius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var horizontalSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 8;
      var verticalSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 6;
      var alphaStart = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var alphaRange = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : Math.PI * 2;
      var thetaStart = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
      var thetaRange = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : Math.PI;

      _classCallCheck(this, SphereGeometry);

      _this59 = _super58.call(this, engine);
      _this59._parameters = {
        radius: radius || 1,
        horizontalSegments: Math.max(3, Math.floor(horizontalSegments)),
        verticalSegments: Math.max(2, Math.floor(verticalSegments)),
        alphaStart: alphaStart,
        alphaRange: alphaRange,
        thetaStart: thetaStart,
        thetaRange: thetaRange
      };
      _this59._thetaEnd = _this59._parameters.thetaStart + _this59._parameters.thetaRange;

      _this59.initialize(engine);

      return _this59;
    }

    _createClass(SphereGeometry, [{
      key: "initialize",
      value: function initialize(engine) {
        var _this$_parameters = this._parameters,
            verticalSegments = _this$_parameters.verticalSegments,
            horizontalSegments = _this$_parameters.horizontalSegments;
        var index = 0;
        var grid = [];
        var vertices = new Float32Array((verticalSegments + 1) * (horizontalSegments + 1) * 8);
        var indices = [];

        for (var iy = 0; iy <= verticalSegments; iy++) {
          var verticesRow = [];
          var v = iy / verticalSegments;

          for (var ix = 0; ix <= horizontalSegments; ix++) {
            var u = ix / horizontalSegments;
            var posX = -this._parameters.radius * Math.cos(this._parameters.alphaStart + u * this._parameters.alphaRange) * Math.sin(this._parameters.thetaStart + v * this._parameters.thetaRange);
            var posY = this._parameters.radius * Math.cos(this._parameters.thetaStart + v * this._parameters.thetaRange);
            var posZ = this._parameters.radius * Math.sin(this._parameters.alphaStart + u * this._parameters.alphaRange) * Math.sin(this._parameters.thetaStart + v * this._parameters.thetaRange);
            posX = Math.abs(posX) < 1e-6 ? 0 : posX;
            posY = Math.abs(posY) < 1e-6 ? 0 : posY;
            posZ = Math.abs(posZ) < 1e-6 ? 0 : posZ;
            var offset = index * 8;
            vertices[offset] = posX;
            vertices[offset + 1] = posY;
            vertices[offset + 2] = posZ;
            vertices[offset + 3] = posX;
            vertices[offset + 4] = posY;
            vertices[offset + 5] = posZ;
            vertices[offset + 6] = u;
            vertices[offset + 7] = 1 - v;
            verticesRow.push(index++);
          }

          grid.push(verticesRow);
        }

        for (var _iy = 0; _iy < verticalSegments; _iy++) {
          for (var _ix = 0; _ix < horizontalSegments; _ix++) {
            var a = grid[_iy][_ix + 1];
            var b = grid[_iy][_ix];
            var c = grid[_iy + 1][_ix];
            var d = grid[_iy + 1][_ix + 1];
            if (_iy !== 0 || this._parameters.thetaStart > 0) indices.push(a, b, d);
            if (_iy !== verticalSegments - 1 || this._thetaEnd < Math.PI) indices.push(b, c, d);
          }
        }

        this._initialize(engine, vertices, Uint16Array.from(indices));
      }
    }]);

    return SphereGeometry;
  }(ShapeGeometry);

  var PlaneGeometry = /*#__PURE__*/function (_ShapeGeometry3) {
    _inherits(PlaneGeometry, _ShapeGeometry3);

    var _super59 = _createSuper(PlaneGeometry);

    function PlaneGeometry(engine) {
      var _this60;

      var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      var horizontalSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      var verticalSegments = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;

      _classCallCheck(this, PlaneGeometry);

      _this60 = _super59.call(this, engine);
      _this60._parameters = {
        width: width,
        height: height,
        horizontalSegments: Math.floor(horizontalSegments),
        verticalSegments: Math.floor(verticalSegments)
      };
      _this60.halfWidth = _this60._parameters.width / 2;
      _this60.halfHeight = _this60._parameters.height / 2;

      _this60.initialize(engine);

      return _this60;
    }

    _createClass(PlaneGeometry, [{
      key: "initialize",
      value: function initialize(engine) {
        var _this$_parameters2 = this._parameters,
            verticalSegments = _this$_parameters2.verticalSegments,
            horizontalSegments = _this$_parameters2.horizontalSegments;
        var index = 0;
        var offset = 0;
        var grid = [];
        var vertices = new Float32Array((verticalSegments + 1) * (horizontalSegments + 1) * 8);
        var indices = new Uint16Array(verticalSegments * horizontalSegments * 6);

        for (var iy = 0; iy <= verticalSegments; iy++) {
          var verticesRow = [];
          var v = iy / verticalSegments;

          for (var ix = 0; ix <= horizontalSegments; ix++) {
            var u = ix / horizontalSegments;
            var posX = u * this._parameters.width - this.halfWidth;
            var posY = v * this._parameters.height - this.halfHeight;
            vertices[offset++] = posX;
            vertices[offset++] = posY;
            vertices[offset++] = 0;
            vertices[offset++] = 0;
            vertices[offset++] = 0;
            vertices[offset++] = 1;
            vertices[offset++] = u;
            vertices[offset++] = 1 - v;
            verticesRow.push(index++);
          }

          grid.push(verticesRow);
        }

        index = 0;

        for (var _iy2 = 0; _iy2 < verticalSegments; _iy2++) {
          for (var _ix2 = 0; _ix2 < horizontalSegments; _ix2++) {
            var a = grid[_iy2][_ix2 + 1];
            var b = grid[_iy2][_ix2];
            var c = grid[_iy2 + 1][_ix2];
            var d = grid[_iy2 + 1][_ix2 + 1];
            indices[index++] = a;
            indices[index++] = c;
            indices[index++] = b;
            indices[index++] = a;
            indices[index++] = d;
            indices[index++] = c;
          }
        }

        this._initialize(engine, vertices, indices);
      }
    }]);

    return PlaneGeometry;
  }(ShapeGeometry);

  var CylinderGeometry = /*#__PURE__*/function (_ShapeGeometry4) {
    _inherits(CylinderGeometry, _ShapeGeometry4);

    var _super60 = _createSuper(CylinderGeometry);

    function CylinderGeometry(engine) {
      var _this61;

      var radiusTop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var radiusBottom = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      var height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      var radialSegments = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 8;
      var heightSegments = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;
      var openEnded = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
      var thetaStart = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
      var thetaLength = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 2 * Math.PI;
      var frontFace = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : exports.FrontFace.CCW;

      _classCallCheck(this, CylinderGeometry);

      _this61 = _super60.call(this, engine);
      _this61.FrontFace = frontFace;
      _this61._parameters = {
        radiusTop: radiusTop,
        radiusBottom: radiusBottom,
        height: height,
        radialSegments: radialSegments,
        heightSegments: heightSegments,
        openEnded: openEnded,
        thetaStart: thetaStart,
        thetaLength: thetaLength
      };
      _this61._vertices = [];
      _this61._indices = [];
      _this61.index = 0;
      _this61.indexArray = [];
      _this61.halfHeight = _this61._parameters.height / 2;

      _this61.generateTorso();

      if (_this61._parameters.openEnded === false) {
        if (_this61._parameters.radiusTop > 0) _this61.generateCap(true);
        if (_this61._parameters.radiusBottom > 0) _this61.generateCap(false);
      }

      _this61._initialize(engine, Float32Array.from(_this61._vertices), Uint16Array.from(_this61._indices));

      return _this61;
    }

    _createClass(CylinderGeometry, [{
      key: "generateTorso",
      value: function generateTorso() {
        var _this$_parameters3 = this._parameters,
            radialSegments = _this$_parameters3.radialSegments,
            heightSegments = _this$_parameters3.heightSegments,
            radiusBottom = _this$_parameters3.radiusBottom,
            radiusTop = _this$_parameters3.radiusTop,
            height = _this$_parameters3.height;
        var x, y;
        var normal = new Vector3();
        var slope = (radiusBottom - radiusTop) / height;

        for (y = 0; y <= heightSegments; y++) {
          var indexRow = [];
          var v = y / heightSegments;
          var radius = v * (radiusBottom - radiusTop) + radiusTop;

          for (x = 0; x <= radialSegments; x++) {
            var u = x / radialSegments;
            var theta = u * this._parameters.thetaLength + this._parameters.thetaStart;
            var sinTheta = Math.sin(theta);
            var cosTheta = Math.cos(theta);
            var vertX = radius * sinTheta;
            var vertY = -v * height + this.halfHeight;
            var vertZ = radius * cosTheta;

            this._vertices.push(vertX, vertY, vertZ);

            normal.setValue(sinTheta, slope, cosTheta);
            normal.normalize();

            this._vertices.push(normal.x, normal.y, normal.z);

            if (this.FrontFace === exports.FrontFace.CCW) {
              this._vertices.push(u, v);
            } else {
              this._vertices.push(1 - u, v);
            }

            indexRow.push(this.index++);
          }

          this.indexArray.push(indexRow);
        }

        for (x = 0; x < radialSegments; x++) {
          for (y = 0; y < heightSegments; y++) {
            var a = this.indexArray[y][x];
            var b = this.indexArray[y + 1][x];
            var c = this.indexArray[y + 1][x + 1];
            var d = this.indexArray[y][x + 1];

            this._indices.push(a, b, d);

            this._indices.push(b, c, d);
          }
        }
      }
    }, {
      key: "generateCap",
      value: function generateCap(isTop) {
        var radialSegments = this._parameters.radialSegments;
        var x;
        var radius = isTop === true ? this._parameters.radiusTop : this._parameters.radiusBottom;
        var sign = isTop === true ? 1 : -1;
        var centerIndexStart = this.index;

        for (x = 1; x <= radialSegments; x++) {
          this._vertices.push(0, this.halfHeight * sign, 0);

          this._vertices.push(0, sign, 0);

          this._vertices.push(0.5, 0.5);

          this.index++;
        }

        var centerIndexEnd = this.index;

        for (x = 0; x <= radialSegments; x++) {
          var u = x / radialSegments;
          var theta = u * this._parameters.thetaLength + this._parameters.thetaStart;
          var cosTheta = Math.cos(theta);
          var sinTheta = Math.sin(theta);
          var vertexX = radius * sinTheta;
          var vertexY = this.halfHeight * sign;
          var vertexZ = radius * cosTheta;

          this._vertices.push(vertexX, vertexY, vertexZ);

          this._vertices.push(0, sign, 0);

          var uvX = cosTheta * 0.5 + 0.5;
          var uvY = sinTheta * 0.5 * sign + 0.5;

          this._vertices.push(uvX, uvY);

          this.index++;
        }

        for (x = 0; x < radialSegments; x++) {
          var c = centerIndexStart + x;
          var i = centerIndexEnd + x;

          if (isTop === true) {
            this._indices.push(i, i + 1, c);
          } else {
            this._indices.push(i + 1, i, c);
          }
        }
      }
    }]);

    return CylinderGeometry;
  }(ShapeGeometry);

  var CircleGeometry = /*#__PURE__*/function (_ShapeGeometry5) {
    _inherits(CircleGeometry, _ShapeGeometry5);

    var _super61 = _createSuper(CircleGeometry);

    function CircleGeometry(engine) {
      var _this62;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, CircleGeometry);

      _this62 = _super61.call(this, engine);
      _this62.radius = 1;
      _this62.segments = 16;
      _this62.thetaStart = 0;
      _this62.thetaLength = Math.PI * 2;
      _this62.radius = options.radius || _this62.radius;
      _this62.segments = options.segments || _this62.segments;
      _this62.thetaStart = options.thetaStart || _this62.thetaStart;
      _this62.thetaLength = options.thetaLength || _this62.thetaLength;

      var _assertThisInitialize = _assertThisInitialized(_this62),
          segments = _assertThisInitialize.segments,
          radius = _assertThisInitialize.radius;

      var vertices = new Float32Array((segments + 2) * 8);
      vertices.set([0, 0, 0, 0, 0, 1, 0.5, 0.5]);
      var index = 8;

      for (var s = 0; s <= segments; s++) {
        var segment = _this62.thetaStart + s / segments * _this62.thetaLength;
        var x = radius * Math.cos(segment);
        var y = radius * Math.sin(segment);
        vertices[index++] = x;
        vertices[index++] = y;
        vertices[index++] = 0;
        vertices[index++] = 0;
        vertices[index++] = 0;
        vertices[index++] = 1;
        vertices[index++] = (x / radius + 1) * 0.5;
        vertices[index++] = (y / radius + 1) * 0.5;
      }

      var indices = new Uint16Array(segments * 3);
      index = 0;

      for (var i = 1; i <= segments; i++) {
        indices[index++] = i;
        indices[index++] = i + 1;
        indices[index++] = 0;
      }

      _this62._initialize(engine, vertices, indices);

      return _this62;
    }

    return CircleGeometry;
  }(ShapeGeometry);

  var ScreenQuadGeometry = /*#__PURE__*/function (_ShapeGeometry6) {
    _inherits(ScreenQuadGeometry, _ShapeGeometry6);

    var _super62 = _createSuper(ScreenQuadGeometry);

    function ScreenQuadGeometry(engine) {
      var _this63;

      _classCallCheck(this, ScreenQuadGeometry);

      _this63 = _super62.call(this, engine);
      var vertices = new Float32Array([-1, -1, 0, 0, 0, 1, -1, 0, 1, 0, 1, 1, 0, 1, 1, -1, 1, 0, 0, 1]);
      var indices = new Uint16Array([0, 1, 2, 3]);

      _this63._initialize(engine, vertices, indices);

      _this63.subGeometry.topology = exports.PrimitiveTopology.TriangleFan;
      return _this63;
    }

    _createClass(ScreenQuadGeometry, [{
      key: "_initialize",
      value: function _initialize(engine, vertices, indices) {
        var vertexStride = 20;
        var vertexElements = [new VertexElement("POSITION", 0, exports.VertexElementFormat.Vector3, 0), new VertexElement("TEXCOORD_0", 12, exports.VertexElementFormat.Vector2, 0)];

        this._initBuffer(engine, vertices, indices, vertexStride, vertexElements);
      }
    }]);

    return ScreenQuadGeometry;
  }(ShapeGeometry);

  var TorusGeometry = /*#__PURE__*/function (_ShapeGeometry7) {
    _inherits(TorusGeometry, _ShapeGeometry7);

    var _super63 = _createSuper(TorusGeometry);

    function TorusGeometry() {
      var _this64;

      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var engine = arguments.length > 1 ? arguments[1] : undefined;

      _classCallCheck(this, TorusGeometry);

      _this64 = _super63.call(this, engine);
      _this64.parameters = parameters;
      var radius = _this64.parameters.radius || 1;
      var tube = _this64.parameters.tube || 0.4;
      var radialSegments = Math.floor(_this64.parameters.radialSegments) || 8;
      var tubularSegments = Math.floor(_this64.parameters.tubularSegments) || 6;
      var arc = _this64.parameters.arc || Math.PI * 2;
      var vertices = new Float32Array((radialSegments + 1) * (tubularSegments + 1) * 3);
      var indices = new Uint16Array(radialSegments * tubularSegments * 6);
      var index = 0;

      for (var j = 0; j <= radialSegments; j++) {
        for (var i = 0; i <= tubularSegments; i++) {
          var u = i / tubularSegments * arc;
          var v = j / radialSegments * Math.PI * 2;
          vertices[index++] = (radius + tube * Math.cos(v)) * Math.cos(u);
          vertices[index++] = (radius + tube * Math.cos(v)) * Math.sin(u);
          vertices[index++] = tube * Math.sin(v);
        }
      }

      index = 0;

      for (var _j = 1; _j <= radialSegments; _j++) {
        for (var _i19 = 1; _i19 <= tubularSegments; _i19++) {
          var a = (tubularSegments + 1) * _j + _i19 - 1;
          var b = (tubularSegments + 1) * (_j - 1) + _i19 - 1;
          var c = (tubularSegments + 1) * (_j - 1) + _i19;
          var d = (tubularSegments + 1) * _j + _i19;
          indices[index++] = a;
          indices[index++] = b;
          indices[index++] = d;
          indices[index++] = b;
          indices[index++] = c;
          indices[index++] = d;
        }
      }

      _this64._initialize(engine, vertices, indices);

      return _this64;
    }

    _createClass(TorusGeometry, [{
      key: "_initialize",
      value: function _initialize(engine, vertices, indices) {
        var vertexStride = 12;
        var vertexElements = [new VertexElement("POSITION", 0, exports.VertexElementFormat.Vector3, 0)];

        this._initBuffer(engine, vertices, indices, vertexStride, vertexElements);
      }
    }]);

    return TorusGeometry;
  }(ShapeGeometry);

  var Model = /*#__PURE__*/function (_GeometryRenderer) {
    _inherits(Model, _GeometryRenderer);

    var _super64 = _createSuper(Model);

    _createClass(Model, [{
      key: "geometryType",
      set: function set(value) {
        switch (value) {
          case "Sphere":
            var _this$_props = this._props,
                sphereRadius = _this$_props.sphereRadius,
                sphereHorizontalSegments = _this$_props.sphereHorizontalSegments,
                sphereVerticalSegments = _this$_props.sphereVerticalSegments,
                sphereAlphaStart = _this$_props.sphereAlphaStart,
                sphereAlphaRange = _this$_props.sphereAlphaRange,
                sphereThetaStart = _this$_props.sphereThetaStart,
                sphereThetaRange = _this$_props.sphereThetaRange;
            this.geometry = new SphereGeometry(this.engine, sphereRadius, sphereHorizontalSegments, sphereVerticalSegments, sphereAlphaStart, sphereAlphaRange, sphereThetaStart, sphereThetaRange);
            break;

          case "Cylinder":
            var _this$_props2 = this._props,
                cylinderRadiusTop = _this$_props2.cylinderRadiusTop,
                cylinderRadiusBottom = _this$_props2.cylinderRadiusBottom,
                cylinderHeight = _this$_props2.cylinderHeight,
                cylinderRadialSegments = _this$_props2.cylinderRadialSegments,
                cylinderHeightSegments = _this$_props2.cylinderHeightSegments,
                cylinderOpenEnded = _this$_props2.cylinderOpenEnded;
            this.geometry = new CylinderGeometry(this.engine, cylinderRadiusTop, cylinderRadiusBottom, cylinderHeight, cylinderRadialSegments, cylinderHeightSegments, cylinderOpenEnded, void 0, void 0, void 0);
            break;

          case "Plane":
            var _this$_props3 = this._props,
                planeWidth = _this$_props3.planeWidth,
                planeHeight = _this$_props3.planeHeight,
                planeHorizontalSegments = _this$_props3.planeHorizontalSegments,
                planeVerticalSegments = _this$_props3.planeVerticalSegments;
            this.geometry = new PlaneGeometry(this.engine, planeWidth, planeHeight, planeHorizontalSegments, planeVerticalSegments);
            break;

          case "Box":
            var _this$_props4 = this._props,
                boxWidth = _this$_props4.boxWidth,
                boxHeight = _this$_props4.boxHeight,
                boxDepth = _this$_props4.boxDepth;
            this.geometry = new CuboidGeometry(this.engine, boxWidth, boxHeight, boxDepth);
            break;
        }

        this._geometryType = value;
      },
      get: function get() {
        return this._geometryType;
      }
    }]);

    function Model(entity) {
      _classCallCheck(this, Model);

      return _super64.call(this, entity);
    }

    _createClass(Model, [{
      key: "init",
      value: function init(props) {
        this._props = props;
        var _props$geometryType = props.geometryType,
            geometryType = _props$geometryType === void 0 ? GeometryType.Box : _props$geometryType;
        this.material = props.material;
        this.geometryType = geometryType;
      }
    }, {
      key: "setProp",
      value: function setProp(key, value) {
        this._props[key] = value;

        if (key === "material") {
          this.material = value;
        } else {
          this.geometryType = this._props.geometryType;
        }
      }
    }, {
      key: "material",
      get: function get() {
        return this._material;
      },
      set: function set(mtl) {
        if (!mtl) {
          this._material = new BlinnPhongMaterial(this.engine, "mtl");
        } else {
          this._material = mtl;
        }
      }
    }]);

    return Model;
  }(GeometryRenderer);

  var GeometryType;

  (function (GeometryType2) {
    GeometryType2["Box"] = "Box";
    GeometryType2["Cylinder"] = "Cylinder";
    GeometryType2["Plane"] = "Plane";
    GeometryType2["Sphere"] = "Sphere";
  })(GeometryType || (GeometryType = {}));

  var fs = "uniform samplerCube u_cube;\n\nvarying vec3 v_cubeUV;\n\nvoid main() {\n\n    gl_FragColor = textureCube( u_cube, v_cubeUV );\n\n}\n";
  var vs = "#include <common_vert>\n\nuniform mat4 u_mvpNoscale;\n\nvarying vec3 v_cubeUV;\n\nvoid main() {\n\n    v_cubeUV = a_position.xyz;\n    gl_Position = u_mvpNoscale * vec4( a_position, 1.0 );\n    gl_Position.z = gl_Position.w;\n\n}\n";

  var SkyBoxMaterial = /*#__PURE__*/function (_Material4) {
    _inherits(SkyBoxMaterial, _Material4);

    var _super65 = _createSuper(SkyBoxMaterial);

    function SkyBoxMaterial(engine) {
      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SkyBoxMaterial.defaultName;

      _classCallCheck(this, SkyBoxMaterial);

      return _super65.call(this, engine, name);
    }

    _createClass(SkyBoxMaterial, [{
      key: "setModel",
      value: function setModel(modelMatrix) {
        this.modelMatrix = modelMatrix;
      }
    }, {
      key: "prepareDrawing",
      value: function prepareDrawing(context, component) {
        if (this._technique === null) {
          this._generateTechnique();
        }

        if (!this._cacheMat1) {
          this._cacheMat1 = new Matrix();
          this._cacheMat2 = new Matrix();
        }

        var view = context.viewMatrix;
        var proj = context.projectionMatrix;
        Matrix.multiply(view, this.modelMatrix, this._cacheMat1);
        var e = this._cacheMat1.elements;
        e[12] = e[13] = e[14] = 0;
        Matrix.multiply(proj, this._cacheMat1, this._cacheMat2);
        this.setValue("u_mvpNoscale", this._cacheMat2);

        _get(_getPrototypeOf(SkyBoxMaterial.prototype), "prepareDrawing", this).call(this, context, component, void 0);
      }
    }, {
      key: "_generateTechnique",
      value: function _generateTechnique() {
        var tech = new RenderTechnique(SkyBoxMaterial.techniqueName);
        tech.isValid = true;
        tech.uniforms = SkyBoxMaterial.techniqueConfig.uniforms;
        tech.attributes = SkyBoxMaterial.techniqueConfig.attributes;
        tech.states = SkyBoxMaterial.techniqueConfig.states;
        tech.vertexShader = SkyBoxMaterial.vertexShader;
        tech.fragmentShader = SkyBoxMaterial.fragmentShader;
        this._technique = tech;
      }
    }]);

    return SkyBoxMaterial;
  }(Material);

  SkyBoxMaterial.defaultName = "SKY_BOX_MATERIAL";
  SkyBoxMaterial.techniqueName = "SKY_BOX_TECHNIQUE";
  SkyBoxMaterial.vertexShader = vs;
  SkyBoxMaterial.fragmentShader = fs;
  SkyBoxMaterial.techniqueConfig = {
    attributes: {},
    uniforms: {
      u_mvpNoscale: {
        name: "u_mvpNoscale",
        type: exports.DataType.FLOAT_MAT4
      },
      u_cube: {
        name: "u_cube",
        type: exports.DataType.SAMPLER_CUBE
      }
    },
    states: {
      disable: [exports.RenderState.CULL_FACE],
      functions: {
        depthFunc: exports.CompFunc.LEQUAL
      }
    }
  };

  var SkyBox = /*#__PURE__*/function (_GeometryRenderer2) {
    _inherits(SkyBox, _GeometryRenderer2);

    var _super66 = _createSuper(SkyBox);

    function SkyBox(entity) {
      var _this65;

      _classCallCheck(this, SkyBox);

      _this65 = _super66.call(this, entity);
      _this65.geometry = new CuboidGeometry(_this65.engine, 2, 2, 2);
      _this65.material = new SkyBoxMaterial(_this65.engine);
      return _this65;
    }

    _createClass(SkyBox, [{
      key: "update",
      value: function update() {
        this.material.setModel(this.entity.transform.worldMatrix);
      }
    }, {
      key: "render",
      value: function render(camera) {
        if (!this._skyBoxMap) return;

        _get(_getPrototypeOf(SkyBox.prototype), "render", this).call(this, camera);
      }
    }, {
      key: "skyBoxMap",
      get: function get() {
        return this._skyBoxMap;
      },
      set: function set(v) {
        this._skyBoxMap = v;
        this.material.setValue("u_cube", v);
      }
    }]);

    return SkyBox;
  }(GeometryRenderer);

  var fs$1 = "#include <common>\n#include <common_frag>\n#include <pbr_common_frag_define>\n#include <pbr_util_frag_define>\n\n#include <fog_share>\n\n#include <uv_share>\n#include <normal_share>\n#include <color_share>\n#include <worldpos_share>\n#include <refraction_share>\n#include <perturbation_share>\n#include <clipPlane_frag_define>\n\n// light\n#include <ambient_light_frag>\n#include <direct_light_frag>\n#include <point_light_frag>\n#include <spot_light_frag>\n#include <pbr_envmap_light_frag_define>\n\n// prop & texture\n#include <pbr_base_frag_define>\n#include <pbr_texture_frag_define>\n\n// runtime context\n#include <pbr_runtime_frag_define>\n\n// todo: generalize\n#include <pbr_normal_frag_define>\n\n\n// todo: BxDF\n#include <pbr_brdf_cook_torrance_frag_define>\n\n\n// direct + indirect\n#include <pbr_direct_irradiance_frag_define>\n#include <pbr_ibl_diffuse_frag_define>\n#include <pbr_ibl_specular_frag_define>\n\n#include <oit_frag_define>\n\n\nvoid main() {\n    #include <clipPlane_frag>\n\n    #include <pbr_begin_frag>\n    #include <pbr_direct_irradiance_frag>\n    #include <pbr_ibl_diffuse_frag>\n    #include <pbr_ibl_specular_frag>\n    // todo: generalize texture logic\n    #include <pbr_end_frag>\n    #include <gamma_frag>\n    #include <refraction_frag>\n    #include <perturbation_frag>\n    #include <fog_frag>\n\n    #include <oit_frag>\n\n    // gl_FragColor = texture2D( u_baseColorSampler, v_uv );\n}\n";
  var vs$1 = "#include <common>\n#include <common_vert>\n#include <uv_share>\n#include <color_share>\n#include <normal_share>\n#include <worldpos_share>\n#include <clipPlane_vert_define>\n#include <morph_target_vert>\n\n#include <fog_share>\n\nvoid main() {\n\n    #include <begin_position_vert>\n    #include <begin_normal_vert>\n\n    #include <morph_vert>\n    #include <skinning_vert>\n    #include <uv_vert>\n    #include <color_vert>\n    #include <normal_vert>\n    #include <worldpos_vert>\n    #include <clipPlane_vert>\n    #include <position_vert>\n\n    #include <fog_vert>\n}\n";

  var PBRMaterial = /*#__PURE__*/function (_Material5) {
    _inherits(PBRMaterial, _Material5);

    var _super67 = _createSuper(PBRMaterial);

    function PBRMaterial(engine) {
      var _this66;

      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : PBRMaterial.MATERIAL_NAME;
      var props = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      _classCallCheck(this, PBRMaterial);

      _this66 = _super67.call(this, engine, name);

      _this66.createDefaulteValues();

      _this66.setUniforms(props);

      _this66.setStates(props);

      return _this66;
    }

    _createClass(PBRMaterial, [{
      key: "createDefaulteValues",
      value: function createDefaulteValues() {
        var _this67 = this;

        this._uniformObj = {
          baseColorFactor: new Vector4(1, 1, 1, 1),
          metallicFactor: 1,
          roughnessFactor: 1,
          metallicRoughness: new Vector2(1, 1),
          normalScale: 1,
          emissiveFactor: new Vector3(0, 0, 0),
          occlusionStrength: 1,
          alphaCutoff: 0.5,
          specularFactor: new Vector3(1, 1, 1),
          glossinessFactor: 0,
          envMapIntensity: 1,
          refractionRatio: 1 / 1.33,
          refractionDepth: 1,
          perturbationUOffset: 0,
          perturbationVOffset: 0
        };
        this._stateObj = {
          alphaMode: "OPAQUE",
          doubleSided: false,
          side: exports.Side.FRONT,
          unlit: false,
          srgb: false,
          srgbFast: false,
          gamma: false,
          blendFunc: [],
          blendFuncSeparate: [exports.BlendFunc.SRC_ALPHA, exports.BlendFunc.ONE_MINUS_SRC_ALPHA, exports.BlendFunc.ONE, exports.BlendFunc.ONE],
          depthMask: [false],
          getOpacityFromRGB: false,
          isMetallicWorkflow: true,
          envMapModeRefract: false
        };
        Object.keys(this._uniformObj).forEach(function (k) {
          return _this67.setValueByParamName(k, _this67._uniformObj[k]);
        });
      }
    }, {
      key: "setUniforms",
      value: function setUniforms(obj) {
        var _this68 = this;

        Object.keys(obj).forEach(function (key) {
          switch (key) {
            case "baseColorFactor":
              _this68.baseColorFactor = obj[key];
              break;

            case "opacity":
              _this68.opacity = obj[key];
              break;

            case "opacityTexture":
              _this68.opacityTexture = obj[key];
              break;

            case "baseColorTexture":
              _this68.baseColorTexture = obj[key];
              break;

            case "metallicFactor":
              _this68.metallicFactor = obj[key];
              break;

            case "roughnessFactor":
              _this68.roughnessFactor = obj[key];
              break;

            case "metallicTexture":
              _this68.metallicTexture = obj[key];
              break;

            case "roughnessTexture":
              _this68.roughnessTexture = obj[key];
              break;

            case "metallicRoughnessTexture":
              _this68.metallicRoughnessTexture = obj[key];
              break;

            case "normalTexture":
              _this68.normalTexture = obj[key];
              break;

            case "normalScale":
              _this68.normalScale = obj[key];
              break;

            case "emissiveTexture":
              _this68.emissiveTexture = obj[key];
              break;

            case "emissiveFactor":
              _this68.emissiveFactor = obj[key];
              break;

            case "occlusionTexture":
              _this68.occlusionTexture = obj[key];
              break;

            case "occlusionStrength":
              _this68.occlusionStrength = obj[key];
              break;

            case "alphaCutoff":
              _this68.alphaCutoff = obj[key];
              break;

            case "specularFactor":
              _this68.specularFactor = obj[key];
              break;

            case "glossinessFactor":
              _this68.glossinessFactor = obj[key];
              break;

            case "specularGlossinessTexture":
              _this68.specularGlossinessTexture = obj[key];
              break;

            case "reflectionTexture":
              _this68.reflectionTexture = obj[key];
              break;

            case "envMapIntensity":
              _this68.envMapIntensity = obj[key];
              break;

            case "refractionRatio":
              _this68.refractionRatio = obj[key];
              break;

            case "refractionDepth":
              _this68.refractionDepth = obj[key];
              break;

            case "refractionTexture":
              _this68.refractionTexture = obj[key];
              break;

            case "perturbationTexture":
              _this68.perturbationTexture = obj[key];
              break;

            case "perturbationUOffset":
              _this68.perturbationUOffset = obj[key];
              break;

            case "perturbationVOffset":
              _this68.perturbationVOffset = obj[key];
              break;
          }
        });
      }
    }, {
      key: "setStates",
      value: function setStates(obj) {
        var _this69 = this;

        Object.keys(obj).forEach(function (key) {
          switch (key) {
            case "doubleSided":
              _this69.doubleSided = obj[key];
              break;

            case "side":
              _this69.side = obj[key];
              break;

            case "alphaMode":
              _this69.alphaMode = obj[key];
              break;

            case "unlit":
              _this69.unlit = obj[key];
              break;

            case "srgb":
              _this69.srgb = obj[key];
              break;

            case "srgbFast":
              _this69.srgbFast = obj[key];
              break;

            case "gamma":
              _this69.gamma = obj[key];
              break;

            case "blendFunc":
              _this69.blendFunc = obj[key];
              break;

            case "blendFuncSeparate":
              _this69.blendFuncSeparate = obj[key];
              break;

            case "depthMask":
              _this69.depthMask = obj[key];
              break;

            case "getOpacityFromRGB":
              _this69.getOpacityFromRGB = obj[key];
              break;

            case "isMetallicWorkflow":
              _this69.isMetallicWorkflow = obj[key];
              break;

            case "envMapModeRefract":
              _this69.envMapModeRefract = obj[key];
              break;
          }
        });
      }
    }, {
      key: "setValueByParamName",
      value: function setValueByParamName(paramName, value) {
        var uniforms = PBRMaterial.TECH_CONFIG.uniforms;
        var uniformName = Object.keys(uniforms).find(function (key) {
          return uniforms[key].paramName === paramName;
        });

        if (uniformName) {
          this.setValue(uniformName, value);
        }
      }
    }, {
      key: "updateTechnique",
      value: function updateTechnique(stateName, v) {
        var _this$technique;

        if (this[stateName] === v) return;
        this._stateObj[stateName] = v;
        var states = (_this$technique = this.technique) === null || _this$technique === void 0 ? void 0 : _this$technique.states;
        if (!states) return;

        switch (stateName) {
          case "doubleSided":
          case "side":
            if (this.doubleSided) {
              states.disable.push(exports.RenderState.CULL_FACE);
            } else {
              var _index = states.disable.indexOf(exports.RenderState.CULL_FACE);

              if (_index > -1) {
                states.disable.splice(_index, 1);
              }

              switch (this.side) {
                case exports.Side.FRONT:
                  states.functions.cullFace = [exports.CullFace.BACK];
                  break;

                case exports.Side.BACK:
                  states.functions.cullFace = [exports.CullFace.FRONT];
                  break;

                case exports.Side.NONE:
                  states.functions.cullFace = [exports.CullFace.FRONT_AND_BACK];
                  break;

                default:
                  delete states.functions.cullFace;
              }
            }

            break;

          case "blendFunc":
          case "blendFuncSeparate":
            if (this.blendFunc.length) {
              states.functions.blendFunc = this.blendFunc;
            } else {
              states.functions.blendFuncSeparate = this.blendFuncSeparate;
            }

            break;

          case "depthMask":
            states.functions.depthMask = v;
            break;

          default:
            this._technique = null;
        }
      }
    }, {
      key: "prepareDrawing",
      value: function prepareDrawing(context, component, primitive) {
        var _scene$clipPlanes;

        var camera = context.camera;
        var scene = camera.scene;
        var canvas = scene.engine.canvas;
        var lightMgr = scene.findFeature(LightFeature);
        var canOIT = camera._renderPipeline.canOIT;
        lightMgr.bindMaterialValues(this);
        this.setValue("u_resolution", new Vector2(canvas.width, canvas.height));

        for (var i = 0; i < this._clipPlaneCount; i++) {
          this.setValue("u_clipPlanes[".concat(i, "]"), scene.clipPlanes[i]);
        }

        if (canOIT) {
          this.setValue("u_depthSampler", camera._renderPipeline.depthTexture);
        }

        var _lightMgr$lightSortAm2 = lightMgr.lightSortAmount,
            ambientLightCount = _lightMgr$lightSortAm2.ambientLightCount,
            directLightCount = _lightMgr$lightSortAm2.directLightCount,
            pointLightCount = _lightMgr$lightSortAm2.pointLightCount,
            spotLightCount = _lightMgr$lightSortAm2.spotLightCount,
            envMapLightCount = _lightMgr$lightSortAm2.envMapLightCount,
            useDiffuseEnv = _lightMgr$lightSortAm2.useDiffuseEnv,
            useSpecularEnv = _lightMgr$lightSortAm2.useSpecularEnv;

        if (!this._technique || this._ambientLightCount !== ambientLightCount || this._envMapLightCount !== envMapLightCount || this._useDiffuseEnv !== useDiffuseEnv || this._useSpecularEnv !== useSpecularEnv || this._directLightCount !== directLightCount || this._pointLightCount !== pointLightCount || this._spotLightCount !== spotLightCount || this._clipPlaneCount !== ((_scene$clipPlanes = scene.clipPlanes) === null || _scene$clipPlanes === void 0 ? void 0 : _scene$clipPlanes.length) || this._useOIT !== canOIT) {
          var _scene$clipPlanes2;

          this._ambientLightCount = ambientLightCount;
          this._envMapLightCount = envMapLightCount;
          this._useDiffuseEnv = useDiffuseEnv;
          this._useSpecularEnv = useSpecularEnv;
          this._directLightCount = directLightCount;
          this._pointLightCount = pointLightCount;
          this._spotLightCount = spotLightCount;
          this._clipPlaneCount = (_scene$clipPlanes2 = scene.clipPlanes) === null || _scene$clipPlanes2 === void 0 ? void 0 : _scene$clipPlanes2.length;
          this._useOIT = canOIT;

          this._generateTechnique(camera, component, primitive);
        }

        _get(_getPrototypeOf(PBRMaterial.prototype), "prepareDrawing", this).call(this, context, component, primitive);
      }
    }, {
      key: "_generateTechnique",
      value: function _generateTechnique(camera, component, primitive) {
        var customMacros = this._generateShaderMacros(camera, component, primitive);

        var techName = PBRMaterial.TECHNIQUE_NAME;
        var vertex = PBRMaterial.STATIC_VERTEX_SHADER;
        var frag = PBRMaterial.STATIC_FRAGMENT_SHADER;

        var config = this._generateConfig();

        var lightMgr = camera.scene.findFeature(LightFeature);
        var tech = new RenderTechnique(techName);
        tech.isValid = true;
        tech.uniforms = _objectSpread2(_objectSpread2({}, lightMgr.getUniformDefine()), config.uniforms);
        tech.attributes = config.attributes;
        tech.fragmentPrecision = "highp";
        tech.customMacros = customMacros;
        tech.states = config.states;
        tech.vertexShader = vertex;
        tech.fragmentShader = frag;
        this._technique = tech;
        return tech;
      }
    }, {
      key: "_generateShaderMacros",
      value: function _generateShaderMacros(camera, component, primitive) {
        var rhi = camera.scene.engine._hardwareRenderer;
        var _macros = ["O3_NEED_WORLDPOS"];

        if (!primitive._vertexElementMap.NORMAL || !primitive._vertexElementMap.TANGENT) {
          if (rhi.canIUse(exports.GLCapabilityType.standardDerivatives)) _macros.push("HAS_DERIVATIVES");
        }

        var uniforms = Object.keys(this._values);
        if (uniforms.indexOf("u_baseColorSampler") > -1) _macros.push("HAS_BASECOLORMAP");
        if (uniforms.indexOf("u_normalSampler") > -1) _macros.push("O3_HAS_NORMALMAP");
        if (uniforms.indexOf("u_metallicSampler") > -1) _macros.push("HAS_METALMAP");
        if (uniforms.indexOf("u_roughnessSampler") > -1) _macros.push("HAS_ROUGHNESSMAP");
        if (uniforms.indexOf("u_metallicRoughnessSampler") > -1) _macros.push("HAS_METALROUGHNESSMAP");
        if (uniforms.indexOf("u_emissiveSampler") > -1) _macros.push("HAS_EMISSIVEMAP");
        if (uniforms.indexOf("u_occlusionSampler") > -1) _macros.push("HAS_OCCLUSIONMAP");
        if (uniforms.indexOf("u_specularGlossinessSampler") > -1) _macros.push("HAS_SPECULARGLOSSINESSMAP");
        if (uniforms.indexOf("u_perturbationSampler") > -1) _macros.push("HAS_PERTURBATIONMAP");
        if (uniforms.indexOf("u_reflectionSampler") > -1) _macros.push("HAS_REFLECTIONMAP");

        if (uniforms.indexOf("u_refractionSampler") > -1) {
          this.setValueByParamName("PTMMatrix", new Matrix(0.5, 0, 0, 0, 0, 0.5, 0, 0, 0, 0, 0.5, 0, 0.5, 0.5, 0.5, 1));

          _macros.push("HAS_REFRACTIONMAP");
        }

        if (this.alphaMode === "MASK") {
          _macros.push("ALPHA_MASK");
        } else if (this.alphaMode === "BLEND" && !this.refractionTexture) {
          _macros.push("ALPHA_BLEND");

          if (uniforms.indexOf("u_opacitySampler") > -1) {
            _macros.push("HAS_OPACITYMAP");

            if (this.getOpacityFromRGB) {
              _macros.push("GETOPACITYFROMRGB");
            }
          }
        }

        if (this._envMapLightCount) {
          _macros.push("O3_HAS_ENVMAP_LIGHT");

          if (this._useDiffuseEnv) _macros.push("O3_USE_DIFFUSE_ENV");
          if (this._useSpecularEnv) _macros.push("O3_USE_SPECULAR_ENV");
          if (rhi.canIUse(exports.GLCapabilityType.shaderTextureLod)) _macros.push("HAS_TEX_LOD");
        }

        if (this._ambientLightCount) {
          _macros.push("O3_HAS_AMBIENT_LIGHT");
        }

        if (this._directLightCount) _macros.push("O3_DIRECT_LIGHT_COUNT ".concat(this._directLightCount));
        if (this._pointLightCount) _macros.push("O3_POINT_LIGHT_COUNT ".concat(this._pointLightCount));
        if (this._spotLightCount) _macros.push("O3_SPOT_LIGHT_COUNT ".concat(this._spotLightCount));
        if (this._clipPlaneCount) _macros.push("O3_CLIPPLANE_NUM ".concat(this._clipPlaneCount));
        if (this._stateObj.unlit) _macros.push("UNLIT");
        if (this._stateObj.srgb) _macros.push("MANUAL_SRGB");
        if (this._stateObj.srgbFast) _macros.push("SRGB_FAST_APPROXIMATION");
        if (this._stateObj.gamma) _macros.push("GAMMA");
        if (this._stateObj.isMetallicWorkflow) _macros.push("IS_METALLIC_WORKFLOW");
        if (this._stateObj.envMapModeRefract) _macros.push("ENVMAPMODE_REFRACT");

        if (camera._renderPipeline.canOIT) {
          _macros.push("OIT_ENABLE");
        }

        return _macros;
      }
    }, {
      key: "_generateConfig",
      value: function _generateConfig() {
        var defaultState = PBRMaterial.TECH_CONFIG.states;
        var states = {
          disable: defaultState.disable.slice(),
          enable: defaultState.enable.slice(),
          functions: _extends({}, defaultState.functions)
        };

        if (this.doubleSided) {
          states.disable.push(exports.RenderState.CULL_FACE);
        } else {
          switch (this.side) {
            case exports.Side.FRONT:
              states.functions.cullFace = [exports.CullFace.BACK];
              break;

            case exports.Side.BACK:
              states.functions.cullFace = [exports.CullFace.FRONT];
              break;

            case exports.Side.NONE:
              states.functions.cullFace = [exports.CullFace.FRONT_AND_BACK];
              break;

            default:
              delete states.functions.cullFace;
          }
        }

        if (this.alphaMode === "BLEND" && !this.refractionTexture) {
          states.enable.push(exports.RenderState.BLEND);

          if (this.blendFunc.length) {
            states.functions.blendFunc = this._stateObj.blendFunc;
          } else {
            states.functions.blendFuncSeparate = this._stateObj.blendFuncSeparate;
          }

          states.functions.depthMask = this._stateObj.depthMask;
          this.renderType = exports.MaterialType.TRANSPARENT;
        } else {
          this.renderType = exports.MaterialType.OPAQUE;
        }

        var clipPlaneUniforms = {};

        for (var i = 0; i < this._clipPlaneCount; i++) {
          clipPlaneUniforms["u_clipPlanes[".concat(i, "]")] = {
            name: "u_clipPlanes[".concat(i, "]"),
            type: exports.DataType.FLOAT_VEC4
          };
        }

        PBRMaterial.TECH_CONFIG.uniforms = _extends({}, PBRMaterial.TECH_CONFIG.uniforms, clipPlaneUniforms);
        return _extends({}, PBRMaterial.TECH_CONFIG, {
          states: states
        });
      }
    }, {
      key: "clone",
      value: function clone(name) {
        var newMtl = new PBRMaterial(this._engine, name || this.name);
        newMtl.renderType = this.renderType;
        newMtl.useFog = this.useFog;

        for (var name2 in this._uniformObj) {
          var value = this._uniformObj[name2];

          if (value instanceof Texture) {
            newMtl[name2] = value;
          } else {
            newMtl[name2] = Util.clone(value);
          }
        }

        if (this._stateObj) {
          newMtl._stateObj = Util.clone(this._stateObj);
        }

        return newMtl;
      }
    }, {
      key: "baseColorFactor",
      get: function get() {
        return this._uniformObj.baseColorFactor;
      },
      set: function set(v) {
        this._uniformObj.baseColorFactor = v;
        this.setValueByParamName("baseColorFactor", v);
      }
    }, {
      key: "opacity",
      get: function get() {
        return this.baseColorFactor.w;
      },
      set: function set(val) {
        this.baseColorFactor.w = val;
      }
    }, {
      key: "baseColorTexture",
      get: function get() {
        return this._uniformObj.baseColorTexture;
      },
      set: function set(v) {
        this.setValueByParamName("baseColorTexture", v);
        this._uniformObj.baseColorTexture = v;
      }
    }, {
      key: "opacityTexture",
      get: function get() {
        return this._uniformObj.opacityTexture;
      },
      set: function set(v) {
        this.setValueByParamName("opacityTexture", v);
        this._uniformObj.opacityTexture = v;
      }
    }, {
      key: "metallicFactor",
      get: function get() {
        return this._uniformObj.metallicFactor;
      },
      set: function set(v) {
        this._uniformObj.metallicFactor = v;
        this._uniformObj.metallicRoughness.x = v;
        this.setValueByParamName("metallicRoughness", this._uniformObj.metallicRoughness);
      }
    }, {
      key: "roughnessFactor",
      get: function get() {
        return this._uniformObj.roughnessFactor;
      },
      set: function set(v) {
        this._uniformObj.roughnessFactor = v;
        this._uniformObj.metallicRoughness.y = v;
        this.setValueByParamName("metallicRoughness", this._uniformObj.metallicRoughness);
      }
    }, {
      key: "metallicTexture",
      get: function get() {
        return this._uniformObj.metallicTexture;
      },
      set: function set(v) {
        this.setValueByParamName("metallicTexture", v);
        this._uniformObj.metallicTexture = v;
      }
    }, {
      key: "roughnessTexture",
      get: function get() {
        return this._uniformObj.roughnessTexture;
      },
      set: function set(v) {
        this.setValueByParamName("roughnessTexture", v);
        this._uniformObj.roughnessTexture = v;
      }
    }, {
      key: "metallicRoughnessTexture",
      get: function get() {
        return this._uniformObj.metallicRoughnessTexture;
      },
      set: function set(v) {
        this.setValueByParamName("metallicRoughnessTexture", v);
        this._uniformObj.metallicRoughnessTexture = v;
      }
    }, {
      key: "normalTexture",
      get: function get() {
        return this._uniformObj.normalTexture;
      },
      set: function set(v) {
        this.setValueByParamName("normalTexture", v);
        this._uniformObj.normalTexture = v;
      }
    }, {
      key: "normalScale",
      get: function get() {
        return this._uniformObj.normalScale;
      },
      set: function set(v) {
        this._uniformObj.normalScale = v;
        this.setValueByParamName("normalScale", v);
      }
    }, {
      key: "emissiveTexture",
      get: function get() {
        return this._uniformObj.emissiveTexture;
      },
      set: function set(v) {
        this.setValueByParamName("emissiveTexture", v);
        this._uniformObj.emissiveTexture = v;
      }
    }, {
      key: "emissiveFactor",
      get: function get() {
        return this._uniformObj.emissiveFactor;
      },
      set: function set(v) {
        this._uniformObj.emissiveFactor = v;
        this.setValueByParamName("emissiveFactor", v);
      }
    }, {
      key: "occlusionTexture",
      get: function get() {
        return this._uniformObj.occlusionTexture;
      },
      set: function set(v) {
        this.setValueByParamName("occlusionTexture", v);
        this._uniformObj.occlusionTexture = v;
      }
    }, {
      key: "occlusionStrength",
      get: function get() {
        return this._uniformObj.occlusionStrength;
      },
      set: function set(v) {
        this._uniformObj.occlusionStrength = v;
        this.setValueByParamName("occlusionStrength", v);
      }
    }, {
      key: "alphaCutoff",
      get: function get() {
        return this._uniformObj.alphaCutoff;
      },
      set: function set(v) {
        this._uniformObj.alphaCutoff = v;
        this.setValueByParamName("alphaCutoff", v);
      }
    }, {
      key: "specularFactor",
      get: function get() {
        return this._uniformObj.specularFactor;
      },
      set: function set(v) {
        this.setValueByParamName("specularFactor", v);
        this._uniformObj.specularFactor = v;
      }
    }, {
      key: "glossinessFactor",
      get: function get() {
        return this._uniformObj.glossinessFactor;
      },
      set: function set(v) {
        this.setValueByParamName("glossinessFactor", v);
        this._uniformObj.glossinessFactor = v;
      }
    }, {
      key: "specularGlossinessTexture",
      get: function get() {
        return this._uniformObj.specularGlossinessTexture;
      },
      set: function set(v) {
        this.setValueByParamName("specularGlossinessTexture", v);
        this._uniformObj.specularGlossinessTexture = v;
      }
    }, {
      key: "reflectionTexture",
      get: function get() {
        return this._uniformObj.reflectionTexture;
      },
      set: function set(v) {
        this.setValueByParamName("reflectionTexture", v);
        this._uniformObj.reflectionTexture = v;
      }
    }, {
      key: "envMapIntensity",
      get: function get() {
        return this._uniformObj.envMapIntensity;
      },
      set: function set(v) {
        this.setValueByParamName("envMapIntensity", v);
        this._uniformObj.envMapIntensity = v;
      }
    }, {
      key: "refractionRatio",
      get: function get() {
        return this._uniformObj.refractionRatio;
      },
      set: function set(v) {
        this.setValueByParamName("refractionRatio", v);
        this._uniformObj.refractionRatio = v;
      }
    }, {
      key: "refractionDepth",
      get: function get() {
        return this._uniformObj.refractionDepth;
      },
      set: function set(v) {
        this.setValueByParamName("refractionDepth", v);
        this._uniformObj.refractionDepth = v;
      }
    }, {
      key: "refractionTexture",
      get: function get() {
        return this._uniformObj.refractionTexture;
      },
      set: function set(v) {
        this.setValueByParamName("refractionTexture", v);
        this._uniformObj.refractionTexture = v;
      }
    }, {
      key: "perturbationTexture",
      get: function get() {
        return this._uniformObj.perturbationTexture;
      },
      set: function set(v) {
        this.setValueByParamName("perturbationTexture", v);
        this._uniformObj.perturbationTexture = v;
      }
    }, {
      key: "perturbationUOffset",
      get: function get() {
        return this._uniformObj.perturbationUOffset;
      },
      set: function set(v) {
        this.setValueByParamName("perturbationUOffset", v);
        this._uniformObj.perturbationUOffset = v;
      }
    }, {
      key: "perturbationVOffset",
      get: function get() {
        return this._uniformObj.perturbationVOffset;
      },
      set: function set(v) {
        this.setValueByParamName("perturbationVOffset", v);
        this._uniformObj.perturbationVOffset = v;
      }
    }, {
      key: "alphaMode",
      get: function get() {
        return this._stateObj.alphaMode;
      },
      set: function set(v) {
        this.updateTechnique("alphaMode", v);
      }
    }, {
      key: "doubleSided",
      get: function get() {
        return this._stateObj.doubleSided;
      },
      set: function set(v) {
        if (v) {
          this._stateObj.side = exports.Side.DOUBLE;
        } else if (this._stateObj.side === exports.Side.DOUBLE) {
          this._stateObj.side = exports.Side.FRONT;
        }

        this.updateTechnique("doubleSided", v);
      }
    }, {
      key: "side",
      get: function get() {
        return this._stateObj.side;
      },
      set: function set(v) {
        if (v === exports.Side.DOUBLE) {
          this._stateObj.doubleSided = true;
        } else {
          this._stateObj.doubleSided = false;
        }

        this.updateTechnique("side", v);
      }
    }, {
      key: "unlit",
      get: function get() {
        return this._stateObj.unlit;
      },
      set: function set(v) {
        this.updateTechnique("unlit", v);
      }
    }, {
      key: "srgb",
      get: function get() {
        return this._stateObj.srgb;
      },
      set: function set(v) {
        this.updateTechnique("srgb", v);
      }
    }, {
      key: "srgbFast",
      get: function get() {
        return this._stateObj.srgbFast;
      },
      set: function set(v) {
        this.updateTechnique("srgbFast", v);
      }
    }, {
      key: "gamma",
      get: function get() {
        return this._stateObj.gamma;
      },
      set: function set(v) {
        this.updateTechnique("gamma", v);
      }
    }, {
      key: "blendFunc",
      get: function get() {
        return this._stateObj.blendFunc;
      },
      set: function set(v) {
        this.updateTechnique("blendFunc", v);
      }
    }, {
      key: "blendFuncSeparate",
      get: function get() {
        return this._stateObj.blendFuncSeparate;
      },
      set: function set(v) {
        this.updateTechnique("blendFuncSeparate", v);
      }
    }, {
      key: "depthMask",
      get: function get() {
        return this._stateObj.depthMask;
      },
      set: function set(v) {
        this.updateTechnique("depthMask", v);
      }
    }, {
      key: "getOpacityFromRGB",
      get: function get() {
        return this._stateObj.getOpacityFromRGB;
      },
      set: function set(v) {
        this.updateTechnique("getOpacityFromRGB", v);
      }
    }, {
      key: "isMetallicWorkflow",
      get: function get() {
        return this._stateObj.isMetallicWorkflow;
      },
      set: function set(v) {
        this.updateTechnique("isMetallicWorkflow", v);
      }
    }, {
      key: "envMapModeRefract",
      get: function get() {
        return this._stateObj.envMapModeRefract;
      },
      set: function set(v) {
        this.updateTechnique("envMapModeRefract", v);
      }
    }]);

    return PBRMaterial;
  }(Material);

  PBRMaterial.MATERIAL_NAME = "PBR_MATERIAL";
  PBRMaterial.TECHNIQUE_NAME = "PBR_TECHNIQUE";
  PBRMaterial.STATIC_VERTEX_SHADER = vs$1;
  PBRMaterial.STATIC_FRAGMENT_SHADER = fs$1;
  PBRMaterial.attribUniformVec4 = 12;
  PBRMaterial.TECH_CONFIG = {
    attributes: {},
    uniforms: _extends({
      u_baseColorSampler: {
        name: "u_baseColorSampler",
        paramName: "baseColorTexture",
        type: exports.DataType.SAMPLER_2D
      },
      u_baseColorFactor: {
        name: "u_baseColorFactor",
        paramName: "baseColorFactor",
        type: exports.DataType.FLOAT_VEC4
      },
      u_normalSampler: {
        name: "u_normalSampler",
        paramName: "normalTexture",
        type: exports.DataType.SAMPLER_2D
      },
      u_normalScale: {
        name: "u_normalScale",
        paramName: "normalScale",
        type: exports.DataType.FLOAT
      },
      u_lightDirection: {
        name: "u_lightDirection",
        type: exports.DataType.FLOAT_VEC3
      },
      u_lightColor: {
        name: "u_lightColor",
        type: exports.DataType.FLOAT_VEC3
      },
      u_metallicRoughnessValue: {
        name: "u_metallicRoughnessValue",
        paramName: "metallicRoughness",
        type: exports.DataType.FLOAT_VEC2
      },
      u_metallicSampler: {
        name: "u_metallicSampler",
        paramName: "metallicTexture",
        type: exports.DataType.SAMPLER_2D
      },
      u_roughnessSampler: {
        name: "u_roughnessSampler",
        paramName: "roughnessTexture",
        type: exports.DataType.SAMPLER_2D
      },
      u_metallicRoughnessSampler: {
        name: "u_metallicRoughnessSampler",
        paramName: "metallicRoughnessTexture",
        type: exports.DataType.SAMPLER_2D
      },
      u_emissiveFactor: {
        name: "u_emissiveFactor",
        paramName: "emissiveFactor",
        type: exports.DataType.FLOAT_VEC3
      },
      u_emissiveSampler: {
        name: "u_emissiveSampler",
        paramName: "emissiveTexture",
        type: exports.DataType.SAMPLER_2D
      },
      u_occlusionSampler: {
        name: "u_occlusionSampler",
        paramName: "occlusionTexture",
        type: exports.DataType.SAMPLER_2D
      },
      u_occlusionStrength: {
        name: "u_occlusionStrength",
        paramName: "occlusionStrength",
        type: exports.DataType.FLOAT
      },
      u_alphaCutoff: {
        name: "u_alphaCutoff",
        paramName: "alphaCutoff",
        type: exports.DataType.FLOAT
      },
      u_opacitySampler: {
        name: "u_opacitySampler",
        paramName: "opacityTexture",
        type: exports.DataType.SAMPLER_2D
      },
      u_specularFactor: {
        name: "u_specularFactor",
        paramName: "specularFactor",
        type: exports.DataType.FLOAT_VEC3
      },
      u_glossinessFactor: {
        name: "u_glossinessFactor",
        paramName: "glossinessFactor",
        type: exports.DataType.FLOAT
      },
      u_specularGlossinessSampler: {
        name: "u_specularGlossinessSampler",
        paramName: "specularGlossinessTexture",
        type: exports.DataType.SAMPLER_2D
      },
      u_reflectionSampler: {
        name: "u_reflectionSampler",
        paramName: "reflectionTexture",
        type: exports.DataType.SAMPLER_CUBE
      },
      u_PTMMatrix: {
        name: "u_PTMMatrix",
        paramName: "PTMMatrix",
        type: exports.DataType.FLOAT_MAT4
      },
      u_envMapIntensity: {
        name: "u_envMapIntensity",
        paramName: "envMapIntensity",
        type: exports.DataType.FLOAT
      },
      u_refractionRatio: {
        name: "u_refractionRatio",
        paramName: "refractionRatio",
        type: exports.DataType.FLOAT
      },
      u_refractionDepth: {
        name: "u_refractionDepth",
        paramName: "refractionDepth",
        type: exports.DataType.FLOAT
      },
      u_refractionSampler: {
        name: "u_refractionSampler",
        paramName: "refractionTexture",
        type: exports.DataType.SAMPLER_2D
      },
      u_resolution: {
        name: "u_resolution",
        paramName: "resolution",
        type: exports.DataType.FLOAT_VEC2
      },
      u_perturbationSampler: {
        name: "u_perturbationSampler",
        paramName: "perturbationTexture",
        type: exports.DataType.SAMPLER_2D
      },
      u_perturbationUOffset: {
        name: "u_perturbationUOffset",
        paramName: "perturbationUOffset",
        type: exports.DataType.FLOAT
      },
      u_perturbationVOffset: {
        name: "u_perturbationVOffset",
        paramName: "perturbationVOffset",
        type: exports.DataType.FLOAT
      },
      u_depthSampler: {
        name: "u_depthSampler",
        type: exports.DataType.SAMPLER_2D
      }
    }),
    states: {
      disable: [],
      enable: [],
      functions: {}
    }
  };

  var GPUParticleSystem = /*#__PURE__*/function (_GeometryRenderer3) {
    _inherits(GPUParticleSystem, _GeometryRenderer3);

    var _super68 = _createSuper(GPUParticleSystem);

    function GPUParticleSystem(entity) {
      var _this70;

      _classCallCheck(this, GPUParticleSystem);

      _this70 = _super68.call(this, entity);
      _this70._time = 0;
      _this70._isInit = false;
      _this70._isStart = false;
      return _this70;
    }

    _createClass(GPUParticleSystem, [{
      key: "initialize",
      value: function initialize(props) {
        this.maxCount = props.maxCount !== void 0 ? props.maxCount : 1e3;
        this.once = props.once || false;
        this.options = props.options || {};
        this.getOptions = props.getOptions;
        this.rotateToVelocity = props.rotateToVelocity || false;

        if (props.blendFuncSeparate) {
          this.blendFuncSeparate = props.blendFuncSeparate;
        }

        this.blendFunc = props.blendFunc || [exports.BlendFunc.SRC_ALPHA, exports.BlendFunc.ONE_MINUS_SRC_ALPHA];
        this.useOriginColor = props.useOriginColor !== void 0 ? props.useOriginColor : true;
        this.fragmentShader = props.fragmentShader || null;
        this.vertexShader = props.vertexShader || null;
        this.particleTex = props.texture || null;
        this.fadeIn = props.fadeIn || false;
        this.fadeOut = props.fadeOut === void 0 ? true : props.fadeOut;
        this.particleMaskTex = props.maskTexture || null;
        this.isScaleByLifetime = props.isScaleByLifetime || false;
        this.scaleFactor = props.scaleFactor || 1;
        this.spriteSheet = props.spriteSheet || null;
        this.is2d = props.is2d === void 0 ? true : props.is2d;
        this.interleaved = props.spriteSheet || true;
        this.setMaterial();
        this.geometry = this._createGeometry();
        this._isInit = true;
        var options = this.getOptions ? this.getOptions(this._time) : this.options;

        for (var x = 0; x < this.maxCount; x++) {
          this._spawnParticle(options, x);
        }

        this._vertexBuffer.setData(this._vertices);

        return this;
      }
    }, {
      key: "update",
      value: function update(deltaTime) {
        if (!this._isInit || !this._isStart) {
          return;
        }

        this._time += deltaTime / 1e3;
        this.material.setValue("uTime", this._time);
      }
    }, {
      key: "setOptions",
      value: function setOptions(options) {
        if (options !== void 0) {
          this.options = _objectSpread2(_objectSpread2({}, this.options), options);
        }

        return this;
      }
    }, {
      key: "start",
      value: function start() {
        this._isStart = true;
        this._time = 0;
        this.material.setValue("uActive", 1);
      }
    }, {
      key: "stop",
      value: function stop() {
        this.material.setValue("uActive", 0);
      }
    }, {
      key: "destroy",
      value: function destroy() {
        _get(_getPrototypeOf(GPUParticleSystem.prototype), "destroy", this).call(this);

        this.options = null;

        if (this.particleTex) {
          this.particleTex = null;
        }

        if (this.particleMaskTex) {
          this.particleMaskTex = null;
        }
      }
    }, {
      key: "setMaterial",
      value: function setMaterial() {
        var technique = this._createTechnique();

        var material = new Material(this.engine, "particleMaterial");
        material.technique = technique;
        material.renderType = exports.MaterialType.TRANSPARENT;
        material.setValue("uOnce", this.once ? 1 : 0);
        material.setValue("uTime", this._time);

        if (this.particleTex) {
          this.particleTex.wrapModeU = this.particleTex.wrapModeV = exports.TextureWrapMode.Clamp;
          material.setValue("particleTex", this.particleTex);
        }

        if (this.particleMaskTex) {
          this.particleMaskTex.wrapModeU = this.particleTex.wrapModeV = exports.TextureWrapMode.Clamp;
          material.setValue("particleMaskTex", this.particleMaskTex);
        }

        this.material = material;
      }
    }, {
      key: "_createTechnique",
      value: function _createTechnique() {
        var cfg = {
          attributes: {
            positionStart: {
              name: "positionStart",
              semantic: "POSITIONSTART",
              type: exports.DataType.FLOAT_VEC3
            },
            color: {
              name: "color",
              semantic: "COLOR",
              type: exports.DataType.FLOAT_VEC3
            },
            alpha: {
              name: "alpha",
              semantic: "ALPHA",
              type: exports.DataType.FLOAT
            },
            acceleration: {
              name: "acceleration",
              semantic: "ACCELERATION",
              type: exports.DataType.FLOAT_VEC3
            },
            velocity: {
              name: "velocity",
              semantic: "VELOCITY",
              type: exports.DataType.FLOAT_VEC3
            },
            startAngle: {
              name: "startAngle",
              semantic: "STARTANGLE",
              type: exports.DataType.FLOAT
            },
            lifeTime: {
              name: "lifeTime",
              semantic: "LIFETIME",
              type: exports.DataType.FLOAT
            },
            startTime: {
              name: "startTime",
              semantic: "STARTTIME",
              type: exports.DataType.FLOAT
            },
            size: {
              name: "size",
              semantic: "SIZE",
              type: exports.DataType.FLOAT
            },
            rotateRate: {
              name: "rotateRate",
              semantic: "ROTATERATE",
              type: exports.DataType.FLOAT
            },
            scaleFactor: {
              name: "scaleFactor",
              semantic: "SCALEFACTOR",
              type: exports.DataType.FLOAT
            },
            uv: {
              name: "uv",
              semantic: "UV",
              type: exports.DataType.FLOAT_VEC3
            },
            normalizedUv: {
              name: "normalizedUv",
              semantic: "NORMALIZED_UV",
              type: exports.DataType.FLOAT_VEC2
            }
          },
          uniforms: {
            uOnce: {
              name: "uOnce",
              type: exports.DataType.FLOAT
            },
            uActive: {
              name: "uActive",
              type: exports.DataType.FLOAT
            },
            uTime: {
              name: "uTime",
              type: exports.DataType.FLOAT
            },
            matModelViewProjection: {
              name: "matModelViewProjection",
              semantic: exports.UniformSemantic.MODELVIEWPROJECTION,
              type: exports.DataType.FLOAT_MAT4
            },
            matModelView: {
              name: "matModelView",
              semantic: exports.UniformSemantic.MODELVIEW,
              type: exports.DataType.FLOAT_MAT4
            }
          },
          states: {
            enable: [exports.RenderState.BLEND],
            functions: {
              depthMask: [false]
            }
          }
        };

        if (this.is2d) {
          cfg.uniforms.matViewInverse = {
            name: "matViewInverse",
            semantic: exports.UniformSemantic.VIEWINVERSE,
            type: exports.DataType.FLOAT_MAT4
          };
          cfg.uniforms.matProjection = {
            name: "matProjection",
            semantic: exports.UniformSemantic.PROJECTION,
            type: exports.DataType.FLOAT_MAT4
          };
          cfg.uniforms.matView = {
            name: "matView",
            semantic: exports.UniformSemantic.VIEW,
            type: exports.DataType.FLOAT_MAT4
          };
          cfg.uniforms.matWorld = {
            name: "matWorld",
            semantic: exports.UniformSemantic.MODEL,
            type: exports.DataType.FLOAT_MAT4
          };
        } else {
          cfg.states.disable = [exports.RenderState.CULL_FACE];
        }

        if (this.blendFuncSeparate) {
          cfg.states.functions.blendFuncSeparate = this.blendFuncSeparate;
        } else {
          cfg.states.functions.blendFunc = this.blendFunc;
        }

        if (this.particleTex) {
          cfg.uniforms.particleTex = {
            name: "particleTex",
            type: exports.DataType.SAMPLER_2D
          };
        }

        if (this.particleMaskTex) {
          cfg.uniforms.particleMaskTex = {
            name: "particleMaskTex",
            type: exports.DataType.SAMPLER_2D
          };
        }

        var tech = new RenderTechnique("particleTech");
        tech.isValid = true;
        tech.uniforms = cfg.uniforms;
        tech.attributes = cfg.attributes;
        tech.states = cfg.states;
        tech.vertexShader = this._createVertexShader();
        tech.fragmentShader = this._createFragmentShader();
        return tech;
      }
    }, {
      key: "_createGeometry",
      value: function _createGeometry() {
        var geometry2 = new BufferGeometry(this._entity.engine, "particleGeometry");
        var vertexStride = 96;
        var vertexFloatCount = this.maxCount * 4 * vertexStride;
        var vertices = new Float32Array(vertexFloatCount);
        var indices = new Uint16Array(6 * this.maxCount);

        for (var i = 0, idx = 0; i < this.maxCount; ++i) {
          var startIndex = i * 4;
          indices[idx++] = startIndex + 0;
          indices[idx++] = startIndex + 1;
          indices[idx++] = startIndex + 2;
          indices[idx++] = startIndex + 0;
          indices[idx++] = startIndex + 2;
          indices[idx++] = startIndex + 3;
        }

        var vertexElements = [new VertexElement("POSITIONSTART", 0, exports.VertexElementFormat.Vector3, 0), new VertexElement("VELOCITY", 12, exports.VertexElementFormat.Vector3, 0), new VertexElement("ACCELERATION", 24, exports.VertexElementFormat.Vector3, 0), new VertexElement("COLOR", 36, exports.VertexElementFormat.Vector3, 0), new VertexElement("ALPHA", 48, exports.VertexElementFormat.Float, 0), new VertexElement("SIZE", 52, exports.VertexElementFormat.Float, 0), new VertexElement("ROTATERATE", 56, exports.VertexElementFormat.Float, 0), new VertexElement("STARTTIME", 60, exports.VertexElementFormat.Float, 0), new VertexElement("LIFETIME", 64, exports.VertexElementFormat.Float, 0), new VertexElement("STARTANGLE", 68, exports.VertexElementFormat.Float, 0), new VertexElement("SCALEFACTOR", 72, exports.VertexElementFormat.Float, 0), new VertexElement("UV", 76, exports.VertexElementFormat.Vector3, 0), new VertexElement("NORMALIZED_UV", 88, exports.VertexElementFormat.Vector2, 0)];
        var vertexBuffer = new Buffer(this.engine, exports.BufferBindFlag.VertexBuffer, vertexFloatCount * 4, exports.BufferUsage.Dynamic);
        var indexBuffer = new Buffer(this.engine, exports.BufferBindFlag.IndexBuffer, indices, exports.BufferUsage.Dynamic);
        geometry2.setVertexBufferBinding(vertexBuffer, vertexStride);
        geometry2.setIndexBufferBinding(indexBuffer, exports.IndexFormat.UInt16);
        geometry2.setVertexElements(vertexElements);
        geometry2.addSubGeometry(0, indices.length);
        this._vertexBuffer = vertexBuffer;
        this._vertexStride = vertexStride;
        this._vertices = vertices;
        return geometry2;
      }
    }, {
      key: "_spawnParticle",
      value: function _spawnParticle(options, i) {
        var position = options.position !== void 0 ? options.position.clone() : new Vector3();
        var positionRandomness = options.positionRandomness !== void 0 ? options.positionRandomness.clone() : new Vector3();
        var positionArray = options.positionArray;
        var velocity = options.velocity !== void 0 ? options.velocity.clone() : new Vector3();
        var velocityRandomness = options.velocityRandomness !== void 0 ? options.velocityRandomness.clone() : new Vector3();
        var color = options.color !== void 0 ? options.color.clone() : new Vector3(1, 1, 1);
        var colorRandomness = options.colorRandomness !== void 0 ? options.colorRandomness : 1;
        var alpha = options.alpha !== void 0 ? options.alpha : 1;
        var alphaRandomness = options.alphaRandomness !== void 0 ? options.alphaRandomness : 0;
        var lifetime = options.lifetime !== void 0 ? options.lifetime : 5;
        var size = options.size !== void 0 ? options.size : 1;
        var sizeRandomness = options.sizeRandomness !== void 0 ? options.sizeRandomness : 0;
        var smoothPosition = options.smoothPosition !== void 0 ? options.smoothPosition : false;
        var startTimeRandomness = options.startTimeRandomness !== void 0 ? options.startTimeRandomness : 0;
        var acceleration = options.acceleration !== void 0 ? options.acceleration.clone() : new Vector3();
        var accelerationRandomness = options.accelerationRandomness !== void 0 ? options.accelerationRandomness.clone() : new Vector3();
        var startAngle = options.startAngle !== void 0 ? options.startAngle : 0;
        var startAngleRandomness = options.startAngleRandomness !== void 0 ? options.startAngleRandomness : 0;
        var rotateRate = options.rotateRate !== void 0 ? options.rotateRate : 0;
        var rotateRateRandomness = options.rotateRateRandomness !== void 0 ? options.rotateRateRandomness : 0;
        var scaleFactor = options.scaleFactor !== void 0 ? options.scaleFactor : 1;
        var x = position.x;
        var y = position.y;
        var z = position.z;

        if (positionArray) {
          if (positionArray.length !== this.maxCount) {
            throw Error("The length of positionArray must be equal to maxCount.");
          }

          x += positionArray[i].x;
          y += positionArray[i].y;
          z += positionArray[i].z;
        } else {
          x += this._getRandom() * positionRandomness.x;
          y += this._getRandom() * positionRandomness.y;
          z += this._getRandom() * positionRandomness.z;
        }

        if (smoothPosition === true) {
          x += -(velocity.x * this._getRandom());
          y += -(velocity.y * this._getRandom());
          z += -(velocity.z * this._getRandom());
        }

        var velX = velocity.x + this._getRandom() * velocityRandomness.x;
        var velY = velocity.y + this._getRandom() * velocityRandomness.y;
        var velZ = velocity.z + this._getRandom() * velocityRandomness.z;
        var accX = acceleration.x + this._getRandom() * accelerationRandomness.x;
        var accY = acceleration.y + this._getRandom() * accelerationRandomness.y;
        var accZ = acceleration.z + this._getRandom() * accelerationRandomness.z;
        color.x = MathUtil.clamp(color.x + this._getRandom() * colorRandomness, 0, 1);
        color.y = MathUtil.clamp(color.y + this._getRandom() * colorRandomness, 0, 1);
        color.z = MathUtil.clamp(color.z + this._getRandom() * colorRandomness, 0, 1);
        size = Math.max(size + this._getRandom() * sizeRandomness * size * 2, 0);
        var lifeTime = lifetime + this._getRandom() * lifetime;
        var sa = startAngle + this._getRandom() * Math.PI * startAngleRandomness * 2;
        var rr = rotateRate + this._getRandom() * rotateRateRandomness;
        var particleAlpha = MathUtil.clamp(alpha + this._getRandom() * alphaRandomness, 0, 1);
        var startTime = Math.random() * startTimeRandomness;
        var vertices = this._vertices;

        for (var j = 0; j < 4; j++) {
          var k = (i * 4 + j) * this._vertexStride / 4;
          vertices[k] = x;
          vertices[k + 1] = y;
          vertices[k + 2] = z;
          vertices[k + 3] = velX;
          vertices[k + 4] = velY;
          vertices[k + 5] = velZ;
          vertices[k + 6] = accX;
          vertices[k + 7] = accY;
          vertices[k + 8] = accZ;
          vertices[k + 9] = color[0];
          vertices[k + 10] = color[1];
          vertices[k + 11] = color[2];
          vertices[k + 12] = particleAlpha;
          vertices[k + 13] = size;
          vertices[k + 14] = rr;
          vertices[k + 15] = startTime;
          vertices[k + 16] = lifeTime;
          vertices[k + 17] = sa;
          vertices[k + 18] = scaleFactor;

          this._setUvs(i, j, k);
        }
      }
    }, {
      key: "_setUvs",
      value: function _setUvs(i, j, k) {
        var spriteSheet = this.spriteSheet;
        var particleTex = this.particleTex;
        var rects;
        var normalizedRects = [[-0.5, -0.5], [0.5, -0.5], [0.5, 0.5], [-0.5, 0.5]];

        if (particleTex) {
          var width = particleTex.image ? particleTex.image.width : particleTex.width;
          var height = particleTex.image ? particleTex.image.height : particleTex.height;

          if (spriteSheet) {
            var _spriteSheet = spriteSheet[i % spriteSheet.length],
                x = _spriteSheet.x,
                y = _spriteSheet.y,
                w = _spriteSheet.w,
                h = _spriteSheet.h;
            var u = x / width;
            var v = y / height;
            var p = u + w / width;
            var q = v + h / height;
            rects = [[u, q, h / w], [p, q, h / w], [p, v, h / w], [u, v, h / w]];
          } else {
            rects = [[0, 0, height / width], [1, 0, height / width], [1, 1, height / width], [0, 1, height / width]];
          }
        } else {
          rects = [[0, 0, 1], [1, 0, 1], [1, 1, 1], [0, 1, 1]];
        }

        var vertices = this._vertices;
        var uv = rects[j];
        vertices[k + 19] = uv[0];
        vertices[k + 20] = uv[1];
        vertices[k + 21] = uv[2];
        var nuv = normalizedRects[j];
        vertices[k + 22] = nuv[0];
        vertices[k + 23] = nuv[1];
      }
    }, {
      key: "_getRandom",
      value: function _getRandom() {
        return Math.random() - 0.5;
      }
    }, {
      key: "_getShader",
      value: function _getShader() {
        return {
          vertexShader: "\n        precision highp float;\n        precision highp int;\n\n        attribute float lifeTime;\n        attribute float startTime;\n        attribute float size;\n        attribute float rotateRate;\n        attribute vec3 velocity;\n        attribute vec3 acceleration;\n        attribute vec3 positionStart;\n        attribute vec3 color;\n        attribute float alpha;\n        attribute float startAngle;\n        attribute float scaleFactor;\n        attribute vec3 uv;\n        attribute vec2 normalizedUv;\n        \n        uniform float uTime;\n        uniform float uOnce;\n        uniform float uActive;\n        uniform mat4 matModelViewProjection;\n        uniform mat4 matModelView;\n        uniform mat4 matViewInverse;\n        uniform mat4 matView;\n        uniform mat4 matProjection;\n        uniform mat4 matWorld;\n\n        varying vec3 v_color;\n        varying float v_alpha;\n        varying float lifeLeft;\n        varying mat2 vTextureMat;\n        varying vec2 v_uv;\n\n        mat2 rotation2d(float angle) {\n          float s = sin(angle);\n          float c = cos(angle);\n        \n          return mat2(\n            c, -s,\n            s, c\n          );\n        }\n\n        void main()\n        {\n          v_color = color;\n          v_uv = uv.xy;\n          v_alpha = alpha;\n          \n          // float deltaTime = max(mod(uTime, lifeTime), 0.0);\n          // \u771F\u5B9E\u7684\u751F\u547D\u5468\u671F\n          float life = lifeTime + startTime;\n          // \u5F53\u524D\u5DF2\u8FC7\u53BB\u7684\u65F6\u95F4\n          float deltaTime = max(mod(uTime, life) - startTime, 0.0);\n\n          bool isDying = false;\n\n          if (uOnce == 1.0 || uActive == 0.0) {\n            isDying = true;\n          }\n\n          if ((isDying && uTime > life)) {\n            deltaTime = life;\n          }\n\n          // \u6CA1\u51FA\u751F\u5C31\u4EE3\u8868\u6B7B\u4EA1\uFF0C\u5426\u5219\u6CA1\u51FA\u751F\u5C31\u663E\u793A\u4E86\n          if (deltaTime == 0.0) {\n            deltaTime = life;\n          }\n\n          lifeLeft = 1.0 - deltaTime / lifeTime;\n          float scale = size;\n          vec3 position = positionStart + (velocity + acceleration * deltaTime * 0.5) * deltaTime;\n      ",
          postionShader: "\n        gl_Position = matModelViewProjection * vec4(position, 1.0 );\n      ",
          sizeVertexShader: "\n          scale *= pow(scaleFactor, deltaTime);\n      ",
          isScaleByLifetimeVertexShader: "\n          scale *= lifeLeft;\n      ",
          rotateToVelocityVertexShader: "\n        vec3 v = velocity + acceleration * deltaTime;\n        float angle = atan(v.z, v.x) * 2.0;\n        float s = sin(angle);\n        float c = cos(angle);\n      ",
          rotationVertexShader: "\n        float deltaAngle = deltaTime * rotateRate;\n        float angle = startAngle + deltaAngle;\n        float s = sin(angle);\n        float c = cos(angle);\n\n      ",
          rotation2dShader: "\n        vec2 rotatedPoint = rotation2d(angle) * vec2(normalizedUv.x, normalizedUv.y * uv.z);\n\n        vec3 basisX = matViewInverse[0].xyz;\n        vec3 basisZ = matViewInverse[1].xyz;\n\n        vec3 localPosition = vec3(basisX * rotatedPoint.x + \n                    basisZ * rotatedPoint.y) * scale + position;\n\n        gl_Position = matProjection * matView * vec4(localPosition + matWorld[3].xyz, 1.);\n      ",
          rotation3dShader: "\n        vec4 rotatedPoint = vec4((normalizedUv.x * c + normalizedUv.y * uv.z * s) * scale , 0., \n                                 (normalizedUv.x * s - normalizedUv.y * uv.z * c) * scale, 1.);\n      \n        vec4 orientation = vec4(0, 0, 0, 1);\n        vec4 q2 = orientation + orientation;\n        vec4 qx = orientation.xxxw * q2.xyzx;\n        vec4 qy = orientation.xyyw * q2.xyzy;\n        vec4 qz = orientation.xxzw * q2.xxzz;\n      \n        mat4 localMatrix = mat4(\n            (1.0 - qy.y) - qz.z, \n            qx.y + qz.w, \n            qx.z - qy.w,\n            0,\n      \n            qx.y - qz.w, \n            (1.0 - qx.x) - qz.z, \n            qy.z + qx.w,\n            0,\n      \n            qx.z + qy.w, \n            qy.z - qx.w, \n            (1.0 - qx.x) - qy.y,\n            0,\n      \n            position.x, position.y, position.z, 1);\n\n        rotatedPoint = localMatrix * rotatedPoint;\n\n        gl_Position = matModelViewProjection * rotatedPoint;\n      ",
          fragmentShader: "\n        precision mediump float;\n        precision mediump int;\n\n        varying vec3 v_color;\n        varying float v_alpha;\n        varying float lifeLeft;\n        varying vec2 v_uv;\n        uniform sampler2D particleTex;\n        uniform sampler2D particleMaskTex;\n\n        void main()\n        {\n          float alphaFactor = 1.0;\n      ",
          fadeInFragmentShader: "\n        float fadeInFactor = step(0.5, lifeLeft);\n        alphaFactor = 2.0 * fadeInFactor * (1.0 - lifeLeft) + (1.0 - fadeInFactor);\n      ",
          fadeOutFragmentShader: "\n        float fadeOutFactor = step(0.5, lifeLeft);\n        alphaFactor = alphaFactor * 2.0 * (1.0 - fadeOutFactor) * lifeLeft + alphaFactor * fadeOutFactor;\n      ",
          noImgFragmentShader: " \n        gl_FragColor = vec4( v_color, alphaFactor * v_alpha);\n      ",
          imgFragmentShader: "\n        vec4 tex = texture2D(particleTex, v_uv);\n      ",
          originColorFragmentShader: "\n        gl_FragColor = vec4(tex.rgb, alphaFactor * tex.a * v_alpha);\n      ",
          createColorFragmentShader: "\n        gl_FragColor = vec4(v_color * tex.rgb, alphaFactor * tex.a * v_alpha);\n      ",
          createColorWithMaskFragmentShader: "\n        vec4 maskTex = texture2D( particleMaskTex, v_uv);\n        gl_FragColor = vec4(v_color * tex.rgb + maskTex.a, alphaFactor * tex.a * v_alpha);\n      "
        };
      }
    }, {
      key: "_createVertexShader",
      value: function _createVertexShader() {
        var shader = this._getShader();

        var vertexShader = "";

        if (this.vertexShader) {
          vertexShader = this.vertexShader;
        } else {
          vertexShader = shader.vertexShader;

          if (this.isScaleByLifetime) {
            vertexShader += shader.isScaleByLifetimeVertexShader;
          } else {
            vertexShader += shader.sizeVertexShader;
          }

          if (this.rotateToVelocity) {
            vertexShader += shader.rotateToVelocityVertexShader;
          } else {
            vertexShader += shader.rotationVertexShader;
          }

          if (this.is2d) {
            vertexShader += shader.rotation2dShader;
          } else {
            vertexShader += shader.rotation3dShader;
          }

          vertexShader += "}";
        }

        return vertexShader;
      }
    }, {
      key: "_createFragmentShader",
      value: function _createFragmentShader() {
        var shader = this._getShader();

        var fragmentShader = "";

        if (this.fragmentShader) {
          fragmentShader = this.fragmentShader;
        } else {
          fragmentShader = shader.fragmentShader;

          if (this.fadeIn) {
            fragmentShader += shader.fadeInFragmentShader;
          }

          if (this.fadeOut) {
            fragmentShader += shader.fadeOutFragmentShader;
          }

          if (!this.particleTex) {
            fragmentShader += shader.noImgFragmentShader;
          } else {
            fragmentShader += shader.imgFragmentShader;

            if (this.useOriginColor) {
              fragmentShader += shader.originColorFragmentShader;
            } else {
              if (this.particleMaskTex) {
                fragmentShader += shader.createColorWithMaskFragmentShader;
              } else {
                fragmentShader += shader.createColorFragmentShader;
              }
            }
          }

          fragmentShader += "}";
        }

        return fragmentShader;
      }
    }]);

    return GPUParticleSystem;
  }(GeometryRenderer);

  var Particle = /*#__PURE__*/function (_GPUParticleSystem) {
    _inherits(Particle, _GPUParticleSystem);

    var _super69 = _createSuper(Particle);

    function Particle(entity) {
      _classCallCheck(this, Particle);

      return _super69.call(this, entity);
    }

    _createClass(Particle, [{
      key: "init",
      value: function init(props) {
        this._options = {
          position: props.__position,
          positionRandomness: props.__positionRandomness,
          velocity: props.__velocity,
          velocityRandomness: props.__velocityRandomness,
          acceleration: props.__acceleration,
          accelerationRandomness: props.__accelerationRandomness,
          color: props.__color,
          colorRandomness: props.__colorRandomness,
          lifetime: props.__lifetime,
          size: props.__size,
          sizeRandomness: props.__sizeRandomness,
          startAngle: props.__startAngle,
          startAngleRandomness: props.__startAngleRandomness,
          rotateRate: props.__rotateRate,
          rotateRateRandomness: props.__rotateRateRandomness,
          scaleFactor: props.__scaleFactor,
          alpha: props.__alpha,
          alphaRandomness: props.__alphaRandomness,
          startTimeRandomness: props.__startTimeRandomness
        };
        this._config = {
          maxCount: props.__maxCount,
          once: props.__once,
          rotateToVelocity: props.__rotateToVelocity,
          isScaleByLifetime: props.__isScaleByLifetime,
          fadeIn: props.__fadeIn,
          fadeOut: props.__fadeOut,
          texture: props.__texture ? props.__texture : null,
          maskTexture: props.__maskTexture ? props.__maskTexture : null,
          useOriginColor: props.__useOriginColor,
          is2d: props.__is2d,
          options: this._options
        };

        if (props.__spriteSheet) {
          if (_typeof(props.__spriteSheet) === "object" && props.__spriteSheet.length) {
            this._config.spriteSheet = props.__spriteSheet;
          } else if (typeof props.__spriteSheet === "string") {
            try {
              var spriteSheet = JSON.parse(props.__spriteSheet);

              if (spriteSheet.length) {
                this._config.spriteSheet = spriteSheet;
              }
            } catch (e) {}
          }
        }

        if (props.__positionArray) {
          if (_typeof(props.__positionArray) === "object" && props.__positionArray.length) {
            this._options.positionArray = props.__positionArray;
          } else if (typeof props.__positionArray === "string") {
            try {
              var positionArray = JSON.parse(props.__positionArray);

              if (positionArray.length) {
                this._options.positionArray = positionArray;
              }
            } catch (e) {}
          }
        }

        if (props.__separate) {
          this._config.blendFuncSeparate = [exports.BlendFunc[props.__srcRGB || "SRC_ALPHA"], exports.BlendFunc[props.__dstRGB || "ONE_MINUS_SRC_ALPHA"], exports.BlendFunc[props.__srcAlpha || "SRC_ALPHA"], exports.BlendFunc[props.__dstAlpha || "ONE_MINUS_SRC_ALPHA"]];
        } else if (props.__src && props.__dst) {
          this._config.blendFunc = [exports.BlendFunc[props.__src], exports.BlendFunc[props.__dst]];
        }

        this.initialize(this._config);

        if (props.__defaultStart === true || props.__defaultStart === void 0) {
          this.start();
        }
      }
    }, {
      key: "updateOption",
      value: function updateOption(key, value) {
        this._options = _objectSpread2(_objectSpread2({}, this._options), {}, _defineProperty({}, key, value));
        this._config = _objectSpread2(_objectSpread2({}, this._config), {}, {
          options: _objectSpread2({}, this._options)
        });
        this.initialize(this._config);
        this.start();
      }
    }, {
      key: "updateConfig",
      value: function updateConfig(key, value) {
        this._config = _objectSpread2(_objectSpread2({}, this._config), {}, _defineProperty({}, key, value));
        this.initialize(this._config);
        this.start();
      }
    }, {
      key: "__position",
      set: function set(value) {
        this.updateOption("position", value);
      }
    }, {
      key: "__positionRandomness",
      set: function set(value) {
        this.updateOption("positionRandomness", value);
      }
    }, {
      key: "__velocity",
      set: function set(value) {
        this.updateOption("velocity", value);
      }
    }, {
      key: "__velocityRandomness",
      set: function set(value) {
        this.updateOption("velocityRandomness", value);
      }
    }, {
      key: "__acceleration",
      set: function set(value) {
        this.updateOption("acceleration", value);
      }
    }, {
      key: "__accelerationRandomness",
      set: function set(value) {
        this.updateOption("accelerationRandomness", value);
      }
    }, {
      key: "__color",
      set: function set(value) {
        this.updateOption("color", value);
      }
    }, {
      key: "__colorRandomness",
      set: function set(value) {
        this.updateOption("colorRandomness", value);
      }
    }, {
      key: "__lifetime",
      set: function set(value) {
        this.updateOption("lifetime", value);
      }
    }, {
      key: "__size",
      set: function set(value) {
        this.updateOption("size", value);
      }
    }, {
      key: "__sizeRandomness",
      set: function set(value) {
        this.updateOption("sizeRandomness", value);
      }
    }, {
      key: "__startAngle",
      set: function set(value) {
        this.updateOption("startAngle", value);
      }
    }, {
      key: "__startAngleRandomness",
      set: function set(value) {
        this.updateOption("startAngleRandomness", value);
      }
    }, {
      key: "__rotateRate",
      set: function set(value) {
        this.updateOption("rotateRate", value);
      }
    }, {
      key: "__rotateRateRandomness",
      set: function set(value) {
        this.updateOption("rotateRateRandomness", value);
      }
    }, {
      key: "__scaleFactor",
      set: function set(value) {
        this.updateOption("scaleFactor", value);
      }
    }, {
      key: "__alpha",
      set: function set(value) {
        this.updateOption("alpha", value);
      }
    }, {
      key: "__alphaRandomness",
      set: function set(value) {
        this.updateOption("alphaRandomness", value);
      }
    }, {
      key: "__startTimeRandomness",
      set: function set(value) {
        this.updateOption("startTimeRandomness", value);
      }
    }, {
      key: "__positionArray",
      set: function set(value) {
        if (_typeof(value) === "object" && value.length) {
          this.updateOption("positionArray", value);
        } else if (typeof value === "string") {
          try {
            var positionArray = JSON.parse(value);

            if (positionArray.length) {
              this.updateOption("positionArray", positionArray);
            } else {
              this.updateOption("positionArray", null);
            }
          } catch (e) {
            this.updateOption("positionArray", null);
          }
        } else {
          this.updateOption("positionArray", null);
        }
      }
    }, {
      key: "__maxCount",
      set: function set(value) {
        this.updateConfig("maxCount", value);
      }
    }, {
      key: "__useOriginColor",
      set: function set(value) {
        this.updateConfig("useOriginColor", value);
      }
    }, {
      key: "__once",
      set: function set(value) {
        this.updateConfig("once", value);
      }
    }, {
      key: "__rotateToVelocity",
      set: function set(value) {
        this.updateConfig("rotateToVelocity", value);
      }
    }, {
      key: "__isScaleByLifetime",
      set: function set(value) {
        this.updateConfig("isScaleByLifetime", value);
      }
    }, {
      key: "__fadeIn",
      set: function set(value) {
        this.updateConfig("fadeIn", value);
      }
    }, {
      key: "__fadeOut",
      set: function set(value) {
        this.updateConfig("fadeOut", value);
      }
    }, {
      key: "__texture",
      set: function set(value) {
        this.updateConfig("texture", value);
      }
    }, {
      key: "__maskTexture",
      set: function set(value) {
        this.updateConfig("maskTexture", value);
      }
    }, {
      key: "__spriteSheet",
      set: function set(value) {
        if (_typeof(value) === "object" && value.length) {
          this.updateConfig("spriteSheet", value);
        } else if (typeof value === "string") {
          try {
            var spriteSheet = JSON.parse(value);

            if (spriteSheet.length) {
              this.updateConfig("spriteSheet", spriteSheet);
            } else {
              this.updateConfig("spriteSheet", null);
            }
          } catch (e) {
            this.updateConfig("spriteSheet", null);
          }
        } else {
          this.updateConfig("spriteSheet", null);
        }
      }
    }, {
      key: "__is2d",
      set: function set(value) {
        this.updateConfig("is2d", value);
      }
    }]);

    return Particle;
  }(GPUParticleSystem);

  var FRAG_SHADER$1 = "varying vec2 v_uv;\n\nuniform sampler2D u_texture;\n\nvoid main(void) {\n\n  gl_FragColor = texture2D(u_texture, v_uv);\n\n}\n";
  var VERT_SHADER = "attribute vec3 a_position;\nattribute vec2 a_uv;\n\nvarying vec2 v_uv;\n\nuniform mat4 u_projMat;\nuniform mat4 u_viewMat;\n\nvoid main() {\n\n  gl_Position = u_projMat * u_viewMat * vec4( a_position, 1.0 );\n  v_uv = a_uv;\n\n}\n";

  var TrailMaterial = /*#__PURE__*/function (_Material6) {
    _inherits(TrailMaterial, _Material6);

    var _super70 = _createSuper(TrailMaterial);

    function TrailMaterial() {
      _classCallCheck(this, TrailMaterial);

      return _super70.apply(this, arguments);
    }

    _createClass(TrailMaterial, [{
      key: "_generateTechnique",
      value: function _generateTechnique() {
        var tech = new RenderTechnique("trail_tech");
        tech.isValid = true;
        tech.uniforms = {
          u_texture: {
            name: "u_texture",
            type: exports.DataType.SAMPLER_2D
          }
        };
        tech.attributes = {};
        tech.states = {
          enable: [exports.RenderState.BLEND],
          functions: {
            blendFunc: [exports.BlendFunc.SRC_ALPHA, exports.BlendFunc.ONE],
            depthMask: [false]
          }
        };
        tech.customMacros = [];
        tech.vertexShader = VERT_SHADER;
        tech.fragmentShader = FRAG_SHADER$1;
        this._technique = tech;
        this.renderType = exports.MaterialType.TRANSPARENT;
      }
    }, {
      key: "prepareDrawing",
      value: function prepareDrawing(context, component, primitive) {
        if (this._technique === null) {
          this._generateTechnique();
        }

        _get(_getPrototypeOf(TrailMaterial.prototype), "prepareDrawing", this).call(this, context, component, primitive);
      }
    }]);

    return TrailMaterial;
  }(Material);

  var _tempVector3 = new Vector3();

  var TrailRenderer = /*#__PURE__*/function (_GeometryRenderer4) {
    _inherits(TrailRenderer, _GeometryRenderer4);

    var _super71 = _createSuper(TrailRenderer);

    function TrailRenderer(entity, props) {
      var _this71;

      _classCallCheck(this, TrailRenderer);

      _this71 = _super71.call(this, entity);
      _this71._stroke = props.stroke || 0.2;
      _this71._minSeg = props.minSeg || 0.02;
      _this71._lifetime = props.lifetime || 1e3;
      _this71._maxPointNum = _this71._lifetime / 1e3 * entity.engine.targetFrameRate;
      _this71._points = [];
      _this71._pointStates = [];
      _this71._strapPoints = [];

      for (var i = 0; i < _this71._maxPointNum; i++) {
        _this71._points.push(new Vector3());

        _this71._pointStates.push(_this71._lifetime);

        _this71._strapPoints.push(new Vector3());

        _this71._strapPoints.push(new Vector3());
      }

      _this71._curPointNum = 0;
      var mtl = props.material || new TrailMaterial(_this71.engine, "trial_mtl");
      _this71.material = mtl;

      _this71.setTexture(props.texture);

      _this71._initGeometry();

      return _this71;
    }

    _createClass(TrailRenderer, [{
      key: "update",
      value: function update(deltaTime) {
        var mov = 0,
            newIdx = 0;

        for (var i = 0; i < this._curPointNum; i++) {
          this._pointStates[i] -= deltaTime;

          if (this._pointStates[i] < 0) {
            mov++;
          } else if (mov > 0) {
            newIdx = i - mov;
            this._pointStates[newIdx] = this._pointStates[i];

            this._points[i].cloneTo(this._points[newIdx]);
          }
        }

        this._curPointNum -= mov;
        var appendNewPoint = true;

        if (this._curPointNum === this._maxPointNum) {
          appendNewPoint = false;
        } else if (this._curPointNum > 0) {
          var lastPoint = this._points[this._points.length - 1];

          if (Vector3.distance(this.entity.worldPosition, lastPoint) < this._minSeg) {
            appendNewPoint = false;
          }
        }

        if (appendNewPoint) {
          this._pointStates[this._curPointNum] = this._lifetime;
          this.entity.worldPosition.cloneTo(this._points[this._curPointNum]);
          this._curPointNum++;
        }
      }
    }, {
      key: "render",
      value: function render(camera) {
        this._updateStrapVertices(camera, this._points);

        this._updateStrapCoords();

        this._vertexBuffer.setData(this._vertices);

        _get(_getPrototypeOf(TrailRenderer.prototype), "render", this).call(this, camera);
      }
    }, {
      key: "setTexture",
      value: function setTexture(texture) {
        if (texture) {
          this.material.setValue("u_texture", texture);
        }
      }
    }, {
      key: "_initGeometry",
      value: function _initGeometry() {
        var geometry2 = new BufferGeometry(this._entity.engine);
        var vertexStride = 20;
        var vertexCount = this._maxPointNum * 2;
        var vertexFloatCount = vertexCount * vertexStride;
        var vertices = new Float32Array(vertexFloatCount);
        var vertexElements = [new VertexElement("POSITION", 0, exports.VertexElementFormat.Vector3, 0), new VertexElement("TEXCOORD_0", 12, exports.VertexElementFormat.Vector2, 0)];
        var vertexBuffer = new Buffer(this.engine, vertexFloatCount * 4, exports.BufferUsage.Dynamic);
        geometry2.setVertexBufferBinding(vertexBuffer, vertexStride);
        geometry2.setVertexElements(vertexElements);
        geometry2.addSubGeometry(0, vertexCount, exports.PrimitiveTopology.TriangleStrip);
        this._vertexBuffer = vertexBuffer;
        this._vertexStride = vertexStride;
        this._vertices = vertices;
        this.geometry = geometry2;
      }
    }, {
      key: "_updateStrapVertices",
      value: function _updateStrapVertices(camera, points) {
        var m = camera.viewMatrix;
        var e = m.elements;
        var vx = new Vector3(e[0], e[4], e[8]);
        var vy = new Vector3(e[1], e[5], e[9]);
        var vz = new Vector3(e[2], e[6], e[10]);
        var s = this._stroke;
        vy.scale(s);
        var up = new Vector3();
        var down = new Vector3();
        var rotation = new Quaternion();
        Vector3.transformByQuat(vx, rotation, vx);
        Vector3.transformByQuat(vy, rotation, vy);
        var dy = new Vector3();
        var cross = new Vector3();
        var perpVector = new Vector3();
        vx.normalize();
        var vertieces = this._vertices;

        for (var i = 0; i < this._maxPointNum; i++) {
          if (i < this._curPointNum) {
            var p = points[i];

            if (i === this._curPointNum - 1 && i !== 0) {
              Vector3.subtract(p, points[i - 1], perpVector);
            } else {
              Vector3.subtract(points[i + 1], p, perpVector);
            }

            this._projectOnPlane(perpVector, vz, perpVector);

            perpVector.normalize();
            var angle = Math.acos(Vector3.dot(vx, perpVector));
            Vector3.cross(vx, perpVector, cross);

            if (Vector3.dot(cross, vz) <= 0) {
              angle = Math.PI * 2 - angle;
            }

            Quaternion.rotationAxisAngle(vz, angle, rotation);
            Vector3.transformByQuat(vy, rotation, dy);
            Vector3.add(p, dy, up);
            Vector3.subtract(p, dy, down);
          }

          var p0 = i * 2 * this._vertexStride / 4;
          var p1 = (i * 2 + 1) * this._vertexStride / 4;
          vertieces[p0] = up.x;
          vertieces[p0 + 1] = up.y;
          vertieces[p0 + 2] = up.z;
          vertieces[p1] = down.x;
          vertieces[p1 + 1] = down.y;
          vertieces[p1 + 2] = down.z;
        }
      }
    }, {
      key: "_updateStrapCoords",
      value: function _updateStrapCoords() {
        if (this._prePointsNum === this._curPointNum) {
          return;
        }

        this._prePointsNum = this._curPointNum;
        var count = this._curPointNum;
        var texDelta = 1 / count;
        var vertieces = this._vertices;

        for (var i = 0; i < count; i++) {
          var d = 1 - i * texDelta;
          var p0 = i * 2 * this._vertexStride / 4;
          var p1 = (i * 2 + 1) * this._vertexStride / 4;
          vertieces[p0] = 0;
          vertieces[p0 + 1] = d;
          vertieces[p1] = 1;
          vertieces[p1 + 1] = d;
        }
      }
    }, {
      key: "_projectOnVector",
      value: function _projectOnVector(a, p, out) {
        var n_p = p.clone();
        Vector3.normalize(n_p, n_p);
        var cosine = Vector3.dot(a, n_p);
        out.x = n_p.x * cosine;
        out.y = n_p.y * cosine;
        out.z = n_p.z * cosine;
      }
    }, {
      key: "_projectOnPlane",
      value: function _projectOnPlane(a, n, out) {
        this._projectOnVector(a, n, _tempVector3);

        Vector3.subtract(a, _tempVector3, out);
      }
    }]);

    return TrailRenderer;
  }(GeometryRenderer);

  var BoxCollider = /*#__PURE__*/function (_ABoxCollider) {
    _inherits(BoxCollider, _ABoxCollider);

    var _super72 = _createSuper(BoxCollider);

    function BoxCollider(entity) {
      var _this72;

      _classCallCheck(this, BoxCollider);

      _this72 = _super72.call(this, entity);
      _this72._center = new Vector3();
      _this72._size = new Vector3();
      _this72.isShowCollider = true;
      _this72.center = _this72.center;
      _this72.size = _this72.size;
      _this72.isShowCollider = _this72.isShowCollider;
      return _this72;
    }

    _createClass(BoxCollider, [{
      key: "center",
      get: function get() {
        return this._center;
      },
      set: function set(value) {
        this._center = value;
        this.setBoxCenterSize(this._center, this._size);
      }
    }, {
      key: "size",
      get: function get() {
        return this._size;
      },
      set: function set(value) {
        this._size = value;
        this.setBoxCenterSize(this._center, this._size);
      }
    }]);

    return BoxCollider;
  }(ABoxCollider);

  var SphereCollider = /*#__PURE__*/function (_ASphereCollider) {
    _inherits(SphereCollider, _ASphereCollider);

    var _super73 = _createSuper(SphereCollider);

    function SphereCollider(entity) {
      var _this73;

      _classCallCheck(this, SphereCollider);

      _this73 = _super73.call(this, entity);
      _this73.__center = new Vector3();
      _this73.__radius = 1;
      _this73.isShowCollider = true;
      _this73._center = _this73._center;
      _this73._radius = _this73._radius;
      _this73.isShowCollider = _this73.isShowCollider;
      return _this73;
    }

    _createClass(SphereCollider, [{
      key: "_center",
      get: function get() {
        return this.__center;
      },
      set: function set(value) {
        this.__center = value;
        this.setSphere(this.__center, this.__radius);
      }
    }, {
      key: "_radius",
      get: function get() {
        return this.__radius;
      },
      set: function set(value) {
        this.__radius = value;
        this.setSphere(this.__center, this.__radius);
      }
    }]);

    return SphereCollider;
  }(ASphereCollider);

  Scene.registerFeature(ColliderFeature);

  function intersectBox2Box(boxA, boxB) {
    return boxA.min.x <= boxB.max.x && boxA.max.x >= boxB.min.x && boxA.min.y <= boxB.max.y && boxA.max.y >= boxB.min.y && boxA.min.z <= boxB.max.z && boxA.max.z >= boxB.min.z;
  }

  function intersectSphere2Sphere(sphereA, sphereB) {
    var distance = Vector3.distance(sphereA.center, sphereB.center);
    return distance < sphereA.radius + sphereA.radius;
  }

  function intersectSphere2Box(sphere, box) {
    var center = sphere.center;
    var closestPoint = new Vector3(Math.max(box.min.x, Math.min(center.x, box.max.x)), Math.max(box.min.y, Math.min(center.y, box.max.y)), Math.max(box.min.z, Math.min(center.z, box.max.z)));
    var distance = Vector3.distance(center, closestPoint);
    return distance < sphere.radius;
  }

  var CollisionDetection = /*#__PURE__*/function (_Script) {
    _inherits(CollisionDetection, _Script);

    var _super74 = _createSuper(CollisionDetection);

    function CollisionDetection(entity) {
      var _this74;

      _classCallCheck(this, CollisionDetection);

      _this74 = _super74.call(this, entity);
      _this74._colliderManager = null;
      _this74._myCollider = null;
      _this74._overlopCollider = null;
      return _this74;
    }

    _createClass(CollisionDetection, [{
      key: "onUpdate",
      value: function onUpdate(deltaTime) {
        _get(_getPrototypeOf(CollisionDetection.prototype), "onUpdate", this).call(this, deltaTime);

        var overlopCollider = null;

        if (this._colliderManager && this._myCollider) {
          var colliders = this._colliderManager.colliders;

          if (this._myCollider instanceof ABoxCollider) {
            this._box = this._getWorldBox(this._myCollider);

            for (var i = 0, len = colliders.length; i < len; i++) {
              var collider2 = colliders[i];

              if (collider2 != this._myCollider && this._boxCollision(collider2)) {
                overlopCollider = collider2;
                this.trigger(new Event("collision", this, {
                  collider: collider2
                }));
              }
            }
          } else if (this._myCollider instanceof ASphereCollider) {
            this._sphere = this._getWorldSphere(this._myCollider);

            for (var _i20 = 0, _len6 = colliders.length; _i20 < _len6; _i20++) {
              var _collider = colliders[_i20];

              if (_collider != this._myCollider && this._sphereCollision(_collider)) {
                overlopCollider = _collider;
                this.trigger(new Event("collision", this, {
                  collider: _collider
                }));
              }
            }
          }
        }

        if (overlopCollider != null && this._overlopCollider != overlopCollider) {
          this.trigger(new Event("begin_overlop", this, {
            collider: overlopCollider
          }));
        }

        if (this._overlopCollider != null && this._overlopCollider != overlopCollider) {
          var e = this._overlopCollider;
          this.trigger(new Event("end_overlop", this, {
            collider: e
          }));
        }

        this._overlopCollider = overlopCollider;
      }
    }, {
      key: "_getWorldBox",
      value: function _getWorldBox(boxCollider) {
        var mat = boxCollider.entity.transform.worldMatrix;
        var max = new Vector3();
        var min = new Vector3();
        Vector3.transformCoordinate(boxCollider.boxMax, mat, max);
        Vector3.transformCoordinate(boxCollider.boxMin, mat, min);
        var temp = CollisionDetection._tempVec3;
        var corners = boxCollider.getCorners();

        for (var i = 0; i < 8; i++) {
          Vector3.transformCoordinate(corners[i], mat, temp);
          if (temp.x > max.x) max.x = temp.x;
          if (temp.y > max.y) max.y = temp.y;
          if (temp.z > max.z) max.z = temp.z;
          if (temp.x < min.x) min.x = temp.x;
          if (temp.y < min.y) min.y = temp.y;
          if (temp.z < min.z) min.z = temp.z;
        }

        return {
          min: min,
          max: max
        };
      }
    }, {
      key: "_getWorldSphere",
      value: function _getWorldSphere(sphereCollider) {
        var center = new Vector3();
        Vector3.transformCoordinate(sphereCollider.center, sphereCollider.entity.transform.worldMatrix, center);
        return {
          radius: sphereCollider.radius,
          center: center
        };
      }
    }, {
      key: "_boxCollision",
      value: function _boxCollision(other) {
        if (other instanceof ABoxCollider) {
          var box = this._getWorldBox(other);

          return intersectBox2Box(box, this._box);
        } else if (other instanceof ASphereCollider) {
          var sphere = this._getWorldSphere(other);

          return intersectSphere2Box(sphere, this._box);
        }

        return false;
      }
    }, {
      key: "_sphereCollision",
      value: function _sphereCollision(other) {
        if (other instanceof ABoxCollider) {
          var box = this._getWorldBox(other);

          return intersectSphere2Box(this._sphere, box);
        } else if (other instanceof ASphereCollider) {
          var sphere = this._getWorldSphere(other);

          return intersectSphere2Sphere(sphere, this._sphere);
        }

        return false;
      }
    }, {
      key: "onAwake",
      value: function onAwake() {
        this._colliderManager = this.scene.findFeature(ColliderFeature);
        this._myCollider = this.entity.getComponent(Collider);
      }
    }, {
      key: "overlopCollider",
      get: function get() {
        return this._overlopCollider;
      }
    }]);

    return CollisionDetection;
  }(Script);

  CollisionDetection._tempVec3 = new Vector3();

  var Fog = /*#__PURE__*/function (_Component8) {
    _inherits(Fog, _Component8);

    var _super75 = _createSuper(Fog);

    function Fog(node) {
      var _this75;

      _classCallCheck(this, Fog);

      _this75 = _super75.call(this, node);
      _this75.color = new Vector3(1, 0, 0);
      return _this75;
    }

    _createClass(Fog, [{
      key: "_onEnable",
      value: function _onEnable() {
        this.scene.findFeature(FogFeature).fog = this;
      }
    }, {
      key: "_onDisable",
      value: function _onDisable() {
        this.scene.findFeature(FogFeature).fog = null;
      }
    }, {
      key: "bindMaterialValues",
      value: function bindMaterialValues(mtl) {}
    }]);

    return Fog;
  }(Component);

  var EXP2Fog = /*#__PURE__*/function (_Fog) {
    _inherits(EXP2Fog, _Fog);

    var _super76 = _createSuper(EXP2Fog);

    function EXP2Fog() {
      var _this76;

      _classCallCheck(this, EXP2Fog);

      _this76 = _super76.apply(this, arguments);
      _this76.density = 25e-4;
      return _this76;
    }

    _createClass(EXP2Fog, [{
      key: "bindMaterialValues",
      value: function bindMaterialValues(mtl) {
        mtl.setValue("u_fogColor", this.color);
        mtl.setValue("u_fogDensity", this.density);
      }
    }]);

    return EXP2Fog;
  }(Fog);

  function hasFogFeature() {
    return true;
  }

  function getFogMacro() {
    return this.findFeature(FogFeature).macro;
  }

  function bindFogToMaterial(mtl) {
    this.findFeature(FogFeature).bindFogToMaterial(mtl);
  }

  var FogFeature = /*#__PURE__*/function (_SceneFeature3) {
    _inherits(FogFeature, _SceneFeature3);

    var _super77 = _createSuper(FogFeature);

    function FogFeature() {
      var _this77;

      _classCallCheck(this, FogFeature);

      _this77 = _super77.call(this);
      _this77._fog = null;
      _this77._macros = [];
      return _this77;
    }

    _createClass(FogFeature, [{
      key: "bindFogToMaterial",
      value: function bindFogToMaterial(mtl) {
        if (this.fog && mtl.useFog) {
          this.fog.bindMaterialValues(mtl);
        }

        return this;
      }
    }, {
      key: "fog",
      get: function get() {
        return this._fog;
      },
      set: function set(v) {
        if (v !== this._fog) {
          this._fog = v;
          var macro = [];

          if (v instanceof Fog) {
            macro.push("O3_HAS_FOG");

            if (v instanceof EXP2Fog) {
              macro.push("O3_FOG_EXP2");
            }
          }

          if (this._macros.length !== macro.length) {
            this._macros = macro;
          }
        }
      }
    }, {
      key: "macro",
      get: function get() {
        return this._macros;
      }
    }]);

    return FogFeature;
  }(SceneFeature);

  var LinearFog = /*#__PURE__*/function (_Fog2) {
    _inherits(LinearFog, _Fog2);

    var _super78 = _createSuper(LinearFog);

    function LinearFog() {
      var _this78;

      _classCallCheck(this, LinearFog);

      _this78 = _super78.apply(this, arguments);
      _this78.near = 1;
      _this78.far = 1e3;
      return _this78;
    }

    _createClass(LinearFog, [{
      key: "bindMaterialValues",
      value: function bindMaterialValues(mtl) {
        mtl.setValue("u_fogColor", this.color);
        mtl.setValue("u_fogNear", this.near);
        mtl.setValue("u_fogFar", this.far);
      }
    }]);

    return LinearFog;
  }(Fog);

  Scene.registerFeature(FogFeature);
  Scene.prototype.hasFogFeature = hasFogFeature;
  Scene.prototype.getFogMacro = getFogMacro;
  Scene.prototype.bindFogToMaterial = bindFogToMaterial;
  var cacheId = 0;

  var Probe = /*#__PURE__*/function (_Component9) {
    _inherits(Probe, _Component9);

    var _super79 = _createSuper(Probe);

    _createClass(Probe, [{
      key: "camera",
      set: function set(camera) {
        if (camera === this._camera) return;
        this._camera && this.renderPipeline.removeRenderPass(this.renderPass);
        this._camera = camera;
        camera && this.renderPipeline.addRenderPass(this.renderPass);
      },
      get: function get() {
        return this._camera;
      }
    }, {
      key: "texture",
      get: function get() {
        var _this$renderPass$rend;

        return (_this$renderPass$rend = this.renderPass.renderTarget) === null || _this$renderPass$rend === void 0 ? void 0 : _this$renderPass$rend.getColorTexture();
      }
    }, {
      key: "depthTexture",
      get: function get() {
        var _this$renderPass$rend2;

        return (_this$renderPass$rend2 = this.renderPass.renderTarget) === null || _this$renderPass$rend2 === void 0 ? void 0 : _this$renderPass$rend2.depthTexture;
      }
    }, {
      key: "cubeTexture",
      get: function get() {
        var _this$renderPass$rend3;

        return (_this$renderPass$rend3 = this.renderPass.renderTarget) === null || _this$renderPass$rend3 === void 0 ? void 0 : _this$renderPass$rend3.getColorTexture();
      }
    }, {
      key: "renderPipeline",
      get: function get() {
        return this.camera._renderPipeline;
      }
    }, {
      key: "rhi",
      get: function get() {
        return this.camera.scene.engine._hardwareRenderer;
      }
    }, {
      key: "renderItems",
      get: function get() {
        var _this80 = this;

        var opaqueQueue = this.renderPipeline.opaqueQueue;
        var transparentQueue = this.renderPipeline.transparentQueue;
        return opaqueQueue.items.concat(transparentQueue.items).filter(function (item) {
          if (!item.primitive) return false;
          if (_this80.excludeRenderList.includes(item.material)) return false;
          if (_this80.renderAll) return true;
          if (_this80.renderList.includes(item.material)) return true;
        });
      }
    }, {
      key: "samples",
      get: function get() {
        return this.renderTarget.antiAliasing;
      }
    }]);

    function Probe(entity) {
      var _this79;

      _classCallCheck(this, Probe);

      _this79 = _super79.call(this, entity);
      _this79.cacheId = cacheId++;
      _this79.renderPass = new RenderPass("_renderPass" + _this79.cacheId, -10);
      _this79.renderPass.renderOverride = true;
      _this79.renderPass.preRender = _this79.preRender.bind(_assertThisInitialized(_this79));
      _this79.renderPass.render = _this79.render.bind(_assertThisInitialized(_this79));
      _this79.renderPass.postRender = _this79.postRender.bind(_assertThisInitialized(_this79));

      _this79.addEventListener("enabled", function () {
        _this79.renderPass.enabled = true;
      });

      _this79.addEventListener("disabled", function () {
        _this79.renderPass.enabled = false;
      });

      return _this79;
    }

    _createClass(Probe, [{
      key: "init",
      value: function init() {
        var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        this.isCube = !!config.isCube;
        this.camera = config.camera || this.scene._activeCameras[0];
        this.excludeRenderList = config.excludeRenderList || [];
        this.renderAll = !!config.renderAll;
        this.renderList = config.renderList || [];
        this.clipPlanes = config.clipPlanes || [];
        var width = config.width || 1024;
        var height = config.height || 1024;
        var samples = config.samples || 1;
        this.renderTarget = new RenderTarget(this.engine, width, height, new RenderColorTexture(this.engine, width, height, void 0, false, this.isCube), exports.RenderBufferDepthFormat.Depth, samples);
        this.renderTargetSwap = new RenderTarget(this.engine, width, height, new RenderColorTexture(this.engine, width, height, void 0, false, this.isCube), exports.RenderBufferDepthFormat.Depth, samples);
        this.renderPass.renderTarget = this.renderTarget;
      }
    }, {
      key: "preRender",
      value: function preRender() {
        this.oriClipPlane = this.scene.clipPlanes;
        this.scene.clipPlanes = this.clipPlanes;
      }
    }, {
      key: "render",
      value: function render() {
        var _this81 = this;

        var context = RenderContext._getRenderContext(this.camera);

        this.renderItems.forEach(function (item) {
          var component = item.component,
              primitive = item.primitive,
              subPrimitive = item.subPrimitive,
              material = item.material;
          if (!(component.renderPassFlag & _this81.renderPassFlag)) return;
          material.prepareDrawing(context, component, primitive);

          _this81.rhi.drawPrimitive(primitive, subPrimitive, material);
        });
      }
    }, {
      key: "postRender",
      value: function postRender() {
        this.scene.clipPlanes = this.oriClipPlane;

        if (this.renderPass.enabled) {
          if (this.onTextureChange) {
            if (this.isCube) {
              this.onTextureChange(this.cubeTexture);
            } else {
              this.onTextureChange(this.texture, this.depthTexture);
            }
          }

          if (this.renderPass.renderTarget === this.renderTarget) {
            this.renderPass.renderTarget = this.renderTargetSwap;
          } else {
            this.renderPass.renderTarget = this.renderTarget;
          }
        }
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.enabled = false;
        this.renderPipeline.removeRenderPass(this.renderPass);

        _get(_getPrototypeOf(Probe.prototype), "destroy", this).call(this);

        this.renderTarget.destroy();
        this.renderTargetSwap.destroy();
      }
    }, {
      key: "onTextureChange",
      value: function onTextureChange(texture, depthTexture) {}
    }]);

    return Probe;
  }(Component);

  var PlaneProbe = /*#__PURE__*/function (_Probe) {
    _inherits(PlaneProbe, _Probe);

    var _super80 = _createSuper(PlaneProbe);

    function PlaneProbe(node) {
      _classCallCheck(this, PlaneProbe);

      return _super80.call(this, node);
    }

    _createClass(PlaneProbe, [{
      key: "init",
      value: function init() {
        var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _get(_getPrototypeOf(PlaneProbe.prototype), "init", this).call(this, config);
      }
    }, {
      key: "storeMaterial",
      value: function storeMaterial() {
        this.renderItems.forEach(function (item) {
          var material = item.material;
          item.initialSide = material.side;
          material.side = exports.Side.BACK;
        });
      }
    }, {
      key: "restoreMaterial",
      value: function restoreMaterial() {
        this.renderItems.forEach(function (item) {
          var material = item.material;
          material.side = item.initialSide;
          delete item.initialSide;
        });
      }
    }, {
      key: "preRender",
      value: function preRender() {
        _get(_getPrototypeOf(PlaneProbe.prototype), "preRender", this).call(this);

        this.storeMaterial();
      }
    }, {
      key: "postRender",
      value: function postRender() {
        _get(_getPrototypeOf(PlaneProbe.prototype), "postRender", this).call(this);

        this.restoreMaterial();
      }
    }]);

    return PlaneProbe;
  }(Probe);

  var cacheTarget = new Vector3();
  var cacheUp = new Vector3();
  var cacheDir = new Vector3();
  var fovRadian = 90 * Math.PI / 180;

  var CubeProbe = /*#__PURE__*/function (_Probe2) {
    _inherits(CubeProbe, _Probe2);

    var _super81 = _createSuper(CubeProbe);

    function CubeProbe(node) {
      var _this82;

      _classCallCheck(this, CubeProbe);

      _this82 = _super81.call(this, node);
      _this82.oriViewMatrix = new Matrix();
      _this82.oriInverseViewMatrix = new Matrix();
      _this82.oriProjectionMatrix = new Matrix();
      _this82.oriInverseProjectionMatrix = new Matrix();
      return _this82;
    }

    _createClass(CubeProbe, [{
      key: "init",
      value: function init() {
        var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _get(_getPrototypeOf(CubeProbe.prototype), "init", this).call(this, _objectSpread2(_objectSpread2({}, config), {}, {
          isCube: true
        }));

        this.position = config.position || new Vector3();
      }
    }, {
      key: "storeCamera",
      value: function storeCamera() {
        this.camera.viewMatrix.cloneTo(this.oriViewMatrix);
        this.camera.inverseViewMatrix.cloneTo(this.oriInverseViewMatrix);
        this.camera.projectionMatrix.cloneTo(this.oriProjectionMatrix);
        this.camera.inverseProjectionMatrix.cloneTo(this.oriInverseProjectionMatrix);
      }
    }, {
      key: "restoreCamera",
      value: function restoreCamera() {
        this.oriViewMatrix.cloneTo(this.camera.viewMatrix);
        this.oriInverseViewMatrix.cloneTo(this.camera.inverseViewMatrix);
        this.oriProjectionMatrix.cloneTo(this.camera.projectionMatrix);
        this.oriInverseProjectionMatrix.cloneTo(this.camera.inverseProjectionMatrix);
      }
    }, {
      key: "preRender",
      value: function preRender() {
        _get(_getPrototypeOf(CubeProbe.prototype), "preRender", this).call(this);

        this.storeCamera();
      }
    }, {
      key: "render",
      value: function render() {
        for (var faceIndex = 0; faceIndex < 6; faceIndex++) {
          this.rhi.setRenderTargetFace(this.renderPass.renderTarget, faceIndex);
          this.rhi.clearRenderTarget(this.renderPass.clearMode, this.renderPass.clearParam);
          this.setCamera(faceIndex);

          _get(_getPrototypeOf(CubeProbe.prototype), "render", this).call(this);

          if (faceIndex < 5) {
            this.rhi.blitRenderTarget(this.renderPass.renderTarget);
          }
        }
      }
    }, {
      key: "postRender",
      value: function postRender() {
        _get(_getPrototypeOf(CubeProbe.prototype), "postRender", this).call(this);

        this.restoreCamera();
      }
    }, {
      key: "setCamera",
      value: function setCamera(faceIndex) {
        switch (faceIndex) {
          case 0:
            cacheUp.setValue(0, -1, 0);
            cacheDir.setValue(1, 0, 0);
            break;

          case 1:
            cacheUp.setValue(0, -1, 0);
            cacheDir.setValue(-1, 0, 0);
            break;

          case 2:
            cacheUp.setValue(0, 0, 1);
            cacheDir.setValue(0, 1, 0);
            break;

          case 3:
            cacheUp.setValue(0, 0, -1);
            cacheDir.setValue(0, -1, 0);
            break;

          case 4:
            cacheUp.setValue(0, -1, 0);
            cacheDir.setValue(0, 0, 1);
            break;

          case 5:
            cacheUp.setValue(0, -1, 0);
            cacheDir.setValue(0, 0, -1);
            break;
        }

        Vector3.add(this.position, cacheDir, cacheTarget);
        Matrix.lookAt(this.position, cacheTarget, cacheUp, this.camera.viewMatrix);
        Matrix.invert(this.camera.viewMatrix, this.camera.inverseViewMatrix);
        Matrix.perspective(fovRadian, 1, this.camera.nearClipPlane, this.camera.farClipPlane, this.camera.projectionMatrix);
        Matrix.invert(this.camera.projectionMatrix, this.camera.inverseProjectionMatrix);
      }
    }]);

    return CubeProbe;
  }(Probe);

  var LightShadow = /*#__PURE__*/function () {
    function LightShadow() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        engine: null,
        width: 512,
        height: 512
      };

      _classCallCheck(this, LightShadow);

      this._mapSize = new Vector2(props.width, props.height);
      this._renderTarget = new RenderTarget(props.engine, props.width, props.height, new RenderColorTexture(props.engine, props.width, props.height));
      this.bias = 5e-3;
      this.intensity = 0.2;
      this.radius = 1;
      this.projectionMatrix = new Matrix();
    }

    _createClass(LightShadow, [{
      key: "initShadowProjectionMatrix",
      value: function initShadowProjectionMatrix(light) {
        if (light instanceof DirectLight) {
          Matrix.ortho(-5, 5, -5, 5, 0.1, 50, this.projectionMatrix);
        }

        if (light instanceof PointLight) {
          Matrix.perspective(MathUtil.degreeToRadian(50), 1, 0.5, 50, this.projectionMatrix);
        }

        if (light instanceof SpotLight) {
          var fov = Math.min(Math.PI / 2, light.angle * 2 * Math.sqrt(2));
          Matrix.perspective(fov, 1, 0.1, light.distance + 5, this.projectionMatrix);
        }
      }
    }, {
      key: "bindShadowValues",
      value: function bindShadowValues(mtl, index, light) {
        mtl.setValue("u_viewMatFromLight[".concat(index, "]"), light.viewMatrix);
        mtl.setValue("u_projMatFromLight[".concat(index, "]"), this.projectionMatrix);
        var uniformName = "u_shadows[".concat(index, "]");
        mtl.setValue(uniformName + ".bias", this.bias);
        mtl.setValue(uniformName + ".intensity", this.intensity);
        mtl.setValue(uniformName + ".radius", this.radius);
        mtl.setValue(uniformName + ".mapSize", this._mapSize);
        mtl.setValue("u_shadowMaps[".concat(index, "]"), this.map);
      }
    }, {
      key: "renderTarget",
      get: function get() {
        return this._renderTarget;
      }
    }, {
      key: "map",
      get: function get() {
        return this._renderTarget.getColorTexture();
      }
    }, {
      key: "mapSize",
      get: function get() {
        return this._mapSize;
      }
    }], [{
      key: "getUniformDefine",
      value: function getUniformDefine(index) {
        var uniforms = {};
        uniforms["u_viewMatFromLight[".concat(index, "]")] = {
          name: "u_viewMatFromLight[".concat(index, "]"),
          type: exports.DataType.FLOAT_MAT4
        };
        uniforms["u_projMatFromLight[".concat(index, "]")] = {
          name: "u_projMatFromLight[".concat(index, "]"),
          type: exports.DataType.FLOAT_MAT4
        };
        var uniformName = "u_shadows[".concat(index, "]");
        uniforms[uniformName + ".bias"] = {
          name: uniformName + ".bias",
          type: exports.DataType.FLOAT
        };
        uniforms[uniformName + ".intensity"] = {
          name: uniformName + ".intensity",
          type: exports.DataType.FLOAT
        };
        uniforms[uniformName + ".radius"] = {
          name: uniformName + ".radius",
          type: exports.DataType.FLOAT
        };
        uniforms[uniformName + ".mapSize"] = {
          name: uniformName + ".mapSize",
          type: exports.DataType.FLOAT_VEC2
        };
        uniforms["u_shadowMaps[".concat(index, "]")] = {
          name: "u_shadowMaps[".concat(index, "]"),
          type: exports.DataType.SAMPLER_2D
        };
        return uniforms;
      }
    }]);

    return LightShadow;
  }();

  Object.defineProperty(Light.prototype, "enableShadow", {
    get: function get() {
      return this._enableShadow;
    },
    set: function set(enabled) {
      this._enableShadow = enabled;

      if (this._enableShadow) {
        if (this instanceof AmbientLight) {
          Logger.warn("Has no shadow!");
          return;
        }

        this.shadow = this.shadow || new LightShadow({
          engine: this.engine,
          width: 512,
          height: 512
        });
        this.shadow.initShadowProjectionMatrix(this);
      }
    }
  });
  Object.defineProperty(Component.prototype, "recieveShadow", {
    get: function get() {
      return this._recieveShadow;
    },
    set: function set(enabled) {
      this._recieveShadow = enabled;
    }
  });
  Object.defineProperty(Component.prototype, "castShadow", {
    get: function get() {
      return this._castShadow;
    },
    set: function set(enabled) {
      this._castShadow = enabled;
    }
  });
  var fs$2 = "precision mediump float;\n\n/**\n * \n*/\nvec4 pack (float depth) {\n\n  // rgba 432z,11/256\n  const vec4 bitShift = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);\n  const vec4 bitMask = vec4(1.0/256.0, 1.0/256.0, 1.0/256.0, 0.0);\n\n  vec4 rgbaDepth = fract(depth * bitShift); //z\n\n  // Cut off the value which do not fit in 8 bits\n  rgbaDepth -= rgbaDepth.gbaa * bitMask;\n\n  return rgbaDepth;\n}\n\nvoid main() {\n\n  // zrgba,z\n  gl_FragColor = pack(gl_FragCoord.z);\n\n}";
  var vs$2 = "#include <common_vert>\n#include <normal_share>\n#include <shadow_share>\n\nvoid main() {\n\n    #include <begin_position_vert>\n    #include <begin_normal_vert>\n    #include <skinning_vert>\n    #include <shadow_vert>\n    #include <position_vert>\n\n}\n";

  var ShadowMapMaterial = /*#__PURE__*/function (_ComplexMaterial) {
    _inherits(ShadowMapMaterial, _ComplexMaterial);

    var _super82 = _createSuper(ShadowMapMaterial);

    function ShadowMapMaterial() {
      _classCallCheck(this, ShadowMapMaterial);

      return _super82.apply(this, arguments);
    }

    _createClass(ShadowMapMaterial, [{
      key: "_generateTechnique",
      value: function _generateTechnique(camera, component) {
        var customMacros = this._generateMacros();

        var uniforms = this._generateFragmentUniform();

        var tech = new RenderTechnique(this.name);
        tech.isValid = true;
        tech.uniforms = uniforms;
        tech.attributes = {};
        tech.states = {};
        tech.customMacros = customMacros;
        tech.vertexShader = vs$2;
        tech.fragmentShader = fs$2;
        return tech;
      }
    }, {
      key: "_generateFragmentUniform",
      value: function _generateFragmentUniform() {
        var uniforms = {
          u_viewMatFromLight: {
            name: "u_viewMatFromLight",
            type: exports.DataType.FLOAT_MAT4
          },
          u_projMatFromLight: {
            name: "u_projMatFromLight",
            type: exports.DataType.FLOAT_MAT4
          }
        };
        return uniforms;
      }
    }, {
      key: "_generateMacros",
      value: function _generateMacros() {
        var macros = [];
        macros.push("O3_GENERATE_SHADOW_MAP");
        return macros;
      }
    }]);

    return ShadowMapMaterial;
  }(ComplexMaterial);

  var ShadowMapPass = /*#__PURE__*/function (_RenderPass2) {
    _inherits(ShadowMapPass, _RenderPass2);

    var _super83 = _createSuper(ShadowMapPass);

    function ShadowMapPass(name, priority, renderTarget, replaceMaterial, mask, light) {
      var _this83;

      _classCallCheck(this, ShadowMapPass);

      _this83 = _super83.call(this, name, priority, renderTarget, replaceMaterial, mask);
      _this83.light = light;
      return _this83;
    }

    _createClass(ShadowMapPass, [{
      key: "preRender",
      value: function preRender(camera, opaqueQueue, transparentQueue) {
        this.replaceMaterial.setValue("u_viewMatFromLight", this.light.viewMatrix);
        this.replaceMaterial.setValue("u_projMatFromLight", this.light.shadow.projectionMatrix);
      }
    }]);

    return ShadowMapPass;
  }(RenderPass);

  var fs$3 = "varying vec2 v_uv;\n\nuniform vec4 u_ambientLight;\n\n#ifdef O3_SHADOW_MAP_COUNT\n\nstruct Shadow {\n  float     bias;\n  float     intensity;\n  vec2      mapSize;\n  float     radius;\n};\n\nuniform Shadow u_shadows[O3_SHADOW_MAP_COUNT];\n\nuniform sampler2D u_shadowMaps[O3_SHADOW_MAP_COUNT];\n\nvarying vec4 v_PositionFromLight[O3_SHADOW_MAP_COUNT];\n\nconst vec4 bitShift = vec4(1.0, 1.0/256.0, 1.0/(256.0*256.0), 1.0/(256.0*256.0*256.0));\n\n/**\n* \n*/\nfloat unpack(const in vec4 rgbaDepth) {\n  return dot(rgbaDepth, bitShift);\n}\n\n/**\n* \n*/\nfloat getVisibility(vec4 positionFromLight, const in sampler2D shadowMap, vec2 mapSize, float intensity, float bias, float radius) {\n\n    vec3 shadowCoord = (positionFromLight.xyz/positionFromLight.w)/2.0 + 0.5;\n    float filterX = step(0.0, shadowCoord.x) * (1.0 - step(1.0, shadowCoord.x));\n    float filterY = step(0.0, shadowCoord.y) * (1.0 - step(1.0, shadowCoord.y));\n\n    shadowCoord.z -= bias;\n    vec2 texelSize = vec2( 1.0 ) / mapSize;\n\n    float visibility = 0.0;\n    for (float y = -1.0 ; y <=1.0 ; y+=1.0) {\n      for (float x = -1.0 ; x <=1.0 ; x+=1.0) {\n        vec2 uv = shadowCoord.xy + texelSize * vec2(x, y) * radius;\n        vec4 rgbaDepth = texture2D(shadowMap, uv);\n        float depth = unpack(rgbaDepth);\n        visibility += step(depth, shadowCoord.z) * intensity;\n      }\n    }\n\n    visibility *= ( 1.0 / 9.0 );\n    return visibility * filterX * filterY;\n\n}\n\n#endif\n\nvoid main() {\n\n  vec4 shadowColor = vec4(1.0, 1.0, 1.0, 1.0);\n\n#ifdef O3_SHADOW_MAP_COUNT\n\n  float visibility = 1.0;\n\n  for(int i = 0; i < O3_SHADOW_MAP_COUNT; i++) {\n\n   visibility -= getVisibility(v_PositionFromLight[i], u_shadowMaps[i], u_shadows[i].mapSize, u_shadows[i].intensity, u_shadows[i].bias, u_shadows[i].radius);\n\n  }\n\n  visibility = clamp(visibility, 0.0, 1.0);\n  shadowColor = vec4(visibility, visibility, visibility, 1.0);\n\n#endif\n\n  gl_FragColor = shadowColor;\n}";

  var ShadowMaterial = /*#__PURE__*/function (_ComplexMaterial2) {
    _inherits(ShadowMaterial, _ComplexMaterial2);

    var _super84 = _createSuper(ShadowMaterial);

    function ShadowMaterial() {
      _classCallCheck(this, ShadowMaterial);

      return _super84.apply(this, arguments);
    }

    _createClass(ShadowMaterial, [{
      key: "_generateTechnique",
      value: function _generateTechnique(camera, component) {
        var customMacros = this._generateMacros();

        var uniforms = this._generateFragmentUniform();

        var tech = new RenderTechnique(this.name);
        tech.autoConvert = false;
        tech.isValid = true;
        tech.uniforms = uniforms;
        tech.attributes = {};
        tech.states = {};
        tech.customMacros = customMacros;
        tech.vertexShader = vs$2;
        tech.fragmentShader = fs$3;
        tech.states = {
          enable: [exports.RenderState.BLEND],
          functions: {
            depthFunc: [exports.CompFunc.LEQUAL],
            blendFunc: [exports.BlendFunc.DST_COLOR, exports.BlendFunc.ZERO]
          }
        };
        return tech;
      }
    }, {
      key: "_generateFragmentUniform",
      value: function _generateFragmentUniform() {
        var uniforms = {};

        for (var i = 0; i < this.shadowMapCount; i++) {
          var lgtUniforms = LightShadow.getUniformDefine(i);
          uniforms = _objectSpread2(_objectSpread2({}, uniforms), lgtUniforms);
        }

        return uniforms;
      }
    }, {
      key: "_generateMacros",
      value: function _generateMacros() {
        var macros = [];

        if (this.shadowMapCount > 0) {
          macros.push("O3_SHADOW_MAP_COUNT ".concat(this.shadowMapCount));
        }

        return macros;
      }
    }]);

    return ShadowMaterial;
  }(ComplexMaterial);

  var ShadowPass = /*#__PURE__*/function (_RenderPass3) {
    _inherits(ShadowPass, _RenderPass3);

    var _super85 = _createSuper(ShadowPass);

    function ShadowPass() {
      var _this84;

      _classCallCheck(this, ShadowPass);

      for (var _len7 = arguments.length, args = new Array(_len7), _key5 = 0; _key5 < _len7; _key5++) {
        args[_key5] = arguments[_key5];
      }

      _this84 = _super85.call.apply(_super85, [this].concat(args));
      _this84.clearMode = exports.ClearMode.DONT_CLEAR;
      return _this84;
    }

    _createClass(ShadowPass, [{
      key: "preRender",
      value: function preRender(camera, opaqueQueue, transparentQueue) {
        this.enabled = false;
        var lightMgr = camera.scene.findFeature(LightFeature);

        if (lightMgr) {
          var pass = camera._renderPipeline.defaultRenderPass;
          this.renderTarget = pass.renderTarget;
          var lights = lightMgr.visibleLights;
          var shadowMapCount = 0;

          for (var i = 0, len = lights.length; i < len; i++) {
            var lgt = lights[i];

            if (lgt.enableShadow) {
              lgt.shadow.bindShadowValues(this.replaceMaterial, shadowMapCount, lgt);
              shadowMapCount++;
            }
          }

          if (shadowMapCount !== this.replaceMaterial.shadowMapCount) {
            this.replaceMaterial.shadowMapCount = shadowMapCount;
            this.replaceMaterial.clearTechniques();
          }

          if (shadowMapCount) this.enabled = true;
        }
      }
    }]);

    return ShadowPass;
  }(RenderPass);

  var ShadowFeature = /*#__PURE__*/function (_SceneFeature4) {
    _inherits(ShadowFeature, _SceneFeature4);

    var _super86 = _createSuper(ShadowFeature);

    function ShadowFeature() {
      _classCallCheck(this, ShadowFeature);

      return _super86.apply(this, arguments);
    }

    _createClass(ShadowFeature, [{
      key: "preRender",
      value: function preRender(scene, camera) {
        var lightMgr = camera.scene.findFeature(LightFeature);

        if (lightMgr && lightMgr.visibleLights.length > 0) {
          if (!this._shadowPass) {
            this.addShadowPass(camera);
          }

          var lights = lightMgr.visibleLights;

          for (var i = 0, len = lights.length; i < len; i++) {
            var lgt = lights[i];

            if (lgt.enableShadow && !lgt.shadowMapPass) {
              lgt.shadowMapPass = this.addShadowMapPass(camera, lgt);
            } else if (!lgt.enableShadow && lgt.shadowMapPass) {
              var renderer = camera._renderPipeline;
              renderer.removeRenderPass(lgt.shadowMapPass);
              lgt.shadowMapPass = null;
            }
          }

          this.updatePassRenderFlag(camera._renderPipeline.opaqueQueue);
          this.updatePassRenderFlag(camera._renderPipeline.transparentQueue);
        }
      }
    }, {
      key: "addShadowPass",
      value: function addShadowPass(camera) {
        var shadowMaterial = new ShadowMaterial(camera.engine, "shadowMaterial");
        this._shadowPass = new ShadowPass("ShadowPass", 1, null, shadowMaterial, exports.MaskList.SHADOW);
        var renderer = camera._renderPipeline;
        renderer.addRenderPass(this._shadowPass);
      }
    }, {
      key: "addShadowMapPass",
      value: function addShadowMapPass(camera, light) {
        this._shadowMapMaterial = this._shadowMapMaterial || new ShadowMapMaterial(camera.engine, "shadowMapMaterial");
        var shadowMapPass = new ShadowMapPass("ShadowMapPass", -1, light.shadow.renderTarget, this._shadowMapMaterial, exports.MaskList.SHADOW_MAP, light);
        var renderer = camera._renderPipeline;
        renderer.addRenderPass(shadowMapPass);
        return shadowMapPass;
      }
    }, {
      key: "updatePassRenderFlag",
      value: function updatePassRenderFlag(renderQueue) {
        var items = renderQueue.items;

        for (var i = 0, len = items.length; i < len; i++) {
          var item = items[i];
          var ability = item.component;
          var recieveShadow = ability.recieveShadow;
          var castShadow = ability.castShadow;

          if (recieveShadow === true) {
            ability.addPassMasks(exports.MaskList.SHADOW);
          } else if (recieveShadow === false) {
            ability.removePassMasks(exports.MaskList.SHADOW);
          }

          if (castShadow === true) {
            ability.addPassMasks(exports.MaskList.SHADOW_MAP);
          } else if (castShadow === false) {
            ability.removePassMasks(exports.MaskList.SHADOW_MAP);
          }
        }
      }
    }]);

    return ShadowFeature;
  }(SceneFeature);

  Scene.registerFeature(ShadowFeature);
  Scene.registerFeature(LightFeature);
  Scene.prototype.hasLight = hasLight;

  var DRACOWorker = /*#__PURE__*/function () {
    function DRACOWorker(workerSourceURL, decoderWASMBinary) {
      var _this = this;

      _classCallCheck(this, DRACOWorker);

      this._costs = {};
      this._currentLoad = 0;
      this._callbacks = {};
      this._worker = new Worker(workerSourceURL);

      this._worker.onmessage = function (e) {
        var message = e.data;

        switch (message.type) {
          case "decode":
            _this._callbacks[message.id].resolve(message.geometry);

            break;

          case "error":
            _this._callbacks[message.id].reject(message);

            break;

          default:
            Logger.error('DRACOWorker: Unexpected message, "' + message.type + '"');
        }
      };

      if (decoderWASMBinary) {
        this._worker.postMessage({
          type: "init",
          decoderConfig: {
            wasmBinary: decoderWASMBinary
          }
        });
      } else {
        this._worker.postMessage({
          type: "init",
          decoderConfig: {}
        });
      }
    }

    _createClass(DRACOWorker, [{
      key: "setCosts",
      value: function setCosts(taskId, cost) {
        this._costs[taskId] = cost;
      }
    }, {
      key: "addCurrentLoad",
      value: function addCurrentLoad(cost) {
        this._currentLoad += cost;
      }
    }, {
      key: "setCallback",
      value: function setCallback(taskId, resolve, reject) {
        this._callbacks[taskId] = {
          resolve: resolve,
          reject: reject
        };
      }
    }, {
      key: "decode",
      value: function decode(taskId, taskConfig, buffer) {
        this._worker.postMessage({
          type: "decode",
          id: taskId,
          taskConfig: taskConfig,
          buffer: buffer
        }, [buffer]);
      }
    }, {
      key: "releaseTask",
      value: function releaseTask(taskId) {
        this._currentLoad -= this._costs[taskId];
        delete this._callbacks[taskId];
        delete this._costs[taskId];
      }
    }, {
      key: "currentLoad",
      get: function get() {
        return this._currentLoad;
      }
    }]);

    return DRACOWorker;
  }();

  var workerString = 'let decoderPending;\nlet decoderConfig;\n\nonmessage = function(e) {\n  const message = e.data;\n\n  switch (message.type) {\n    case "init":\n      decoderConfig = message.decoderConfig;\n      decoderPending = new Promise(function(resolve /*, reject*/) {\n        decoderConfig.onModuleLoaded = function(draco) {\n          // Module is Promise-like. Wrap before resolving to avoid loop.\n          resolve({ draco: draco });\n        };\n        DracoDecoderModule(decoderConfig);\n      });\n      break;\n\n    case "decode":\n      const buffer = message.buffer;\n      const taskConfig = message.taskConfig;\n      decoderPending.then(module => {\n        const draco = module.draco;\n        const decoder = new draco.Decoder();\n        const decoderBuffer = new draco.DecoderBuffer();\n        decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\n        try {\n          const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\n          const buffers = geometry.attributes.map(attr => attr.array.buffer);\n          if (geometry.index) buffers.push(geometry.index.array.buffer);\n          self.postMessage({ type: "decode", id: message.id, geometry }, buffers);\n        } catch (error) {\n          console.error(error);\n          self.postMessage({ type: "error", id: message.id, error: error.message });\n        } finally {\n          draco.destroy(decoderBuffer);\n          draco.destroy(decoder);\n        }\n      });\n      break;\n  }\n};\n\nfunction decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n  const attributeIDs = taskConfig.attributeIDs;\n  const attributeTypes = taskConfig.attributeTypes;\n\n  let dracoGeometry;\n  let decodingStatus;\n\n  const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n  if (geometryType === draco.TRIANGULAR_MESH) {\n    dracoGeometry = new draco.Mesh();\n    decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n  } else {\n    throw new Error("DRACODecoder worker: Unexpected geometry type.");\n  }\n\n  if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n    throw new Error("DRACODecoder worker: Decoding failed: " + decodingStatus.error_msg());\n  }\n\n  const geometry = { index: null, attributes: [] };\n\n  // Gather all vertex attributes.\n  for (let attributeName in attributeIDs) {\n    const attributeType = self[attributeTypes[attributeName]];\n\n    let attribute;\n    let attributeID;\n\n    // A Draco file may be created with default vertex attributes, whose attribute IDs\n    // are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n    // a Draco file may contain a custom set of attributes, identified by known unique\n    // IDs. glTF files always do the latter, and `.drc` files typically do the former.\n    if (taskConfig.useUniqueIDs) {\n      attributeID = attributeIDs[attributeName];\n      attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n    } else {\n      attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n      if (attributeID === -1) continue;\n      attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n    }\n    geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\n  }\n  // Add index.\n  if (geometryType === draco.TRIANGULAR_MESH) {\n    // Generate mesh faces.\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    let dataSize;\n    let ptr;\n    let index;\n    const indexType = self[taskConfig.indexType];\n\n    switch (indexType) {\n      case Uint16Array:\n        dataSize = numIndices * 2;\n        ptr = draco._malloc(dataSize);\n        decoder.GetTrianglesUInt16Array(dracoGeometry, dataSize, ptr);\n        index = new Uint16Array(draco.HEAPU16.buffer, ptr, numIndices).slice();\n        draco._free(ptr);\n        break;\n      case Uint32Array:\n        dataSize = numIndices * 4;\n        ptr = draco._malloc(dataSize);\n        decoder.GetTrianglesUInt32Array(dracoGeometry, dataSize, ptr);\n        index = new Uint32Array(draco.HEAPU32.buffer, ptr, numIndices).slice();\n        draco._free(ptr);\n      default:\n        throw new Error("DRACODecoder: Unexpected index type.");\n    }\n    geometry.index = { array: index, itemSize: 1 };\n  }\n  draco.destroy(dracoGeometry);\n  return geometry;\n}\n\nfunction decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n  const numComponents = attribute.num_components();\n  const numPoints = dracoGeometry.num_points();\n  const numValues = numPoints * numComponents;\n  let ptr;\n  let array;\n  let dataSize;\n  switch (attributeType) {\n    case Float32Array:\n      dataSize = numValues * 4;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_FLOAT32, dataSize, ptr);\n      array = new Float32Array(draco.HEAPF32.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Int8Array:\n      ptr = draco._malloc(numValues);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_INT8, numValues, ptr);\n      array = new Int8Array(draco.HEAP8.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Int16Array:\n      dataSize = numValues * 2;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_INT16, dataSize, ptr);\n      array = new Int16Array(draco.HEAP16.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Int32Array:\n      dataSize = numValues * 4;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_INT32, dataSize, ptr);\n      array = new Int32Array(draco.HEAP32.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Uint8Array:\n      ptr = draco._malloc(numValues);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_UINT8, numValues, ptr);\n      array = new Uint8Array(draco.HEAPU8.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Uint16Array:\n      dataSize = numValues * 2;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_UINT16, dataSize, ptr);\n      array = new Uint16Array(draco.HEAPU16.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Uint32Array:\n      dataSize = numValues * 4;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_UINT32, dataSize, ptr);\n      array = new Uint32Array(draco.HEAPU32.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    default:\n      throw new Error("DRACODecoder: Unexpected attribute type.");\n  }\n\n  return {\n    name: attributeName,\n    array: array,\n    itemSize: numComponents\n  };\n}\n';
  var LIB_PATH = "https://gw.alipayobjects.com/os/lib/alipay/draco-javascript/1.3.6/lib/";
  var JS_FILE = "draco_decoder_gltf.js";
  var WASM_FILE = "draco_decoder_gltf.r3bin";
  var WASM_WRAPPER_FILE = "draco_wasm_wrapper_gltf.js";

  var DRACODecoder = /*#__PURE__*/function () {
    function DRACODecoder() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        type: "wasm",
        workerLimit: 4
      };

      _classCallCheck(this, DRACODecoder);

      this.pool = [];
      this.workerLimit = Math.min(navigator.hardwareConcurrency || 4, 4);
      this.currentTaskId = 1;
      this.taskCache = new WeakMap();

      if (config.workerLimit > this.workerLimit) {
        Logger.warn("DRACOWorkerPool: Can not initialize worker pool with limit:" + config.workerLimit);
      } else {
        var _config$workerLimit;

        this.workerLimit = (_config$workerLimit = config.workerLimit) !== null && _config$workerLimit !== void 0 ? _config$workerLimit : 4;
      }

      this.useJS = (typeof WebAssembly === "undefined" ? "undefined" : _typeof(WebAssembly)) !== "object" || config.type === "js";
      this.loadLibPromise = this.preloadLib();
    }

    _createClass(DRACODecoder, [{
      key: "preloadLib",
      value: function preloadLib() {
        var _this2 = this;

        if (this.loadLibPromise) {
          return this.loadLibPromise;
        }

        return new Promise(function (resolve, reject) {
          if (_this2.useJS) {
            request("".concat(LIB_PATH).concat(JS_FILE), {
              type: "text"
            }).then(function (jsSource) {
              var body = [jsSource, workerString].join("\n");
              var workerSourceURL = URL.createObjectURL(new Blob([body]));
              resolve({
                workerSourceURL: workerSourceURL,
                decoderWASMBinary: null
              });
            })["catch"](function (reason) {
              reject(reason);
            });
          } else {
            Promise.all([request("".concat(LIB_PATH).concat(WASM_WRAPPER_FILE), {
              type: "text"
            }), request("".concat(LIB_PATH).concat(WASM_FILE), {
              type: "arraybuffer"
            })]).then(function (resources) {
              var _resources = _slicedToArray(resources, 2),
                  wrapperSource = _resources[0],
                  decoderWASMBinary = _resources[1];

              var body = [wrapperSource, workerString].join("\n");
              var workerSourceURL = URL.createObjectURL(new Blob([body]));
              resolve({
                workerSourceURL: workerSourceURL,
                decoderWASMBinary: decoderWASMBinary
              });
            })["catch"](function (reason) {
              reject(reason);
            });
          }
        });
      }
    }, {
      key: "getWorker",
      value: function getWorker() {
        var _this3 = this;

        return this.preloadLib().then(function (worderResources) {
          if (_this3.pool.length < _this3.workerLimit) {
            var dracoWorker = new DRACOWorker(worderResources.workerSourceURL, worderResources.decoderWASMBinary);

            _this3.pool.push(dracoWorker);
          } else {
            _this3.pool.sort(function (a, b) {
              return a.currentLoad > b.currentLoad ? -1 : 1;
            });
          }

          return _this3.pool[_this3.pool.length - 1];
        });
      }
    }, {
      key: "decode",
      value: function decode(buffer, taskConfig) {
        var _this4 = this;

        var taskKey = JSON.stringify(taskConfig);

        if (this.taskCache.has(buffer)) {
          var cachedTask = this.taskCache.get(buffer);

          if (cachedTask.key === taskKey) {
            return cachedTask.promise;
          } else if (buffer.byteLength === 0) {
            throw new Error("DRACODecoder: Unable to re-decode a buffer with different settings. Buffer has already been transferred.");
          }
        }

        var taskId = this.currentTaskId++;
        var cost = buffer.byteLength;
        var taskWorker;
        var task = new Promise(function (resolve, reject) {
          _this4.getWorker().then(function (worker2) {
            taskWorker = worker2;
            worker2.setCosts(taskId, cost);
            worker2.addCurrentLoad(cost);
            worker2.setCallback(taskId, resolve, reject);
            worker2.decode(taskId, taskConfig, buffer);
          })["catch"](function (e) {
            reject(e);
          });
        });
        task["finally"](function () {
          if (taskWorker && taskId) {
            taskWorker.releaseTask(taskId);
          }
        });
        this.taskCache.set(buffer, {
          key: taskKey,
          promise: task
        });
        return task;
      }
    }]);

    return DRACODecoder;
  }();

  var __defProp$a = Object.defineProperty;
  var __getOwnPropDesc$a = Object.getOwnPropertyDescriptor;

  var __decorate$a = function __decorate(decorators, target, key, kind) {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$a(target, key) : target;

    for (var i = decorators.length - 1, decorator; i >= 0; i--) {
      if (decorator = decorators[i]) result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    }

    if (kind && result) __defProp$a(target, key, result);
    return result;
  };

  function isBase64(url) {
    return /^data:(.+?);base64,/.test(url);
  }

  var BufferLoader = /*#__PURE__*/function (_Loader) {
    _inherits(BufferLoader, _Loader);

    var _super = _createSuper(BufferLoader);

    function BufferLoader() {
      _classCallCheck(this, BufferLoader);

      return _super.apply(this, arguments);
    }

    _createClass(BufferLoader, [{
      key: "load",
      value: function load(item) {
        var url = item.url;

        if (isBase64(url)) {
          return new AssetPromise(function (resolve) {
            var base64Str = url.slice(13 + RegExp.$1.length);
            var result = Uint8Array.from(atob(base64Str), function (c) {
              return c.charCodeAt(0);
            });
            resolve(result.buffer);
          });
        }

        return this.request(url, _objectSpread2(_objectSpread2({}, item), {}, {
          type: "arraybuffer"
        }));
      }
    }]);

    return BufferLoader;
  }(Loader);

  BufferLoader = __decorate$a([resourceLoader(exports.AssetType.Buffer, ["bin", "r3bin"], false)], BufferLoader);
  var WEBGL_COMPONENT_TYPES = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array
  };

  function decodeText(array) {
    if (typeof TextDecoder !== "undefined") {
      return new TextDecoder().decode(array);
    }

    var s = "";

    for (var i = 0, il = array.length; i < il; i++) {
      s += String.fromCharCode(array[i]);
    }

    return decodeURIComponent(encodeURIComponent(s));
  }

  function getAccessorTypeSize(accessorType) {
    var ACCESSOR_TYPE_SIZE = {
      SCALAR: 1,
      VEC2: 2,
      VEC3: 3,
      VEC4: 4,
      MAT2: 4,
      MAT3: 9,
      MAT4: 16
    };
    return ACCESSOR_TYPE_SIZE[accessorType];
  }

  function getComponentType(componentType) {
    return WEBGL_COMPONENT_TYPES[componentType];
  }

  function getAccessorData(gltf, accessor, buffers) {
    var _bufferView$byteStrid;

    var bufferView = gltf.bufferViews[accessor.bufferView];
    var arrayBuffer = buffers[bufferView.buffer];
    var accessorByteOffset = accessor.hasOwnProperty("byteOffset") ? accessor.byteOffset : 0;
    var bufferViewByteOffset = bufferView.hasOwnProperty("byteOffset") ? bufferView.byteOffset : 0;
    var byteOffset = accessorByteOffset + bufferViewByteOffset;
    var accessorTypeSize = getAccessorTypeSize(accessor.type);
    var length = accessorTypeSize * accessor.count;
    var byteStride = (_bufferView$byteStrid = bufferView.byteStride) !== null && _bufferView$byteStrid !== void 0 ? _bufferView$byteStrid : 0;
    var arrayType = getComponentType(accessor.componentType);
    var uint8Array;

    if (byteStride) {
      uint8Array = new Uint8Array(length * arrayType.BYTES_PER_ELEMENT);
      var originalBufferView = new Uint8Array(arrayBuffer, bufferViewByteOffset, bufferView.byteLength);
      var viewAccessor = 0;
      var accessorByteSize = accessorTypeSize * arrayType.BYTES_PER_ELEMENT;

      for (var i = 0; i < accessor.count; i++) {
        viewAccessor = i * byteStride + accessorByteOffset;

        for (var j = 0; j < accessorByteSize; j++) {
          uint8Array[i * accessorByteSize + j] = originalBufferView[viewAccessor + j];
        }
      }
    } else {
      uint8Array = new Uint8Array(arrayBuffer, byteOffset, length * arrayType.BYTES_PER_ELEMENT);
      uint8Array = new Uint8Array(uint8Array);
    }

    return new arrayType(uint8Array.buffer);
  }

  function getBufferData(bufferView, buffers) {
    var arrayBuffer = buffers[bufferView.buffer];
    var byteOffset = bufferView.byteOffset || 0;
    return arrayBuffer.slice(byteOffset, byteOffset + bufferView.byteLength);
  }

  function getVertexStride(accessor) {
    var size = getAccessorTypeSize(accessor.type);
    var componentType = getComponentType(accessor.componentType);
    return size * componentType.BYTES_PER_ELEMENT;
  }

  function createVertexElement(gltf, semantic, accessor, index) {
    var size = getAccessorTypeSize(accessor.type);
    return new VertexElement(semantic, 0, getElementFormat(accessor.componentType, size), index);
  }

  function getIndexFormat(type) {
    switch (type) {
      case exports.DataType.UNSIGNED_BYTE:
        return exports.IndexFormat.UInt8;

      case exports.DataType.UNSIGNED_SHORT:
        return exports.IndexFormat.UInt16;

      case exports.DataType.UNSIGNED_INT:
        return exports.IndexFormat.UInt32;
    }
  }

  function getElementFormat(type, size) {
    if (type == exports.DataType.FLOAT) {
      switch (size) {
        case 1:
          return exports.VertexElementFormat.Float;

        case 2:
          return exports.VertexElementFormat.Vector2;

        case 3:
          return exports.VertexElementFormat.Vector3;

        case 4:
          return exports.VertexElementFormat.Vector4;
      }
    }

    if (type == exports.DataType.UNSIGNED_SHORT) {
      switch (size) {
        case 2:
          return exports.VertexElementFormat.UShort2;

        case 4:
          return exports.VertexElementFormat.UShort4;
      }
    }
  }

  function loadImageBuffer(imageBuffer, type) {
    return new Promise(function (resolve, reject) {
      var blob = new window.Blob([imageBuffer], {
        type: type
      });
      var img = new Image();
      img.src = URL.createObjectURL(blob);
      img.crossOrigin = "anonymous";

      img.onerror = function () {
        reject(new Error("Failed to load image buffer"));
      };

      img.onload = function () {
        requestAnimationFrame(function () {
          resolve(img);
        });
      };
    });
  }

  function isAbsoluteUrl(url) {
    return /^(?:http|blob|data:|\/)/.test(url);
  }

  function parseRelativeUrl(baseUrl, relativeUrl) {
    if (isAbsoluteUrl(relativeUrl)) {
      return relativeUrl;
    }

    return baseUrl.substring(0, baseUrl.lastIndexOf("/") + 1) + relativeUrl;
  }

  var decoder;
  var glTFDracoMeshCompression = {
    init: function init() {
      if (!decoder) {
        decoder = new DRACODecoder();
      }
    },
    parse: function parse(extension, gltfPrimitive, gltf, buffers) {
      var bufferViews = gltf.bufferViews,
          accessors = gltf.accessors;
      var bufferViewIndex = extension.bufferView;
      var gltfAttributeMap = extension.attributes;
      var attributeMap = {};
      var attributeTypeMap = {};

      for (var attributeName in gltfAttributeMap) {
        attributeMap[attributeName] = gltfAttributeMap[attributeName];
      }

      for (var _attributeName in gltfPrimitive.attributes) {
        if (gltfAttributeMap[_attributeName] !== void 0) {
          var accessorDef = accessors[gltfPrimitive.attributes[_attributeName]];
          attributeTypeMap[_attributeName] = getComponentType(accessorDef.componentType).name;
        }
      }

      var indexAccessor = accessors[gltfPrimitive.indices];
      var indexType = getComponentType(indexAccessor.componentType).name;
      var taskConfig = {
        attributeIDs: attributeMap,
        attributeTypes: attributeTypeMap,
        useUniqueIDs: true,
        indexType: indexType
      };
      var buffer = getBufferData(bufferViews[bufferViewIndex], buffers);
      return decoder.decode(buffer, taskConfig).then(function (parsedGeometry) {
        return parsedGeometry;
      });
    }
  };
  var TARGET_PATH_MAP = {
    translation: "position",
    rotation: "rotation",
    scale: "scale",
    weights: "weights"
  };
  var nodeCount = 0;
  var RegistedObjs = {};
  var RegistedCustomMaterials = {};

  var getDefaultMaterial = function () {
    return function (engine) {
      var defaultMateril = new ConstantMaterial(engine, "default");
      defaultMateril.emission = new Vector4(0.749, 0.749, 0.749, 1);
      return defaultMateril;
    };
  }();

  var HandledExtensions = {
    PBRMaterial: "PBRMaterial",
    KHR_lights: "KHR_lights",
    KHR_materials_unlit: "KHR_materials_unlit",
    KHR_materials_pbrSpecularGlossiness: "KHR_materials_pbrSpecularGlossiness",
    KHR_techniques_webgl: "KHR_techniques_webgl",
    KHR_draco_mesh_compression: "KHR_draco_mesh_compression"
  };
  var KHR_lights = null;
  var extensionParsers = {
    KHR_lights: KHR_lights,
    KHR_materials_unlit: PBRMaterial,
    KHR_materials_pbrSpecularGlossiness: PBRMaterial,
    KHR_techniques_webgl: Material,
    KHR_draco_mesh_compression: glTFDracoMeshCompression
  };

  function RegistExtension(extobj) {
    Object.keys(extobj).forEach(function (name) {
      if (RegistedObjs[name] === void 0) {
        RegistedObjs[name] = extobj[name];

        switch (name) {
          case HandledExtensions.PBRMaterial:
            extensionParsers.KHR_materials_unlit = PBRMaterial;
            break;

          case HandledExtensions.KHR_lights:
            KHR_lights = extobj[name];
            extensionParsers.KHR_lights = KHR_lights;
            break;

          default:
            if (Material.isPrototypeOf(extobj[name]) && extobj[name].TECH_NAME) RegistedCustomMaterials[extobj[name].TECH_NAME] = extobj[name];
            break;
        }
      }
    });
  }

  var GLTFResource = /*#__PURE__*/function (_EngineObject) {
    _inherits(GLTFResource, _EngineObject);

    var _super2 = _createSuper(GLTFResource);

    function GLTFResource() {
      _classCallCheck(this, GLTFResource);

      return _super2.apply(this, arguments);
    }

    return GLTFResource;
  }(EngineObject);

  function parseGLTF(data, engine) {
    var resources = {
      engine: engine,
      gltf: data.gltf,
      buffers: data.buffers,
      asset: new GLTFResource(engine)
    };
    resources.asset.textures = data.textures;
    resources.asset.meta = data.gltf;

    if (resources.gltf.asset && resources.gltf.asset.version) {
      resources.gltf.version = Number(resources.gltf.asset.version);
      resources.gltf.isGltf2 = resources.gltf.version >= 2 && resources.gltf.version <= 3;
    }

    parseExtensions(resources);
    return parseResources(resources, "materials", parseMaterial).then(function () {
      return parseResources(resources, "meshes", parseMesh);
    }).then(function () {
      return parseResources(resources, "nodes", parseNode);
    }).then(function () {
      return parseResources(resources, "scenes", parseScene);
    }).then(function () {
      return parseResources(resources, "skins", parseSkin);
    }).then(function () {
      return parseResources(resources, "animations", parseAnimation);
    }).then(function () {
      return buildSceneGraph(resources);
    });
  }

  function parseExtensions(resources) {
    var gltf = resources.gltf,
        asset = resources.asset;
    var extensions = gltf.extensions,
        extensionsUsed = gltf.extensionsUsed,
        extensionsRequired = gltf.extensionsRequired;

    if (extensionsUsed) {
      Logger.info("extensionsUsed: ", extensionsUsed);

      for (var i = 0; i < extensionsUsed.length; i++) {
        if (Object.keys(extensionParsers).indexOf(extensionsUsed[i]) > -1) {
          if (!extensionParsers[extensionsUsed[i]]) {
            Logger.warn("extension " + extensionsUsed[i] + " is used, you can add this extension into gltf");
          }
        } else {
          Logger.warn("extensionsUsed has unsupported extension " + extensionsUsed[i]);
        }
      }
    }

    if (extensionsRequired) {
      Logger.info("extensionsRequired: ".concat(extensionsRequired));

      for (var _i = 0; _i < extensionsRequired.length; _i++) {
        if (Object.keys(extensionParsers).indexOf(extensionsRequired[_i]) < 0 || !extensionParsers[extensionsRequired[_i]]) {
          Logger.error("model has not supported required extension ".concat(extensionsRequired[_i]));
        }

        if (extensionsRequired[_i] === HandledExtensions.KHR_draco_mesh_compression) {
          extensionParsers.KHR_draco_mesh_compression.init();
        }
      }
    }

    if (extensions) {
      if (KHR_lights && extensions.KHR_lights) {
        asset.lights = KHR_lights.parseLights(extensions.KHR_lights.lights);
      }
    }
  }

  function parseResources(resources, name, handler) {
    var gltf = resources.gltf,
        asset = resources.asset;

    if (!asset[name]) {
      asset[name] = [];
    }

    if (gltf.hasOwnProperty(name)) {
      var entities = gltf[name] || [];
      Logger.debug(name + ":", entities);
      var promises = [];

      for (var i = entities.length - 1; i >= 0; i--) {
        promises.push(handler(entities[i], resources));
      }

      return Promise.all(promises).then(function (results) {
        for (var _i2 = 0; _i2 < results.length; _i2++) {
          asset[name].push(results[_i2]);
        }
      });
    }

    return Promise.resolve();
  }

  function parseMaterial(gltfMaterial, resources) {
    var gltf = resources.gltf,
        asset = resources.asset;
    var material;

    if (gltf.isGltf2 && typeof gltfMaterial.technique === "undefined") {
      var uniformObj = {};
      var stateObj = {};
      var pbrMetallicRoughness = gltfMaterial.pbrMetallicRoughness,
          normalTexture = gltfMaterial.normalTexture,
          emissiveTexture = gltfMaterial.emissiveTexture,
          emissiveFactor = gltfMaterial.emissiveFactor,
          occlusionTexture = gltfMaterial.occlusionTexture,
          alphaMode = gltfMaterial.alphaMode,
          alphaCutoff = gltfMaterial.alphaCutoff,
          doubleSided = gltfMaterial.doubleSided,
          extensions = gltfMaterial.extensions;

      if (pbrMetallicRoughness) {
        var baseColorFactor = pbrMetallicRoughness.baseColorFactor,
            baseColorTexture = pbrMetallicRoughness.baseColorTexture,
            metallicFactor = pbrMetallicRoughness.metallicFactor,
            roughnessFactor = pbrMetallicRoughness.roughnessFactor,
            metallicRoughnessTexture = pbrMetallicRoughness.metallicRoughnessTexture;

        if (baseColorTexture) {
          uniformObj.baseColorTexture = getItemByIdx("textures", baseColorTexture.index || 0, resources, false);
        }

        if (baseColorFactor) {
          uniformObj.baseColorFactor = _construct(Vector4, _toConsumableArray(baseColorFactor));
        }

        uniformObj.metallicFactor = metallicFactor !== void 0 ? metallicFactor : 1;
        uniformObj.roughnessFactor = roughnessFactor !== void 0 ? roughnessFactor : 1;

        if (metallicRoughnessTexture) {
          uniformObj.metallicRoughnessTexture = getItemByIdx("textures", metallicRoughnessTexture.index || 0, resources, false);
        }
      }

      if (normalTexture) {
        var index = normalTexture.index,
            texCoord = normalTexture.texCoord,
            scale = normalTexture.scale;
        uniformObj.normalTexture = getItemByIdx("textures", index || 0, resources, false);

        if (_typeof(scale) !== void 0) {
          uniformObj.normalScale = scale;
        }
      }

      if (emissiveTexture) {
        uniformObj.emissiveTexture = getItemByIdx("textures", emissiveTexture.index || 0, resources, false);
      }

      if (occlusionTexture) {
        uniformObj.occlusionTexture = getItemByIdx("textures", occlusionTexture.index || 0, resources, false);

        if (occlusionTexture.strength !== void 0) {
          uniformObj.occlusionStrength = occlusionTexture.strength;
        }
      }

      stateObj.doubleSided = !!doubleSided;
      stateObj.alphaMode = alphaMode || "OPAQUE";

      if (alphaMode === "MASK") {
        uniformObj.alphaCutoff = alphaCutoff === void 0 ? 0.5 : alphaCutoff;
      }

      if (extensions) {
        if (extensions.KHR_materials_unlit) {
          stateObj.unlit = true;
        }

        if (extensions.KHR_materials_pbrSpecularGlossiness) {
          var _extensions$KHR_mater = extensions.KHR_materials_pbrSpecularGlossiness,
              diffuseFactor = _extensions$KHR_mater.diffuseFactor,
              diffuseTexture = _extensions$KHR_mater.diffuseTexture,
              specularFactor = _extensions$KHR_mater.specularFactor,
              glossinessFactor = _extensions$KHR_mater.glossinessFactor,
              specularGlossinessTexture = _extensions$KHR_mater.specularGlossinessTexture;
          stateObj.isMetallicWorkflow = false;

          if (diffuseFactor) {
            uniformObj.baseColorFactor = _construct(Vector4, _toConsumableArray(diffuseFactor));
          }

          if (diffuseTexture) {
            uniformObj.baseColorTexture = getItemByIdx("textures", diffuseTexture.index || 0, resources, false);
          }

          if (specularFactor) {
            uniformObj.specularFactor = _construct(Vector3, _toConsumableArray(specularFactor));
          }

          if (glossinessFactor !== void 0) {
            uniformObj.glossinessFactor = glossinessFactor;
          }

          if (specularGlossinessTexture) {
            uniformObj.specularGlossinessTexture = getItemByIdx("textures", specularGlossinessTexture.index || 0, resources, false);
          }
        }
      }

      var unlit = gltfMaterial.unlit,
          srgb = gltfMaterial.srgb,
          gamma = gltfMaterial.gamma,
          blendFunc = gltfMaterial.blendFunc,
          depthMask = gltfMaterial.depthMask;
      if (unlit) stateObj.unlit = true;
      if (srgb) stateObj.srgb = true;
      if (gamma) stateObj.gamma = true;
      if (blendFunc) stateObj.blendFunc = blendFunc;
      if (depthMask !== void 0) stateObj.depthMask = depthMask;
      material = new PBRMaterial(resources.engine, gltfMaterial.name || PBRMaterial.MATERIAL_NAME, _extends({}, uniformObj, stateObj));
    } else {
      var techniqueName = gltfMaterial.technique;
      Logger.warn("Deprecated: Please use a model that meets the glTF 2.0 specification");

      if (techniqueName === "Texture") {
        material = new PBRMaterial(resources.engine, gltfMaterial.name || PBRMaterial.MATERIAL_NAME);
        material.unlit = true;
        var _index = gltfMaterial.values._MainTex[0];
        material.baseColorTexture = getItemByIdx("textures", _index || 0, resources, false);
      }
    }

    return Promise.resolve(material);
  }

  function parseSkin(gltfSkin, resources) {
    var gltf = resources.gltf,
        buffers = resources.buffers;
    var jointCount = gltfSkin.joints.length;
    var skin = new Skin(gltfSkin.name);
    var accessor = gltf.accessors[gltfSkin.inverseBindMatrices];
    var buffer = getAccessorData(gltf, accessor, buffers);
    var MAT4_LENGTH = 16;

    for (var i = 0; i < jointCount; i++) {
      var startIdx = MAT4_LENGTH * i;
      var endIdx = startIdx + MAT4_LENGTH;
      skin.inverseBindMatrices[i] = _construct(Matrix, _toConsumableArray(buffer.subarray(startIdx, endIdx)));
    }

    for (var _i3 = 0; _i3 < jointCount; _i3++) {
      var node2 = getItemByIdx("nodes", gltfSkin.joints[_i3], resources);
      skin.joints[_i3] = node2.name;
    }

    var node = getItemByIdx("nodes", gltfSkin.skeleton == null ? gltfSkin.joints[0] : gltfSkin.skeleton, resources);
    skin.skeleton = node.name;
    return Promise.resolve(skin);
  }

  function parsePrimitiveVertex(mesh, primitive, primitiveGroup, gltfPrimitive, gltf, getVertexBufferData, getIndexBufferData, engine) {
    var i = 0;
    var vertexElements = [];

    for (var attributeSemantic in gltfPrimitive.attributes) {
      var accessorIdx = gltfPrimitive.attributes[attributeSemantic];
      var accessor = gltf.accessors[accessorIdx];
      var stride = getVertexStride(accessor);
      var vertexELement = createVertexElement(gltf, attributeSemantic, accessor, i);
      vertexElements.push(vertexELement);
      var bufferData = getVertexBufferData(attributeSemantic);
      var vertexBuffer = new Buffer(engine, exports.BufferBindFlag.VertexBuffer, bufferData.byteLength, exports.BufferUsage.Static);
      vertexBuffer.setData(bufferData);
      primitive.setVertexBufferBinding(vertexBuffer, stride, i++);

      if (vertexELement.semantic == "POSITION") {
        var position = new Vector3();
        var vertexCount = bufferData.length / 3;
        var _mesh$bounds = mesh.bounds,
            min = _mesh$bounds.min,
            max = _mesh$bounds.max;

        for (var i2 = 0; i2 < vertexCount; i2++) {
          var offset = i2 * 3;
          position.setValue(bufferData[offset], bufferData[offset + 1], bufferData[offset + 2]);
          Vector3.min(min, position, min);
          Vector3.max(max, position, max);
        }
      }
    }

    primitive.setVertexElements(vertexElements);
    var indexAccessor = gltf.accessors[gltfPrimitive.indices];
    var indexData = getIndexBufferData();
    var indexCount = indexAccessor.count;
    var indexFormat = getIndexFormat(indexAccessor.componentType);
    var indexByteSize = indexFormat == exports.IndexFormat.UInt32 ? 4 : indexFormat == exports.IndexFormat.UInt16 ? 2 : 1;
    var indexBuffer = new Buffer(engine, exports.BufferBindFlag.IndexBuffer, indexCount * indexByteSize, exports.BufferUsage.Static);
    indexBuffer.setData(indexData);
    primitive.setIndexBufferBinding(new IndexBufferBinding(indexBuffer, indexFormat));
    primitiveGroup.start = 0;
    primitiveGroup.count = indexCount;
    return Promise.resolve(primitive);
  }

  function parseMesh(gltfMesh, resources) {
    var gltf = resources.gltf,
        buffers = resources.buffers,
        engine = resources.engine;
    var mesh = new Mesh(gltfMesh.name);
    var primitivePromises = [];
    var groups = [];

    var _loop = function _loop(i) {
      primitivePromises.push(new Promise(function (resolve, reject) {
        var gltfPrimitive = gltfMesh.primitives[i];
        var primitive = new Primitive(engine, gltfPrimitive.name || gltfMesh.name || i);
        var subPrimitive = new SubPrimitive();
        groups.push(subPrimitive);
        subPrimitive.topology = gltfPrimitive.mode == null ? exports.PrimitiveTopology.Triangles : gltfPrimitive.mode;

        if (gltfPrimitive.hasOwnProperty("targets")) {
          primitive.targets = [];
          mesh.weights = gltfMesh.weights || new Array(gltfPrimitive.targets.length).fill(0);
        }

        var vertexPromise;

        if (gltfPrimitive.extensions && gltfPrimitive.extensions[HandledExtensions.KHR_draco_mesh_compression]) {
          var extensionParser = extensionParsers.KHR_draco_mesh_compression;
          var extension = gltfPrimitive.extensions[HandledExtensions.KHR_draco_mesh_compression];
          vertexPromise = extensionParser.parse(extension, gltfPrimitive, gltf, buffers).then(function (decodedGeometry) {
            return parsePrimitiveVertex(mesh, primitive, subPrimitive, gltfPrimitive, gltf, function (attributeSemantic) {
              for (var i2 = 0; i2 < decodedGeometry.attributes.length; i2++) {
                if (decodedGeometry.attributes[i2].name === attributeSemantic) {
                  return decodedGeometry.attributes[i2].array;
                }
              }

              return null;
            }, function () {
              return decodedGeometry.index.array;
            }, resources.engine);
          });
        } else {
          vertexPromise = parsePrimitiveVertex(mesh, primitive, subPrimitive, gltfPrimitive, gltf, function (attributeSemantic) {
            var accessorIdx = gltfPrimitive.attributes[attributeSemantic];
            var accessor = gltf.accessors[accessorIdx];
            return getAccessorData(gltf, accessor, buffers);
          }, function () {
            var indexAccessor = gltf.accessors[gltfPrimitive.indices];
            return getAccessorData(gltf, indexAccessor, buffers);
          }, resources.engine);
        }

        vertexPromise.then(function (processedPrimitive) {
          resolve(processedPrimitive);
        })["catch"](function (e) {
          reject(e);
        });
      }));
    };

    for (var i = 0; i < gltfMesh.primitives.length; i++) {
      _loop(i);
    }

    return Promise.all(primitivePromises).then(function (primitives) {
      for (var _i4 = 0; _i4 < primitives.length; _i4++) {
        mesh.primitives.push(primitives[_i4]);
        mesh.groups.push(groups[_i4]);
      }

      return mesh;
    });
  }

  function parseAnimation(gltfAnimation, resources) {
    var gltf = resources.gltf,
        buffers = resources.buffers;
    var gltfSamplers = gltfAnimation.samplers || [];
    var gltfChannels = gltfAnimation.channels || [];
    var animationIdx = gltf.animations.indexOf(gltfAnimation);
    var animationClip = new AnimationClip(gltfAnimation.name || "Animation".concat(animationIdx));
    var duration = -1;
    var durationIndex = -1;

    for (var i = 0; i < gltfSamplers.length; i++) {
      var gltfSampler = gltfSamplers[i];
      var inputAccessor = gltf.accessors[gltfSampler.input];
      var outputAccessor = gltf.accessors[gltfSampler.output];
      var input = getAccessorData(gltf, inputAccessor, buffers);
      var output = getAccessorData(gltf, outputAccessor, buffers);
      var outputAccessorSize = getAccessorTypeSize(outputAccessor.type);
      if (outputAccessorSize * input.length !== output.length) outputAccessorSize = output.length / input.length;
      var samplerInterpolation = exports.InterpolationType.LINEAR;

      switch (gltfSampler.interpolation) {
        case "CUBICSPLINE":
          samplerInterpolation = exports.InterpolationType.CUBICSPLINE;
          break;

        case "STEP":
          samplerInterpolation = exports.InterpolationType.STEP;
          break;
      }

      var maxTime = input[input.length - 1];

      if (maxTime > duration) {
        duration = maxTime;
        durationIndex = i;
      }

      animationClip.addSampler(input, output, outputAccessorSize, samplerInterpolation);
    }

    animationClip.durationIndex = durationIndex;
    animationClip.duration = duration;

    for (var _i5 = 0; _i5 < gltfChannels.length; _i5++) {
      var gltfChannel = gltfChannels[_i5];
      var target = gltfChannel.target;
      var samplerIndex = gltfChannel.sampler;
      var targetNode = getItemByIdx("nodes", target.node, resources);
      var targetPath = TARGET_PATH_MAP[target.path];
      animationClip.addChannel(samplerIndex, targetNode.name, targetPath);
    }

    return Promise.resolve(animationClip);
  }

  function parseNode(gltfNode, resources) {
    var entity = new Entity(resources.engine, gltfNode.name || "GLTF_NODE_".concat(nodeCount++));

    if (gltfNode.hasOwnProperty("matrix")) {
      var m = gltfNode.matrix;
      var mat = new Matrix();
      mat.setValueByArray(m);
      var pos = new Vector3();
      var scale = new Vector3(1, 1, 1);
      var rot = new Quaternion();
      mat.decompose(pos, rot, scale);
      entity.transform.position = pos;
      entity.transform.rotationQuaternion = rot;
      entity.transform.scale = scale;
    } else {
      for (var key in TARGET_PATH_MAP) {
        if (gltfNode.hasOwnProperty(key)) {
          var mapKey = TARGET_PATH_MAP[key];

          if (mapKey === "weights") {
            entity[mapKey] = gltfNode[key];
          } else {
            var arr = gltfNode[key];
            var len = arr.length;
            var obj = entity[mapKey];

            if (len === 2) {
              obj.setValue(arr[0], arr[1]);
            } else if (len === 3) {
              obj.setValue(arr[0], arr[1], arr[2]);
            } else if (len === 4) {
              obj.setValue(arr[0], arr[1], arr[2], arr[3]);
            }

            entity[mapKey] = obj;
          }
        }
      }
    }

    if (gltfNode.camera !== void 0) {
      var cameraOptions = resources.gltf.cameras[gltfNode.camera];
      var camera = entity.addComponent(exports.Camera);

      if (cameraOptions.type === "orthographic") {
        camera.isOrthographic = true;
        var _cameraOptions$orthog = cameraOptions.orthographic,
            ymag = _cameraOptions$orthog.ymag,
            xmag = _cameraOptions$orthog.xmag,
            zfar = _cameraOptions$orthog.zfar,
            znear = _cameraOptions$orthog.znear;

        if (znear !== void 0) {
          camera.nearClipPlane = znear;
        }

        if (zfar !== void 0) {
          camera.farClipPlane = zfar;
        }

        if (ymag && xmag) {
          camera.orthographicSize = Math.max(ymag, xmag) / 2;
        }

        if (ymag !== void 0 && xmag) {
          camera.orthographicSize = xmag / 2;
        }

        if (xmag !== void 0 && ymag) {
          camera.orthographicSize = ymag / 2;
        }
      } else {
        var _cameraOptions$perspe = cameraOptions.perspective,
            aspectRatio = _cameraOptions$perspe.aspectRatio,
            yfov = _cameraOptions$perspe.yfov,
            _zfar = _cameraOptions$perspe.zfar,
            _znear = _cameraOptions$perspe.znear;

        if (yfov !== void 0) {
          camera.fieldOfView = yfov;
        }

        if (_zfar !== void 0) {
          camera.farClipPlane = _zfar;
        }

        if (_znear !== void 0) {
          camera.nearClipPlane = _znear;
        }
      }
    }

    if (gltfNode.extensions) {
      if (KHR_lights && gltfNode.extensions.KHR_lights) {
        var lightIdx = gltfNode.extensions.KHR_lights.light;

        if (lightIdx !== void 0) {
          var light = getItemByIdx("lights", lightIdx, resources);

          if (light) {
            var lightCon = entity.addComponent(light.ability);

            _extends(lightCon, light.props);
          }
        }
      }
    }

    return Promise.resolve(entity);
  }

  function parseScene(gltfScene, resources) {
    var sceneNodes = [];

    for (var i = 0; i < gltfScene.nodes.length; i++) {
      var node = getItemByIdx("nodes", gltfScene.nodes[i], resources);
      sceneNodes.push(node);
    }

    if (gltfScene.extensions) {
      if (KHR_lights && gltfScene.extensions.KHR_lights) {
        var lightIdx = gltfScene.extensions.KHR_lights.light;

        if (lightIdx !== void 0) {
          var light = getItemByIdx("lights", lightIdx, resources);
          if (light) sceneNodes[0].addComponent(light.ability, light.props);
        }
      }
    }

    return Promise.resolve({
      nodes: sceneNodes
    });
  }

  function getItemByIdx(name, idx, resources) {
    var inverse = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
    var asset = resources.asset;
    var itemIdx = inverse ? asset[name].length - idx - 1 : idx;
    return asset[name][itemIdx];
  }

  function buildSceneGraph(resources) {
    var _gltf$scene;

    var asset = resources.asset,
        gltf = resources.gltf;
    var gltfNodes = gltf.nodes || [];
    var gltfMeshes = gltf.meshes;
    asset.defaultScene = getItemByIdx("scenes", (_gltf$scene = gltf.scene) !== null && _gltf$scene !== void 0 ? _gltf$scene : 0, resources);

    for (var i = gltfNodes.length - 1; i >= 0; i--) {
      var gltfNode = gltfNodes[i];
      var node = getItemByIdx("nodes", i, resources);

      if (gltfNode.hasOwnProperty("children")) {
        var children = gltfNode.children || [];

        for (var j = children.length - 1; j >= 0; j--) {
          var childNode = getItemByIdx("nodes", children[j], resources);
          node.addChild(childNode);
        }
      }

      if (gltfNode.hasOwnProperty("mesh")) {
        var meshIndex = gltfNode.mesh;
        node.meshIndex = meshIndex;
        var gltfMeshPrimitives = gltfMeshes[meshIndex].primitives;
        var mesh = getItemByIdx("meshes", meshIndex, resources);
        var renderer = void 0;

        if (gltfNode.hasOwnProperty("skin") || mesh.hasOwnProperty("weights")) {
          var skin = getItemByIdx("skins", gltfNode.skin, resources);
          var weights = mesh.weights;
          var skinRenderer = node.addComponent(SkinnedMeshRenderer);
          skinRenderer.mesh = mesh;
          skinRenderer.skin = skin;
          skinRenderer.setWeights(weights);
          renderer = skinRenderer;
        } else {
          renderer = node.addComponent(MeshRenderer);
          renderer.mesh = mesh;
        }

        for (var _j = 0, m = gltfMeshPrimitives.length; _j < m; _j++) {
          var materialIndex = gltfMeshPrimitives[_j].material;
          mesh.primitives[_j].materialIndex = materialIndex;
          var material = materialIndex !== void 0 ? getItemByIdx("materials", materialIndex, resources) : getDefaultMaterial(node.engine);
          renderer.setSharedMaterial(_j, material);
        }
      }
    }

    var nodes = asset.defaultScene.nodes;

    if (nodes.length === 1) {
      asset.defaultSceneRoot = nodes[0];
    } else {
      var rootNode = new Entity(resources.engine);

      for (var _i6 = 0; _i6 < nodes.length; _i6++) {
        rootNode.addChild(nodes[_i6]);
      }

      asset.defaultSceneRoot = rootNode;
    }

    var animator = asset.defaultSceneRoot.addComponent(Animation);
    var animations = asset.animations;

    if (animations) {
      animations.forEach(function (clip) {
        animator.addAnimationClip(clip, clip.name);
      });
    }

    return resources.asset;
  }

  function parseGLB(glb) {
    var UINT32_LENGTH = 4;
    var GLB_HEADER_MAGIC = 1179937895;
    var GLB_HEADER_LENGTH = 12;
    var GLB_CHUNK_TYPES = {
      JSON: 1313821514,
      BIN: 5130562
    };
    var dataView = new DataView(glb);
    var header = {
      magic: dataView.getUint32(0, true),
      version: dataView.getUint32(UINT32_LENGTH, true),
      length: dataView.getUint32(2 * UINT32_LENGTH, true)
    };

    if (header.magic !== GLB_HEADER_MAGIC) {
      console.error("Invalid glb magic number. Expected 0x46546C67, found 0x" + header.magic.toString(16));
      return null;
    }

    var chunkLength = dataView.getUint32(GLB_HEADER_LENGTH, true);
    var chunkType = dataView.getUint32(GLB_HEADER_LENGTH + UINT32_LENGTH, true);

    if (chunkType !== GLB_CHUNK_TYPES.JSON) {
      console.error("Invalid glb chunk type. Expected 0x004E4942, found 0x" + chunkType.toString(16));
      return null;
    }

    var glTFData = new Uint8Array(glb, GLB_HEADER_LENGTH + 2 * UINT32_LENGTH, chunkLength);
    var gltf = JSON.parse(decodeText(glTFData));
    var buffers = [];
    var byteOffset = GLB_HEADER_LENGTH + 2 * UINT32_LENGTH + chunkLength;

    while (byteOffset < header.length) {
      chunkLength = dataView.getUint32(byteOffset, true);
      chunkType = dataView.getUint32(byteOffset + UINT32_LENGTH, true);

      if (chunkType !== GLB_CHUNK_TYPES.BIN) {
        console.error("Invalid glb chunk type. Expected 0x004E4942, found 0x" + chunkType.toString(16));
        return null;
      }

      var currentOffset = byteOffset + 2 * UINT32_LENGTH;
      var buffer = glb.slice(currentOffset, currentOffset + chunkLength);
      buffers.push(buffer);
      byteOffset += chunkLength + 2 * UINT32_LENGTH;
    }

    return {
      gltf: gltf,
      buffers: buffers
    };
  }

  var __defProp$1$1 = Object.defineProperty;
  var __getOwnPropDesc$1$1 = Object.getOwnPropertyDescriptor;

  var __decorate$1$1 = function __decorate$1(decorators, target, key, kind) {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$1$1(target, key) : target;

    for (var i = decorators.length - 1, decorator; i >= 0; i--) {
      if (decorator = decorators[i]) result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    }

    if (kind && result) __defProp$1$1(target, key, result);
    return result;
  };

  var GLTFLoader = /*#__PURE__*/function (_Loader2) {
    _inherits(GLTFLoader, _Loader2);

    var _super3 = _createSuper(GLTFLoader);

    function GLTFLoader() {
      var _this;

      _classCallCheck(this, GLTFLoader);

      _this = _super3.apply(this, arguments);

      _this.requestGLTF = function (item, resourceManager) {
        return _this.request(item.url, _objectSpread2(_objectSpread2({}, item), {}, {
          type: "json"
        })).then(function (res) {
          return _this._loadGLTFResources(item, res, resourceManager);
        });
      };

      _this.requestGLB = function (item, resourceManager) {
        return _this.request(item.url, _objectSpread2(_objectSpread2({}, item), {}, {
          type: "arraybuffer"
        })).then(parseGLB).then(function (res) {
          return _objectSpread2(_objectSpread2({}, res), {}, {
            baseUrl: item.url,
            resourceManager: resourceManager
          });
        }).then(_this._loadImages);
      };

      _this._loadImages = function (_ref) {
        var gltf = _ref.gltf,
            buffers = _ref.buffers,
            baseUrl = _ref.baseUrl,
            resourceManager = _ref.resourceManager;

        if (!gltf.images) {
          return Promise.resolve({
            gltf: gltf,
            buffers: buffers
          });
        }

        var texturePromises = void 0;
        var rhi = resourceManager.engine._hardwareRenderer;

        if (gltf.astc && rhi.canIUse(exports.GLCapabilityType.pvrtc)) {
          texturePromises = _this._loadCompressedTexture(resourceManager, gltf.pvrtc, baseUrl);
        } else if (gltf.pvrtc && rhi.canIUse(exports.GLCapabilityType.astc)) {
          texturePromises = _this._loadCompressedTexture(resourceManager, gltf.astc, baseUrl);
        } else if (gltf.etc && rhi.canIUse(exports.GLCapabilityType.etc)) {
          texturePromises = _this._loadCompressedTexture(resourceManager, gltf.etc, baseUrl);
        } else {
          texturePromises = _this._loadBasicImages(resourceManager, gltf.images, baseUrl, buffers, gltf);
        }

        return texturePromises.then(function (textures) {
          return {
            gltf: gltf,
            buffers: buffers,
            textures: textures
          };
        });
      };

      _this._loadBasicImages = function (resourceManager, images, baseUrl, buffers, gltf) {
        return Promise.all(images.map(function (_ref2) {
          var uri = _ref2.uri,
              bufferViewIndex = _ref2.bufferView,
              mimeType = _ref2.mimeType;

          if (uri) {
            return resourceManager.load({
              url: parseRelativeUrl(baseUrl, uri),
              type: exports.AssetType.Texture2D
            });
          } else {
            var bufferView = gltf.bufferViews[bufferViewIndex];
            var bufferData = getBufferData(bufferView, buffers);
            return loadImageBuffer(bufferData, mimeType).then(function (image) {
              var tex = new Texture2D(resourceManager.engine, image.width, image.height);
              tex.setImageSource(image);
              tex.generateMipmaps();
              return tex;
            });
          }
        }));
      };

      _this._loadCompressedTexture = function (resourceManager, images, baseUrl) {
        var promises = images.map(function (item) {
          return resourceManager.load({
            url: parseRelativeUrl(baseUrl, item.uri),
            type: exports.AssetType.KTX
          });
        });
        return Promise.all(promises);
      };

      return _this;
    }

    _createClass(GLTFLoader, [{
      key: "load",
      value: function load(item, resourceManager) {
        var _this2 = this;

        return new AssetPromise(function (resolve, reject) {
          var requestGLTFResource = _this2.isGLB(item.url) ? _this2.requestGLB : _this2.requestGLTF;
          requestGLTFResource(item, resourceManager).then(function (res) {
            parseGLTF(res, resourceManager.engine).then(function (gltf) {
              resolve(gltf);
            });
          })["catch"](function (e) {
            console.error(e);
            reject("Error loading glTF JSON from " + item.url);
          });
        });
      }
    }, {
      key: "isGLB",
      value: function isGLB(url) {
        return url.substring(url.lastIndexOf(".") + 1) === "glb";
      }
    }, {
      key: "_loadGLTFResources",
      value: function _loadGLTFResources(item, gltf, resourceManager) {
        return this._loadBuffers(item.url, gltf, resourceManager).then(this._loadImages);
      }
    }, {
      key: "_loadBuffers",
      value: function _loadBuffers(baseUrl, gltf, resourceManager) {
        if (gltf.buffers) {
          return Promise.all(gltf.buffers.map(function (item) {
            if (item instanceof ArrayBuffer) {
              return Promise.resolve(item);
            }

            return resourceManager.load({
              url: parseRelativeUrl(baseUrl, item.uri),
              type: exports.AssetType.Buffer
            });
          })).then(function (buffers) {
            return {
              buffers: buffers,
              gltf: gltf,
              baseUrl: baseUrl,
              resourceManager: resourceManager
            };
          });
        }

        return Promise.resolve({
          baseUrl: baseUrl,
          gltf: gltf,
          resourceManager: resourceManager
        });
      }
    }]);

    return GLTFLoader;
  }(Loader);

  GLTFLoader = __decorate$1$1([resourceLoader(exports.AssetType.Perfab, ["gltf", "glb"])], GLTFLoader);
  var __defProp$2$1 = Object.defineProperty;
  var __getOwnPropDesc$2$1 = Object.getOwnPropertyDescriptor;

  var __decorate$2$1 = function __decorate$2(decorators, target, key, kind) {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$2$1(target, key) : target;

    for (var i = decorators.length - 1, decorator; i >= 0; i--) {
      if (decorator = decorators[i]) result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    }

    if (kind && result) __defProp$2$1(target, key, result);
    return result;
  };

  var JSONLoader = /*#__PURE__*/function (_Loader3) {
    _inherits(JSONLoader, _Loader3);

    var _super4 = _createSuper(JSONLoader);

    function JSONLoader() {
      _classCallCheck(this, JSONLoader);

      return _super4.apply(this, arguments);
    }

    _createClass(JSONLoader, [{
      key: "load",
      value: function load(item) {
        return this.request(item.url, _objectSpread2(_objectSpread2({}, item), {}, {
          type: "json"
        }));
      }
    }]);

    return JSONLoader;
  }(Loader);

  JSONLoader = __decorate$2$1([resourceLoader(exports.AssetType.JSON, ["json"], false)], JSONLoader);
  var HEADER_LEN = 12 + 13 * 4;
  var COMPRESSED_2D = 0;

  function getMipmaps(ktxContainer, loadMipmaps) {
    var mipmaps = [];
    var dataOffset = HEADER_LEN + ktxContainer.bytesOfKeyValueData;
    var width = ktxContainer.pixelWidth;
    var height = ktxContainer.pixelHeight;
    var mipmapCount = loadMipmaps ? ktxContainer.numberOfMipmapLevels : 1;

    for (var level = 0; level < mipmapCount; level++) {
      var imageSize = new Int32Array(ktxContainer.buffer, dataOffset, 1)[0];
      dataOffset += 4;

      for (var face = 0; face < ktxContainer.numberOfFaces; face++) {
        var byteArray = new Uint8Array(ktxContainer.buffer, dataOffset, imageSize);
        mipmaps.push({
          data: byteArray,
          width: width,
          height: height
        });
        dataOffset += imageSize;
        dataOffset += 3 - (imageSize + 3) % 4;
      }

      width = Math.max(1, width * 0.5);
      height = Math.max(1, height * 0.5);
    }

    return mipmaps;
  }

  function isValid(data) {
    if (data.byteLength >= 12) {
      var identifier = new Uint8Array(data, 0, 12);

      if (identifier[0] === 171 && identifier[1] === 75 && identifier[2] === 84 && identifier[3] === 88 && identifier[4] === 32 && identifier[5] === 49 && identifier[6] === 49 && identifier[7] === 187 && identifier[8] === 13 && identifier[9] === 10 && identifier[10] === 26 && identifier[11] === 10) {
        return true;
      }
    }

    return false;
  }

  function getEngineFormat(internalFormat) {
    switch (internalFormat) {
      case exports.GLCompressedTextureInternalFormat.RGB_S3TC_DXT1_EXT:
        return exports.TextureFormat.DXT1;

      case exports.GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT:
        return exports.TextureFormat.DXT5;

      case exports.GLCompressedTextureInternalFormat.RGB_ETC1_WEBGL:
        return exports.TextureFormat.ETC1_RGB;

      case exports.GLCompressedTextureInternalFormat.RGB8_ETC2:
        return exports.TextureFormat.ETC2_RGB;

      case exports.GLCompressedTextureInternalFormat.RGB8_PUNCHTHROUGH_ALPHA1_ETC2:
        return exports.TextureFormat.ETC2_RGBA5;

      case exports.GLCompressedTextureInternalFormat.RGBA8_ETC2_EAC:
        return exports.TextureFormat.ETC2_RGBA8;

      case exports.GLCompressedTextureInternalFormat.RGB_PVRTC_2BPPV1_IMG:
        return exports.TextureFormat.PVRTC_RGB2;

      case exports.GLCompressedTextureInternalFormat.RGBA_PVRTC_2BPPV1_IMG:
        return exports.TextureFormat.PVRTC_RGBA2;

      case exports.GLCompressedTextureInternalFormat.RGB_PVRTC_4BPPV1_IMG:
        return exports.TextureFormat.PVRTC_RGB4;

      case exports.GLCompressedTextureInternalFormat.RGBA_PVRTC_4BPPV1_IMG:
        return exports.TextureFormat.PVRTC_RGBA4;

      case exports.GLCompressedTextureInternalFormat.RGBA_ASTC_4X4_KHR:
        return exports.TextureFormat.ASTC_4x4;

      case exports.GLCompressedTextureInternalFormat.RGBA_ASTC_5X5_KHR:
        return exports.TextureFormat.ASTC_5x5;

      case exports.GLCompressedTextureInternalFormat.RGBA_ASTC_6X6_KHR:
        return exports.TextureFormat.ASTC_6x6;

      case exports.GLCompressedTextureInternalFormat.RGBA_ASTC_8X8_KHR:
        return exports.TextureFormat.ASTC_8x8;

      case exports.GLCompressedTextureInternalFormat.RGBA_ASTC_10X10_KHR:
        return exports.TextureFormat.ASTC_10x10;

      case exports.GLCompressedTextureInternalFormat.RGBA_ASTC_12X12_KHR:
        return exports.TextureFormat.ASTC_12x12;

      default:
        var formatName = exports.GLCompressedTextureInternalFormat[internalFormat];
        throw new Error("this format is not supported in Oasis Engine: ".concat(formatName));
    }
  }

  var khronosTextureContainerParser = {
    parse: function parse(buffer, facesExpected, withMipmaps) {
      var mapEngineFormat = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      if (!isValid(buffer)) {
        throw new Error("khronosTextureContainerParser: invalid KTX file, texture missing KTX identifier");
      }

      var dataSize = Uint32Array.BYTES_PER_ELEMENT;
      var headerDataView = new DataView(buffer, 12, 13 * dataSize);
      var endianness = headerDataView.getUint32(0, true);
      var littleEndian = endianness === 67305985;
      var parsedResult = {
        buffer: buffer,
        glType: headerDataView.getUint32(1 * dataSize, littleEndian),
        glTypeSize: headerDataView.getUint32(2 * dataSize, littleEndian),
        glFormat: headerDataView.getUint32(3 * dataSize, littleEndian),
        glInternalFormat: headerDataView.getUint32(4 * dataSize, littleEndian),
        glBaseInternalFormat: headerDataView.getUint32(5 * dataSize, littleEndian),
        pixelWidth: headerDataView.getUint32(6 * dataSize, littleEndian),
        pixelHeight: headerDataView.getUint32(7 * dataSize, littleEndian),
        pixelDepth: headerDataView.getUint32(8 * dataSize, littleEndian),
        numberOfArrayElements: headerDataView.getUint32(9 * dataSize, littleEndian),
        numberOfFaces: headerDataView.getUint32(10 * dataSize, littleEndian),
        numberOfMipmapLevels: headerDataView.getUint32(11 * dataSize, littleEndian),
        bytesOfKeyValueData: headerDataView.getUint32(12 * dataSize, littleEndian),
        loadType: COMPRESSED_2D
      };

      if (parsedResult.glType !== 0) {
        throw new Error("only compressed formats currently supported");
      } else {
        parsedResult.numberOfMipmapLevels = Math.max(1, parsedResult.numberOfMipmapLevels);
      }

      if (parsedResult.pixelHeight === 0 || parsedResult.pixelDepth !== 0) {
        throw new Error("only 2D textures currently supported");
      }

      if (parsedResult.numberOfArrayElements !== 0) {
        throw new Error("texture arrays not currently supported");
      }

      if (parsedResult.numberOfFaces !== facesExpected) {
        throw new Error("number of faces expected" + facesExpected + ", but found " + parsedResult.numberOfFaces);
      }

      if (withMipmaps) {
        parsedResult.mipmaps = getMipmaps(parsedResult, true);
      }

      if (mapEngineFormat) {
        parsedResult.engineFormat = getEngineFormat(parsedResult.glInternalFormat);
      }

      return parsedResult;
    }
  };

  function parseSingleKTX(data) {
    var ktx = khronosTextureContainerParser.parse(data, 1, true, true);
    return {
      mipmaps: ktx.mipmaps,
      engineFormat: ktx.engineFormat,
      internalFormat: ktx.glInternalFormat,
      width: ktx.pixelWidth,
      height: ktx.pixelHeight
    };
  }

  function parseCubeKTX(dataArray) {
    var mipmapsFaces = [];
    var internalFormat;
    var engineFormat;
    var width;
    var height;

    for (var i = 0; i < dataArray.length; i++) {
      var ktx = khronosTextureContainerParser.parse(dataArray[i], 1, true, true);
      mipmapsFaces.push(ktx.mipmaps);

      if (i === 0) {
        width = ktx.pixelWidth;
        height = ktx.pixelHeight;
        internalFormat = ktx.glInternalFormat;
        engineFormat = ktx.engineFormat;
      }
    }

    return {
      mipmapsFaces: mipmapsFaces,
      engineFormat: engineFormat,
      internalFormat: internalFormat,
      width: width,
      height: height
    };
  }

  var __defProp$3$1 = Object.defineProperty;
  var __getOwnPropDesc$3$1 = Object.getOwnPropertyDescriptor;

  var __decorate$3$1 = function __decorate$3(decorators, target, key, kind) {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$3$1(target, key) : target;

    for (var i = decorators.length - 1, decorator; i >= 0; i--) {
      if (decorator = decorators[i]) result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    }

    if (kind && result) __defProp$3$1(target, key, result);
    return result;
  };

  var KTXCubeLoader = /*#__PURE__*/function (_Loader4) {
    _inherits(KTXCubeLoader, _Loader4);

    var _super5 = _createSuper(KTXCubeLoader);

    function KTXCubeLoader() {
      _classCallCheck(this, KTXCubeLoader);

      return _super5.apply(this, arguments);
    }

    _createClass(KTXCubeLoader, [{
      key: "load",
      value: function load(item, resourceManager) {
        var _this3 = this;

        return new AssetPromise(function (resolve, reject) {
          Promise.all(item.urls.map(function (url) {
            return _this3.request(url, _objectSpread2(_objectSpread2({}, item), {}, {
              type: "arraybuffer"
            }));
          })).then(function (data) {
            var parsedData = parseCubeKTX(data);
            var width = parsedData.width,
                mipmapsFaces = parsedData.mipmapsFaces,
                engineFormat = parsedData.engineFormat;
            var mipmap = mipmapsFaces[0].length > 1;
            var texture = new TextureCubeMap(resourceManager.engine, width, engineFormat, mipmap);

            for (var face = 0; face < 6; face++) {
              var length = mipmapsFaces[face].length;

              for (var miplevel = 0; miplevel < length; miplevel++) {
                var _mipmapsFaces$face$mi = mipmapsFaces[face][miplevel],
                    data2 = _mipmapsFaces$face$mi.data,
                    width2 = _mipmapsFaces$face$mi.width,
                    height = _mipmapsFaces$face$mi.height;
                texture.setPixelBuffer(exports.TextureCubeFace.PositiveX + face, data2, miplevel, 0, 0, width2, height);
              }
            }

            resolve(texture);
          })["catch"](function (e) {
            reject(e);
          });
        });
      }
    }]);

    return KTXCubeLoader;
  }(Loader);

  KTXCubeLoader = __decorate$3$1([resourceLoader(exports.AssetType.KTXCube, [])], KTXCubeLoader);
  var __defProp$4$1 = Object.defineProperty;
  var __getOwnPropDesc$4$1 = Object.getOwnPropertyDescriptor;

  var __decorate$4$1 = function __decorate$4(decorators, target, key, kind) {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$4$1(target, key) : target;

    for (var i = decorators.length - 1, decorator; i >= 0; i--) {
      if (decorator = decorators[i]) result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    }

    if (kind && result) __defProp$4$1(target, key, result);
    return result;
  };

  var KTXLoader = /*#__PURE__*/function (_Loader5) {
    _inherits(KTXLoader, _Loader5);

    var _super6 = _createSuper(KTXLoader);

    function KTXLoader() {
      _classCallCheck(this, KTXLoader);

      return _super6.apply(this, arguments);
    }

    _createClass(KTXLoader, [{
      key: "load",
      value: function load(item, resourceManager) {
        var _this4 = this;

        return new AssetPromise(function (resolve, reject) {
          _this4.request(item.url, _objectSpread2(_objectSpread2({}, item), {}, {
            type: "arraybuffer"
          })).then(function (bin) {
            var parsedData = parseSingleKTX(bin);
            var width = parsedData.width,
                height = parsedData.height,
                mipmaps = parsedData.mipmaps,
                engineFormat = parsedData.engineFormat;
            var mipmap = mipmaps.length > 1;
            var texture = new Texture2D(resourceManager.engine, width, height, engineFormat, mipmap);

            for (var miplevel = 0; miplevel < mipmaps.length; miplevel++) {
              var _mipmaps$miplevel = mipmaps[miplevel],
                  width2 = _mipmaps$miplevel.width,
                  height2 = _mipmaps$miplevel.height,
                  data = _mipmaps$miplevel.data;
              texture.setPixelBuffer(data, miplevel, 0, 0, width2, height2);
            }

            resolve(texture);
          })["catch"](function (e) {
            reject(e);
          });
        });
      }
    }]);

    return KTXLoader;
  }(Loader);

  KTXLoader = __decorate$4$1([resourceLoader(exports.AssetType.KTX, ["ktx"])], KTXLoader);
  var __defProp$5$1 = Object.defineProperty;
  var __getOwnPropDesc$5$1 = Object.getOwnPropertyDescriptor;

  var __decorate$5$1 = function __decorate$5(decorators, target, key, kind) {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$5$1(target, key) : target;

    for (var i = decorators.length - 1, decorator; i >= 0; i--) {
      if (decorator = decorators[i]) result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    }

    if (kind && result) __defProp$5$1(target, key, result);
    return result;
  };

  var Texture2DLoader = /*#__PURE__*/function (_Loader6) {
    _inherits(Texture2DLoader, _Loader6);

    var _super7 = _createSuper(Texture2DLoader);

    function Texture2DLoader() {
      _classCallCheck(this, Texture2DLoader);

      return _super7.apply(this, arguments);
    }

    _createClass(Texture2DLoader, [{
      key: "load",
      value: function load(item, resourceManager) {
        var _this5 = this;

        return new AssetPromise(function (resolve, reject) {
          _this5.request(item.url, _objectSpread2(_objectSpread2({}, item), {}, {
            type: "image"
          })).then(function (image) {
            var texture = new Texture2D(resourceManager.engine, image.width, image.height);
            if (!texture._glTexture) return;
            texture.setImageSource(image);
            texture.generateMipmaps();

            if (item.url.indexOf("data:") !== 0) {
              var splitPath = item.url.split("/");
              texture.name = splitPath[splitPath.length - 1];
            }

            resolve(texture);
          })["catch"](function (e) {
            reject(e);
          });
        });
      }
    }]);

    return Texture2DLoader;
  }(Loader);

  Texture2DLoader = __decorate$5$1([resourceLoader(exports.AssetType.Texture2D, ["png", "jpg", "webp", "jpeg"])], Texture2DLoader);
  var __defProp$6$1 = Object.defineProperty;
  var __getOwnPropDesc$6$1 = Object.getOwnPropertyDescriptor;

  var __decorate$6$1 = function __decorate$6(decorators, target, key, kind) {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$6$1(target, key) : target;

    for (var i = decorators.length - 1, decorator; i >= 0; i--) {
      if (decorator = decorators[i]) result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    }

    if (kind && result) __defProp$6$1(target, key, result);
    return result;
  };

  var TextureCubeLoader = /*#__PURE__*/function (_Loader7) {
    _inherits(TextureCubeLoader, _Loader7);

    var _super8 = _createSuper(TextureCubeLoader);

    function TextureCubeLoader() {
      _classCallCheck(this, TextureCubeLoader);

      return _super8.apply(this, arguments);
    }

    _createClass(TextureCubeLoader, [{
      key: "load",
      value: function load(item, resourceManager) {
        var _this6 = this;

        return new AssetPromise(function (resolve, reject) {
          Promise.all(item.urls.map(function (url) {
            return _this6.request(url, _objectSpread2(_objectSpread2({}, item), {}, {
              type: "image"
            }));
          })).then(function (images) {
            var _images$ = images[0],
                width = _images$.width,
                height = _images$.height;

            if (width !== height) {
              console.error("The cube texture must have the same width and height");
              return;
            }

            var tex = new TextureCubeMap(resourceManager.engine, width);
            if (!tex._glTexture) return;

            for (var faceIndex = 0; faceIndex < 6; faceIndex++) {
              tex.setImageSource(exports.TextureCubeFace.PositiveX + faceIndex, images[faceIndex], 0);
            }

            tex.generateMipmaps();
            resolve(tex);
          })["catch"](function (e) {
            reject(e);
          });
        });
      }
    }]);

    return TextureCubeLoader;
  }(Loader);

  TextureCubeLoader = __decorate$6$1([resourceLoader(exports.AssetType.TextureCube, [""])], TextureCubeLoader);

  var GLTFModel = /*#__PURE__*/function (_Component) {
    _inherits(GLTFModel, _Component);

    var _super9 = _createSuper(GLTFModel);

    function GLTFModel(entity) {
      var _this7;

      _classCallCheck(this, GLTFModel);

      _this7 = _super9.call(this, entity);
      _this7._hasBuiltNode = false;
      return _this7;
    }

    _createClass(GLTFModel, [{
      key: "init",
      value: function init(props) {
        var _this8 = this;

        var _props$asset = props.asset,
            asset = _props$asset === void 0 ? null : _props$asset,
            autoPlay = props.autoPlay,
            loop = props.loop,
            isClone = props.isClone;

        if (isClone) {
          var rootName = props.gltfRootName;

          if (rootName) {
            this.GLTFNode = this.entity.findByName(rootName);
          }
        }

        if (!this.GLTFNode) {
          var _rootName = "GLTF-".concat(Date.now());

          props.gltfRootName = _rootName;
          this.GLTFNode = this.entity.createChild(_rootName);
          this._hasBuiltNode = false;
        } else {
          this._hasBuiltNode = true;
        }

        this.asset = asset;
        this.loop = loop;
        this.autoPlay = autoPlay;
        this.addEventListener("enabled", function () {
          _this8.GLTFNode.isActive = true;
        });
        this.addEventListener("disabled", function () {
          _this8.GLTFNode.isActive = false;
        });
      }
    }, {
      key: "asset",
      get: function get() {
        return this._asset;
      },
      set: function set(value) {
        if (value && value.defaultSceneRoot === this.GLTFNode) {
          return;
        }

        if (!this._hasBuiltNode) {
          this.GLTFNode.clearChildren();

          if (value !== null) {
            if (this.GLTFNode) {
              this.GLTFNode.destroy();
            }

            this.GLTFNode = value.defaultSceneRoot.clone();
            this._animator = this.GLTFNode.getComponent(Animation);
            this.entity.addChild(this.GLTFNode);
          }
        }

        this._asset = value;
      }
    }, {
      key: "animator",
      get: function get() {
        return this._animator;
      }
    }, {
      key: "autoPlay",
      get: function get() {
        return this._autoPlay;
      },
      set: function set(value) {
        if (this._animator) {
          if (value) {
            this._animator.playAnimationClip(value, {
              wrapMode: this._loop
            });
          } else {
            this._animator.stop(false);
          }
        }

        this._autoPlay = value;
      }
    }, {
      key: "loop",
      get: function get() {
        return this._loop;
      },
      set: function set(value) {
        if (this._animator && this.autoPlay) {
          this._animator.playAnimationClip(this._autoPlay, {
            wrapMode: value
          });
        }

        this._loop = value;
      }
    }]);

    return GLTFModel;
  }(Component);

  var PluginManager = /*#__PURE__*/function () {
    function PluginManager() {
      _classCallCheck(this, PluginManager);

      this.registeredPlugins = new Set();
      this.plugins = [];
    }

    _createClass(PluginManager, [{
      key: "register",
      value: function register(plugin) {
        this.registeredPlugins.add(plugin);
      }
    }, {
      key: "boot",
      value: function boot(oasis) {
        var _iterator = _createForOfIteratorHelper(this.registeredPlugins.values()),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var plugin = _step.value;

            if (typeof plugin === "function") {
              plugin = plugin(oasis);
            }

            this.plugins.push(plugin);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    }, {
      key: "reset",
      value: function reset() {
        this.registeredPlugins.clear();
        this.plugins = [];
      }
    }, {
      key: "nodeAdded",
      value: function nodeAdded(entity) {
        this.delegateMethod("nodeAdded", entity);
      }
    }, {
      key: "delegateMethod",
      value: function delegateMethod(name) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        this.plugins.forEach(function (plugin) {
          return plugin[name] && plugin[name].apply(plugin, args);
        });
      }
    }]);

    return PluginManager;
  }();

  function pluginHook(options) {
    return function (target, propertyName, descriptor) {
      var method = descriptor.value;

      descriptor.value = function () {
        var _this$oasis$pluginMan,
            _this9 = this;

        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        options.before && (_this$oasis$pluginMan = this.oasis.pluginManager).delegateMethod.apply(_this$oasis$pluginMan, [options.before].concat(args));
        return Promise.resolve(method.apply(this, arguments)).then(function (returnObj) {
          options.after && _this9.oasis.pluginManager.delegateMethod(options.after, returnObj);
          return returnObj;
        });
      };
    };
  }

  function switchElementsIndex(elements, currentIndex, targetIndex) {
    if (currentIndex === targetIndex || targetIndex === null || targetIndex === void 0) {
      return;
    }

    var _ref3 = [elements[targetIndex], elements[currentIndex]];
    elements[currentIndex] = _ref3[0];
    elements[targetIndex] = _ref3[1];
  }

  function isAsset(config) {
    return config && config.type === "asset";
  }

  function getAllGetters(obj) {
    var result = [];
    var prototype = Object.getPrototypeOf(obj);
    var prototype_property_descriptors = Object.getOwnPropertyDescriptors(prototype);

    for (var _i7 = 0, _Object$entries = Object.entries(prototype_property_descriptors); _i7 < _Object$entries.length; _i7++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i7], 2),
          property = _Object$entries$_i[0],
          descriptor = _Object$entries$_i[1];

      if (typeof descriptor.get === "function") {
        result.push(property);
      }
    }

    return result;
  }

  var SchemaResource = /*#__PURE__*/function () {
    function SchemaResource(resourceManager, _resource) {
      _classCallCheck(this, SchemaResource);

      this.resourceManager = resourceManager;
      this._resource = _resource;
      this._meta = {};
      this._attachedResources = [];
      this.setMeta();
    }

    _createClass(SchemaResource, [{
      key: "setMeta",
      value: function setMeta() {}
    }, {
      key: "loadWithAttachedResources",
      value: function loadWithAttachedResources(resourceLoader, assetConfig, oasis) {
        var _this10 = this;

        return new Promise(function (resolve, reject) {
          _this10.load(resourceLoader, assetConfig, oasis).then(function () {
            resolve({
              resources: [_this10],
              structure: {
                index: 0,
                props: {}
              }
            });
          })["catch"](function (e) {
            reject(e);
          });
        });
      }
    }, {
      key: "getProps",
      value: function getProps() {
        return {};
      }
    }, {
      key: "bind",
      value: function bind() {}
    }, {
      key: "attach",
      value: function attach() {}
    }, {
      key: "update",
      value: function update(key, value) {
        if (isAsset(value)) {
          var resource = this.resourceManager.get(value.id);

          if (resource) {
            this._resource[key] = resource.resource;
          } else {
            Logger.warn("SchemaResource: ".concat(this.meta.name, " can't find asset, which id is: ").concat(value.id));
          }
        } else {
          this._resource[key] = value;
        }
      }
    }, {
      key: "updateMeta",
      value: function updateMeta(key, value) {
        this._meta[key] = value;
      }
    }, {
      key: "onDestroy",
      value: function onDestroy() {}
    }, {
      key: "resource",
      get: function get() {
        return this._resource;
      }
    }, {
      key: "meta",
      get: function get() {
        return this._meta;
      }
    }, {
      key: "attachedResources",
      get: function get() {
        return this._attachedResources;
      }
    }]);

    return SchemaResource;
  }();

  var TextureResource = /*#__PURE__*/function (_SchemaResource) {
    _inherits(TextureResource, _SchemaResource);

    var _super10 = _createSuper(TextureResource);

    function TextureResource() {
      _classCallCheck(this, TextureResource);

      return _super10.apply(this, arguments);
    }

    _createClass(TextureResource, [{
      key: "load",
      value: function load(resourceManager, assetConfig, oasis) {
        var _this11 = this;

        return new Promise(function (resolve, reject) {
          var _assetConfig$props, _assetConfig$props$co, _url;

          var url;
          var assetType = exports.AssetType.Texture2D;

          if (_this11.resourceManager.useCompressedTexture && assetConfig !== null && assetConfig !== void 0 && (_assetConfig$props = assetConfig.props) !== null && _assetConfig$props !== void 0 && (_assetConfig$props$co = _assetConfig$props.compression) !== null && _assetConfig$props$co !== void 0 && _assetConfig$props$co.compressions.length) {
            var rhi = oasis.engine._hardwareRenderer;
            var compressions = assetConfig.props.compression.compressions;

            for (var i = 0; i < compressions.length; i++) {
              var compression = compressions[i];

              if (compression.container === "ktx" && rhi.canIUse(exports.GLCapabilityType[compression.type])) {
                url = compression.url;
                assetType = exports.AssetType.KTX;
                break;
              }
            }
          }

          url = (_url = url) !== null && _url !== void 0 ? _url : assetConfig.url;
          resourceManager.load({
            url: url,
            type: assetType
          }).then(function (res) {
            _this11._resource = res;
            resolve(_this11);
          })["catch"](function (e) {
            reject(e);
          });
        });
      }
    }, {
      key: "setMeta",
      value: function setMeta() {
        if (this.resource) {
          this._meta.name = this.resource.name;

          if (this.resource.image) {
            this._meta.url = this.resource.image.src;
          }
        }
      }
    }]);

    return TextureResource;
  }(SchemaResource);

  var PBRMaterialResource = /*#__PURE__*/function (_SchemaResource2) {
    _inherits(PBRMaterialResource, _SchemaResource2);

    var _super11 = _createSuper(PBRMaterialResource);

    function PBRMaterialResource() {
      _classCallCheck(this, PBRMaterialResource);

      return _super11.apply(this, arguments);
    }

    _createClass(PBRMaterialResource, [{
      key: "load",
      value: function load(resourceManager, assetConfig) {
        var _this12 = this;

        return new Promise(function (resolve) {
          var assetObj = new PBRMaterial(resourceManager.engine, assetConfig.name);
          _this12.configProps = assetConfig.props;

          for (var k in _this12.configProps) {
            if (!isAsset(_this12.configProps[k])) {
              assetObj[k] = _this12.configProps[k];
            }
          }

          _this12._resource = assetObj;

          _this12.setMeta();

          resolve(_this12);
        });
      }
    }, {
      key: "loadWithAttachedResources",
      value: function loadWithAttachedResources(resourceManager, assetConfig) {
        var _this13 = this;

        return new Promise(function (resolve, reject) {
          var loadPromise;

          if (assetConfig.resource instanceof PBRMaterial) {
            loadPromise = new Promise(function (resolve2) {
              _this13._resource = assetConfig.resource;

              _this13.setMeta();

              resolve2(_this13);
            });
          } else if (assetConfig.props) {
            loadPromise = _this13.load(resourceManager, assetConfig);
          } else {
            reject("Load PBRMaterial Error");
          }

          if (loadPromise) {
            loadPromise.then(function () {
              var result = {
                resources: [_this13],
                structure: {
                  index: 0,
                  props: {}
                }
              };
              var material = _this13._resource;
              getAllGetters(_this13._resource).forEach(function (attr) {
                if (!(material[attr] instanceof Texture)) return;
                var textureResource = new TextureResource(_this13.resourceManager, material[attr]);

                _this13.attachedResources.push(textureResource);

                result.resources.push(textureResource);
                result.structure.props[attr] = {
                  index: result.resources.length - 1
                };
              });
              resolve(result);
            });
          }
        });
      }
    }, {
      key: "setMeta",
      value: function setMeta() {
        if (this.resource) {
          this.meta.name = this.resource.name;
        }
      }
    }, {
      key: "getProps",
      value: function getProps() {
        var _this14 = this;

        var result = {};
        var props = getAllGetters(this.resource);
        props.forEach(function (prop) {
          return result[prop] = _this14.resource[prop];
        });
        return result;
      }
    }, {
      key: "bind",
      value: function bind() {
        var _this15 = this;

        var resource = this._resource;
        Object.keys(this.configProps).forEach(function (attr) {
          var value = _this15.configProps[attr];

          if (isAsset(value)) {
            var textureResource = _this15.resourceManager.get(value.id);

            if (textureResource && textureResource instanceof TextureResource) {
              resource[attr] = textureResource.resource;

              _this15._attachedResources.push(textureResource);
            } else {
              resource[attr] = null;
              Logger.warn("PBRMaterialResource: ".concat(_this15.meta.name, " can't find asset \"").concat(attr, "\", which id is: ").concat(value.id));
            }
          } else {
            if (attr === "side") {
              return;
            }

            resource[attr] = value;
          }
        });
      }
    }]);

    return PBRMaterialResource;
  }(SchemaResource);

  var GLTFResource$1 = /*#__PURE__*/function (_SchemaResource3) {
    _inherits(GLTFResource$1, _SchemaResource3);

    var _super12 = _createSuper(GLTFResource$1);

    function GLTFResource$1() {
      _classCallCheck(this, GLTFResource$1);

      return _super12.apply(this, arguments);
    }

    _createClass(GLTFResource$1, [{
      key: "load",
      value: function load(resourceManager, assetConfig, oasis) {
        var _assetConfig$props2,
            _this16 = this;

        if (!!((_assetConfig$props2 = assetConfig.props) !== null && _assetConfig$props2 !== void 0 && _assetConfig$props2.compression)) {
          glTFDracoMeshCompression.init();
        }

        return resourceManager.load({
          url: assetConfig.url,
          type: exports.AssetType.Perfab
        }).then(function (res) {
          var gltf = res;

          if (assetConfig.props) {
            gltf.newMaterial = assetConfig.props.newMaterial;
          }

          _this16._resource = gltf;
        });
      }
    }, {
      key: "loadWithAttachedResources",
      value: function loadWithAttachedResources(resourceManager, assetConfig, oasis) {
        var _this17 = this;

        return new Promise(function (resolve) {
          _this17.load(resourceManager, assetConfig, oasis).then(function () {
            var gltf = _this17.resource;
            var materials = gltf.materials;
            var loadPromises = [];
            var result = {
              resources: [_this17],
              structure: {
                index: 0,
                props: {
                  newMaterial: []
                }
              }
            };

            for (var i = 0; i < materials.length; i++) {
              var material = materials[i];
              var materialResource = new PBRMaterialResource(_this17.resourceManager);

              _this17._attachedResources.push(materialResource);

              loadPromises.push(materialResource.loadWithAttachedResources(resourceManager, {
                type: "PBRMaterial",
                name: material.name,
                resource: material
              }));
            }

            Promise.all(loadPromises).then(function (res) {
              var newMaterial = result.structure.props.newMaterial;
              res.forEach(function (mat) {
                var matStructure = mat.structure;
                var matResource = mat.resources[matStructure.index];
                result.resources.push(matResource);
                matStructure.index = result.resources.length - 1;

                for (var key in matStructure.props) {
                  if (matStructure.props.hasOwnProperty(key)) {
                    var textureStructure = matStructure.props[key];
                    var textureResource = mat.resources[textureStructure.index];
                    result.resources.push(textureResource);
                    textureStructure.index = result.resources.length - 1;
                  }
                }

                newMaterial.push(matStructure);
              });
              resolve(result);
            });
          });
        });
      }
    }, {
      key: "setMeta",
      value: function setMeta(assetConfig) {
        if (assetConfig) {
          this.meta.name = assetConfig.name;
        }
      }
    }, {
      key: "bind",
      value: function bind() {
        var resource = this._resource;
        this.bindMaterials(resource.newMaterial);
      }
    }, {
      key: "update",
      value: function update(key, value) {
        if (key === "newMaterial") {
          this.bindMaterials(value);
        } else {
          this._resource[key] = value;
        }
      }
    }, {
      key: "bindMaterials",
      value: function bindMaterials(materials) {
        if (!materials || !materials.length) {
          return;
        }

        var gltf = this._resource;
        var meshes = gltf.meshes;

        for (var i = 0; i < materials.length; i++) {
          var mtlResource = this.resourceManager.get(materials[i].id);

          if (mtlResource) {
            this._attachedResources.push(mtlResource);

            gltf.materials[i] = mtlResource.resource;
          } else {
            Logger.warn("GLTFResource: ".concat(this.meta.name, " can't find asset \"material\", which id is: ").concat(materials[i].id));
          }
        }

        for (var j = 0; j < meshes.length; j++) {
          var node = this.getNodeByMeshIndex(gltf.nodes, meshes.length - 1 - j);

          if (node) {
            for (var k = 0; k < meshes[j].primitives.length; k++) {
              var primitive = meshes[j].primitives[k];
              var meshRenderer = node.getComponent(MeshRenderer);
              var material = gltf.materials[gltf.materials.length - 1 - primitive.materialIndex];

              if (meshRenderer && material && material instanceof Material) {
                meshRenderer.setSharedMaterial(k, material);
              }
            }
          }
        }
      }
    }, {
      key: "getNodeByMeshIndex",
      value: function getNodeByMeshIndex(nodes, index) {
        for (var i = 0; i <= nodes.length; i++) {
          var node = nodes[i];

          if (node.meshIndex === index) {
            return node;
          }
        }

        return null;
      }
    }]);

    return GLTFResource$1;
  }(SchemaResource);

  var ShaderMaterialResource = /*#__PURE__*/function (_SchemaResource4) {
    _inherits(ShaderMaterialResource, _SchemaResource4);

    var _super13 = _createSuper(ShaderMaterialResource);

    function ShaderMaterialResource() {
      _classCallCheck(this, ShaderMaterialResource);

      return _super13.apply(this, arguments);
    }

    _createClass(ShaderMaterialResource, [{
      key: "loadShaderDefine",
      value: function loadShaderDefine(oasis) {
        var _this18 = this;

        return new Promise(function (resolve) {
          var name = _this18.scripts[0].name;

          if (_this18.resourceManager.isLocal) {
            var _oasis$options$script, _oasis$options;

            resolve((_oasis$options$script = (_oasis$options = oasis.options) === null || _oasis$options === void 0 ? void 0 : _oasis$options.scripts[name]) !== null && _oasis$options$script !== void 0 ? _oasis$options$script : {});
          } else {
            var oldScriptDom = document.getElementById(name);

            if (oldScriptDom) {
              document.body.removeChild(oldScriptDom);
            }

            var scriptDom = document.createElement("script");
            scriptDom.crossOrigin = "anonymous";

            scriptDom.onload = function () {
              var _ref4;

              var scripts = window.o3Scripts;
              resolve((_ref4 = scripts && scripts[name]) !== null && _ref4 !== void 0 ? _ref4 : {});
            };

            scriptDom.id = name;
            scriptDom.src = _this18._meta.url;
            document.body.appendChild(scriptDom);
          }
        }).then(function (shaderMaterialDefine) {
          var _shaderMaterialDefine = shaderMaterialDefine.vertexShader,
              vertexShader = _shaderMaterialDefine === void 0 ? "" : _shaderMaterialDefine,
              _shaderMaterialDefine2 = shaderMaterialDefine.fragmentShader,
              fragmentShader = _shaderMaterialDefine2 === void 0 ? "" : _shaderMaterialDefine2,
              _shaderMaterialDefine3 = shaderMaterialDefine.states,
              states = _shaderMaterialDefine3 === void 0 ? {} : _shaderMaterialDefine3,
              _shaderMaterialDefine4 = shaderMaterialDefine.uniforms,
              uniforms = _shaderMaterialDefine4 === void 0 ? {} : _shaderMaterialDefine4,
              _shaderMaterialDefine5 = shaderMaterialDefine.attributes,
              attributes = _shaderMaterialDefine5 === void 0 ? {} : _shaderMaterialDefine5;
          _this18._resource.uniforms = uniforms;
          _this18._resource.attributes = attributes;
          _this18._resource.vertexShader = vertexShader;
          _this18._resource.fragmentShader = fragmentShader;
          _this18._resource.renderStates = states;
        });
      }
    }, {
      key: "createMaterial",
      value: function createMaterial(engine) {
        var material = new ShaderMaterial(engine, this.meta.name || "shader_mtl");
        this._resource = material;
      }
    }, {
      key: "load",
      value: function load(resourceLoader, assetConfig, oasis) {
        var _this19 = this;

        this.setMeta(assetConfig);
        this.scripts = assetConfig.props.scripts;
        this.createMaterial(oasis.engine);
        return this.loadShaderDefine(oasis).then(function () {
          return new Promise(function (resolve, reject) {
            try {
              for (var k in assetConfig.props) {
                _this19._resource[k] = assetConfig.props[k];
              }

              _this19._resource.updateTechnique();

              resolve(_this19);
            } catch (_unused) {
              reject("[shader material] createTechnique error");
            }
          });
        });
      }
    }, {
      key: "setMeta",
      value: function setMeta(assetConfig) {
        if (assetConfig) {
          this._meta.name = assetConfig.name;
          this._meta.url = assetConfig.url;
          this._meta.source = assetConfig.source;
        }
      }
    }, {
      key: "updateMeta",
      value: function updateMeta(key, value) {
        var _this20 = this;

        _get(_getPrototypeOf(ShaderMaterialResource.prototype), "updateMeta", this).call(this, key, value);

        if (key === "url") {
          this.loadShaderDefine().then(function () {
            try {
              _this20._resource.updateTechnique();
            } catch (_unused2) {
              console.error("[shader material] createTechnique error");
            }
          });
        }
      }
    }, {
      key: "update",
      value: function update(key, value) {
        this._resource[key] = value;

        this._resource.updateTechnique();
      }
    }]);

    return ShaderMaterialResource;
  }(SchemaResource);

  var scriptAbility = {};

  function script(name) {
    return function (target) {
      scriptAbility[name] = target;
    };
  }

  var ScriptResource = /*#__PURE__*/function (_SchemaResource5) {
    _inherits(ScriptResource, _SchemaResource5);

    var _super14 = _createSuper(ScriptResource);

    function ScriptResource() {
      var _this21;

      _classCallCheck(this, ScriptResource);

      _this21 = _super14.apply(this, arguments);
      _this21.isInit = false;
      return _this21;
    }

    _createClass(ScriptResource, [{
      key: "initScriptContext",
      value: function initScriptContext() {
        if (this.isInit) {
          return;
        }

        this.isInit = true;
        window.__o3_script_context__ = {
          o3: Parser._components["o3"],
          script: function script(name) {
            return function (target) {
              scriptAbility[name] = target;
            };
          }
        };
      }
    }, {
      key: "load",
      value: function load(resourceLoader, assetConfig, oasis) {
        var _this22 = this;

        this.initScriptContext();
        return new Promise(function (resolve) {
          var config = assetConfig;
          var scripts = config.props.scripts;

          if (!_this22.resourceManager.isLocal) {
            var scriptDom = document.createElement("script");
            scriptDom.crossOrigin = "anonymous";

            _this22.setMeta(assetConfig);

            scriptDom.onload = function () {
              var o3Scripts = window.o3Scripts;

              for (var i = 0; i < scripts.length; i++) {
                var name = scripts[i].name;
                _this22._resource = o3Scripts && o3Scripts[name];
                scriptAbility[name] = _this22._resource;
              }

              resolve(_this22);
            };

            scriptDom.src = assetConfig.url;
            document.body.appendChild(scriptDom);
          } else {
            for (var i = 0; i < scripts.length; i++) {
              var _oasis$options2;

              var name = scripts[i].name;
              scriptAbility[name] = (_oasis$options2 = oasis.options) === null || _oasis$options2 === void 0 ? void 0 : _oasis$options2.scripts[name];
            }

            resolve(_this22);
          }
        });
      }
    }, {
      key: "setMeta",
      value: function setMeta(assetConfig) {
        if (assetConfig) {
          this._meta.name = assetConfig.name;
          this._meta.url = assetConfig.url;
          this._meta.source = assetConfig.source;
        }
      }
    }]);

    return ScriptResource;
  }(SchemaResource);

  var BlinnPhongMaterialResource = /*#__PURE__*/function (_SchemaResource6) {
    _inherits(BlinnPhongMaterialResource, _SchemaResource6);

    var _super15 = _createSuper(BlinnPhongMaterialResource);

    function BlinnPhongMaterialResource() {
      _classCallCheck(this, BlinnPhongMaterialResource);

      return _super15.apply(this, arguments);
    }

    _createClass(BlinnPhongMaterialResource, [{
      key: "load",
      value: function load(resourceManager, assetConfig) {
        var _this23 = this;

        return new Promise(function (resolve) {
          var assetObj = new BlinnPhongMaterial(resourceManager.engine, assetConfig.name);

          for (var k in assetConfig.props) {
            assetObj[k] = assetConfig.props[k];
          }

          _this23._resource = assetObj;

          _this23.setMeta();

          resolve(_this23);
        });
      }
    }, {
      key: "setMeta",
      value: function setMeta() {
        if (this.resource) {
          this.meta.name = this.resource.name;
        }
      }
    }]);

    return BlinnPhongMaterialResource;
  }(SchemaResource);

  var imageOrderMap = {
    px: 0,
    nx: 1,
    py: 2,
    ny: 3,
    pz: 4,
    nz: 5
  };

  var TextureCubeMapResource = /*#__PURE__*/function (_SchemaResource7) {
    _inherits(TextureCubeMapResource, _SchemaResource7);

    var _super16 = _createSuper(TextureCubeMapResource);

    function TextureCubeMapResource() {
      _classCallCheck(this, TextureCubeMapResource);

      return _super16.apply(this, arguments);
    }

    _createClass(TextureCubeMapResource, [{
      key: "load",
      value: function load(resourceManager, assetConfig, oasis) {
        var _this24 = this;

        return new Promise(function (resolve, reject) {
          var _assetConfig$props3, _assetConfig$props3$c;

          var imageUrls = [];
          var type = exports.AssetType.TextureCube;

          if (_this24.resourceManager.useCompressedTexture && assetConfig !== null && assetConfig !== void 0 && (_assetConfig$props3 = assetConfig.props) !== null && _assetConfig$props3 !== void 0 && (_assetConfig$props3$c = _assetConfig$props3.compression) !== null && _assetConfig$props3$c !== void 0 && _assetConfig$props3$c.compressions.length) {
            var rhi = oasis.engine._hardwareRenderer;
            var compressions = assetConfig.props.compression.compressions;

            for (var i = 0; i < compressions.length; i++) {
              var compression = compressions[i];

              if (compression.container === "ktx" && rhi.canIUse(exports.GLCapabilityType[compression.type])) {
                for (var key in compression.files) {
                  if (compression.files.hasOwnProperty(key)) {
                    var image = compression.files[key];
                    imageUrls[imageOrderMap[key]] = image.url;
                  }
                }

                console.warn(compression.type);
                type = exports.AssetType.KTXCube;
                break;
              }
            }
          }

          if (type === exports.AssetType.TextureCube) {
            for (var _key3 in assetConfig.props.images) {
              if (assetConfig.props.images.hasOwnProperty(_key3)) {
                var _image = assetConfig.props.images[_key3];
                imageUrls[imageOrderMap[_key3]] = _image.url;
              }
            }
          }

          resourceManager.load({
            urls: imageUrls,
            type: type
          }).then(function (res) {
            _this24._resource = res;
            resolve(_this24);
          })["catch"](function (e) {
            reject(e);
          });
        });
      }
    }, {
      key: "setMeta",
      value: function setMeta() {
        if (this.resource) {
          this.meta.name = this.resource.name;
        }
      }
    }]);

    return TextureCubeMapResource;
  }(SchemaResource);

  var BaseResource = /*#__PURE__*/function (_SchemaResource8) {
    _inherits(BaseResource, _SchemaResource8);

    var _super17 = _createSuper(BaseResource);

    function BaseResource() {
      _classCallCheck(this, BaseResource);

      return _super17.apply(this, arguments);
    }

    _createClass(BaseResource, [{
      key: "load",
      value: function load(resourceLoader, assetConfig) {
        var _this25 = this;

        return new Promise(function (resolve) {
          _this25._resource = assetConfig;

          _this25.setMetaData("name", _this25.resource.name);

          _this25.setMetaData("url", _this25.resource.url);

          resolve(_this25);
        });
      }
    }, {
      key: "setMetaData",
      value: function setMetaData(key, value) {
        this._meta[key] = value;
      }
    }]);

    return BaseResource;
  }(SchemaResource);

  var __defProp$7$1 = Object.defineProperty;
  var __getOwnPropDesc$7$1 = Object.getOwnPropertyDescriptor;

  var __decorate$7$1 = function __decorate$7(decorators, target, key, kind) {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$7$1(target, key) : target;

    for (var i = decorators.length - 1, decorator; i >= 0; i--) {
      if (decorator = decorators[i]) result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    }

    if (kind && result) __defProp$7$1(target, key, result);
    return result;
  };

  var AbilityManager = /*#__PURE__*/function () {
    function AbilityManager(oasis) {
      _classCallCheck(this, AbilityManager);

      this.oasis = oasis;
      this.abilityMap = {};
    }

    _createClass(AbilityManager, [{
      key: "add",
      value: function add(abilityConfig) {
        var type = abilityConfig.type,
            nodeId = abilityConfig.node,
            props = abilityConfig.props,
            id = abilityConfig.id,
            index = abilityConfig.index;
        var node = this.oasis.nodeManager.get(nodeId);
        var AbilityConstructor = this.getCompConstructor(type);

        if (!AbilityConstructor) {
          Logger.error("".concat(type, " abiltiy is not defined"));
          return;
        }

        var abilityProps = this.mixPropsToExplicitProps(props);
        var ability = node.addComponent(AbilityConstructor);
        var enabled = abilityProps.enabled;

        if (enabled !== void 0) {
          ability.enabled = enabled;
        }

        if (type === "Model" || type === "GLTFModel" || type === "Particle") {
          ability.init(abilityProps);
        } else {
          for (var k in abilityProps) {
            if (abilityProps[k] !== null) {
              ability[k] = abilityProps[k];
            }
          }
        }

        var abilityArray = node._components;
        var currentIndex = abilityArray.length - 1;
        switchElementsIndex(abilityArray, currentIndex, index);
        ability.id = id;
        this.abilityMap[id] = ability;
        return ability;
      }
    }, {
      key: "update",
      value: function update(id, key, value) {
        if (this.get(id).constructor.name === "Model") {
          if (value && this.checkIsAsset(value)) {
            this.get(id).setProp(key, this.oasis.resourceManager.get(value.id).resource);
          } else {
            this.get(id).setProp(key, value);
          }
        } else {
          if (value && this.checkIsAsset(value)) {
            this.get(id)[key] = this.oasis.resourceManager.get(value.id).resource;
          } else {
            this.get(id)[key] = value;
          }
        }

        return {
          id: id,
          key: key,
          value: value
        };
      }
    }, {
      key: "get",
      value: function get(id) {
        return this.abilityMap[id];
      }
    }, {
      key: "delete",
      value: function _delete(id) {
        var ability = this.abilityMap[id];
        ability.destroy();
        delete this.abilityMap[id];
        return id;
      }
    }, {
      key: "getCompConstructor",
      value: function getCompConstructor(type) {
        var splits = type.split(".");

        if (splits[0] === "script") {
          return scriptAbility[splits[1]];
        }

        var constructor = Parser._components["o3"][type];

        if (!constructor) {
          throw new Error("".concat(type, " is not defined"));
        }

        return constructor;
      }
    }, {
      key: "mixPropsToExplicitProps",
      value: function mixPropsToExplicitProps(props) {
        var explicitProps = _objectSpread2({}, props);

        for (var k in props) {
          var prop = props[k];

          if (prop && this.checkIsAsset(prop)) {
            var res = this.oasis.resourceManager.get(prop.id);

            if (res) {
              explicitProps[k] = res.resource;
            } else {
              explicitProps[k] = null;
              Logger.warn("AbilityManager: can't get asset \"".concat(k, "\", which id is ").concat(prop.id));
            }
          }
        }

        return explicitProps;
      }
    }, {
      key: "checkIsAsset",
      value: function checkIsAsset(prop) {
        return prop.type === "asset";
      }
    }]);

    return AbilityManager;
  }();

  __decorate$7$1([pluginHook({
    after: "abilityAdded",
    before: "beforeAbilityAdded"
  })], AbilityManager.prototype, "add", 1);

  __decorate$7$1([pluginHook({
    before: "beforeAbilityUpdated",
    after: "abilityUpdated"
  })], AbilityManager.prototype, "update", 1);

  __decorate$7$1([pluginHook({
    after: "abilityDeleted",
    before: "beforeAbilityDeleted"
  })], AbilityManager.prototype, "delete", 1);

  var __defProp$8$1 = Object.defineProperty;
  var __getOwnPropDesc$8$1 = Object.getOwnPropertyDescriptor;

  var __decorate$8$1 = function __decorate$8(decorators, target, key, kind) {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$8$1(target, key) : target;

    for (var i = decorators.length - 1, decorator; i >= 0; i--) {
      if (decorator = decorators[i]) result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    }

    if (kind && result) __defProp$8$1(target, key, result);
    return result;
  };

  var NodeManager = /*#__PURE__*/function () {
    function NodeManager(oasis) {
      _classCallCheck(this, NodeManager);

      this.oasis = oasis;
      this.nodeMap = {};
      this.root = new Entity(this.oasis.engine, "root");
    }

    _createClass(NodeManager, [{
      key: "addRootEntity",
      value: function addRootEntity() {
        this.oasis.engine.sceneManager.activeScene.addRootEntity(this.root);
      }
    }, {
      key: "add",
      value: function add(nodeConfig) {
        this.create(nodeConfig);
        this.append(nodeConfig.id, nodeConfig.parent, nodeConfig.index);
        return this.get(nodeConfig.id);
      }
    }, {
      key: "update",
      value: function update(id, key, value) {
        this.get(id)[key] = value;
        return {
          id: id,
          key: key,
          value: value
        };
      }
    }, {
      key: "get",
      value: function get(id) {
        return this.nodeMap[id];
      }
    }, {
      key: "reset",
      value: function reset() {
        this.nodeMap = {};
      }
    }, {
      key: "delete",
      value: function _delete(id) {
        this.nodeMap[id].destroy();
        delete this.nodeMap[id];
      }
    }, {
      key: "create",
      value: function create(nodeConfig) {
        var isActive = nodeConfig.isActive,
            position = nodeConfig.position,
            rotation = nodeConfig.rotation,
            scale = nodeConfig.scale,
            id = nodeConfig.id,
            name = nodeConfig.name;
        var entity = new Entity(this.oasis.engine, name);
        entity.isActive = isActive;
        entity.transform.position = new Vector3(position[0], position[1], position[2]);
        entity.transform.rotation = new Vector3(rotation[0], rotation[1], rotation[2]);
        entity.transform.scale = new Vector3(scale[0], scale[1], scale[2]);
        entity.id = id;
        this.nodeMap[id] = entity;
        return entity;
      }
    }, {
      key: "append",
      value: function append(childId, parentId, index) {
        var child = this.nodeMap[childId];
        var parent = this.nodeMap[parentId] || this.root;
        parent.addChild(child);
        var children = parent._children;
        var currentIndex = children.length - 1;
        switchElementsIndex(children, currentIndex, index);
      }
    }]);

    return NodeManager;
  }();

  __decorate$8$1([pluginHook({
    after: "nodeAdded"
  })], NodeManager.prototype, "add", 1);

  __decorate$8$1([pluginHook({
    before: "beforeNodeUpdated",
    after: "nodeUpdated"
  })], NodeManager.prototype, "update", 1);

  __decorate$8$1([pluginHook({
    before: "beforeNodeDeleted"
  })], NodeManager.prototype, "delete", 1);

  var __defProp$9$1 = Object.defineProperty;
  var __getOwnPropDesc$9$1 = Object.getOwnPropertyDescriptor;

  var __decorate$9$1 = function __decorate$9(decorators, target, key, kind) {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$9$1(target, key) : target;

    for (var i = decorators.length - 1, decorator; i >= 0; i--) {
      if (decorator = decorators[i]) result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    }

    if (kind && result) __defProp$9$1(target, key, result);
    return result;
  };

  var RESOURCE_CLASS = {
    script: ScriptResource,
    gltf: GLTFResource$1,
    texture: TextureResource,
    cubeTexture: TextureCubeMapResource,
    PBRMaterial: PBRMaterialResource,
    PBRSpecularMaterial: PBRMaterialResource,
    unlitMaterial: PBRMaterialResource,
    ShaderMaterial: ShaderMaterialResource,
    BlinnPhongMaterial: BlinnPhongMaterialResource,
    base: BaseResource
  };
  var RESOURCE_TYPE = new Map();

  for (var key in RESOURCE_CLASS) {
    if (RESOURCE_CLASS.hasOwnProperty(key)) {
      var element = RESOURCE_CLASS[key];

      if (element === PBRMaterialResource) {
        RESOURCE_TYPE.set(element, "PBRMaterial");
      } else {
        RESOURCE_TYPE.set(element, key);
      }
    }
  }

  var resourceFactory = {
    createResource: function createResource(resourceManager, type) {
      return new RESOURCE_CLASS[type](resourceManager);
    }
  };

  function registerResource(type, resource) {
    if (!RESOURCE_CLASS.hasOwnProperty(type)) {
      RESOURCE_CLASS[type] = resource;
      RESOURCE_TYPE.set(resource, type);
    }
  }

  var SchemaResourceManager = /*#__PURE__*/function () {
    function SchemaResourceManager(oasis) {
      _classCallCheck(this, SchemaResourceManager);

      this.oasis = oasis;
      this.resourceMap = {};
      this.resourceIdMap = new WeakMap();
      this.maxId = 0;
      this.engineResourceManager = this.oasis.engine.resourceManager;
    }

    _createClass(SchemaResourceManager, [{
      key: "load",
      value: function load(asset) {
        var _this26 = this;

        var resource = resourceFactory.createResource(this, asset.type);
        var loadPromise = resource.load(this.oasis.engine.resourceManager, asset, this.oasis);
        this.maxId = Math.max(+asset.id, this.maxId);
        loadPromise.then(function () {
          _this26.resourceMap[asset.id] = resource;

          _this26.resourceIdMap.set(resource, asset.id);
        });
        return loadPromise;
      }
    }, {
      key: "add",
      value: function add(asset) {
        var _this27 = this;

        var resource = resourceFactory.createResource(this, asset.type);
        return new Promise(function (resolve) {
          resource.loadWithAttachedResources(_this27.oasis.engine.resourceManager, asset, _this27.oasis).then(function (result) {
            resolve(_this27.getAddResourceResult(result.resources, result.structure));
          });
        });
      }
    }, {
      key: "remove",
      value: function remove(id) {
        var _this28 = this;

        return new Promise(function (resolve) {
          var resource = _this28.resourceMap[id];
          var result = [id];
          var hasAttachedResource = false;
          delete _this28.resourceMap[id];

          if (resource) {
            var attached = resource.attachedResources;

            for (var index = 0; index < attached.length; index++) {
              var attachedResource = attached[index];

              var attachedResourceId = _this28.resourceIdMap.get(attachedResource);

              if (attachedResourceId) {
                hasAttachedResource = true;

                _this28.remove(attachedResourceId).then(function (attachedResourceRemoveResult) {
                  result.push.apply(result, _toConsumableArray(attachedResourceRemoveResult));
                  resolve(result);
                });
              }
            }
          }

          if (!hasAttachedResource) {
            resolve(result);
          }
        });
      }
    }, {
      key: "update",
      value: function update(id, key, value) {
        var resource = this.get(id);

        if (resource) {
          resource.update(key, value);
        }

        return {
          resource: resource,
          id: id,
          key: key,
          value: value
        };
      }
    }, {
      key: "updateMeta",
      value: function updateMeta(id, key, value) {
        var resource = this.get(id);

        if (resource) {
          resource.updateMeta(key, value);
        }
      }
    }, {
      key: "get",
      value: function get(id) {
        return this.resourceMap[id];
      }
    }, {
      key: "getAll",
      value: function getAll() {
        return ObjectValues(this.resourceMap);
      }
    }, {
      key: "getAddResourceResult",
      value: function getAddResourceResult(resources2, structure) {
        var _this29 = this;

        var addResourceResult = {};
        var resource = resources2[structure.index];
        var id = "".concat(++this.maxId);
        this.resourceMap[id] = resource;
        this.resourceIdMap.set(resource, id);
        addResourceResult.id = this.maxId;
        addResourceResult.type = RESOURCE_TYPE.get(resource.constructor);
        addResourceResult.meta = resource.meta;
        addResourceResult.props = {};

        for (var _key4 in structure.props) {
          if (structure.props.hasOwnProperty(_key4)) {
            var _element = structure.props[_key4];

            if (_element) {
              if (Array.isArray(_element)) {
                addResourceResult.props[_key4] = _element.map(function (child) {
                  return _this29.getAddResourceResult(resources2, child);
                });
              } else {
                addResourceResult.props[_key4] = this.getAddResourceResult(resources2, _element);
              }
            }
          }
        }

        return addResourceResult;
      }
    }, {
      key: "isLocal",
      get: function get() {
        return this.oasis.options.local;
      }
    }, {
      key: "useCompressedTexture",
      get: function get() {
        var _this$oasis$options$u;

        return (_this$oasis$options$u = this.oasis.options.useCompressedTexture) !== null && _this$oasis$options$u !== void 0 ? _this$oasis$options$u : true;
      }
    }]);

    return SchemaResourceManager;
  }();

  __decorate$9$1([pluginHook({
    before: "beforeResourceRemove"
  })], SchemaResourceManager.prototype, "remove", 1);

  __decorate$9$1([pluginHook({
    after: "resourceUpdated",
    before: "beforeResourceUpdate"
  })], SchemaResourceManager.prototype, "update", 1);

  var __defProp$a$1 = Object.defineProperty;
  var __getOwnPropDesc$a$1 = Object.getOwnPropertyDescriptor;

  var __decorate$a$1 = function __decorate$a(decorators, target, key, kind) {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$a$1(target, key) : target;

    for (var i = decorators.length - 1, decorator; i >= 0; i--) {
      if (decorator = decorators[i]) result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    }

    if (kind && result) __defProp$a$1(target, key, result);
    return result;
  };

  var Oasis = /*#__PURE__*/function (_EventDispatcher) {
    _inherits(Oasis, _EventDispatcher);

    var _super18 = _createSuper(Oasis);

    function Oasis(_options, pluginManager) {
      var _options$scripts;

      var _this30;

      _classCallCheck(this, Oasis);

      _this30 = _super18.call(this, _options.engine);
      _this30._options = _options;
      _this30.pluginManager = pluginManager;
      _this30.engine = null;
      _this30.oasis = _assertThisInitialized(_this30);
      _this30.engine = _options.engine;

      _this30.resetFeature();

      _this30.schema = _options.config;
      _this30.timeout = _options.timeout;
      _options.scripts = (_options$scripts = _options.scripts) !== null && _options$scripts !== void 0 ? _options$scripts : {};
      _this30.nodeManager = new NodeManager(_assertThisInitialized(_this30));
      _this30.abilityManager = new AbilityManager(_assertThisInitialized(_this30));
      _this30.nodeManager.add = _this30.nodeManager.add.bind(_this30.nodeManager);
      _this30.abilityManager.add = _this30.abilityManager.add.bind(_this30.abilityManager);
      _this30.resourceManager = new SchemaResourceManager(_assertThisInitialized(_this30));

      if (_options.fps) {
        _this30.engine.targetFrameRate = _options.fps;
        _this30.engine.vSyncCount = 0;
      }

      return _this30;
    }

    _createClass(Oasis, [{
      key: "updateConfig",
      value: function updateConfig(config) {
        this.schema = config;
        this.init();
      }
    }, {
      key: "init",
      value: function init() {
        var _this31 = this;

        return this.loadResources().then(function () {
          _this31.bindResources();

          _this31.parseEntities();

          _this31.parseNodeAbilities();

          _this31.attach();

          _this31.nodeManager.addRootEntity();

          _this31.pluginManager.boot(_this31);
        });
      }
    }, {
      key: "loadResources",
      value: function loadResources() {
        var _this32 = this;

        var _this$schema$assets = this.schema.assets,
            assets = _this$schema$assets === void 0 ? {} : _this$schema$assets;
        var loadingPromises = ObjectValues(assets).filter(function (asset) {
          if (RESOURCE_CLASS[asset.type]) {
            return true;
          }

          console.warn("".concat(asset.type, " loader is not defined. the ").concat(asset.type, " type will be ignored."));
          return false;
        }).map(function (asset) {
          return _this32.resourceManager.load(asset);
        });
        return Promise.all(loadingPromises);
      }
    }, {
      key: "bindResources",
      value: function bindResources() {
        this.resourceManager.getAll().forEach(function (resource) {
          resource.bind();
        });
      }
    }, {
      key: "parseEntities",
      value: function parseEntities() {
        var nodes = this.schema.nodes;
        var indices = this.bfsNodes();
        indices.map(function (index) {
          return nodes[index];
        }).forEach(this.nodeManager.add);
      }
    }, {
      key: "parseNodeAbilities",
      value: function parseNodeAbilities() {
        var abilities = this.schema.abilities;
        Object.keys(abilities).map(function (id) {
          return _objectSpread2({
            id: id
          }, abilities[id]);
        }).forEach(this.abilityManager.add);
      }
    }, {
      key: "bfsNodes",
      value: function bfsNodes() {
        var nodes = this.schema.nodes;
        var roots = ObjectValues(nodes).filter(function (node) {
          return !nodes[node.parent];
        }).map(function (node) {
          return node.id;
        });
        var result = [];

        var traverseChildren = function traverseChildren(roots2) {
          result = result.concat(roots2);
          roots2.forEach(function (id) {
            var children = nodes[id].children;
            children && traverseChildren(children);
          });
        };

        traverseChildren(roots);
        return result;
      }
    }, {
      key: "resetFeature",
      value: function resetFeature() {
        var scene = this.engine.sceneManager.activeScene;
        scene.features.splice(2, 1);
        scene.features.splice(3, 1);
        scene.hasFogFeature = void 0;
        scene.getFogMacro = void 0;
        scene.bindFogToMaterial = void 0;
      }
    }, {
      key: "attach",
      value: function attach() {
        this.resourceManager.getAll().forEach(function (resource) {
          resource.attach();
        });
      }
    }, {
      key: "canvas",
      get: function get() {
        return this._options.canvas;
      }
    }, {
      key: "options",
      get: function get() {
        return this._options;
      }
    }], [{
      key: "create",
      value: function create(options, pluginManager) {
        var oasis = new Oasis(options, pluginManager);
        return oasis.init().then(function () {
          options.autoPlay && oasis.engine.run();
          return oasis;
        });
      }
    }]);

    return Oasis;
  }(EventDispatcher);

  __decorate$a$1([pluginHook({
    after: "schemaParsed"
  })], Oasis.prototype, "init", 1);

  var _vec3Attribute = ["color", "center", "size", "__position", "__positionRandomness", "__color", "__velocity", "__velocityRandomness", "__acceleration", "__accelerationRandomness", "_center"];

  function compatibleToV2(config) {
    var _config$abilities = config.abilities,
        abilities = _config$abilities === void 0 ? {} : _config$abilities,
        _config$assets = config.assets,
        assets = _config$assets === void 0 ? {} : _config$assets;
    var ids = Object.keys(abilities);
    var assetKeys = Object.keys(assets);

    for (var i = 0, l = ids.length; i < l; ++i) {
      handleProps(abilities[ids[i]].props);
    }

    for (var _i8 = 0, _l = assetKeys.length; _i8 < _l; ++_i8) {
      handleAssets(assets[assetKeys[_i8]].props);
    }

    return config;
  }

  function handleProps(props) {
    var keys = Object.keys(props);

    for (var i = 0, l = keys.length; i < l; ++i) {
      var k = keys[i];
      var v = props[k];

      if (v !== null && _typeof(v) === "object" && v.length > 1) {
        if (k === "backgroundColor" || k === "tintColor") {
          props[k] = new Vector4(v[0], v[1], v[2], v[3]);
        } else if (_vec3Attribute.indexOf(k) !== -1) {
          props[k] = new Vector3(v[0], v[1], v[2]);
        }
      }
    }
  }

  function handleAssets() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    if (!props) {
      return;
    }

    var keys = Object.keys(props);

    for (var i = 0, l = keys.length; i < l; i++) {
      var _key5 = keys[i];
      var value = props[_key5];

      if (_key5 === "newMaterial" || _key5 === "blendFuncSeparate" || _key5 === "scripts") {
        continue;
      }

      switch (value === null || value === void 0 ? void 0 : value.length) {
        case 2:
          props[_key5] = new Vector2(value[0], value[1]);
          break;

        case 3:
          props[_key5] = new Vector3(value[0], value[1], value[2]);
          break;

        case 4:
          props[_key5] = new Vector4(value[0], value[1], value[2], value[3]);
          break;
      }
    }
  }

  var CURRENT_SCHEMA_VERSION = 3;

  var Parser = /*#__PURE__*/function () {
    function Parser() {
      _classCallCheck(this, Parser);

      this.pluginManager = new PluginManager();
    }

    _createClass(Parser, [{
      key: "parse",
      value: function parse(options) {
        var _options$config;

        if ((options === null || options === void 0 ? void 0 : (_options$config = options.config) === null || _options$config === void 0 ? void 0 : _options$config.version) !== CURRENT_SCHEMA_VERSION) {
          var _options$config2;

          console.warn("schema-parser: schema version \"".concat(options === null || options === void 0 ? void 0 : (_options$config2 = options.config) === null || _options$config2 === void 0 ? void 0 : _options$config2.version, "\" is out of date, please re-pull the latest version (version ").concat(CURRENT_SCHEMA_VERSION, ") of the schema"));
        }

        compatibleToV2(options.config);
        return Oasis.create(options, this.pluginManager);
      }
    }, {
      key: "register",
      value: function register(plugin) {
        this.pluginManager.register(plugin);
      }
    }, {
      key: "resetPlugins",
      value: function resetPlugins() {
        this.pluginManager.reset();
      }
    }], [{
      key: "create",
      value: function create() {
        var parser2 = new Parser();
        return parser2;
      }
    }, {
      key: "registerComponents",
      value: function registerComponents(namespace, components) {
        if (!this._components[namespace]) {
          this._components[namespace] = {};
        }

        _extends(this._components[namespace], components);
      }
    }]);

    return Parser;
  }();

  Parser._components = {};
  var parser = Parser.create();

  var programList = [];

  function addLineNum(str) {
    var lines = str.split("\n");
    var limitLength = (lines.length + 1).toString().length + 6;
    var prefix;
    return lines.map(function (line, index) {
      prefix = "0:".concat(index + 1);
      if (prefix.length >= limitLength) return prefix.substring(0, limitLength) + line;

      for (var i = 0; i < limitLength - prefix.length; i++) {
        prefix += " ";
      }

      return prefix + line;
    }).join("\n");
  }

  var GLShaderProgram = /*#__PURE__*/function () {
    function GLShaderProgram(gl, _engine) {
      _classCallCheck(this, GLShaderProgram);

      this._engine = _engine;
      this._gl = gl;
      this._vertexShader = null;
      this._fragmentShader = null;
      this._vertexShaderSource = null;
      this._fragmentShaderSource = null;
      this._program = null;
      this._attributeCache = {};
      this._uniformCache = {};
    }

    _createClass(GLShaderProgram, [{
      key: "createFromSource",
      value: function createFromSource(vertexSource, fragmentSource, attribLocSet) {
        var gl = this._gl;

        var vertexShader = this._compileShader(gl.VERTEX_SHADER, vertexSource);

        if (!vertexShader) {
          return false;
        }

        var fragmentShader = this._compileShader(gl.FRAGMENT_SHADER, fragmentSource);

        if (!fragmentShader) {
          return false;
        }

        var program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);

        if (attribLocSet) {
          for (var attribName in attribLocSet) {
            gl.bindAttribLocation(program, attribLocSet[attribName], attribName);
          }
        }

        gl.linkProgram(program);
        gl.validateProgram(program);

        if (gl.isContextLost()) {
          Logger.error("Contex lost while linking program.");
          gl.deleteShader(vertexShader);
          gl.deleteShader(fragmentShader);
          return null;
        }

        if (!gl.getProgramParameter(program, gl.LINK_STATUS) && !gl.isContextLost()) {
          var msg = "Could not link WebGL program. \n" + gl.getProgramInfoLog(program);
          console.error(msg);

          this._engine.dispatch("linkProgramError", msg);

          gl.deleteProgram(program);
          return false;
        }

        this._vertexShader = vertexShader;
        this._fragmentShader = fragmentShader;
        this._vertexShaderSource = vertexSource;
        this._fragmentShaderSource = fragmentSource;
        this._program = program;
        return true;
      }
    }, {
      key: "_compileShader",
      value: function _compileShader(shaderType, shaderSource) {
        var gl = this._gl;
        var shader = gl.createShader(shaderType);
        gl.shaderSource(shader, shaderSource);
        gl.compileShader(shader);

        if (gl.isContextLost()) {
          Logger.error("Contex lost while compiling shader.");
          gl.deleteShader(shader);
          return null;
        }

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS) && !gl.isContextLost()) {
          var msg = "Could not compile WebGL shader.\n".concat(addLineNum(shaderSource), "\n").concat(gl.getShaderInfoLog(shader));
          console.error(msg);

          this._engine.dispatch("compileShaderError", msg);

          gl.deleteShader(shader);
          return null;
        }

        return shader;
      }
    }, {
      key: "getAttribLocation",
      value: function getAttribLocation(glProgram, name) {
        if (this._attributeCache.hasOwnProperty(name)) {
          return this._attributeCache[name];
        } else {
          return this._attributeCache[name] = this._gl.getAttribLocation(glProgram, name);
        }
      }
    }, {
      key: "getUniformLocation",
      value: function getUniformLocation(glProgram, name) {
        if (this._uniformCache.hasOwnProperty(name)) {
          return this._uniformCache[name];
        } else {
          return this._uniformCache[name] = this._gl.getUniformLocation(glProgram, name);
        }
      }
    }, {
      key: "finalize",
      value: function finalize() {
        var gl = this._gl;

        if (this._vertexShader) {
          gl.deleteShader(this._vertexShader);
        }

        if (this._fragmentShader) {
          gl.deleteShader(this._fragmentShader);
        }

        if (this._program) {
          gl.deleteProgram(this._program);
        }

        this._vertexShader = null;
        this._fragmentShader = null;
        this._vertexShaderSource = null;
        this._fragmentShaderSource = null;
        this._program = null;
        this._attributeCache = {};
        this._uniformCache = {};
        GLShaderProgram.releaseProgram(this);
      }
    }, {
      key: "program",
      get: function get() {
        return this._program;
      }
    }], [{
      key: "requireProgram",
      value: function requireProgram(tech, gl, engine) {
        var program = null;
        programList.some(function (p) {
          if (p._gl === gl && p._vertexShaderSource === tech.vertexShader && p._fragmentShaderSource === tech.fragmentShader) {
            program = p;
            return true;
          }
        });

        if (!program) {
          program = new GLShaderProgram(gl, engine);
          var sucess = program.createFromSource(tech.vertexShader, tech.fragmentShader, tech.attribLocSet);
          if (!sucess) return null;
          programList.push(program);
        }

        return program;
      }
    }, {
      key: "releaseProgram",
      value: function releaseProgram(program) {
        var index = programList.indexOf(program);

        if (index !== -1) {
          programList.splice(index, 1);
        }
      }
    }]);

    return GLShaderProgram;
  }();

  var GLAsset = /*#__PURE__*/function () {
    function GLAsset(rhi, asset) {
      _classCallCheck(this, GLAsset);

      this._rhi = rhi;
      this.asset = asset;
    }

    _createClass(GLAsset, [{
      key: "rhi",
      get: function get() {
        return this._rhi;
      }
    }]);

    return GLAsset;
  }();

  var GLTechnique = /*#__PURE__*/function (_GLAsset) {
    _inherits(GLTechnique, _GLAsset);

    var _super = _createSuper(GLTechnique);

    function GLTechnique(rhi, tech) {
      var _this;

      _classCallCheck(this, GLTechnique);

      _this = _super.call(this, rhi, tech);
      _this.cacheID = ++GLTechnique.cacheCounter;
      _this._tech = tech;
      _this._activeTextureCount = 0;
      var gl = rhi.gl;
      _this._program = GLShaderProgram.requireProgram(tech, gl, rhi._engine);

      if (_this._program) {
        _this.valid = true;
        var glProgram = _this._program.program;
        _this._attributes = {};
        var attributes = tech.attributes;

        for (var name in attributes) {
          _this._attributes[name] = {
            name: name,
            semantic: attributes[name].semantic,
            location: _this._program.getAttribLocation(glProgram, name)
          };
        }

        _this._uniforms = {};
        var uniforms = tech.uniforms;

        for (var _name2 in uniforms) {
          var loc = _this._program.getUniformLocation(glProgram, _name2);

          if (loc !== null) {
            _this._uniforms[_name2] = {
              name: _name2,
              location: loc
            };
          }
        }
      } else {
        _this.valid = false;
      }

      return _this;
    }

    _createClass(GLTechnique, [{
      key: "finalize",
      value: function finalize(forceDispose) {
        if (this._program && forceDispose) {
          this._program = null;
        }
      }
    }, {
      key: "begin",
      value: function begin(mtl) {
        var gl = this.rhi.gl;
        var glProgram = this._program.program;
        this._activeTextureCount = 0;
        gl.useProgram(glProgram);
        var uniforms = this._uniforms;
        var assetUniforms = this._tech.uniforms;

        for (var name in assetUniforms) {
          if (uniforms.hasOwnProperty(name)) {
            var value = mtl.getValue(name);
            value != null && this._uploadUniformValue(assetUniforms[name], uniforms[name].location, value);
          }
        }

        var stateManager = this.rhi.renderStates;

        if (this._tech.states) {
          stateManager.pushStateBlock(this._tech.name);

          this._applyStates(stateManager);
        }
      }
    }, {
      key: "end",
      value: function end() {
        if (this._tech.states) {
          var stateManager = this.rhi.renderStates;
          stateManager.popStateBlock();
        }
      }
    }, {
      key: "_applyStates",
      value: function _applyStates(stateManager) {
        var states = this._tech.states;
        var enable = states.enable;

        if (enable) {
          for (var i = 0, len = enable.length; i < len; i++) {
            stateManager.enable(enable[i]);
          }
        }

        var disable = states.disable;

        if (disable) {
          for (var _i = 0, _len = disable.length; _i < _len; _i++) {
            stateManager.disable(disable[_i]);
          }
        }

        var functions = states.functions;

        if (functions) {
          for (var name in functions) {
            var args = Array.isArray(functions[name]) ? functions[name] : [functions[name]];
            var func = stateManager[name];
            func.apply(stateManager, args);
          }
        }
      }
    }, {
      key: "_uploadUniformValue",
      value: function _uploadUniformValue(uniform, location, value) {
        var gl = this.rhi.gl;

        switch (uniform.type) {
          case exports.DataType.FLOAT:
            if (value.length) gl.uniform1fv(location, value);else gl.uniform1f(location, value);
            break;

          case exports.DataType.FLOAT_ARRAY:
            gl.uniform1fv(location, value);
            break;

          case exports.DataType.INT:
            if (value.length) gl.uniform1iv(location, value);else gl.uniform1i(location, value);
            break;

          case exports.DataType.INT_ARRAY:
            gl.uniform1iv(location, value);
            break;

          case exports.DataType.FLOAT_VEC2:
            gl.uniform2f(location, value.x, value.y);
            break;

          case exports.DataType.FLOAT_VEC2_ARRAY:
            gl.uniform2fv(location, value);
            break;

          case exports.DataType.FLOAT_VEC3:
            gl.uniform3f(location, value.x, value.y, value.z);
            break;

          case exports.DataType.FLOAT_VEC3_ARRAY:
            gl.uniform3fv(location, value);
            break;

          case exports.DataType.FLOAT_VEC4:
            gl.uniform4f(location, value.x, value.y, value.z, value.w);
            break;

          case exports.DataType.FLOAT_VEC4_ARRAY:
            gl.uniform4fv(location, value);
            break;

          case exports.DataType.INT_VEC2:
            gl.uniform2i(location, value.x, value.y);
            break;

          case exports.DataType.INT_VEC2_ARRAY:
            gl.uniform2iv(location, value);
            break;

          case exports.DataType.INT_VEC3:
            gl.uniform3i(location, value.x, value.y, value.z);
            break;

          case exports.DataType.INT_VEC3_ARRAY:
            gl.uniform3iv(location, value);
            break;

          case exports.DataType.INT_VEC4:
            gl.uniform4i(location, value.x, value.y, value.z, value.w);
            break;

          case exports.DataType.INT_VEC4_ARRAY:
            gl.uniform4iv(location, value);
            break;

          case exports.DataType.FLOAT_MAT2:
            gl.uniformMatrix2fv(location, false, value.elements);
            break;

          case exports.DataType.FLOAT_MAT2_ARRAY:
            gl.uniformMatrix2fv(location, false, value);
            break;

          case exports.DataType.FLOAT_MAT3:
            gl.uniformMatrix3fv(location, false, value.elements);
            break;

          case exports.DataType.FLOAT_MAT3_ARRAY:
            gl.uniformMatrix3fv(location, false, value);
            break;

          case exports.DataType.FLOAT_MAT4:
            gl.uniformMatrix4fv(location, false, value.elements);
            break;

          case exports.DataType.FLOAT_MAT4_ARRAY:
            gl.uniformMatrix4fv(location, false, value);
            break;

          case exports.DataType.SAMPLER_2D:
            {
              this._uploadTexture(value, location);

              break;
            }

          case exports.DataType.SAMPLER_2D_ARRAY:
            {
              this._uploadTextures(value, location);

              break;
            }

          case exports.DataType.SAMPLER_CUBE:
            {
              this._uploadTexture(value, location);

              break;
            }

          case exports.DataType.SAMPLER_CUBE_ARRAY:
            {
              this._uploadTextures(value, location);

              break;
            }

          default:
            Logger.warn("UNKNOWN uniform type: " + uniform.type);
            break;
        }
      }
    }, {
      key: "_uploadTexture",
      value: function _uploadTexture(texture, location) {
        if (texture) {
          var gl = this.rhi.gl;
          var index = this._activeTextureCount++;
          gl.activeTexture(gl.TEXTURE0 + index);
          gl.bindTexture(texture._target, texture._glTexture);
          gl.uniform1i(location, index);
        }
      }
    }, {
      key: "_uploadTextures",
      value: function _uploadTextures(textures, location) {
        if (!this._tempSamplerArray || this._tempSamplerArray.length !== textures.length) {
          this._tempSamplerArray = new Int32Array(textures.length);
        }

        var gl = this.rhi.gl;

        for (var i = 0, length = textures.length; i < length; i++) {
          var texture = textures[i];

          if (texture) {
            var index = this._activeTextureCount++;
            gl.activeTexture(gl.TEXTURE0 + index);
            gl.bindTexture(texture._target, texture._glTexture);
            this._tempSamplerArray[i] = index;
          } else {
            this._tempSamplerArray[i] = -1;
          }
        }

        gl.uniform1iv(location, this._tempSamplerArray);
      }
    }, {
      key: "program",
      get: function get() {
        return this._program;
      }
    }, {
      key: "attributes",
      get: function get() {
        return this._attributes;
      }
    }, {
      key: "uniforms",
      get: function get() {
        return this._uniforms;
      }
    }]);

    return GLTechnique;
  }(GLAsset);

  GLTechnique.cacheCounter = 0;

  var GLTexture = /*#__PURE__*/function (_GLAsset2) {
    _inherits(GLTexture, _GLAsset2);

    var _super2 = _createSuper(GLTexture);

    function GLTexture(rhi, config, type) {
      var _this2;

      _classCallCheck(this, GLTexture);

      _this2 = _super2.call(this, rhi, config);
      _this2._gl = rhi.gl;
      _this2._glTexture = config._glTexture;
      _this2._config = config;
      _this2._type = type;
      return _this2;
    }

    _createClass(GLTexture, [{
      key: "activeBinding",
      value: function activeBinding(textureIndex) {
        var gl = this._gl;
        gl.activeTexture(gl.TEXTURE0 + textureIndex);
        gl.bindTexture(this._type, this._glTexture);
      }
    }, {
      key: "finalize",
      value: function finalize() {}
    }, {
      key: "glTexture",
      get: function get() {
        return this._glTexture;
      }
    }]);

    return GLTexture;
  }(GLAsset);

  var WebCanvas = /*#__PURE__*/function () {
    function WebCanvas(webCanvas) {
      _classCallCheck(this, WebCanvas);

      this._scale = new Vector2();
      var width = webCanvas.width;
      var height = webCanvas.height;
      this._webCanvas = webCanvas;
      this._width = width;
      this._height = height;
    }

    _createClass(WebCanvas, [{
      key: "resizeByClientSize",
      value: function resizeByClientSize() {
        var pixelRatio = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.devicePixelRatio;
        var webCanvas = this._webCanvas;

        if (webCanvas instanceof HTMLCanvasElement) {
          var width = webCanvas.clientWidth;
          var height = webCanvas.clientHeight;
          this.width = width * pixelRatio;
          this.height = height * pixelRatio;
        }
      }
    }, {
      key: "setScale",
      value: function setScale(x, y) {
        this._scale.setValue(x, y);

        this.scale = this._scale;
      }
    }, {
      key: "width",
      get: function get() {
        return this._width;
      },
      set: function set(value) {
        if (this._width !== value) {
          this._webCanvas.width = value;
          this._width = value;
        }
      }
    }, {
      key: "height",
      get: function get() {
        return this._height;
      },
      set: function set(value) {
        if (this._height !== value) {
          this._webCanvas.height = value;
          this._height = value;
        }
      }
    }, {
      key: "scale",
      get: function get() {
        var webCanvas = this._webCanvas;

        if (webCanvas instanceof HTMLCanvasElement) {
          this._scale.setValue(webCanvas.clientWidth * devicePixelRatio / webCanvas.width, webCanvas.clientHeight * devicePixelRatio / webCanvas.height);
        }

        return this._scale;
      },
      set: function set(value) {
        var webCanvas = this._webCanvas;

        if (webCanvas instanceof HTMLCanvasElement) {
          webCanvas.style.transformOrigin = "left top";
          webCanvas.style.transform = "scale(".concat(value.x, ", ").concat(value.y, ")");
        }
      }
    }]);

    return WebCanvas;
  }();

  var GLAssetsCache = /*#__PURE__*/function () {
    function GLAssetsCache(rhi) {
      var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, GLAssetsCache);

      this._rhi = rhi;
      this._objectSet = {};
      this._checkList = [];
      this._nextID = 1;
      this._enableCollect = props.enableCollect === void 0 ? true : !!props.enableCollect;
    }

    _createClass(GLAssetsCache, [{
      key: "requireObject",
      value: function requireObject(asset, ctor) {
        var cachedObject = null;

        if (asset.cacheID) {
          cachedObject = this._objectSet[asset.cacheID];
        }

        if (!cachedObject || asset.needRecreate) {
          var cacheID = this._nextID++;
          var objectSet = this._objectSet;
          cachedObject = new ctor(this._rhi, asset);
          objectSet[cacheID] = cachedObject;
          cachedObject.cacheID = cacheID;
          cachedObject.asset = asset;
          asset.cacheID = cacheID;
          asset.needRecreate = false;

          if (this._enableCollect && asset.type === exports.InternalAssetType.Cache) {
            this._checkList.push(cachedObject);
          }
        }

        cachedObject.activeFrame = this._rhi.frameCount;
        return cachedObject;
      }
    }, {
      key: "compact",
      value: function compact() {
        if (!this._enableCollect) return;
        var currentFrame = this._rhi.frameCount;
        var checkList = this._checkList;
        var objectSet = this._objectSet;

        for (var i = checkList.length - 1; i >= 0; i--) {
          var cachedObject = checkList[i];

          if (cachedObject.activeFrame < currentFrame) {
            delete objectSet[cachedObject.cacheID];
            checkList.splice(i, 1);
            cachedObject.finalize();
          }
        }
      }
    }, {
      key: "finalize",
      value: function finalize() {
        for (var name in this._objectSet) {
          var obj = this._objectSet[name];
          obj.finalize(true);
        }

        this._objectSet = {};
        this._checkList = [];
      }
    }]);

    return GLAssetsCache;
  }();

  var GLCapability = /*#__PURE__*/function () {
    _createClass(GLCapability, [{
      key: "maxDrawBuffers",
      get: function get() {
        if (!this._maxDrawBuffers) {
          if (this.canIUse(exports.GLCapabilityType.drawBuffers)) {
            this._maxDrawBuffers = this._rhi.gl.getParameter(this._rhi.gl.MAX_DRAW_BUFFERS);
          } else {
            this._maxDrawBuffers = 1;
          }
        }

        return this._maxDrawBuffers;
      }
    }, {
      key: "maxAnisoLevel",
      get: function get() {
        if (!this._maxAnisoLevel) {
          var ext = this._rhi.requireExtension(exports.GLCapabilityType.textureFilterAnisotropic);

          this._maxAnisoLevel = ext ? this._rhi.gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;
        }

        return this._maxAnisoLevel;
      }
    }, {
      key: "maxAntiAliasing",
      get: function get() {
        if (!this._maxAntiAliasing) {
          var gl = this._rhi.gl;
          var canMSAA = this.canIUse(exports.GLCapabilityType.multipleSample);
          this._maxAntiAliasing = canMSAA ? gl.getParameter(gl.MAX_SAMPLES) : 1;
        }

        return this._maxAntiAliasing;
      }
    }, {
      key: "rhi",
      get: function get() {
        return this._rhi;
      }
    }]);

    function GLCapability(rhi) {
      _classCallCheck(this, GLCapability);

      this._rhi = rhi;
      this.capabilityList = new Map();
      this.init();
      this.compatibleAllInterface();
    }

    _createClass(GLCapability, [{
      key: "canIUse",
      value: function canIUse(capabilityType) {
        return this.capabilityList.get(capabilityType);
      }
    }, {
      key: "canIUseCompressedTextureInternalFormat",
      value: function canIUseCompressedTextureInternalFormat(internalType) {
        var RGBA_ASTC_4X4_KHR = exports.GLCompressedTextureInternalFormat.RGBA_ASTC_4X4_KHR,
            RGBA_ASTC_12X12_KHR = exports.GLCompressedTextureInternalFormat.RGBA_ASTC_12X12_KHR,
            SRGB8_ALPHA8_ASTC_4X4_KHR = exports.GLCompressedTextureInternalFormat.SRGB8_ALPHA8_ASTC_4X4_KHR,
            SRGB8_ALPHA8_ASTC_12X12_KHR = exports.GLCompressedTextureInternalFormat.SRGB8_ALPHA8_ASTC_12X12_KHR,
            RGB_ETC1_WEBGL = exports.GLCompressedTextureInternalFormat.RGB_ETC1_WEBGL,
            R11_EAC = exports.GLCompressedTextureInternalFormat.R11_EAC,
            SRGB8_ALPHA8_ETC2_EAC = exports.GLCompressedTextureInternalFormat.SRGB8_ALPHA8_ETC2_EAC,
            RGB_PVRTC_4BPPV1_IMG = exports.GLCompressedTextureInternalFormat.RGB_PVRTC_4BPPV1_IMG,
            RGBA_PVRTC_2BPPV1_IMG = exports.GLCompressedTextureInternalFormat.RGBA_PVRTC_2BPPV1_IMG,
            RGB_S3TC_DXT1_EXT = exports.GLCompressedTextureInternalFormat.RGB_S3TC_DXT1_EXT,
            RGBA_S3TC_DXT5_EXT = exports.GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT;

        if (internalType >= RGBA_ASTC_4X4_KHR && RGBA_ASTC_12X12_KHR <= RGBA_ASTC_12X12_KHR || internalType >= SRGB8_ALPHA8_ASTC_4X4_KHR && internalType <= SRGB8_ALPHA8_ASTC_12X12_KHR) {
          return this.canIUse(exports.GLCapabilityType.astc);
        } else if (internalType === RGB_ETC1_WEBGL) {
          return this.canIUse(exports.GLCapabilityType.etc1);
        } else if (internalType >= R11_EAC && internalType <= SRGB8_ALPHA8_ETC2_EAC) {
          return this.canIUse(exports.GLCapabilityType.etc);
        } else if (internalType >= RGB_PVRTC_4BPPV1_IMG && internalType <= RGBA_PVRTC_2BPPV1_IMG) {
          return this.canIUse(exports.GLCapabilityType.pvrtc);
        } else if (internalType >= RGB_S3TC_DXT1_EXT && internalType <= RGBA_S3TC_DXT5_EXT) {
          return this.canIUse(exports.GLCapabilityType.s3tc);
        }

        return false;
      }
    }, {
      key: "init",
      value: function init() {
        var cap = this.capabilityList;
        var isWebGL2 = this.rhi.isWebGL2;
        var requireExtension = this.rhi.requireExtension.bind(this.rhi);
        var standardDerivatives = exports.GLCapabilityType.standardDerivatives,
            shaderTextureLod = exports.GLCapabilityType.shaderTextureLod,
            elementIndexUint = exports.GLCapabilityType.elementIndexUint,
            depthTexture = exports.GLCapabilityType.depthTexture,
            vertexArrayObject = exports.GLCapabilityType.vertexArrayObject,
            instancedArrays = exports.GLCapabilityType.instancedArrays,
            multipleSample = exports.GLCapabilityType.multipleSample,
            drawBuffers = exports.GLCapabilityType.drawBuffers,
            astc = exports.GLCapabilityType.astc,
            astc_webkit = exports.GLCapabilityType.astc_webkit,
            etc = exports.GLCapabilityType.etc,
            etc_webkit = exports.GLCapabilityType.etc_webkit,
            etc1 = exports.GLCapabilityType.etc1,
            etc1_webkit = exports.GLCapabilityType.etc1_webkit,
            pvrtc = exports.GLCapabilityType.pvrtc,
            pvrtc_webkit = exports.GLCapabilityType.pvrtc_webkit,
            s3tc = exports.GLCapabilityType.s3tc,
            s3tc_webkit = exports.GLCapabilityType.s3tc_webkit,
            textureFloat = exports.GLCapabilityType.textureFloat,
            textureHalfFloat = exports.GLCapabilityType.textureHalfFloat,
            textureFloatLinear = exports.GLCapabilityType.textureFloatLinear,
            textureHalfFloatLinear = exports.GLCapabilityType.textureHalfFloatLinear,
            WEBGL_colorBufferFloat = exports.GLCapabilityType.WEBGL_colorBufferFloat,
            colorBufferFloat = exports.GLCapabilityType.colorBufferFloat,
            colorBufferHalfFloat = exports.GLCapabilityType.colorBufferHalfFloat,
            textureFilterAnisotropic = exports.GLCapabilityType.textureFilterAnisotropic;
        cap.set(standardDerivatives, isWebGL2 || !!requireExtension(standardDerivatives));
        cap.set(shaderTextureLod, isWebGL2 || !!requireExtension(shaderTextureLod));
        cap.set(elementIndexUint, isWebGL2 || !!requireExtension(elementIndexUint));
        cap.set(depthTexture, isWebGL2 || !!requireExtension(depthTexture));
        cap.set(vertexArrayObject, isWebGL2 || !!requireExtension(vertexArrayObject));
        cap.set(instancedArrays, isWebGL2 || !!requireExtension(instancedArrays));
        cap.set(multipleSample, isWebGL2);
        cap.set(drawBuffers, isWebGL2 || !!requireExtension(drawBuffers));
        cap.set(textureFloat, isWebGL2 || !!requireExtension(textureFloat));
        cap.set(textureHalfFloat, isWebGL2 || !!requireExtension(textureHalfFloat));
        cap.set(textureFloatLinear, !!requireExtension(textureFloatLinear));
        cap.set(textureHalfFloatLinear, isWebGL2 || !!requireExtension(textureHalfFloatLinear));
        cap.set(colorBufferFloat, isWebGL2 && !!requireExtension(colorBufferFloat) || !!requireExtension(WEBGL_colorBufferFloat));
        cap.set(colorBufferHalfFloat, isWebGL2 && !!requireExtension(colorBufferFloat) || !!requireExtension(colorBufferHalfFloat));
        cap.set(textureFilterAnisotropic, !!requireExtension(textureFilterAnisotropic));
        cap.set(astc, !!(requireExtension(astc) || requireExtension(astc_webkit)));
        cap.set(etc, !!(requireExtension(etc) || requireExtension(etc_webkit)));
        cap.set(etc1, !!(requireExtension(etc1) || requireExtension(etc1_webkit)));
        cap.set(pvrtc, !!(requireExtension(pvrtc) || requireExtension(pvrtc_webkit)));
        cap.set(s3tc, !!(requireExtension(s3tc) || requireExtension(s3tc_webkit)));
      }
    }, {
      key: "compatibleInterface",
      value: function compatibleInterface(capabilityType, flatItem) {
        var rhi = this.rhi;
        var gl = rhi.gl;
        var ext = null;

        if (ext = rhi.requireExtension(capabilityType)) {
          for (var glKey in flatItem) {
            var extensionKey = flatItem[glKey];
            var extensionVal = ext[extensionKey];

            if (extensionVal !== null && extensionVal !== void 0 && extensionVal.bind) {
              gl[glKey] = extensionVal.bind(ext);
            } else {
              gl[glKey] = extensionVal;
            }
          }
        }
      }
    }, {
      key: "compatibleAllInterface",
      value: function compatibleAllInterface() {
        var depthTexture = exports.GLCapabilityType.depthTexture,
            vertexArrayObject = exports.GLCapabilityType.vertexArrayObject,
            instancedArrays = exports.GLCapabilityType.instancedArrays,
            drawBuffers = exports.GLCapabilityType.drawBuffers,
            textureFilterAnisotropic = exports.GLCapabilityType.textureFilterAnisotropic,
            textureHalfFloat = exports.GLCapabilityType.textureHalfFloat,
            colorBufferHalfFloat = exports.GLCapabilityType.colorBufferHalfFloat,
            WEBGL_colorBufferFloat = exports.GLCapabilityType.WEBGL_colorBufferFloat;
        var isWebGL2 = this.rhi.isWebGL2;

        if (!isWebGL2) {
          this.compatibleInterface(depthTexture, {
            UNSIGNED_INT_24_8: "UNSIGNED_INT_24_8_WEBGL"
          });
          this.compatibleInterface(vertexArrayObject, {
            createVertexArray: "createVertexArrayOES",
            deleteVertexArray: "deleteVertexArrayOES",
            isVertexArray: "isVertexArrayOES",
            bindVertexArray: "bindVertexArrayOES"
          });
          this.compatibleInterface(instancedArrays, {
            drawArraysInstanced: "drawArraysInstancedANGLE",
            drawElementsInstanced: "drawElementsInstancedANGLE",
            vertexAttribDivisor: "vertexAttribDivisorANGLE"
          });
          this.compatibleInterface(drawBuffers, {
            MAX_DRAW_BUFFERS: "MAX_DRAW_BUFFERS_WEBGL"
          });
          var items = {};

          if (this.canIUse(exports.GLCapabilityType.drawBuffers)) {
            var maxDrawBuffers = this.maxDrawBuffers;

            for (var i = 0; i < maxDrawBuffers; i++) {
              i != 0 && (items["COLOR_ATTACHMENT".concat(i)] = "COLOR_ATTACHMENT".concat(i, "_WEBGL"));
              items["DRAW_BUFFER".concat(i)] = "DRAW_BUFFER".concat(i, "_WEBGL");
            }

            this.compatibleInterface(drawBuffers, _objectSpread2({
              drawBuffers: "drawBuffersWEBGL"
            }, items));
          }

          this.compatibleInterface(textureHalfFloat, {
            HAFL_FLOAT: "HALF_FLOAT_OES"
          });
          this.compatibleInterface(colorBufferHalfFloat, {
            RGBA16F: "RBGA16F_EXT"
          });
          this.compatibleInterface(WEBGL_colorBufferFloat, {
            RGBA32F: "RBGA32F_EXT"
          });
        }

        this.compatibleInterface(textureFilterAnisotropic, {
          TEXTURE_MAX_ANISOTROPY_EXT: "TEXTURE_MAX_ANISOTROPY_EXT"
        });
      }
    }, {
      key: "canIUseMoreJoints",
      get: function get() {
        return this.canIUse(exports.GLCapabilityType.textureFloat) && this.rhi.renderStates.getParameter(this.rhi.gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) > 0;
      }
    }]);

    return GLCapability;
  }();

  var GLExtensions = /*#__PURE__*/function () {
    function GLExtensions(rhi) {
      _classCallCheck(this, GLExtensions);

      this.rhi = rhi;
      this._requireResult = {};
    }

    _createClass(GLExtensions, [{
      key: "requireExtension",
      value: function requireExtension(ext) {
        if (this._requireResult[ext] !== void 0) {
          return this._requireResult[ext];
        }

        this._requireResult[ext] = this.rhi.gl.getExtension(ext);
        return this._requireResult[ext];
      }
    }]);

    return GLExtensions;
  }();

  var GLPrimitive = /*#__PURE__*/function () {
    function GLPrimitive(rhi, primitive) {
      _classCallCheck(this, GLPrimitive);

      this.vao = new Map();
      this._primitive = primitive;
      this.canUseInstancedArrays = rhi.canIUse(exports.GLCapabilityType.instancedArrays);
      this._useVao = rhi.canIUse(exports.GLCapabilityType.vertexArrayObject);
      this.gl = rhi.gl;
    }

    _createClass(GLPrimitive, [{
      key: "draw",
      value: function draw(tech, subPrimitive) {
        var gl = this.gl;
        var primitive = this._primitive;

        if (this._useVao) {
          if (!this.vao.has(tech.cacheID)) {
            this.registerVAO(tech);
          }

          var vao = this.vao.get(tech.cacheID);
          gl.bindVertexArray(vao);
        } else {
          this.bindBufferAndAttrib(tech);
        }

        var indexBufferBinding = primitive.indexBufferBinding,
            instanceCount = primitive.instanceCount,
            _glIndexType = primitive._glIndexType;
        var topology = subPrimitive.topology,
            start = subPrimitive.start,
            count = subPrimitive.count;

        if (!instanceCount) {
          if (indexBufferBinding) {
            if (this._useVao) {
              gl.drawElements(topology, count, _glIndexType, start);
            } else {
              var _nativeBuffer = indexBufferBinding.buffer._nativeBuffer;
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _nativeBuffer);
              gl.drawElements(topology, count, _glIndexType, start);
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
            }
          } else {
            gl.drawArrays(topology, start, count);
          }
        } else {
          if (this.canUseInstancedArrays) {
            if (indexBufferBinding) {
              if (this._useVao) {
                gl.drawElementsInstanced(topology, count, _glIndexType, start, instanceCount);
              } else {
                var _nativeBuffer2 = indexBufferBinding.buffer._nativeBuffer;
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _nativeBuffer2);
                gl.drawElementsInstanced(topology, count, _glIndexType, start, instanceCount);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
              }
            } else {
              gl.drawArraysInstanced(topology, start, count, instanceCount);
            }
          } else {
            Logger.error("ANGLE_instanced_arrays extension is not supported");
          }
        }

        if (this._useVao) {
          gl.bindVertexArray(null);
        } else {
          this.disableAttrib();
        }
      }
    }, {
      key: "destroy",
      value: function destroy() {
        if (this._useVao) {
          var gl = this.gl;
          this.vao.forEach(function (vao) {
            gl.deleteVertexArray(vao);
          });
        }
      }
    }, {
      key: "bindBufferAndAttrib",
      value: function bindBufferAndAttrib(tech) {
        var gl = this.gl;
        var primitive = this._primitive;
        var vertexBufferBindings = primitive.vertexBufferBindings;
        this.attribLocArray = [];
        var techAttributes = tech.attributes;
        var attributes = primitive._vertexElementMap;
        var vbo;
        var lastBoundVbo;

        for (var name in techAttributes) {
          var loc = techAttributes[name].location;
          if (loc === -1) continue;
          var semantic = techAttributes[name].semantic;
          var element = attributes[semantic];

          if (element) {
            var _vertexBufferBindings = vertexBufferBindings[element.bindingIndex],
                buffer = _vertexBufferBindings.buffer,
                stride = _vertexBufferBindings.stride;
            vbo = buffer._nativeBuffer;

            if (lastBoundVbo !== vbo) {
              lastBoundVbo = vbo;
              gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
            }

            gl.enableVertexAttribArray(loc);
            var _element$_glElementIn = element._glElementInfo,
                size = _element$_glElementIn.size,
                type2 = _element$_glElementIn.type;
            gl.vertexAttribPointer(loc, size, type2, element.normalized, stride, element.offset);

            if (this.canUseInstancedArrays) {
              gl.vertexAttribDivisor(loc, element.instanceDivisor);
            }

            this.attribLocArray.push(loc);
          } else {
            Logger.warn("vertex attribute not found: " + name);
          }
        }

        gl.bindBuffer(gl.ARRAY_BUFFER, null);
      }
    }, {
      key: "disableAttrib",
      value: function disableAttrib() {
        var gl = this.gl;

        for (var i = 0, l = this.attribLocArray.length; i < l; i++) {
          gl.disableVertexAttribArray(this.attribLocArray[i]);
        }
      }
    }, {
      key: "registerVAO",
      value: function registerVAO(tech) {
        var gl = this.gl;
        var vao = gl.createVertexArray();
        gl.bindVertexArray(vao);
        var indexBufferBinding = this._primitive.indexBufferBinding;

        if (indexBufferBinding) {
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBufferBinding.buffer._nativeBuffer);
        }

        this.bindBufferAndAttrib(tech);
        gl.bindVertexArray(null);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        this.disableAttrib();
        this.vao.set(tech.cacheID, vao);
      }
    }]);

    return GLPrimitive;
  }();

  var GLRenderStates = /*#__PURE__*/function () {
    function GLRenderStates(gl) {
      _classCallCheck(this, GLRenderStates);

      this._stateStack = [];
      this._parameters = {};
      this._gl = gl;
      this._stateStack = [];
      this._parameters = {};
      this._parameters[gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS] = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
      this._parameters[gl.MAX_VERTEX_UNIFORM_VECTORS] = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
      this._parameters[gl.MAX_VERTEX_ATTRIBS] = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
      this._parameters[gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS] = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
      this._parameters[gl.BLEND] = false;
      gl.disable(gl.BLEND);
      this._parameters[gl.CULL_FACE] = true;
      gl.enable(gl.CULL_FACE);
      this._parameters[gl.DEPTH_TEST] = true;
      gl.enable(gl.DEPTH_TEST);
      this._parameters[gl.DITHER] = false;
      gl.disable(gl.DITHER);
      this._parameters[gl.POLYGON_OFFSET_FILL] = false;
      gl.disable(gl.POLYGON_OFFSET_FILL);
      this._parameters[gl.SAMPLE_ALPHA_TO_COVERAGE] = false;
      gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
      this._parameters[gl.SAMPLE_COVERAGE] = false;
      gl.disable(gl.SAMPLE_COVERAGE);
      this._parameters[gl.SCISSOR_TEST] = false;
      gl.disable(gl.SCISSOR_TEST);
      this._parameters[gl.STENCIL_TEST] = false;
      gl.disable(gl.STENCIL_TEST);
      this._parameters[gl.COLOR_WRITEMASK] = [true, true, true, true];
      gl.colorMask(true, true, true, true);
      this._parameters[gl.DEPTH_WRITEMASK] = true;
      gl.depthMask(true);
      this._parameters[gl.BLEND_SRC_RGB] = gl.ONE;
      this._parameters[gl.BLEND_SRC_ALPHA] = gl.ONE;
      this._parameters[gl.BLEND_DST_RGB] = gl.ZERO;
      this._parameters[gl.BLEND_DST_ALPHA] = gl.ZERO;
      gl.blendFunc(gl.ONE, gl.ZERO);
      this._parameters[gl.BLEND_EQUATION_RGB] = gl.FUNC_ADD;
      this._parameters[gl.BLEND_EQUATION_ALPHA] = gl.FUNC_ADD;
      this._parameters[gl.CULL_FACE_MODE] = gl.BACK;
      gl.cullFace(gl.BACK);
      this._parameters[gl.FRONT_FACE] = gl.CCW;
      gl.frontFace(gl.CCW);
      this._parameters[gl.DEPTH_FUNC] = gl.LESS;
      gl.depthFunc(gl.LESS);
      this._parameters[gl.DEPTH_RANGE] = [0, 1];
      gl.depthRange(0, 1);
      this._parameters[gl.POLYGON_OFFSET_FACTOR] = 0;
      this._parameters[gl.POLYGON_OFFSET_UNITS] = 0;
      gl.polygonOffset(0, 0);
      this._parameters[gl.SCISSOR_BOX] = [0, 0, gl.canvas.width, gl.canvas.height];
      this._parameters[gl.STENCIL_FUNC] = gl.ALWAYS;
      this._parameters[gl.STENCIL_VALUE_MASK] = 255;
      this._parameters[gl.STENCIL_REF] = 0;
      gl.stencilFunc(gl.ALWAYS, 0, 255);
      this._parameters[gl.STENCIL_WRITEMASK] = 255;
      gl.stencilMask(255);
      this._parameters[gl.STENCIL_FAIL] = gl.KEEP;
      this._parameters[gl.STENCIL_PASS_DEPTH_FAIL] = gl.KEEP;
      this._parameters[gl.STENCIL_PASS_DEPTH_PASS] = gl.KEEP;
    }

    _createClass(GLRenderStates, [{
      key: "getParameter",
      value: function getParameter(pname) {
        return this._parameters[pname];
      }
    }, {
      key: "pushStateBlock",
      value: function pushStateBlock(_name) {
        var stateBlock = {
          name: _name,
          states: []
        };

        this._stateStack.push(stateBlock);
      }
    }, {
      key: "popStateBlock",
      value: function popStateBlock() {
        var stateBlock = this._stateStack.pop();

        var _iterator = _createForOfIteratorHelper(stateBlock.states),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var state = _step.value;
            var stateFunc = state.func;
            var stateArgs = state.args;
            var parameters = state.parameters;
            stateFunc.apply(this._gl, stateArgs);

            for (var param in parameters) {
              this._parameters[param] = parameters[param];
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    }, {
      key: "_getStateStackTop",
      value: function _getStateStackTop() {
        var count = this._stateStack.length;

        if (count > 0) {
          return this._stateStack[count - 1];
        } else {
          return null;
        }
      }
    }, {
      key: "_pushState",
      value: function _pushState(_func, _args, _param) {
        var stateBlock = this._getStateStackTop();

        if (stateBlock) {
          stateBlock.states.push({
            func: _func,
            args: _args,
            parameters: _param
          });
        }
      }
    }, {
      key: "enable",
      value: function enable(cap) {
        var currentState = this._parameters[cap];
        if (currentState === true) return;
        this._parameters[cap] = true;

        this._gl.enable(cap);

        var pushParam = {};
        pushParam[cap] = false;

        this._pushState(this._gl.disable, [cap], pushParam);
      }
    }, {
      key: "disable",
      value: function disable(cap) {
        var currentState = this._parameters[cap];
        if (currentState === false) return;
        this._parameters[cap] = false;

        this._gl.disable(cap);

        var pushParam = {};
        pushParam[cap] = true;

        this._pushState(this._gl.enable, [cap], pushParam);
      }
    }, {
      key: "blendFunc",
      value: function blendFunc(sfactor, dfactor) {
        var gl = this._gl;
        var param = this._parameters;
        if (param[gl.BLEND_SRC_RGB] === sfactor && param[gl.BLEND_SRC_ALPHA] === sfactor && param[gl.BLEND_DST_RGB] === dfactor && param[gl.BLEND_DST_ALPHA] === dfactor) return;
        var pushArgs = [param[gl.BLEND_SRC_RGB], param[gl.BLEND_DST_RGB], param[gl.BLEND_SRC_ALPHA], param[gl.BLEND_DST_ALPHA]];
        var pushParam = {};
        pushParam[gl.BLEND_SRC_RGB] = param[gl.BLEND_SRC_RGB];
        pushParam[gl.BLEND_DST_RGB] = param[gl.BLEND_DST_RGB];
        pushParam[gl.BLEND_SRC_ALPHA] = param[gl.BLEND_SRC_ALPHA];
        pushParam[gl.BLEND_DST_ALPHA] = param[gl.BLEND_DST_ALPHA];

        this._pushState(gl.blendFuncSeparate, pushArgs, pushParam);

        param[gl.BLEND_SRC_RGB] = sfactor;
        param[gl.BLEND_SRC_ALPHA] = sfactor;
        param[gl.BLEND_DST_RGB] = dfactor;
        param[gl.BLEND_DST_ALPHA] = dfactor;
        gl.blendFunc(sfactor, dfactor);
      }
    }, {
      key: "blendFuncSeparate",
      value: function blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha) {
        var gl = this._gl;
        var param = this._parameters;
        if (param[gl.BLEND_SRC_RGB] === srcRGB && param[gl.BLEND_SRC_ALPHA] === srcAlpha && param[gl.BLEND_DST_RGB] === dstRGB && param[gl.BLEND_DST_ALPHA] === dstAlpha) return;
        var pushArgs = [param[gl.BLEND_SRC_RGB], param[gl.BLEND_DST_RGB], param[gl.BLEND_SRC_ALPHA], param[gl.BLEND_DST_ALPHA]];
        var pushParam = {};
        pushParam[gl.BLEND_SRC_RGB] = param[gl.BLEND_SRC_RGB];
        pushParam[gl.BLEND_DST_RGB] = param[gl.BLEND_DST_RGB];
        pushParam[gl.BLEND_SRC_ALPHA] = param[gl.BLEND_SRC_ALPHA];
        pushParam[gl.BLEND_DST_ALPHA] = param[gl.BLEND_DST_ALPHA];

        this._pushState(gl.blendFuncSeparate, pushArgs, pushParam);

        param[gl.BLEND_SRC_RGB] = srcRGB;
        param[gl.BLEND_SRC_ALPHA] = srcAlpha;
        param[gl.BLEND_DST_RGB] = dstRGB;
        param[gl.BLEND_DST_ALPHA] = dstAlpha;
        gl.blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
      }
    }, {
      key: "blendEquationSeparate",
      value: function blendEquationSeparate(modeRGB, modeAlpha) {
        var gl = this._gl;
        var param = this._parameters;
        if (param[gl.BLEND_EQUATION_RGB] === modeRGB && param[gl.BLEND_EQUATION_ALPHA] === modeAlpha) return;
        var pushArgs = [param[gl.BLEND_EQUATION_RGB], param[gl.BLEND_EQUATION_ALPHA]];
        var pushParam = {};
        pushParam[gl.BLEND_EQUATION_RGB] = param[gl.BLEND_EQUATION_RGB];
        pushParam[gl.BLEND_EQUATION_ALPHA] = param[gl.BLEND_EQUATION_ALPHA];

        this._pushState(gl.blendEquationSeparate, pushArgs, pushParam);

        param[gl.BLEND_EQUATION_RGB] = modeRGB;
        param[gl.BLEND_EQUATION_ALPHA] = modeAlpha;
        gl.blendEquationSeparate(modeRGB, modeAlpha);
      }
    }, {
      key: "colorMask",
      value: function colorMask(red, green, blue, alpha) {
        var gl = this._gl;
        var pushParam = {};
        pushParam[gl.COLOR_WRITEMASK] = this._parameters[gl.COLOR_WRITEMASK];

        this._pushState(gl.colorMask, this._parameters[gl.COLOR_WRITEMASK], pushParam);

        this._parameters[gl.COLOR_WRITEMASK] = [red, green, blue, alpha];
        gl.colorMask(red, green, blue, alpha);
      }
    }, {
      key: "depthMask",
      value: function depthMask(flag) {
        var gl = this._gl;
        if (this._parameters[gl.DEPTH_WRITEMASK] === flag) return;
        var pushParam = {};
        pushParam[gl.DEPTH_WRITEMASK] = this._parameters[gl.DEPTH_WRITEMASK];

        this._pushState(gl.depthMask, [this._parameters[gl.DEPTH_WRITEMASK]], pushParam);

        this._parameters[gl.DEPTH_WRITEMASK] = flag;
        gl.depthMask(flag);
      }
    }, {
      key: "cullFace",
      value: function cullFace(mode) {
        var gl = this._gl;
        if (this._parameters[gl.CULL_FACE_MODE] === mode) return;
        var pushParam = {};
        pushParam[gl.CULL_FACE_MODE] = this._parameters[gl.CULL_FACE_MODE];

        this._pushState(gl.cullFace, [this._parameters[gl.CULL_FACE_MODE]], pushParam);

        this._parameters[gl.CULL_FACE_MODE] = mode;
        gl.cullFace(mode);
      }
    }, {
      key: "frontFace",
      value: function frontFace(mode) {
        var gl = this._gl;
        if (this._parameters[gl.FRONT_FACE] === mode) return;
        var pushParam = {};
        pushParam[gl.FRONT_FACE] = this._parameters[gl.FRONT_FACE];

        this._pushState(gl.frontFace, [this._parameters[gl.FRONT_FACE]], pushParam);

        this._parameters[gl.FRONT_FACE] = mode;
        gl.frontFace(mode);
      }
    }, {
      key: "depthFunc",
      value: function depthFunc(func) {
        var gl = this._gl;
        if (this._parameters[gl.DEPTH_FUNC] === func) return;
        var pushParam = {};
        pushParam[gl.DEPTH_FUNC] = this._parameters[gl.DEPTH_FUNC];

        this._pushState(gl.depthFunc, [this._parameters[gl.DEPTH_FUNC]], pushParam);

        this._parameters[gl.DEPTH_FUNC] = func;
        gl.depthFunc(func);
      }
    }, {
      key: "depthRange",
      value: function depthRange(zNear, zFar) {
        var gl = this._gl;
        var currentValue = this._parameters[gl.DEPTH_RANGE];
        if (currentValue[0] === zNear && currentValue[1] === zFar) return;
        var pushParam = {};
        pushParam[gl.DEPTH_RANGE] = currentValue;

        this._pushState(gl.depthRange, [this._parameters[gl.DEPTH_RANGE]], pushParam);

        this._parameters[gl.DEPTH_RANGE] = [zNear, zFar];
        gl.depthRange(zNear, zFar);
      }
    }, {
      key: "polygonOffset",
      value: function polygonOffset(factor, units) {
        var gl = this._gl;
        if (this._parameters[gl.POLYGON_OFFSET_FACTOR] === factor && this._parameters[gl.POLYGON_OFFSET_UNITS] === units) return;
        var pushParam = {};
        pushParam[gl.POLYGON_OFFSET_FACTOR] = this._parameters[gl.POLYGON_OFFSET_FACTOR];
        pushParam[gl.POLYGON_OFFSET_UNITS] = this._parameters[gl.POLYGON_OFFSET_UNITS];

        this._pushState(gl.polygonOffset, [this._parameters[gl.POLYGON_OFFSET_FACTOR], this._parameters[gl.POLYGON_OFFSET_UNITS]], pushParam);

        this._parameters[gl.POLYGON_OFFSET_FACTOR] = factor;
        this._parameters[gl.POLYGON_OFFSET_UNITS] = units;
        gl.polygonOffset(factor, units);
      }
    }, {
      key: "scissor",
      value: function scissor(x, y, width, height) {
        var gl = this._gl;
        var box = this._parameters[gl.SCISSOR_BOX];
        if (box[0] === x && box[1] === y && box[2] === width && box[3] === height) return;
        var pushParam = {};
        pushParam[gl.SCISSOR_BOX] = box;

        this._pushState(gl.scissor, box, pushParam);

        this._parameters[gl.SCISSOR_BOX] = [x, y, width, height];
        gl.scissor(x, y, width, height);
      }
    }, {
      key: "stencilFunc",
      value: function stencilFunc(func, ref, mask) {
        var gl = this._gl;
        if (this._parameters[gl.STENCIL_FUNC] === func && this._parameters[gl.STENCIL_REF] === ref && this._parameters[gl.STENCIL_VALUE_MASK] === mask) return;
        var pushArgs = [this._parameters[gl.STENCIL_FUNC], this._parameters[gl.STENCIL_REF], this._parameters[gl.STENCIL_VALUE_MASK]];
        var pushParam = {};
        pushParam[gl.STENCIL_FUNC] = pushArgs[0];
        pushParam[gl.STENCIL_REF] = pushArgs[1];
        pushParam[gl.STENCIL_VALUE_MASK] = pushArgs[2];

        this._pushState(gl.stencilFunc, pushArgs, pushParam);

        this._parameters[gl.STENCIL_FUNC] = func;
        this._parameters[gl.STENCIL_REF] = ref;
        this._parameters[gl.STENCIL_VALUE_MASK] = mask;
        gl.stencilFunc(func, ref, mask);
      }
    }, {
      key: "stencilOp",
      value: function stencilOp(fail, zfail, zpass) {
        var gl = this._gl;
        if (this._parameters[gl.STENCIL_FAIL] === fail && this._parameters[gl.STENCIL_PASS_DEPTH_FAIL] === zfail && this._parameters[gl.STENCIL_PASS_DEPTH_PASS] === zpass) return;
        var pushArgs = [this._parameters[gl.STENCIL_FAIL], this._parameters[gl.STENCIL_PASS_DEPTH_FAIL], this._parameters[gl.STENCIL_PASS_DEPTH_PASS]];
        var pushParam = {};
        pushParam[gl.STENCIL_FAIL] = pushArgs[0];
        pushParam[gl.STENCIL_PASS_DEPTH_FAIL] = pushArgs[1];
        pushParam[gl.STENCIL_PASS_DEPTH_PASS] = pushArgs[2];

        this._pushState(gl.stencilOp, pushArgs, pushParam);

        this._parameters[gl.STENCIL_FAIL] = fail;
        this._parameters[gl.STENCIL_BACK_PASS_DEPTH_FAIL] = zfail;
        this._parameters[gl.STENCIL_PASS_DEPTH_PASS] = zpass;
        gl.stencilOp(fail, zfail, zpass);
      }
    }, {
      key: "stencilMask",
      value: function stencilMask(mask) {
        var gl = this._gl;
        if (this._parameters[gl.STENCIL_WRITEMASK] === mask) return;
        var pushParam = {};
        pushParam[gl.STENCIL_WRITEMASK] = this._parameters[gl.STENCIL_WRITEMASK];

        this._pushState(gl.stencilMask, [this._parameters[gl.STENCIL_WRITEMASK]], pushParam);

        this._parameters[gl.STENCIL_WRITEMASK] = mask;
        gl.stencilMask(mask);
      }
    }]);

    return GLRenderStates;
  }();

  var GLSprite = /*#__PURE__*/function () {
    function GLSprite(gl) {
      _classCallCheck(this, GLSprite);

      this.gl = gl;

      this._initVertexAttributes(gl);

      this._vbo = gl.createBuffer();
      this._maxBatchCount = 0;
      this._vertBuffer = null;
      this._vertCursor = 0;
      this._drawSpriteCount = 0;
    }

    _createClass(GLSprite, [{
      key: "setMaxBatchCount",
      value: function setMaxBatchCount(count) {
        var requireSize = count * 6 * 9;

        if (this._vertBuffer && this._vertBuffer.length >= requireSize) {
          return;
        }

        this._maxBatchCount = count;
        this._vertBuffer = new Float32Array(requireSize);
      }
    }, {
      key: "beginDraw",
      value: function beginDraw(count) {
        this._vertCursor = 0;
        this._drawSpriteCount = 0;

        if (count > this._maxBatchCount) {
          this.setMaxBatchCount(count);
        }
      }
    }, {
      key: "drawSprite",
      value: function drawSprite(positionQuad, uvRect, tintColor) {
        this._drawSpriteCount++;

        if (this._drawSpriteCount > this._maxBatchCount) {
          Logger.warn("Sprite: sprite count overflow");
          return;
        }

        var color = tintColor;
        var u = uvRect.u;
        var v = uvRect.v;
        var p = uvRect.u + uvRect.width;
        var q = uvRect.v + uvRect.height;

        this._pushVertex(positionQuad.leftTop, new Vector2(u, v), color);

        this._pushVertex(positionQuad.leftBottom, new Vector2(u, q), color);

        this._pushVertex(positionQuad.rightBottom, new Vector2(p, q), color);

        this._pushVertex(positionQuad.rightBottom, new Vector2(p, q), color);

        this._pushVertex(positionQuad.rightTop, new Vector2(p, v), color);

        this._pushVertex(positionQuad.leftTop, new Vector2(u, v), color);
      }
    }, {
      key: "endDraw",
      value: function endDraw() {
        var vertCount = this._vertCursor / 9;
        if (vertCount <= 0) return;
        var gl = this.gl;
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._vbo);
        gl.bufferData(gl.ARRAY_BUFFER, this._vertBuffer, gl.DYNAMIC_DRAW);

        for (var i = 0, len = this._vertAttributes.length; i < len; i++) {
          var attrib = this._vertAttributes[i];
          gl.vertexAttribPointer(attrib.lastShaderLoc, attrib.size, attrib.type, attrib.normalized, attrib.stride, attrib.offset);
          gl.enableVertexAttribArray(attrib.lastShaderLoc);
        }

        gl.drawArrays(gl.TRIANGLES, 0, vertCount);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);

        for (var _i2 = 0, _len2 = this._vertAttributes.length; _i2 < _len2; _i2++) {
          gl.disableVertexAttribArray(this._vertAttributes[_i2].lastShaderLoc);
        }
      }
    }, {
      key: "_initVertexAttributes",
      value: function _initVertexAttributes(gl) {
        var vertexStride = (3 + 2 + 4) * 4;
        var posAtt = {};
        posAtt.name = "a_pos";
        posAtt.size = 3;
        posAtt.offset = 0;
        posAtt.lastShaderLoc = 0;
        var uvAtt = {};
        uvAtt.name = "a_uv";
        uvAtt.size = 2;
        uvAtt.offset = 3 * 4;
        uvAtt.lastShaderLoc = 1;
        var colorAtt = {};
        colorAtt.name = "a_color";
        colorAtt.size = 4;
        colorAtt.offset = 5 * 4;
        colorAtt.lastShaderLoc = 2;
        this._vertAttributes = [posAtt, uvAtt, colorAtt];

        var _iterator2 = _createForOfIteratorHelper(this._vertAttributes),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var att = _step2.value;
            att.type = gl.FLOAT;
            att.normalized = false;
            att.stride = vertexStride;
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
    }, {
      key: "_pushVertex",
      value: function _pushVertex(pos, uv, color) {
        var vb = this._vertBuffer;
        var id = this._vertCursor;
        vb[id] = pos.x;
        vb[id + 1] = pos.y;
        vb[id + 2] = pos.z;
        vb[id + 3] = uv.x;
        vb[id + 4] = uv.y;
        vb[id + 5] = color.x;
        vb[id + 6] = color.y;
        vb[id + 7] = color.z;
        vb[id + 8] = color.w;
        this._vertCursor += 9;
      }
    }, {
      key: "finalize",
      value: function finalize() {
        if (this._vbo) {
          this.gl.deleteBuffer(this._vbo);
          this._vbo = null;
        }
      }
    }]);

    return GLSprite;
  }();

  var SpriteVertShader = "\nprecision highp float;\n\nuniform mat4 matProjection;\nuniform mat4 matView;\n\nattribute vec3 a_pos;\nattribute vec2 a_uv;\nattribute vec4 a_color;\n\nvarying vec2 v_uv;\nvarying vec4 v_color;\n\nvoid main()\n{\n  gl_Position = matProjection * matView * vec4(a_pos,1.0);\n  v_uv = a_uv;\n  v_color = a_color;\n}\n";
  var SpriteFragmentShader = "\nprecision mediump float;\nprecision mediump int;\n\nuniform sampler2D s_diffuse;\nvarying vec2 v_uv;\nvarying vec4 v_color;\n\nvoid main()\n{\n  // \u53EA\u4F7F\u7528\u8D34\u56FE\u7684Alpha\u505AMask\uFF0C\u8FD9\u6837Tint Color\u4F9D\u7136\u53EF\u4EE5\u63A7\u5236\u63A7\u4EF6Fade Out\n  vec4 baseColor = texture2D(s_diffuse, v_uv);\n  gl_FragColor = baseColor * v_color;\n}\n";
  var SpriteTechnique = {
    name: "spriteTech3D",
    vertexShader: SpriteVertShader,
    fragmentShader: SpriteFragmentShader,
    attribLocSet: {
      a_pos: 0,
      a_uv: 1,
      a_color: 2
    },
    attributes: {
      a_pos: {
        name: "a_pos",
        semantic: "POSITION",
        type: exports.DataType.FLOAT_VEC3
      },
      a_uv: {
        name: "a_uv",
        semantic: "TEXCOORD_0",
        type: exports.DataType.FLOAT_VEC2
      },
      a_color: {
        name: "a_color",
        semantic: "COLOR",
        type: exports.DataType.FLOAT_VEC3
      }
    },
    uniforms: {
      matProjection: {
        name: "matProjection",
        semantic: exports.UniformSemantic.PROJECTION,
        type: exports.DataType.FLOAT_MAT4
      },
      matView: {
        name: "matView",
        semantic: exports.UniformSemantic.VIEW,
        type: exports.DataType.FLOAT_MAT4
      },
      s_diffuse: {
        name: "s_diffuse",
        type: exports.DataType.SAMPLER_2D
      }
    },
    states: {
      disable: [exports.RenderState.CULL_FACE],
      enable: [exports.RenderState.BLEND],
      functions: {
        blendFunc: [exports.BlendFunc.SRC_ALPHA, exports.BlendFunc.ONE_MINUS_SRC_ALPHA],
        depthMask: [false]
      }
    }
  };

  function createSpriteMaterial() {
    var values = {};
    return {
      values: values,
      setValue: function setValue(key, val) {
        values[key] = val;
      },
      getValue: function getValue(key) {
        return values[key];
      }
    };
  }

  var GLSpriteBatcher = /*#__PURE__*/function () {
    function GLSpriteBatcher(rhi) {
      _classCallCheck(this, GLSpriteBatcher);

      this._gl = rhi.gl;
      this._batchedQueue = [];
      this._targetTexture = null;
      this._glSprite = new GLSprite(rhi.gl);
      this._glTech = new GLTechnique(rhi, SpriteTechnique);
      this._material = createSpriteMaterial();
      this._camera = null;
    }

    _createClass(GLSpriteBatcher, [{
      key: "flush",
      value: function flush() {
        if (this._batchedQueue.length === 0) {
          return;
        }

        if (!this._targetTexture) {
          Logger.error("No texture!");
          return;
        }

        this._material.setValue("s_diffuse", this._targetTexture);

        this._material.setValue("matView", this._camera.viewMatrix);

        this._material.setValue("matProjection", this._camera.projectionMatrix);

        this._glTech.begin(this._material);

        this._glSprite.beginDraw(this._batchedQueue.length);

        for (var i = 0, len = this._batchedQueue.length; i < len; i++) {
          var positionQuad = this._batchedQueue[i].positionQuad;
          var uvRect = this._batchedQueue[i].uvRect;
          var tintColor = this._batchedQueue[i].tintColor;

          this._glSprite.drawSprite(positionQuad, uvRect, tintColor);
        }

        this._glSprite.endDraw();

        this._glTech.end();

        this._batchedQueue = [];
        this._targetTexture = null;
        this._camera = null;
      }
    }, {
      key: "canBatch",
      value: function canBatch(texture, renderMode, camera) {
        if (this._targetTexture === null) {
          return true;
        }

        return texture === this._targetTexture && camera === this._camera;
      }
    }, {
      key: "drawSprite",
      value: function drawSprite(positionQuad, uvRect, tintColor, texture, renderMode, camera) {
        if (!this.canBatch(texture, renderMode, camera)) {
          this.flush();
        }

        this._targetTexture = texture;
        this._camera = camera;

        this._batchedQueue.push({
          positionQuad: positionQuad,
          uvRect: uvRect,
          tintColor: tintColor
        });
      }
    }, {
      key: "finalize",
      value: function finalize() {
        this._glSprite.finalize();

        this._glTech.finalize();
      }
    }]);

    return GLSpriteBatcher;
  }();



  (function (WebGLMode2) {
    WebGLMode2[WebGLMode2["Auto"] = 0] = "Auto";
    WebGLMode2[WebGLMode2["WebGL2"] = 1] = "WebGL2";
    WebGLMode2[WebGLMode2["WebGL1"] = 2] = "WebGL1";
  })(exports.WebGLMode || (exports.WebGLMode = {}));

  var WebGLRenderer = /*#__PURE__*/function () {
    _createClass(WebGLRenderer, [{
      key: "isWebGL2",
      get: function get() {
        return this._isWebGL2;
      }
    }]);

    function WebGLRenderer() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, WebGLRenderer);

      this._options = options;
    }

    _createClass(WebGLRenderer, [{
      key: "init",
      value: function init(canvas, engine) {
        var option = this._options;
        this._engine = engine;
        var webCanvas = canvas._webCanvas;
        var webGLMode = option.webGLMode || 0;
        var gl;

        if (webGLMode == 0 || webGLMode == 1) {
          gl = webCanvas.getContext("webgl2", option);

          if (!gl && webCanvas instanceof HTMLCanvasElement) {
            gl = webCanvas.getContext("experimental-webgl2", option);
          }

          this._isWebGL2 = true;
        }

        if (!gl) {
          if (webGLMode == 0 || webGLMode == 2) {
            gl = webCanvas.getContext("webgl", option);

            if (!gl && webCanvas instanceof HTMLCanvasElement) {
              gl = webCanvas.getContext("experimental-webgl", option);
            }

            this._isWebGL2 = false;
          }
        }

        if (!gl) {
          throw new Error("Get GL Context FAILED.");
        }

        this._gl = gl;
        this._renderStates = new GLRenderStates(gl);
        this._assetsCache = new GLAssetsCache(this, option);
        this._extensions = new GLExtensions(this);
        this._capability = new GLCapability(this);
        this._frameCount = 0;
        this._options = null;
      }
    }, {
      key: "createPlatformPrimitive",
      value: function createPlatformPrimitive(primitive) {
        return new GLPrimitive(this, primitive);
      }
    }, {
      key: "requireExtension",
      value: function requireExtension(ext) {
        return this._extensions.requireExtension(ext);
      }
    }, {
      key: "canIUse",
      value: function canIUse(capabilityType) {
        return this.capability.canIUse(capabilityType);
      }
    }, {
      key: "canIUseCompressedTextureInternalFormat",
      value: function canIUseCompressedTextureInternalFormat(type2) {
        return this.capability.canIUseCompressedTextureInternalFormat(type2);
      }
    }, {
      key: "viewport",
      value: function viewport(x, y, width, height) {
        var gl = this._gl;
        gl.viewport(x, gl.drawingBufferHeight - y - height, width, height);
      }
    }, {
      key: "colorMask",
      value: function colorMask(r, g, b, a) {
        this._gl.colorMask(r, g, b, a);
      }
    }, {
      key: "beginFrame",
      value: function beginFrame() {
        this._frameCount++;
      }
    }, {
      key: "clearRenderTarget",
      value: function clearRenderTarget(clearMode, clearParam) {
        var gl = this._gl;

        switch (clearMode) {
          case exports.ClearMode.SOLID_COLOR:
            gl.clearColor(clearParam.x, clearParam.y, clearParam.z, clearParam.w);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            break;

          case exports.ClearMode.DEPTH_ONLY:
            gl.clear(gl.DEPTH_BUFFER_BIT);
            break;

          case exports.ClearMode.COLOR_ONLY:
            gl.clearColor(clearParam.x, clearParam.y, clearParam.z, clearParam.w);
            gl.clear(gl.COLOR_BUFFER_BIT);
            break;

          case exports.ClearMode.STENCIL_ONLY:
            gl.clear(gl.STENCIL_BUFFER_BIT);
            break;

          case exports.ClearMode.ALL_CLEAR:
            gl.clearColor(clearParam.x, clearParam.y, clearParam.z, clearParam.w);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
            break;

          case exports.ClearMode.DONT_CLEAR:
            break;
        }
      }
    }, {
      key: "drawPrimitive",
      value: function drawPrimitive(primitive, group, mtl) {
        var glTech = mtl.technique._glTechnique;
        glTech || (glTech = mtl.technique._glTechnique = new GLTechnique(this, mtl.technique));
        if (!glTech.valid) return;

        if (primitive && glTech) {
          glTech.begin(mtl);
          primitive.draw(glTech, group);
          glTech.end();
        } else {
          Logger.error("draw primitive failed.");
        }
      }
    }, {
      key: "drawSprite",
      value: function drawSprite(positionQuad, uvRect, tintColor, texture, renderMode, camera) {
        if (!this._spriteBatcher) {
          this._spriteBatcher = new GLSpriteBatcher(this);
        }

        this._spriteBatcher.drawSprite(positionQuad, uvRect, tintColor, texture, renderMode, camera);
      }
    }, {
      key: "flushSprite",
      value: function flushSprite() {
        if (this._spriteBatcher) {
          this._spriteBatcher.flush();
        }
      }
    }, {
      key: "activeRenderTarget",
      value: function activeRenderTarget(renderTarget, camera) {
        var gl = this._gl;

        if (renderTarget) {
          renderTarget._activeRenderTarget();

          var width = renderTarget.width,
              height = renderTarget.height;
          gl.viewport(0, 0, width, height);
        } else {
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          var viewport = camera.viewport;
          var _width = gl.drawingBufferWidth;
          var _height = gl.drawingBufferHeight;
          this.viewport(viewport.x * _width, viewport.y * _height, viewport.z * _width, viewport.w * _height);
        }
      }
    }, {
      key: "blitRenderTarget",
      value: function blitRenderTarget(renderTarget) {
        if (renderTarget) {
          if (renderTarget._MSAAFrameBuffer) {
            renderTarget._blitRenderTarget();

            return;
          }
        }
      }
    }, {
      key: "setRenderTargetFace",
      value: function setRenderTargetFace(renderTarget, faceIndex) {
        if (renderTarget) {
          renderTarget._setRenderTargetFace(faceIndex);
        }
      }
    }, {
      key: "endFrame",
      value: function endFrame() {
        var CHECK_FREQ = 8;

        if (this._frameCount % CHECK_FREQ === 0) {
          this._assetsCache.compact();
        }
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this._assetsCache.finalize();
      }
    }, {
      key: "gl",
      get: function get() {
        return this._gl;
      }
    }, {
      key: "assetsCache",
      get: function get() {
        return this._assetsCache;
      }
    }, {
      key: "renderStates",
      get: function get() {
        return this._renderStates;
      }
    }, {
      key: "capability",
      get: function get() {
        return this._capability;
      }
    }, {
      key: "frameCount",
      get: function get() {
        return this._frameCount;
      }
    }, {
      key: "canIUseMoreJoints",
      get: function get() {
        return this.capability.canIUseMoreJoints;
      }
    }]);

    return WebGLRenderer;
  }();

  var WebGLEngine = /*#__PURE__*/function (_Engine) {
    _inherits(WebGLEngine, _Engine);

    var _super3 = _createSuper(WebGLEngine);

    function WebGLEngine(canvas, webGLRendererOptions) {
      _classCallCheck(this, WebGLEngine);

      var webCanvas = new WebCanvas(typeof canvas === "string" ? document.getElementById(canvas) : canvas);
      var hardwareRenderer = new WebGLRenderer(webGLRendererOptions);
      return _super3.call(this, webCanvas, hardwareRenderer);
    }

    _createClass(WebGLEngine, [{
      key: "canvas",
      get: function get() {
        return this._canvas;
      }
    }]);

    return WebGLEngine;
  }(Engine);

  Parser.registerComponents("o3", {
    GLTFModel: GLTFModel,
    SpriteRenderer: SpriteRenderer,
    PointLight: PointLight,
    AmbientLight: AmbientLight,
    DirectLight: DirectLight,
    EnvironmentMapLight: EnvironmentMapLight,
    Particle: Particle,
    SkyBox: SkyBox,
    BoxCollider: BoxCollider,
    GeometryRenderer: GeometryRenderer,
    Camera: exports.Camera,
    Component: Component,
    SphereCollider: SphereCollider,
    PlaneProbe: PlaneProbe,
    Model: Model
  }); //@ts-ignore

  var version = "0.1.29";
  console.log("oasis engine version: ".concat(version));

  exports.ABoxCollider = ABoxCollider;
  exports.ACollider = Collider;
  exports.ASphereCollider = ASphereCollider;
  exports.AmbientLight = AmbientLight;
  exports.Animation = Animation;
  exports.AnimationClip = AnimationClip;
  exports.AssetObject = AssetObject;
  exports.AssetPromise = AssetPromise;
  exports.BasicRenderPipeline = BasicRenderPipeline;
  exports.BlinnPhongMaterial = BlinnPhongMaterial;
  exports.BoundingBox = BoundingBox;
  exports.BoundingSphere = BoundingSphere;
  exports.BoxCollider = BoxCollider;
  exports.Buffer = Buffer;
  exports.BufferGeometry = BufferGeometry;
  exports.BufferUtil = BufferUtil;
  exports.CircleGeometry = CircleGeometry;
  exports.ColliderFeature = ColliderFeature;
  exports.CollisionDetection = CollisionDetection;
  exports.CommonMaterial = CommonMaterial;
  exports.ComplexMaterial = ComplexMaterial;
  exports.Component = Component;
  exports.ConstantMaterial = ConstantMaterial;
  exports.CubeProbe = CubeProbe;
  exports.CuboidGeometry = CuboidGeometry;
  exports.CylinderGeometry = CylinderGeometry;
  exports.DirectLight = DirectLight;
  exports.EXP2Fog = EXP2Fog;
  exports.Engine = Engine;
  exports.EngineFeature = EngineFeature;
  exports.EngineObject = EngineObject;
  exports.Entity = Entity;
  exports.EnvironmentMapLight = EnvironmentMapLight;
  exports.Event = Event;
  exports.EventDispatcher = EventDispatcher;
  exports.FogFeature = FogFeature;
  exports.GLShaderProgram = GLShaderProgram;
  exports.GLTFModel = GLTFModel;
  exports.GLTechnique = GLTechnique;
  exports.GLTexture = GLTexture;
  exports.GPUParticleSystem = GPUParticleSystem;
  exports.GeometryRenderer = GeometryRenderer;
  exports.IndexBufferBinding = IndexBufferBinding;
  exports.LODGroup = LODGroup;
  exports.LambertMaterial = LambertMaterial;
  exports.Light = Light;
  exports.LightFeature = LightFeature;
  exports.LinearFog = LinearFog;
  exports.Loader = Loader;
  exports.Logger = Logger;
  exports.Material = Material;
  exports.MathUtil = MathUtil;
  exports.Matrix = Matrix;
  exports.Matrix3x3 = Matrix3x3;
  exports.Mesh = Mesh;
  exports.MeshRenderer = MeshRenderer;
  exports.Model = Model;
  exports.OBB = OBB;
  exports.Oasis = Oasis;
  exports.ObjectValues = ObjectValues;
  exports.PBRMaterial = PBRMaterial;
  exports.Parser = Parser;
  exports.Particle = Particle;
  exports.PlaneCollider = PlaneCollider;
  exports.PlaneGeometry = PlaneGeometry;
  exports.PlaneProbe = PlaneProbe;
  exports.PointLight = PointLight;
  exports.Primitive = Primitive;
  exports.Probe = Probe;
  exports.Quaternion = Quaternion;
  exports.Ray = Ray;
  exports.RaycastHit = RaycastHit;
  exports.RefObject = RefObject;
  exports.RegistExtension = RegistExtension;
  exports.RenderColorTexture = RenderColorTexture;
  exports.RenderContext = RenderContext;
  exports.RenderDepthTexture = RenderDepthTexture;
  exports.RenderPass = RenderPass;
  exports.RenderQueue = RenderQueue;
  exports.RenderTarget = RenderTarget;
  exports.RenderTechnique = RenderTechnique;
  exports.RenderableComponent = RenderableComponent;
  exports.ResourceManager = ResourceManager;
  exports.Scene = Scene;
  exports.SceneFeature = SceneFeature;
  exports.SceneVisitor = SceneVisitor;
  exports.SchemaResource = SchemaResource;
  exports.ScreenQuadGeometry = ScreenQuadGeometry;
  exports.Script = Script;
  exports.ShaderFactory = ShaderFactory;
  exports.ShaderMaterial = ShaderMaterial;
  exports.ShapeGeometry = ShapeGeometry;
  exports.Skin = Skin;
  exports.SkinnedMeshRenderer = SkinnedMeshRenderer;
  exports.SkyBox = SkyBox;
  exports.SphereCollider = SphereCollider;
  exports.SphereGeometry = SphereGeometry;
  exports.Spherical = Spherical;
  exports.SpotLight = SpotLight;
  exports.SpriteRenderer = SpriteRenderer;
  exports.SubPrimitive = SubPrimitive;
  exports.SystemInfo = SystemInfo;
  exports.Texture = Texture;
  exports.Texture2D = Texture2D;
  exports.TextureCubeMap = TextureCubeMap;
  exports.TextureMaterial = TextureMaterial;
  exports.Time = Time;
  exports.TorusGeometry = TorusGeometry;
  exports.TrailMaterial = TrailMaterial;
  exports.TrailRenderer = TrailRenderer;
  exports.Transform = Transform;
  exports.TransparentMaterial = TransparentMaterial;
  exports.UpdateFlag = UpdateFlag;
  exports.Util = Util;
  exports.Vector2 = Vector2;
  exports.Vector3 = Vector3;
  exports.Vector4 = Vector4;
  exports.VertexBufferBinding = VertexBufferBinding;
  exports.VertexElement = VertexElement;
  exports.WebCanvas = WebCanvas;
  exports.WebGLEngine = WebGLEngine;
  exports.WebGLRenderer = WebGLRenderer;
  exports.bindFogToMaterial = bindFogToMaterial;
  exports.dependencies = dependencies;
  exports.getFogMacro = getFogMacro;
  exports.hasFogFeature = hasFogFeature;
  exports.parseSingleKTX = parseSingleKTX;
  exports.parser = parser;
  exports.registerResource = registerResource;
  exports.request = request;
  exports.resourceLoader = resourceLoader;
  exports.script = script;
  exports.version = version;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
