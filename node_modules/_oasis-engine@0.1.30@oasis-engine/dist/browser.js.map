{"version":3,"file":"browser.js","sources":["../../math/dist/module.js","../../core/dist/module.js","../../draco/dist/module.js","../../loader/dist/module.js","../../rhi-webgl/dist/module.js","../src/index.ts"],"sourcesContent":["var IntersectInfo;\n(function(IntersectInfo2) {\n  IntersectInfo2[IntersectInfo2[\"EXCLUDE\"] = 0] = \"EXCLUDE\";\n  IntersectInfo2[IntersectInfo2[\"INTERSECT\"] = 1] = \"INTERSECT\";\n  IntersectInfo2[IntersectInfo2[\"INCLUDE\"] = 2] = \"INCLUDE\";\n})(IntersectInfo || (IntersectInfo = {}));\n\nfunction pointDistanceToPlane(plane, pt) {\n  return plane.x * pt.x + plane.y * pt.y + plane.z * pt.z + plane.w;\n}\nfunction getMaxScaleByModelMatrix(modelMatrix) {\n  let m = modelMatrix.elements;\n  let scaleXSq = m[0] * m[0] + m[1] * m[1] + m[2] * m[2];\n  let scaleYSq = m[4] * m[4] + m[5] * m[5] + m[6] * m[6];\n  let scaleZSq = m[8] * m[8] + m[9] * m[9] + m[10] * m[10];\n  return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));\n}\n\nclass MathUtil {\n  static clamp(v, min, max) {\n    return Math.max(min, Math.min(max, v));\n  }\n  static equals(a, b) {\n    return Math.abs(a - b) <= MathUtil.zeroTolerance;\n  }\n  static isPowerOf2(v) {\n    return (v & v - 1) === 0;\n  }\n  static radianToDegree(r) {\n    return r * MathUtil.radToDegreeFactor;\n  }\n  static degreeToRadian(d) {\n    return d * MathUtil.degreeToRadFactor;\n  }\n}\nMathUtil.zeroTolerance = 1e-6;\nMathUtil.radToDegreeFactor = 180 / Math.PI;\nMathUtil.degreeToRadFactor = Math.PI / 180;\n\nclass Vector3 {\n  static add(left, right, out) {\n    out.x = left.x + right.x;\n    out.y = left.y + right.y;\n    out.z = left.z + right.z;\n  }\n  static subtract(left, right, out) {\n    out.x = left.x - right.x;\n    out.y = left.y - right.y;\n    out.z = left.z - right.z;\n  }\n  static multiply(left, right, out) {\n    out.x = left.x * right.x;\n    out.y = left.y * right.y;\n    out.z = left.z * right.z;\n  }\n  static divide(left, right, out) {\n    out.x = left.x / right.x;\n    out.y = left.y / right.y;\n    out.z = left.z / right.z;\n  }\n  static dot(left, right) {\n    return left.x * right.x + left.y * right.y + left.z * right.z;\n  }\n  static cross(left, right, out) {\n    const ax = left.x;\n    const ay = left.y;\n    const az = left.z;\n    const bx = right.x;\n    const by = right.y;\n    const bz = right.z;\n    out.x = ay * bz - az * by;\n    out.y = az * bx - ax * bz;\n    out.z = ax * by - ay * bx;\n  }\n  static distance(a, b) {\n    const x = b.x - a.x;\n    const y = b.y - a.y;\n    const z = b.z - a.z;\n    return Math.sqrt(x * x + y * y + z * z);\n  }\n  static distanceSquared(a, b) {\n    const x = b.x - a.x;\n    const y = b.y - a.y;\n    const z = b.z - a.z;\n    return x * x + y * y + z * z;\n  }\n  static equals(left, right) {\n    return MathUtil.equals(left.x, right.x) && MathUtil.equals(left.y, right.y) && MathUtil.equals(left.z, right.z);\n  }\n  static lerp(start, end, t, out) {\n    const {x, y, z} = start;\n    out.x = x + (end.x - x) * t;\n    out.y = y + (end.y - y) * t;\n    out.z = z + (end.z - z) * t;\n  }\n  static max(left, right, out) {\n    out.x = Math.max(left.x, right.x);\n    out.y = Math.max(left.y, right.y);\n    out.z = Math.max(left.z, right.z);\n  }\n  static min(left, right, out) {\n    out.x = Math.min(left.x, right.x);\n    out.y = Math.min(left.y, right.y);\n    out.z = Math.min(left.z, right.z);\n  }\n  static negate(a, out) {\n    out.x = -a.x;\n    out.y = -a.y;\n    out.z = -a.z;\n  }\n  static normalize(a, out) {\n    const {x, y, z} = a;\n    let len = Math.sqrt(x * x + y * y + z * z);\n    if (len > 0) {\n      len = 1 / len;\n      out.x = x * len;\n      out.y = y * len;\n      out.z = z * len;\n    }\n  }\n  static scale(a, s, out) {\n    out.x = a.x * s;\n    out.y = a.y * s;\n    out.z = a.z * s;\n  }\n  static transformNormal(v, m, out) {\n    const {x, y, z} = v;\n    const e = m.elements;\n    out.x = x * e[0] + y * e[4] + z * e[8];\n    out.y = x * e[1] + y * e[5] + z * e[9];\n    out.z = x * e[2] + y * e[6] + z * e[10];\n  }\n  static transformToVec3(v, m, out) {\n    const {x, y, z} = v;\n    const e = m.elements;\n    out.x = x * e[0] + y * e[4] + z * e[8] + e[12];\n    out.y = x * e[1] + y * e[5] + z * e[9] + e[13];\n    out.z = x * e[2] + y * e[6] + z * e[10] + e[14];\n  }\n  static transformToVec4(v, m, out) {\n    const {x, y, z} = v;\n    const e = m.elements;\n    out.x = x * e[0] + y * e[4] + z * e[8] + e[12];\n    out.y = x * e[1] + y * e[5] + z * e[9] + e[13];\n    out.z = x * e[2] + y * e[6] + z * e[10] + e[14];\n    out.w = x * e[3] + y * e[7] + z * e[11] + e[15];\n  }\n  static transformCoordinate(v, m, out) {\n    const {x, y, z} = v;\n    const e = m.elements;\n    let w = x * e[3] + y * e[7] + z * e[11] + e[15];\n    w = 1 / w;\n    out.x = (x * e[0] + y * e[4] + z * e[8] + e[12]) * w;\n    out.y = (x * e[1] + y * e[5] + z * e[9] + e[13]) * w;\n    out.z = (x * e[2] + y * e[6] + z * e[10] + e[14]) * w;\n  }\n  static transformByQuat(v, q, out) {\n    const {x, y, z} = v;\n    const qx = q.x;\n    const qy = q.y;\n    const qz = q.z;\n    const qw = q.w;\n    const ix = qw * x + qy * z - qz * y;\n    const iy = qw * y + qz * x - qx * z;\n    const iz = qw * z + qx * y - qy * x;\n    const iw = -qx * x - qy * y - qz * z;\n    out.x = ix * qw - iw * qx - iy * qz + iz * qy;\n    out.y = iy * qw - iw * qy - iz * qx + ix * qz;\n    out.z = iz * qw - iw * qz - ix * qy + iy * qx;\n  }\n  constructor(x = 0, y = 0, z = 0) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n  setValue(x, y, z) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    return this;\n  }\n  setValueByArray(array, offset = 0) {\n    this.x = array[offset];\n    this.y = array[offset + 1];\n    this.z = array[offset + 2];\n    return this;\n  }\n  add(right) {\n    this.x += right.x;\n    this.y += right.y;\n    this.z += right.z;\n    return this;\n  }\n  subtract(right) {\n    this.x -= right.x;\n    this.y -= right.y;\n    this.z -= right.z;\n    return this;\n  }\n  multiply(right) {\n    this.x *= right.x;\n    this.y *= right.y;\n    this.z *= right.z;\n    return this;\n  }\n  divide(right) {\n    this.x /= right.x;\n    this.y /= right.y;\n    this.z /= right.z;\n    return this;\n  }\n  length() {\n    const {x, y, z} = this;\n    return Math.sqrt(x * x + y * y + z * z);\n  }\n  lengthSquared() {\n    const {x, y, z} = this;\n    return x * x + y * y + z * z;\n  }\n  negate() {\n    this.x = -this.x;\n    this.y = -this.y;\n    this.z = -this.z;\n    return this;\n  }\n  normalize() {\n    Vector3.normalize(this, this);\n    return this;\n  }\n  scale(s) {\n    this.x *= s;\n    this.y *= s;\n    this.z *= s;\n    return this;\n  }\n  toArray(out, outOffset = 0) {\n    out[outOffset] = this.x;\n    out[outOffset + 1] = this.y;\n    out[outOffset + 2] = this.z;\n  }\n  clone() {\n    return new Vector3(this.x, this.y, this.z);\n  }\n  cloneTo(out) {\n    out.x = this.x;\n    out.y = this.y;\n    out.z = this.z;\n    return out;\n  }\n  transformNormal(m) {\n    Vector3.transformNormal(this, m, this);\n    return this;\n  }\n  transformToVec3(m) {\n    Vector3.transformToVec3(this, m, this);\n    return this;\n  }\n  transformCoordinate(m) {\n    Vector3.transformCoordinate(this, m, this);\n    return this;\n  }\n  transformByQuat(q) {\n    Vector3.transformByQuat(this, q, this);\n    return this;\n  }\n}\nVector3._zero = new Vector3(0, 0, 0);\nVector3._one = new Vector3(1, 1, 1);\nVector3._tempVector3 = new Vector3();\n\nclass BoundingSphere {\n  constructor(minLocal, maxLocal, modelMatrix) {\n    this.center = new Vector3();\n    this.radius = 0;\n    this.centerWorld = new Vector3();\n    this.radiusWorld = 0;\n    let distance = Vector3.distance(minLocal, maxLocal);\n    this.radius = distance * 0.5;\n    Vector3.add(minLocal, maxLocal, this.center);\n    this.center.scale(0.5);\n    this.updateByModelMatrix(modelMatrix);\n  }\n  updateByModelMatrix(modelMatrix) {\n    Vector3.transformCoordinate(this.center, modelMatrix, this.centerWorld);\n    this.radiusWorld = this.radius * getMaxScaleByModelMatrix(modelMatrix);\n  }\n  intersectsFrustum(frustumPlanes) {\n    for (let i = 0; i < 6; i++) {\n      const distance = pointDistanceToPlane(frustumPlanes[i], this.centerWorld);\n      if (distance < -this.radiusWorld) {\n        return IntersectInfo.EXCLUDE;\n      }\n      if (distance < this.radiusWorld) {\n        return IntersectInfo.INTERSECT;\n      }\n    }\n    return IntersectInfo.INCLUDE;\n  }\n  isInFrustum(frustumPlanes) {\n    for (let i = 0; i < 6; i++) {\n      const distance = pointDistanceToPlane(frustumPlanes[i], this.centerWorld);\n      if (distance < -this.radiusWorld) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n\nclass BoundingBox {\n  constructor(minWorld, maxWorld) {\n    this.min = new Vector3();\n    this.max = new Vector3();\n    this.update(minWorld, maxWorld);\n  }\n  update(minWorld, maxWorld) {\n    minWorld.cloneTo(this.min);\n    maxWorld.cloneTo(this.max);\n  }\n  setFromCenterAndSize(center, size) {\n    let halfSize = new Vector3();\n    Vector3.scale(size, 0.5, halfSize);\n    Vector3.subtract(center, halfSize, this.min);\n    Vector3.add(center, halfSize, this.max);\n  }\n  intersectsFrustum(frustumPlanes) {\n    const {min, max} = this;\n    const p1 = new Vector3();\n    const p2 = new Vector3();\n    for (let i = 0; i < 6; i++) {\n      const plane = frustumPlanes[i];\n      p1.x = plane.x > 0 ? min.x : max.x;\n      p2.x = plane.x > 0 ? max.x : min.x;\n      p1.y = plane.y > 0 ? min.y : max.y;\n      p2.y = plane.y > 0 ? max.y : min.y;\n      p1.z = plane.z > 0 ? min.z : max.z;\n      p2.z = plane.z > 0 ? max.z : min.z;\n      const d1 = pointDistanceToPlane(plane, p1);\n      const d2 = pointDistanceToPlane(plane, p2);\n      if (d1 < 0 && d2 < 0) {\n        return IntersectInfo.EXCLUDE;\n      }\n      if (d1 < 0 || d2 < 0) {\n        return IntersectInfo.INTERSECT;\n      }\n    }\n    return IntersectInfo.INCLUDE;\n  }\n  isInFrustum(frustumPlanes) {\n    const min = this.min;\n    const max = this.max;\n    const p = new Vector3();\n    for (let i = 0; i < 6; i++) {\n      const plane = frustumPlanes[i];\n      p.x = plane.x > 0 ? max.x : min.x;\n      p.y = plane.y > 0 ? max.y : min.y;\n      p.z = plane.z > 0 ? max.z : min.z;\n      if (pointDistanceToPlane(plane, p) < 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n  clone() {\n    return new BoundingBox(this.min, this.max);\n  }\n  cloneTo(out) {\n    this.min.cloneTo(out.min);\n    this.max.cloneTo(out.max);\n  }\n}\n\nclass Matrix3x3 {\n  constructor(m11 = 1, m12 = 0, m13 = 0, m21 = 0, m22 = 1, m23 = 0, m31 = 0, m32 = 0, m33 = 1) {\n    this.elements = new Float32Array(9);\n    const e = this.elements;\n    e[0] = m11;\n    e[1] = m12;\n    e[2] = m13;\n    e[3] = m21;\n    e[4] = m22;\n    e[5] = m23;\n    e[6] = m31;\n    e[7] = m32;\n    e[8] = m33;\n  }\n  static add(left, right, out) {\n    const le = left.elements;\n    const re = right.elements;\n    const oe = out.elements;\n    oe[0] = le[0] + re[0];\n    oe[1] = le[1] + re[1];\n    oe[2] = le[2] + re[2];\n    oe[3] = le[3] + re[3];\n    oe[4] = le[4] + re[4];\n    oe[5] = le[5] + re[5];\n    oe[6] = le[6] + re[6];\n    oe[7] = le[7] + re[7];\n    oe[8] = le[8] + re[8];\n  }\n  static subtract(left, right, out) {\n    const le = left.elements;\n    const re = right.elements;\n    const oe = out.elements;\n    oe[0] = le[0] - re[0];\n    oe[1] = le[1] - re[1];\n    oe[2] = le[2] - re[2];\n    oe[3] = le[3] - re[3];\n    oe[4] = le[4] - re[4];\n    oe[5] = le[5] - re[5];\n    oe[6] = le[6] - re[6];\n    oe[7] = le[7] - re[7];\n    oe[8] = le[8] - re[8];\n  }\n  static multiply(left, right, out) {\n    const le = left.elements;\n    const re = right.elements;\n    const oe = out.elements;\n    const l11 = le[0], l12 = le[1], l13 = le[2];\n    const l21 = le[3], l22 = le[4], l23 = le[5];\n    const l31 = le[6], l32 = le[7], l33 = le[8];\n    const r11 = re[0], r12 = re[1], r13 = re[2];\n    const r21 = re[3], r22 = re[4], r23 = re[5];\n    const r31 = re[6], r32 = re[7], r33 = re[8];\n    oe[0] = l11 * r11 + l21 * r12 + l31 * r13;\n    oe[1] = l12 * r11 + l22 * r12 + l32 * r13;\n    oe[2] = l13 * r11 + l23 * r12 + l33 * r13;\n    oe[3] = l11 * r21 + l21 * r22 + l31 * r23;\n    oe[4] = l12 * r21 + l22 * r22 + l32 * r23;\n    oe[5] = l13 * r21 + l23 * r22 + l33 * r23;\n    oe[6] = l11 * r31 + l21 * r32 + l31 * r33;\n    oe[7] = l12 * r31 + l22 * r32 + l32 * r33;\n    oe[8] = l13 * r31 + l23 * r32 + l33 * r33;\n  }\n  static equals(left, right) {\n    const le = left.elements;\n    const re = right.elements;\n    return MathUtil.equals(le[0], re[0]) && MathUtil.equals(le[1], re[1]) && MathUtil.equals(le[2], re[2]) && MathUtil.equals(le[3], re[3]) && MathUtil.equals(le[4], re[4]) && MathUtil.equals(le[5], re[5]) && MathUtil.equals(le[6], re[6]) && MathUtil.equals(le[7], re[7]) && MathUtil.equals(le[8], re[8]);\n  }\n  static rotationQuaternion(q, out) {\n    const oe = out.elements;\n    const {x, y, z, w} = q;\n    const x2 = x + x;\n    const y2 = y + y;\n    const z2 = z + z;\n    const xx = x * x2;\n    const yx = y * x2;\n    const yy = y * y2;\n    const zx = z * x2;\n    const zy = z * y2;\n    const zz = z * z2;\n    const wx = w * x2;\n    const wy = w * y2;\n    const wz = w * z2;\n    oe[0] = 1 - yy - zz;\n    oe[3] = yx - wz;\n    oe[6] = zx + wy;\n    oe[1] = yx + wz;\n    oe[4] = 1 - xx - zz;\n    oe[7] = zy - wx;\n    oe[2] = zx - wy;\n    oe[5] = zy + wx;\n    oe[8] = 1 - xx - yy;\n  }\n  static scaling(s, out) {\n    const oe = out.elements;\n    oe[0] = s.x;\n    oe[1] = 0;\n    oe[2] = 0;\n    oe[3] = 0;\n    oe[4] = s.y;\n    oe[5] = 0;\n    oe[6] = 0;\n    oe[7] = 0;\n    oe[8] = 1;\n  }\n  static translation(trans, out) {\n    const oe = out.elements;\n    oe[0] = 1;\n    oe[1] = 0;\n    oe[2] = 0;\n    oe[3] = 0;\n    oe[4] = 1;\n    oe[5] = 0;\n    oe[6] = trans.x;\n    oe[7] = trans.y;\n    oe[8] = 1;\n  }\n  static invert(a, out) {\n    const ae = a.elements;\n    const oe = out.elements;\n    const a11 = ae[0], a12 = ae[1], a13 = ae[2];\n    const a21 = ae[3], a22 = ae[4], a23 = ae[5];\n    const a31 = ae[6], a32 = ae[7], a33 = ae[8];\n    const b12 = a33 * a22 - a23 * a32;\n    const b22 = -a33 * a21 + a23 * a31;\n    const b32 = a32 * a21 - a22 * a31;\n    let det = a11 * b12 + a12 * b22 + a13 * b32;\n    if (!det) {\n      return;\n    }\n    det = 1 / det;\n    oe[0] = b12 * det;\n    oe[1] = (-a33 * a12 + a13 * a32) * det;\n    oe[2] = (a23 * a12 - a13 * a22) * det;\n    oe[3] = b22 * det;\n    oe[4] = (a33 * a11 - a13 * a31) * det;\n    oe[5] = (-a23 * a11 + a13 * a21) * det;\n    oe[6] = b32 * det;\n    oe[7] = (-a32 * a11 + a12 * a31) * det;\n    oe[8] = (a22 * a11 - a12 * a21) * det;\n  }\n  static normalMatrix(mat4, out) {\n    const ae = mat4.elements;\n    const oe = out.elements;\n    const a11 = ae[0], a12 = ae[1], a13 = ae[2], a14 = ae[3];\n    const a21 = ae[4], a22 = ae[5], a23 = ae[6], a24 = ae[7];\n    const a31 = ae[8], a32 = ae[9], a33 = ae[10], a34 = ae[11];\n    const a41 = ae[12], a42 = ae[13], a43 = ae[14], a44 = ae[15];\n    const b00 = a11 * a22 - a12 * a21;\n    const b01 = a11 * a23 - a13 * a21;\n    const b02 = a11 * a24 - a14 * a21;\n    const b03 = a12 * a23 - a13 * a22;\n    const b04 = a12 * a24 - a14 * a22;\n    const b05 = a13 * a24 - a14 * a23;\n    const b06 = a31 * a42 - a32 * a41;\n    const b07 = a31 * a43 - a33 * a41;\n    const b08 = a31 * a44 - a34 * a41;\n    const b09 = a32 * a43 - a33 * a42;\n    const b10 = a32 * a44 - a34 * a42;\n    const b11 = a33 * a44 - a34 * a43;\n    let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n    if (!det) {\n      return null;\n    }\n    det = 1 / det;\n    oe[0] = (a22 * b11 - a23 * b10 + a24 * b09) * det;\n    oe[1] = (a23 * b08 - a21 * b11 - a24 * b07) * det;\n    oe[2] = (a21 * b10 - a22 * b08 + a24 * b06) * det;\n    oe[3] = (a13 * b10 - a12 * b11 - a14 * b09) * det;\n    oe[4] = (a11 * b11 - a13 * b08 + a14 * b07) * det;\n    oe[5] = (a12 * b08 - a11 * b10 - a14 * b06) * det;\n    oe[6] = (a42 * b05 - a43 * b04 + a44 * b03) * det;\n    oe[7] = (a43 * b02 - a41 * b05 - a44 * b01) * det;\n    oe[8] = (a41 * b04 - a42 * b02 + a44 * b00) * det;\n  }\n  static rotate(a, r, out) {\n    const ae = a.elements;\n    const oe = out.elements;\n    const s = Math.sin(r);\n    const c = Math.cos(r);\n    const a11 = ae[0], a12 = ae[1], a13 = ae[2];\n    const a21 = ae[3], a22 = ae[4], a23 = ae[5];\n    const a31 = ae[6], a32 = ae[7], a33 = ae[8];\n    oe[0] = c * a11 + s * a21;\n    oe[1] = c * a12 + s * a22;\n    oe[2] = c * a13 + s * a23;\n    oe[3] = c * a21 - s * a11;\n    oe[4] = c * a22 - s * a12;\n    oe[5] = c * a23 - s * a13;\n    oe[6] = a31;\n    oe[7] = a32;\n    oe[8] = a33;\n  }\n  static scale(m, s, out) {\n    const {x, y} = s;\n    const ae = m.elements;\n    const oe = out.elements;\n    oe[0] = x * ae[0];\n    oe[1] = x * ae[1];\n    oe[2] = x * ae[2];\n    oe[3] = y * ae[3];\n    oe[4] = y * ae[4];\n    oe[5] = y * ae[5];\n    oe[6] = ae[6];\n    oe[7] = ae[7];\n    oe[8] = ae[8];\n  }\n  static translate(m, trans, out) {\n    const {x, y} = trans;\n    const ae = m.elements;\n    const oe = out.elements;\n    const a11 = ae[0], a12 = ae[1], a13 = ae[2];\n    const a21 = ae[3], a22 = ae[4], a23 = ae[5];\n    const a31 = ae[6], a32 = ae[7], a33 = ae[8];\n    oe[0] = a11;\n    oe[1] = a12;\n    oe[2] = a13;\n    oe[3] = a21;\n    oe[4] = a22;\n    oe[5] = a23;\n    oe[6] = x * a11 + y * a21 + a31;\n    oe[7] = x * a12 + y * a22 + a32;\n    oe[8] = x * a13 + y * a23 + a33;\n  }\n  static transpose(a, out) {\n    const ae = a.elements;\n    const oe = out.elements;\n    if (out === a) {\n      const a12 = ae[1];\n      const a13 = ae[2];\n      const a23 = ae[5];\n      oe[1] = ae[3];\n      oe[2] = ae[6];\n      oe[3] = a12;\n      oe[5] = ae[7];\n      oe[6] = a13;\n      oe[7] = a23;\n    } else {\n      oe[0] = ae[0];\n      oe[1] = ae[3];\n      oe[2] = ae[6];\n      oe[3] = ae[1];\n      oe[4] = ae[4];\n      oe[5] = ae[7];\n      oe[6] = ae[2];\n      oe[7] = ae[5];\n      oe[8] = ae[8];\n    }\n  }\n  setValue(m11, m12, m13, m21, m22, m23, m31, m32, m33) {\n    const e = this.elements;\n    e[0] = m11;\n    e[1] = m12;\n    e[2] = m13;\n    e[3] = m21;\n    e[4] = m22;\n    e[5] = m23;\n    e[6] = m31;\n    e[7] = m32;\n    e[8] = m33;\n    return this;\n  }\n  setValueByArray(array, offset = 0) {\n    const srce = this.elements;\n    for (let i = 0; i < 12; i++) {\n      srce[i] = array[i + offset];\n    }\n    return this;\n  }\n  setValueByMatrix(a) {\n    const ae = a.elements;\n    const e = this.elements;\n    e[0] = ae[0];\n    e[1] = ae[1];\n    e[2] = ae[2];\n    e[3] = ae[4];\n    e[4] = ae[5];\n    e[5] = ae[6];\n    e[6] = ae[8];\n    e[7] = ae[9];\n    e[8] = ae[10];\n    return this;\n  }\n  toArray(out, outOffset = 0) {\n    const e = this.elements;\n    out[outOffset] = e[0];\n    out[outOffset + 1] = e[1];\n    out[outOffset + 2] = e[2];\n    out[outOffset + 3] = e[3];\n    out[outOffset + 4] = e[4];\n    out[outOffset + 5] = e[5];\n    out[outOffset + 6] = e[6];\n    out[outOffset + 7] = e[7];\n    out[outOffset + 8] = e[8];\n  }\n  clone() {\n    const e = this.elements;\n    let ret = new Matrix3x3(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8]);\n    return ret;\n  }\n  cloneTo(out) {\n    const e = this.elements;\n    const oe = out.elements;\n    oe[0] = e[0];\n    oe[1] = e[1];\n    oe[2] = e[2];\n    oe[3] = e[3];\n    oe[4] = e[4];\n    oe[5] = e[5];\n    oe[6] = e[6];\n    oe[7] = e[7];\n    oe[8] = e[8];\n    return out;\n  }\n  add(right) {\n    Matrix3x3.add(this, right, this);\n    return this;\n  }\n  subtract(right) {\n    Matrix3x3.subtract(this, right, this);\n    return this;\n  }\n  multiply(right) {\n    Matrix3x3.multiply(this, right, this);\n    return this;\n  }\n  determinant() {\n    const e = this.elements;\n    const a11 = e[0], a12 = e[1], a13 = e[2];\n    const a21 = e[3], a22 = e[4], a23 = e[5];\n    const a31 = e[6], a32 = e[7], a33 = e[8];\n    const b12 = a33 * a22 - a23 * a32;\n    const b22 = -a33 * a21 + a23 * a31;\n    const b32 = a32 * a21 - a22 * a31;\n    return a11 * b12 + a12 * b22 + a13 * b32;\n  }\n  identity() {\n    const e = this.elements;\n    e[0] = 1;\n    e[1] = 0;\n    e[2] = 0;\n    e[3] = 0;\n    e[4] = 1;\n    e[5] = 0;\n    e[6] = 0;\n    e[7] = 0;\n    e[8] = 1;\n    return this;\n  }\n  invert() {\n    Matrix3x3.invert(this, this);\n    return this;\n  }\n  rotate(r) {\n    Matrix3x3.rotate(this, r, this);\n    return this;\n  }\n  scale(s) {\n    Matrix3x3.scale(this, s, this);\n    return this;\n  }\n  translate(trans) {\n    Matrix3x3.translate(this, trans, this);\n    return this;\n  }\n  transpose() {\n    Matrix3x3.transpose(this, this);\n    return this;\n  }\n}\n\nclass Quaternion {\n  static add(left, right, out) {\n    out.x = left.x + right.x;\n    out.y = left.y + right.y;\n    out.z = left.z + right.z;\n    out.w = left.w + right.w;\n  }\n  static multiply(left, right, out) {\n    const ax = left.x, ay = left.y, az = left.z, aw = left.w;\n    const bx = right.x, by = right.y, bz = right.z, bw = right.w;\n    out.x = ax * bw + aw * bx + ay * bz - az * by;\n    out.y = ay * bw + aw * by + az * bx - ax * bz;\n    out.z = az * bw + aw * bz + ax * by - ay * bx;\n    out.w = aw * bw - ax * bx - ay * by - az * bz;\n  }\n  static conjugate(a, out) {\n    out.x = -a.x;\n    out.y = -a.y;\n    out.z = -a.z;\n    out.w = a.w;\n  }\n  static dot(left, right) {\n    return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;\n  }\n  static equals(left, right) {\n    return MathUtil.equals(left.x, right.x) && MathUtil.equals(left.y, right.y) && MathUtil.equals(left.z, right.z) && MathUtil.equals(left.w, right.w);\n  }\n  static rotationAxisAngle(axis, rad, out) {\n    const normalAxis = Quaternion._tempVector3;\n    Vector3.normalize(axis, normalAxis);\n    rad *= 0.5;\n    const s = Math.sin(rad);\n    out.x = normalAxis.x * s;\n    out.y = normalAxis.y * s;\n    out.z = normalAxis.z * s;\n    out.w = Math.cos(rad);\n  }\n  static rotationEuler(x, y, z, out) {\n    Quaternion.rotationYawPitchRoll(y, x, z, out);\n  }\n  static rotationYawPitchRoll(yaw, pitch, roll, out) {\n    const halfRoll = roll * 0.5;\n    const halfPitch = pitch * 0.5;\n    const halfYaw = yaw * 0.5;\n    const sinRoll = Math.sin(halfRoll);\n    const cosRoll = Math.cos(halfRoll);\n    const sinPitch = Math.sin(halfPitch);\n    const cosPitch = Math.cos(halfPitch);\n    const sinYaw = Math.sin(halfYaw);\n    const cosYaw = Math.cos(halfYaw);\n    const cosYawPitch = cosYaw * cosPitch;\n    const sinYawPitch = sinYaw * sinPitch;\n    out.x = cosYaw * sinPitch * cosRoll + sinYaw * cosPitch * sinRoll;\n    out.y = sinYaw * cosPitch * cosRoll - cosYaw * sinPitch * sinRoll;\n    out.z = cosYawPitch * sinRoll - sinYawPitch * cosRoll;\n    out.w = cosYawPitch * cosRoll + sinYawPitch * sinRoll;\n  }\n  static rotationMatrix3x3(m, out) {\n    const me = m.elements;\n    const m11 = me[0], m12 = me[1], m13 = me[2];\n    const m21 = me[3], m22 = me[4], m23 = me[5];\n    const m31 = me[6], m32 = me[7], m33 = me[8];\n    const scale = m11 + m22 + m33;\n    let sqrt, half;\n    if (scale > 0) {\n      sqrt = Math.sqrt(scale + 1);\n      out.w = sqrt * 0.5;\n      sqrt = 0.5 / sqrt;\n      out.x = (m23 - m32) * sqrt;\n      out.y = (m31 - m13) * sqrt;\n      out.z = (m12 - m21) * sqrt;\n    } else if (m11 >= m22 && m11 >= m33) {\n      sqrt = Math.sqrt(1 + m11 - m22 - m33);\n      half = 0.5 / sqrt;\n      out.x = 0.5 * sqrt;\n      out.y = (m12 + m21) * half;\n      out.z = (m13 + m31) * half;\n      out.w = (m23 - m32) * half;\n    } else if (m22 > m33) {\n      sqrt = Math.sqrt(1 + m22 - m11 - m33);\n      half = 0.5 / sqrt;\n      out.x = (m21 + m12) * half;\n      out.y = 0.5 * sqrt;\n      out.z = (m32 + m23) * half;\n      out.w = (m31 - m13) * half;\n    } else {\n      sqrt = Math.sqrt(1 + m33 - m11 - m22);\n      half = 0.5 / sqrt;\n      out.x = (m13 + m31) * half;\n      out.y = (m23 + m32) * half;\n      out.z = 0.5 * sqrt;\n      out.w = (m12 - m21) * half;\n    }\n  }\n  static invert(a, out) {\n    const {x, y, z, w} = a;\n    const dot = x * x + y * y + z * z + w * w;\n    if (dot > MathUtil.zeroTolerance) {\n      const invDot = 1 / dot;\n      out.x = -x * invDot;\n      out.y = -y * invDot;\n      out.z = -z * invDot;\n      out.w = w * invDot;\n    }\n  }\n  static lerp(start, end, t, out) {\n    const inv = 1 - t;\n    if (Quaternion.dot(start, end) >= 0) {\n      out.x = start.x * inv + end.x * t;\n      out.y = start.y * inv + end.y * t;\n      out.z = start.z * inv + end.z * t;\n      out.w = start.w * inv + end.w * t;\n    } else {\n      out.x = start.x * inv - end.x * t;\n      out.y = start.y * inv - end.y * t;\n      out.z = start.z * inv - end.z * t;\n      out.w = start.w * inv - end.w * t;\n    }\n    out.normalize();\n  }\n  static slerp(start, end, t, out) {\n    const ax = start.x;\n    const ay = start.y;\n    const az = start.z;\n    const aw = start.w;\n    let bx = end.x;\n    let by = end.y;\n    let bz = end.z;\n    let bw = end.w;\n    let scale0, scale1;\n    let cosom = ax * bx + ay * by + az * bz + aw * bw;\n    if (cosom < 0) {\n      cosom = -cosom;\n      bx = -bx;\n      by = -by;\n      bz = -bz;\n      bw = -bw;\n    }\n    if (1 - cosom > MathUtil.zeroTolerance) {\n      const omega = Math.acos(cosom);\n      const sinom = Math.sin(omega);\n      scale0 = Math.sin((1 - t) * omega) / sinom;\n      scale1 = Math.sin(t * omega) / sinom;\n    } else {\n      scale0 = 1 - t;\n      scale1 = t;\n    }\n    out.x = scale0 * ax + scale1 * bx;\n    out.y = scale0 * ay + scale1 * by;\n    out.z = scale0 * az + scale1 * bz;\n    out.w = scale0 * aw + scale1 * bw;\n  }\n  static normalize(a, out) {\n    const {x, y, z, w} = a;\n    let len = Math.sqrt(x * x + y * y + z * z + w * w);\n    if (len > MathUtil.zeroTolerance) {\n      len = 1 / len;\n      out.x = x * len;\n      out.y = y * len;\n      out.z = z * len;\n      out.w = w * len;\n    }\n  }\n  static rotationX(rad, out) {\n    rad *= 0.5;\n    const s = Math.sin(rad);\n    const c = Math.cos(rad);\n    out.x = s;\n    out.y = 0;\n    out.z = 0;\n    out.w = c;\n  }\n  static rotationY(rad, out) {\n    rad *= 0.5;\n    const s = Math.sin(rad);\n    const c = Math.cos(rad);\n    out.x = 0;\n    out.y = s;\n    out.z = 0;\n    out.w = c;\n  }\n  static rotationZ(rad, out) {\n    rad *= 0.5;\n    const s = Math.sin(rad);\n    const c = Math.cos(rad);\n    out.x = 0;\n    out.y = 0;\n    out.z = s;\n    out.w = c;\n  }\n  static rotateX(q, rad, out) {\n    const {x, y, z, w} = q;\n    rad *= 0.5;\n    const bx = Math.sin(rad);\n    const bw = Math.cos(rad);\n    out.x = x * bw + w * bx;\n    out.y = y * bw + z * bx;\n    out.z = z * bw - y * bx;\n    out.w = w * bw - x * bx;\n  }\n  static rotateY(q, rad, out) {\n    const {x, y, z, w} = q;\n    rad *= 0.5;\n    const by = Math.sin(rad);\n    const bw = Math.cos(rad);\n    out.x = x * bw - z * by;\n    out.y = y * bw + w * by;\n    out.z = z * bw + x * by;\n    out.w = w * bw - y * by;\n  }\n  static rotateZ(q, rad, out) {\n    const {x, y, z, w} = q;\n    rad *= 0.5;\n    const bz = Math.sin(rad);\n    const bw = Math.cos(rad);\n    out.x = x * bw + y * bz;\n    out.y = y * bw - x * bz;\n    out.z = z * bw + w * bz;\n    out.w = w * bw - z * bz;\n  }\n  static scale(a, s, out) {\n    out.x = a.x * s;\n    out.y = a.y * s;\n    out.z = a.z * s;\n    out.w = a.w * s;\n  }\n  constructor(x = 0, y = 0, z = 0, w = 1) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.w = w;\n  }\n  setValue(x, y, z, w) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.w = w;\n    return this;\n  }\n  setValueByArray(array, offset = 0) {\n    this.x = array[offset];\n    this.y = array[offset + 1];\n    this.z = array[offset + 2];\n    this.w = array[offset + 3];\n    return this;\n  }\n  conjugate() {\n    this.x *= -1;\n    this.y *= -1;\n    this.z *= -1;\n    return this;\n  }\n  getAxisAngle(out) {\n    const {x, y, z} = this;\n    const length = x * x + y * y + z * z;\n    if (length < MathUtil.zeroTolerance) {\n      out.x = 1;\n      out.y = 0;\n      out.z = 0;\n      return 0;\n    } else {\n      const inv = 1 / length;\n      out.x = this.x * inv;\n      out.y = this.y * inv;\n      out.z = this.z * inv;\n      return Math.acos(this.w) * 2;\n    }\n  }\n  identity() {\n    this.x = 0;\n    this.y = 0;\n    this.z = 0;\n    this.w = 1;\n    return this;\n  }\n  length() {\n    const {x, y, z, w} = this;\n    return Math.sqrt(x * x + y * y + z * z + w * w);\n  }\n  lengthSquared() {\n    const {x, y, z, w} = this;\n    return x * x + y * y + z * z + w * w;\n  }\n  normalize() {\n    Quaternion.normalize(this, this);\n    return this;\n  }\n  toEuler(out) {\n    this.toYawPitchRoll(out);\n    const t = out.x;\n    out.x = out.y;\n    out.y = t;\n    return out;\n  }\n  toYawPitchRoll(out) {\n    const {x, y, z, w} = this;\n    const xx = x * x;\n    const yy = y * y;\n    const zz = z * z;\n    const xy = x * y;\n    const zw = z * w;\n    const zx = z * x;\n    const yw = y * w;\n    const yz = y * z;\n    const xw = x * w;\n    out.y = Math.asin(2 * (xw - yz));\n    if (Math.cos(out.y) > MathUtil.zeroTolerance) {\n      out.z = Math.atan2(2 * (xy + zw), 1 - 2 * (zz + xx));\n      out.x = Math.atan2(2 * (zx + yw), 1 - 2 * (yy + xx));\n    } else {\n      out.z = Math.atan2(-2 * (xy - zw), 1 - 2 * (yy + zz));\n      out.x = 0;\n    }\n    return out;\n  }\n  toArray(out, outOffset = 0) {\n    out[outOffset] = this.x;\n    out[outOffset + 1] = this.y;\n    out[outOffset + 2] = this.z;\n    out[outOffset + 3] = this.w;\n  }\n  clone() {\n    return new Quaternion(this.x, this.y, this.z, this.w);\n  }\n  cloneTo(out) {\n    out.x = this.x;\n    out.y = this.y;\n    out.z = this.z;\n    out.w = this.w;\n    return out;\n  }\n  rotateX(rad) {\n    Quaternion.rotateX(this, rad, this);\n    return this;\n  }\n  rotateY(rad) {\n    Quaternion.rotateY(this, rad, this);\n    return this;\n  }\n  rotateZ(rad) {\n    Quaternion.rotateZ(this, rad, this);\n    return this;\n  }\n  rotationAxisAngle(axis, rad) {\n    Quaternion.rotationAxisAngle(axis, rad, this);\n    return this;\n  }\n  multiply(quat) {\n    Quaternion.multiply(this, quat, this);\n    return this;\n  }\n  invert() {\n    Quaternion.invert(this, this);\n    return this;\n  }\n  dot(quat) {\n    return Quaternion.dot(this, quat);\n  }\n  lerp(quat, t) {\n    Quaternion.lerp(this, quat, t, this);\n    return this;\n  }\n}\nQuaternion._tempVector3 = new Vector3();\n\nclass Matrix {\n  constructor(m11 = 1, m12 = 0, m13 = 0, m14 = 0, m21 = 0, m22 = 1, m23 = 0, m24 = 0, m31 = 0, m32 = 0, m33 = 1, m34 = 0, m41 = 0, m42 = 0, m43 = 0, m44 = 1) {\n    this.elements = new Float32Array(16);\n    const e = this.elements;\n    e[0] = m11;\n    e[1] = m12;\n    e[2] = m13;\n    e[3] = m14;\n    e[4] = m21;\n    e[5] = m22;\n    e[6] = m23;\n    e[7] = m24;\n    e[8] = m31;\n    e[9] = m32;\n    e[10] = m33;\n    e[11] = m34;\n    e[12] = m41;\n    e[13] = m42;\n    e[14] = m43;\n    e[15] = m44;\n  }\n  static multiply(left, right, out) {\n    const le = left.elements;\n    const re = right.elements;\n    const oe = out.elements;\n    const l11 = le[0], l12 = le[1], l13 = le[2], l14 = le[3];\n    const l21 = le[4], l22 = le[5], l23 = le[6], l24 = le[7];\n    const l31 = le[8], l32 = le[9], l33 = le[10], l34 = le[11];\n    const l41 = le[12], l42 = le[13], l43 = le[14], l44 = le[15];\n    const r11 = re[0], r12 = re[1], r13 = re[2], r14 = re[3];\n    const r21 = re[4], r22 = re[5], r23 = re[6], r24 = re[7];\n    const r31 = re[8], r32 = re[9], r33 = re[10], r34 = re[11];\n    const r41 = re[12], r42 = re[13], r43 = re[14], r44 = re[15];\n    oe[0] = l11 * r11 + l21 * r12 + l31 * r13 + l41 * r14;\n    oe[1] = l12 * r11 + l22 * r12 + l32 * r13 + l42 * r14;\n    oe[2] = l13 * r11 + l23 * r12 + l33 * r13 + l43 * r14;\n    oe[3] = l14 * r11 + l24 * r12 + l34 * r13 + l44 * r14;\n    oe[4] = l11 * r21 + l21 * r22 + l31 * r23 + l41 * r24;\n    oe[5] = l12 * r21 + l22 * r22 + l32 * r23 + l42 * r24;\n    oe[6] = l13 * r21 + l23 * r22 + l33 * r23 + l43 * r24;\n    oe[7] = l14 * r21 + l24 * r22 + l34 * r23 + l44 * r24;\n    oe[8] = l11 * r31 + l21 * r32 + l31 * r33 + l41 * r34;\n    oe[9] = l12 * r31 + l22 * r32 + l32 * r33 + l42 * r34;\n    oe[10] = l13 * r31 + l23 * r32 + l33 * r33 + l43 * r34;\n    oe[11] = l14 * r31 + l24 * r32 + l34 * r33 + l44 * r34;\n    oe[12] = l11 * r41 + l21 * r42 + l31 * r43 + l41 * r44;\n    oe[13] = l12 * r41 + l22 * r42 + l32 * r43 + l42 * r44;\n    oe[14] = l13 * r41 + l23 * r42 + l33 * r43 + l43 * r44;\n    oe[15] = l14 * r41 + l24 * r42 + l34 * r43 + l44 * r44;\n  }\n  static equals(left, right) {\n    const le = left.elements;\n    const re = right.elements;\n    return MathUtil.equals(le[0], re[0]) && MathUtil.equals(le[1], re[1]) && MathUtil.equals(le[2], re[2]) && MathUtil.equals(le[3], re[3]) && MathUtil.equals(le[4], re[4]) && MathUtil.equals(le[5], re[5]) && MathUtil.equals(le[6], re[6]) && MathUtil.equals(le[7], re[7]) && MathUtil.equals(le[8], re[8]) && MathUtil.equals(le[9], re[9]) && MathUtil.equals(le[10], re[10]) && MathUtil.equals(le[11], re[11]) && MathUtil.equals(le[12], re[12]) && MathUtil.equals(le[13], re[13]) && MathUtil.equals(le[14], re[14]) && MathUtil.equals(le[15], re[15]);\n  }\n  static rotationQuaternion(q, out) {\n    const oe = out.elements;\n    const {x, y, z, w} = q;\n    let x2 = x + x;\n    let y2 = y + y;\n    let z2 = z + z;\n    let xx = x * x2;\n    let yx = y * x2;\n    let yy = y * y2;\n    let zx = z * x2;\n    let zy = z * y2;\n    let zz = z * z2;\n    let wx = w * x2;\n    let wy = w * y2;\n    let wz = w * z2;\n    oe[0] = 1 - yy - zz;\n    oe[1] = yx + wz;\n    oe[2] = zx - wy;\n    oe[3] = 0;\n    oe[4] = yx - wz;\n    oe[5] = 1 - xx - zz;\n    oe[6] = zy + wx;\n    oe[7] = 0;\n    oe[8] = zx + wy;\n    oe[9] = zy - wx;\n    oe[10] = 1 - xx - yy;\n    oe[11] = 0;\n    oe[12] = 0;\n    oe[13] = 0;\n    oe[14] = 0;\n    oe[15] = 1;\n  }\n  static rotationAxisAngle(axis, r, out) {\n    const oe = out.elements;\n    let {x, y, z} = axis;\n    let len = Math.sqrt(x * x + y * y + z * z);\n    let s, c, t;\n    if (Math.abs(len) < MathUtil.zeroTolerance) {\n      return;\n    }\n    len = 1 / len;\n    x *= len;\n    y *= len;\n    z *= len;\n    s = Math.sin(r);\n    c = Math.cos(r);\n    t = 1 - c;\n    oe[0] = x * x * t + c;\n    oe[1] = y * x * t + z * s;\n    oe[2] = z * x * t - y * s;\n    oe[3] = 0;\n    oe[4] = x * y * t - z * s;\n    oe[5] = y * y * t + c;\n    oe[6] = z * y * t + x * s;\n    oe[7] = 0;\n    oe[8] = x * z * t + y * s;\n    oe[9] = y * z * t - x * s;\n    oe[10] = z * z * t + c;\n    oe[11] = 0;\n    oe[12] = 0;\n    oe[13] = 0;\n    oe[14] = 0;\n    oe[15] = 1;\n  }\n  static rotationTranslation(q, trans, out) {\n    Matrix.rotationQuaternion(q, out);\n    const oe = out.elements;\n    oe[12] = trans.x;\n    oe[13] = trans.y;\n    oe[14] = trans.z;\n  }\n  static affineTransformation(scale, rotation, trans, out) {\n    const oe = out.elements;\n    const {x, y, z, w} = rotation;\n    let x2 = x + x;\n    let y2 = y + y;\n    let z2 = z + z;\n    let xx = x * x2;\n    let xy = x * y2;\n    let xz = x * z2;\n    let yy = y * y2;\n    let yz = y * z2;\n    let zz = z * z2;\n    let wx = w * x2;\n    let wy = w * y2;\n    let wz = w * z2;\n    let sx = scale.x;\n    let sy = scale.y;\n    let sz = scale.z;\n    oe[0] = (1 - (yy + zz)) * sx;\n    oe[1] = (xy + wz) * sx;\n    oe[2] = (xz - wy) * sx;\n    oe[3] = 0;\n    oe[4] = (xy - wz) * sy;\n    oe[5] = (1 - (xx + zz)) * sy;\n    oe[6] = (yz + wx) * sy;\n    oe[7] = 0;\n    oe[8] = (xz + wy) * sz;\n    oe[9] = (yz - wx) * sz;\n    oe[10] = (1 - (xx + yy)) * sz;\n    oe[11] = 0;\n    oe[12] = trans.x;\n    oe[13] = trans.y;\n    oe[14] = trans.z;\n    oe[15] = 1;\n  }\n  static scaling(s, out) {\n    const oe = out.elements;\n    oe[0] = s.x;\n    oe[1] = 0;\n    oe[2] = 0;\n    oe[3] = 0;\n    oe[4] = 0;\n    oe[5] = s.y;\n    oe[6] = 0;\n    oe[7] = 0;\n    oe[8] = 0;\n    oe[9] = 0;\n    oe[10] = s.z;\n    oe[11] = 0;\n    oe[12] = 0;\n    oe[13] = 0;\n    oe[14] = 0;\n    oe[15] = 1;\n  }\n  static translation(trans, out) {\n    const oe = out.elements;\n    oe[0] = 1;\n    oe[1] = 0;\n    oe[2] = 0;\n    oe[3] = 0;\n    oe[4] = 0;\n    oe[5] = 1;\n    oe[6] = 0;\n    oe[7] = 0;\n    oe[8] = 0;\n    oe[9] = 0;\n    oe[10] = 1;\n    oe[11] = 0;\n    oe[12] = trans.x;\n    oe[13] = trans.y;\n    oe[14] = trans.z;\n    oe[15] = 1;\n  }\n  static invert(a, out) {\n    const ae = a.elements;\n    const oe = out.elements;\n    const a11 = ae[0], a12 = ae[1], a13 = ae[2], a14 = ae[3];\n    const a21 = ae[4], a22 = ae[5], a23 = ae[6], a24 = ae[7];\n    const a31 = ae[8], a32 = ae[9], a33 = ae[10], a34 = ae[11];\n    const a41 = ae[12], a42 = ae[13], a43 = ae[14], a44 = ae[15];\n    const b00 = a11 * a22 - a12 * a21;\n    const b01 = a11 * a23 - a13 * a21;\n    const b02 = a11 * a24 - a14 * a21;\n    const b03 = a12 * a23 - a13 * a22;\n    const b04 = a12 * a24 - a14 * a22;\n    const b05 = a13 * a24 - a14 * a23;\n    const b06 = a31 * a42 - a32 * a41;\n    const b07 = a31 * a43 - a33 * a41;\n    const b08 = a31 * a44 - a34 * a41;\n    const b09 = a32 * a43 - a33 * a42;\n    const b10 = a32 * a44 - a34 * a42;\n    const b11 = a33 * a44 - a34 * a43;\n    let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n    if (!det) {\n      return null;\n    }\n    det = 1 / det;\n    oe[0] = (a22 * b11 - a23 * b10 + a24 * b09) * det;\n    oe[1] = (a13 * b10 - a12 * b11 - a14 * b09) * det;\n    oe[2] = (a42 * b05 - a43 * b04 + a44 * b03) * det;\n    oe[3] = (a33 * b04 - a32 * b05 - a34 * b03) * det;\n    oe[4] = (a23 * b08 - a21 * b11 - a24 * b07) * det;\n    oe[5] = (a11 * b11 - a13 * b08 + a14 * b07) * det;\n    oe[6] = (a43 * b02 - a41 * b05 - a44 * b01) * det;\n    oe[7] = (a31 * b05 - a33 * b02 + a34 * b01) * det;\n    oe[8] = (a21 * b10 - a22 * b08 + a24 * b06) * det;\n    oe[9] = (a12 * b08 - a11 * b10 - a14 * b06) * det;\n    oe[10] = (a41 * b04 - a42 * b02 + a44 * b00) * det;\n    oe[11] = (a32 * b02 - a31 * b04 - a34 * b00) * det;\n    oe[12] = (a22 * b07 - a21 * b09 - a23 * b06) * det;\n    oe[13] = (a11 * b09 - a12 * b07 + a13 * b06) * det;\n    oe[14] = (a42 * b01 - a41 * b03 - a43 * b00) * det;\n    oe[15] = (a31 * b03 - a32 * b01 + a33 * b00) * det;\n  }\n  static lookAt(eye, target, up, out) {\n    const oe = out.elements;\n    const xAxis = Matrix._tempVec30;\n    const yAxis = Matrix._tempVec31;\n    const zAxis = Matrix._tempVec32;\n    Vector3.subtract(eye, target, zAxis);\n    zAxis.normalize();\n    Vector3.cross(up, zAxis, xAxis);\n    xAxis.normalize();\n    Vector3.cross(zAxis, xAxis, yAxis);\n    oe[0] = xAxis.x;\n    oe[1] = yAxis.x;\n    oe[2] = zAxis.x;\n    oe[3] = 0;\n    oe[4] = xAxis.y;\n    oe[5] = yAxis.y;\n    oe[6] = zAxis.y;\n    oe[7] = 0;\n    oe[8] = xAxis.z;\n    oe[9] = yAxis.z;\n    oe[10] = zAxis.z;\n    oe[11] = 0;\n    oe[12] = -Vector3.dot(xAxis, eye);\n    oe[13] = -Vector3.dot(yAxis, eye);\n    oe[14] = -Vector3.dot(zAxis, eye);\n    oe[15] = 1;\n  }\n  static ortho(left, right, bottom, top, near, far, out) {\n    const oe = out.elements;\n    const lr = 1 / (left - right);\n    const bt = 1 / (bottom - top);\n    const nf = 1 / (near - far);\n    oe[0] = -2 * lr;\n    oe[1] = 0;\n    oe[2] = 0;\n    oe[3] = 0;\n    oe[4] = 0;\n    oe[5] = -2 * bt;\n    oe[6] = 0;\n    oe[7] = 0;\n    oe[8] = 0;\n    oe[9] = 0;\n    oe[10] = 2 * nf;\n    oe[11] = 0;\n    oe[12] = (left + right) * lr;\n    oe[13] = (top + bottom) * bt;\n    oe[14] = (far + near) * nf;\n    oe[15] = 1;\n  }\n  static perspective(fovy, aspect, near, far, out) {\n    const oe = out.elements;\n    const f = 1 / Math.tan(fovy / 2);\n    const nf = 1 / (near - far);\n    oe[0] = f / aspect;\n    oe[1] = 0;\n    oe[2] = 0;\n    oe[3] = 0;\n    oe[4] = 0;\n    oe[5] = f;\n    oe[6] = 0;\n    oe[7] = 0;\n    oe[8] = 0;\n    oe[9] = 0;\n    oe[10] = (far + near) * nf;\n    oe[11] = -1;\n    oe[12] = 0;\n    oe[13] = 0;\n    oe[14] = 2 * far * near * nf;\n    oe[15] = 0;\n  }\n  static rotateAxisAngle(m, axis, r, out) {\n    let {x, y, z} = axis;\n    let len = Math.sqrt(x * x + y * y + z * z);\n    if (Math.abs(len) < MathUtil.zeroTolerance) {\n      return;\n    }\n    const me = m.elements;\n    const oe = out.elements;\n    let s, c, t;\n    len = 1 / len;\n    x *= len;\n    y *= len;\n    z *= len;\n    s = Math.sin(r);\n    c = Math.cos(r);\n    t = 1 - c;\n    let a11 = me[0], a12 = me[1], a13 = me[2], a14 = me[3];\n    let a21 = me[4], a22 = me[5], a23 = me[6], a24 = me[7];\n    let a31 = me[8], a32 = me[9], a33 = me[10], a34 = me[11];\n    let b11 = x * x * t + c;\n    let b12 = y * x * t + z * s;\n    let b13 = z * x * t - y * s;\n    let b21 = x * y * t - z * s;\n    let b22 = y * y * t + c;\n    let b23 = z * y * t + x * s;\n    let b31 = x * z * t + y * s;\n    let b32 = y * z * t - x * s;\n    let b33 = z * z * t + c;\n    oe[0] = a11 * b11 + a21 * b12 + a31 * b13;\n    oe[1] = a12 * b11 + a22 * b12 + a32 * b13;\n    oe[2] = a13 * b11 + a23 * b12 + a33 * b13;\n    oe[3] = a14 * b11 + a24 * b12 + a34 * b13;\n    oe[4] = a11 * b21 + a21 * b22 + a31 * b23;\n    oe[5] = a12 * b21 + a22 * b22 + a32 * b23;\n    oe[6] = a13 * b21 + a23 * b22 + a33 * b23;\n    oe[7] = a14 * b21 + a24 * b22 + a34 * b23;\n    oe[8] = a11 * b31 + a21 * b32 + a31 * b33;\n    oe[9] = a12 * b31 + a22 * b32 + a32 * b33;\n    oe[10] = a13 * b31 + a23 * b32 + a33 * b33;\n    oe[11] = a14 * b31 + a24 * b32 + a34 * b33;\n    if (m !== out) {\n      oe[12] = me[12];\n      oe[13] = me[13];\n      oe[14] = me[14];\n      oe[15] = me[15];\n    }\n  }\n  static scale(m, s, out) {\n    const me = m.elements;\n    const oe = out.elements;\n    const {x, y, z} = s;\n    oe[0] = me[0] * x;\n    oe[1] = me[1] * x;\n    oe[2] = me[2] * x;\n    oe[3] = me[3] * x;\n    oe[4] = me[4] * y;\n    oe[5] = me[5] * y;\n    oe[6] = me[6] * y;\n    oe[7] = me[7] * y;\n    oe[8] = me[8] * z;\n    oe[9] = me[9] * z;\n    oe[10] = me[10] * z;\n    oe[11] = me[11] * z;\n    oe[12] = me[12];\n    oe[13] = me[13];\n    oe[14] = me[14];\n    oe[15] = me[15];\n  }\n  static translate(m, v, out) {\n    const me = m.elements;\n    const oe = out.elements;\n    const {x, y, z} = v;\n    if (m === out) {\n      oe[12] = me[0] * x + me[4] * y + me[8] * z + me[12];\n      oe[13] = me[1] * x + me[5] * y + me[9] * z + me[13];\n      oe[14] = me[2] * x + me[6] * y + me[10] * z + me[14];\n      oe[15] = me[3] * x + me[7] * y + me[11] * z + me[15];\n    } else {\n      const a11 = me[0], a12 = me[1], a13 = me[2], a14 = me[3];\n      const a21 = me[4], a22 = me[5], a23 = me[6], a24 = me[7];\n      const a31 = me[8], a32 = me[9], a33 = me[10], a34 = me[11];\n      oe[0] = a11, oe[1] = a12, oe[2] = a13, oe[3] = a14;\n      oe[4] = a21, oe[5] = a22, oe[6] = a23, oe[7] = a24;\n      oe[8] = a31, oe[9] = a32, oe[10] = a33, oe[11] = a34;\n      oe[12] = a11 * x + a21 * y + a31 * z + me[12];\n      oe[13] = a12 * x + a22 * y + a32 * z + me[13];\n      oe[14] = a13 * x + a23 * y + a33 * z + me[14];\n      oe[15] = a14 * x + a24 * y + a34 * z + me[15];\n    }\n  }\n  static transpose(a, out) {\n    const ae = a.elements;\n    const oe = out.elements;\n    if (out === a) {\n      const a12 = ae[1];\n      const a13 = ae[2];\n      const a14 = ae[3];\n      const a23 = ae[6];\n      const a24 = ae[7];\n      const a34 = ae[11];\n      oe[1] = ae[4];\n      oe[2] = ae[8];\n      oe[3] = ae[12];\n      oe[4] = a12;\n      oe[6] = ae[9];\n      oe[7] = ae[13];\n      oe[8] = a13;\n      oe[9] = a23;\n      oe[11] = ae[14];\n      oe[12] = a14;\n      oe[13] = a24;\n      oe[14] = a34;\n    } else {\n      oe[0] = ae[0];\n      oe[1] = ae[4];\n      oe[2] = ae[8];\n      oe[3] = ae[12];\n      oe[4] = ae[1];\n      oe[5] = ae[5];\n      oe[6] = ae[9];\n      oe[7] = ae[13];\n      oe[8] = ae[2];\n      oe[9] = ae[6];\n      oe[10] = ae[10];\n      oe[11] = ae[14];\n      oe[12] = ae[3];\n      oe[13] = ae[7];\n      oe[14] = ae[11];\n      oe[15] = ae[15];\n    }\n  }\n  setValue(m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44) {\n    const e = this.elements;\n    e[0] = m11;\n    e[1] = m12;\n    e[2] = m13;\n    e[3] = m14;\n    e[4] = m21;\n    e[5] = m22;\n    e[6] = m23;\n    e[7] = m24;\n    e[8] = m31;\n    e[9] = m32;\n    e[10] = m33;\n    e[11] = m34;\n    e[12] = m41;\n    e[13] = m42;\n    e[14] = m43;\n    e[15] = m44;\n    return this;\n  }\n  setValueByArray(array, offset = 0) {\n    const srce = this.elements;\n    for (let i = 0; i < 16; i++) {\n      srce[i] = array[i + offset];\n    }\n    return this;\n  }\n  toArray(out, outOffset = 0) {\n    const e = this.elements;\n    out[outOffset] = e[0];\n    out[outOffset + 1] = e[1];\n    out[outOffset + 2] = e[2];\n    out[outOffset + 3] = e[3];\n    out[outOffset + 4] = e[4];\n    out[outOffset + 5] = e[5];\n    out[outOffset + 6] = e[6];\n    out[outOffset + 7] = e[7];\n    out[outOffset + 8] = e[8];\n    out[outOffset + 9] = e[9];\n    out[outOffset + 10] = e[10];\n    out[outOffset + 11] = e[11];\n    out[outOffset + 12] = e[12];\n    out[outOffset + 13] = e[13];\n    out[outOffset + 14] = e[14];\n    out[outOffset + 15] = e[15];\n  }\n  clone() {\n    const e = this.elements;\n    let ret = new Matrix(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15]);\n    return ret;\n  }\n  cloneTo(out) {\n    const e = this.elements;\n    const oe = out.elements;\n    oe[0] = e[0];\n    oe[1] = e[1];\n    oe[2] = e[2];\n    oe[3] = e[3];\n    oe[4] = e[4];\n    oe[5] = e[5];\n    oe[6] = e[6];\n    oe[7] = e[7];\n    oe[8] = e[8];\n    oe[9] = e[9];\n    oe[10] = e[10];\n    oe[11] = e[11];\n    oe[12] = e[12];\n    oe[13] = e[13];\n    oe[14] = e[14];\n    oe[15] = e[15];\n    return out;\n  }\n  multiply(right) {\n    Matrix.multiply(this, right, this);\n    return this;\n  }\n  determinant() {\n    const e = this.elements;\n    const a11 = e[0], a12 = e[1], a13 = e[2], a14 = e[3];\n    const a21 = e[4], a22 = e[5], a23 = e[6], a24 = e[7];\n    const a31 = e[8], a32 = e[9], a33 = e[10], a34 = e[11];\n    const a41 = e[12], a42 = e[13], a43 = e[14], a44 = e[15];\n    const b00 = a11 * a22 - a12 * a21;\n    const b01 = a11 * a23 - a13 * a21;\n    const b02 = a11 * a24 - a14 * a21;\n    const b03 = a12 * a23 - a13 * a22;\n    const b04 = a12 * a24 - a14 * a22;\n    const b05 = a13 * a24 - a14 * a23;\n    const b06 = a31 * a42 - a32 * a41;\n    const b07 = a31 * a43 - a33 * a41;\n    const b08 = a31 * a44 - a34 * a41;\n    const b09 = a32 * a43 - a33 * a42;\n    const b10 = a32 * a44 - a34 * a42;\n    const b11 = a33 * a44 - a34 * a43;\n    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n  }\n  decompose(pos, q, s) {\n    const rm = Matrix._tempMat30;\n    const e = this.elements;\n    const rme = rm.elements;\n    const m11 = e[0];\n    const m12 = e[1];\n    const m13 = e[2];\n    const m14 = e[3];\n    const m21 = e[4];\n    const m22 = e[5];\n    const m23 = e[6];\n    const m24 = e[7];\n    const m31 = e[8];\n    const m32 = e[9];\n    const m33 = e[10];\n    const m34 = e[11];\n    pos.x = e[12];\n    pos.y = e[13];\n    pos.z = e[14];\n    const xs = Math.sign(m11 * m12 * m13 * m14) < 0 ? -1 : 1;\n    const ys = Math.sign(m21 * m22 * m23 * m24) < 0 ? -1 : 1;\n    const zs = Math.sign(m31 * m32 * m33 * m34) < 0 ? -1 : 1;\n    const sx = xs * Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);\n    const sy = ys * Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);\n    const sz = zs * Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);\n    s.x = sx;\n    s.y = sy;\n    s.z = sz;\n    if (Math.abs(sx) < MathUtil.zeroTolerance || Math.abs(sy) < MathUtil.zeroTolerance || Math.abs(sz) < MathUtil.zeroTolerance) {\n      q.identity();\n      return false;\n    } else {\n      const invSX = 1 / sx;\n      const invSY = 1 / sy;\n      const invSZ = 1 / sz;\n      rme[0] = m11 * invSX;\n      rme[1] = m12 * invSX;\n      rme[2] = m13 * invSX;\n      rme[3] = m21 * invSY;\n      rme[4] = m22 * invSY;\n      rme[5] = m23 * invSY;\n      rme[6] = m31 * invSZ;\n      rme[7] = m32 * invSZ;\n      rme[8] = m33 * invSZ;\n      Quaternion.rotationMatrix3x3(rm, q);\n      return true;\n    }\n  }\n  getRotation(out) {\n    const e = this.elements;\n    let trace = e[0] + e[5] + e[10];\n    if (trace > MathUtil.zeroTolerance) {\n      let S = Math.sqrt(trace + 1) * 2;\n      out.w = 0.25 * S;\n      out.x = (e[6] - e[9]) / S;\n      out.y = (e[8] - e[2]) / S;\n      out.z = (e[1] - e[4]) / S;\n    } else if (e[0] > e[5] && e[0] > e[10]) {\n      let S = Math.sqrt(1 + e[0] - e[5] - e[10]) * 2;\n      out.w = (e[6] - e[9]) / S;\n      out.x = 0.25 * S;\n      out.y = (e[1] + e[4]) / S;\n      out.z = (e[8] + e[2]) / S;\n    } else if (e[5] > e[10]) {\n      let S = Math.sqrt(1 + e[5] - e[0] - e[10]) * 2;\n      out.w = (e[8] - e[2]) / S;\n      out.x = (e[1] + e[4]) / S;\n      out.y = 0.25 * S;\n      out.z = (e[6] + e[9]) / S;\n    } else {\n      let S = Math.sqrt(1 + e[10] - e[0] - e[5]) * 2;\n      out.w = (e[1] - e[4]) / S;\n      out.x = (e[8] + e[2]) / S;\n      out.y = (e[6] + e[9]) / S;\n      out.z = 0.25 * S;\n    }\n    return out;\n  }\n  getScaling(out) {\n    const e = this.elements;\n    const m11 = e[0], m12 = e[1], m13 = e[2];\n    const m21 = e[4], m22 = e[5], m23 = e[6];\n    const m31 = e[8], m32 = e[9], m33 = e[10];\n    out.x = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);\n    out.y = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);\n    out.z = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);\n    return out;\n  }\n  getTranslation(out) {\n    const e = this.elements;\n    out.x = e[12];\n    out.y = e[13];\n    out.z = e[14];\n    return out;\n  }\n  identity() {\n    const e = this.elements;\n    e[0] = 1;\n    e[1] = 0;\n    e[2] = 0;\n    e[3] = 0;\n    e[4] = 0;\n    e[5] = 1;\n    e[6] = 0;\n    e[7] = 0;\n    e[8] = 0;\n    e[9] = 0;\n    e[10] = 1;\n    e[11] = 0;\n    e[12] = 0;\n    e[13] = 0;\n    e[14] = 0;\n    e[15] = 1;\n    return this;\n  }\n  invert() {\n    Matrix.invert(this, this);\n    return this;\n  }\n  rotateAxisAngle(axis, r) {\n    Matrix.rotateAxisAngle(this, axis, r, this);\n    return this;\n  }\n  scale(s) {\n    Matrix.scale(this, s, this);\n    return this;\n  }\n  translate(v) {\n    Matrix.translate(this, v, this);\n    return this;\n  }\n  transpose() {\n    Matrix.transpose(this, this);\n    return this;\n  }\n}\nMatrix._tempVec30 = new Vector3();\nMatrix._tempVec31 = new Vector3();\nMatrix._tempVec32 = new Vector3();\nMatrix._tempMat30 = new Matrix3x3();\nMatrix._tempMat40 = new Matrix();\nMatrix._identity = new Matrix(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n\nclass OBB {\n  constructor(minLocal, maxLocal, modelMatrix) {\n    this.min = new Vector3();\n    this.max = new Vector3();\n    this.corners = [];\n    this.minWorld = new Vector3();\n    this.maxWorld = new Vector3();\n    this.cornersWorld = [];\n    minLocal.cloneTo(this.min);\n    maxLocal.cloneTo(this.max);\n    this.corners = this.getCornersFromMinMax(minLocal, maxLocal);\n    this.updateByModelMatrix(modelMatrix);\n  }\n  getCornersFromMinMax(min, max) {\n    const minX = min.x, minY = min.y, minZ = min.z, maxX = max.x, maxY = max.y, maxZ = max.z;\n    const corners = [\n      new Vector3(minX, minY, minZ),\n      new Vector3(maxX, maxY, maxZ),\n      new Vector3(maxX, minY, minZ),\n      new Vector3(minX, maxY, minZ),\n      new Vector3(minX, minY, maxZ),\n      new Vector3(maxX, maxY, minZ),\n      new Vector3(minX, maxY, maxZ),\n      new Vector3(maxX, minY, maxZ)\n    ];\n    return corners;\n  }\n  updateByModelMatrix(modelMatrix) {\n    const min = this.minWorld;\n    const max = this.maxWorld;\n    min.setValue(Infinity, Infinity, Infinity);\n    max.setValue(-Infinity, -Infinity, -Infinity);\n    for (let i = 0; i < 8; ++i) {\n      const corner = this.corners[i];\n      const cornerWorld = OBB._tempVec3;\n      Vector3.transformCoordinate(corner, modelMatrix, cornerWorld);\n      Vector3.min(min, cornerWorld, min);\n      Vector3.max(max, cornerWorld, max);\n      this.cornersWorld[i] = new Vector3();\n      cornerWorld.cloneTo(this.cornersWorld[i]);\n    }\n  }\n  intersectsFrustum(frustumPlanes) {\n    const cornersWorld = this.cornersWorld;\n    for (let i = 0; i < 6; i++) {\n      const plane = frustumPlanes[i];\n      let isInPlane = false;\n      for (let j = 0; j < 8; j++) {\n        if (pointDistanceToPlane(plane, cornersWorld[j]) > 0) {\n          isInPlane = true;\n        } else if (isInPlane) {\n          return IntersectInfo.INTERSECT;\n        }\n      }\n      if (!isInPlane) {\n        return IntersectInfo.EXCLUDE;\n      }\n    }\n    return IntersectInfo.INCLUDE;\n  }\n  isInFrustum(frustumPlanes) {\n    const cornersWorld = this.cornersWorld;\n    for (let i = 0; i < 6; i++) {\n      const plane = frustumPlanes[i];\n      let isInPlane = false;\n      for (let j = 0; j < 8; j++) {\n        if (pointDistanceToPlane(plane, cornersWorld[j]) > 0) {\n          isInPlane = true;\n          break;\n        }\n      }\n      if (!isInPlane) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\nOBB._tempVec3 = new Vector3();\n\nclass Ray {\n  constructor(origin, direction) {\n    this.origin = new Vector3();\n    this.direction = new Vector3();\n    origin && origin.cloneTo(this.origin);\n    direction && direction.cloneTo(this.direction);\n  }\n  intersectPlane(point, normal) {\n    const origin = this.origin;\n    const denom = Vector3.dot(normal, this.direction);\n    if (Math.abs(denom) > 1e-6) {\n      const p0l0 = new Vector3();\n      Vector3.subtract(point, origin, p0l0);\n      const t = Vector3.dot(p0l0, normal) / denom;\n      if (t >= 0) {\n        return t;\n      }\n    }\n    return false;\n  }\n  getPoint(distance) {\n    const point = new Vector3();\n    Vector3.scale(this.direction, distance, point);\n    return point.add(this.origin);\n  }\n  intersectSphere(center, radius) {\n    const dir = this.direction;\n    const L = new Vector3();\n    Vector3.subtract(this.origin, center, L);\n    const a = Vector3.dot(dir, dir);\n    const b = 2 * Vector3.dot(dir, L);\n    const c = Vector3.dot(L, L) - radius * radius;\n    const s = this._solveQuadratic(a, b, c);\n    if (s) {\n      return s[0];\n    } else {\n      return false;\n    }\n  }\n  intersectAABB(max, min) {\n    const dir = this.direction;\n    const orig = this.origin;\n    const invdir = new Vector3(1 / dir.x, 1 / dir.y, 1 / dir.z);\n    const bounds = [min, max];\n    const sign = [dir.x < 0 ? 1 : 0, dir.y < 0 ? 1 : 0, dir.z < 0 ? 1 : 0];\n    let tmin = (bounds[sign[0]].x - orig.x) * invdir.x;\n    let tmax = (bounds[1 - sign[0]].x - orig.x) * invdir.x;\n    const tymin = (bounds[sign[1]].y - orig.y) * invdir.y;\n    const tymax = (bounds[1 - sign[1]].y - orig.y) * invdir.y;\n    if (tmin > tymax || tymin > tmax) {\n      return false;\n    }\n    if (tymin > tmin) {\n      tmin = tymin;\n    }\n    if (tymax < tmax) {\n      tmax = tymax;\n    }\n    const tzmin = (bounds[sign[2]].z - orig.z) * invdir.z;\n    const tzmax = (bounds[1 - sign[2]].z - orig.z) * invdir.z;\n    if (tmin > tzmax || tzmin > tmax) {\n      return false;\n    }\n    if (tzmin > tmin) {\n      tmin = tzmin;\n    }\n    if (tzmax < tmax) {\n      tmax = tzmax;\n    }\n    let t = tmin;\n    if (t < 0) {\n      t = tmax;\n      if (t < 0) {\n        return false;\n      }\n    }\n    return t;\n  }\n  _solveQuadratic(a, b, c) {\n    const discr = b * b - 4 * a * c;\n    if (discr < 0) {\n      return false;\n    } else if (discr == 0) {\n      const x = -0.5 * b / a;\n      return [x, x];\n    } else {\n      const r = Math.sqrt(discr);\n      const q = b > 0 ? -0.5 * (b + r) : -0.5 * (b - r);\n      const x0 = q / a;\n      const x1 = c / q;\n      if (x0 <= x1) {\n        return [x0, x1];\n      } else {\n        return [x1, x0];\n      }\n    }\n  }\n}\n\nclass RaycastHit {\n  constructor() {\n    this.distance = Number.MAX_VALUE;\n    this.collider = null;\n    this.point = null;\n  }\n}\n\nconst ESP = MathUtil.zeroTolerance;\nclass Spherical {\n  constructor(radius, phi, theta) {\n    this.radius = radius !== void 0 ? radius : 1;\n    this.phi = phi !== void 0 ? phi : 0;\n    this.theta = theta !== void 0 ? theta : 0;\n  }\n  set(radius, phi, theta) {\n    this.radius = radius;\n    this.phi = phi;\n    this.theta = theta;\n    return this;\n  }\n  makeSafe() {\n    this.phi = MathUtil.clamp(this.phi, ESP, Math.PI - ESP);\n    return this;\n  }\n  setFromVec3(v3) {\n    this.radius = v3.length();\n    if (this.radius === 0) {\n      this.theta = 0;\n      this.phi = 0;\n    } else {\n      this.theta = Math.atan2(v3.x, v3.z);\n      this.phi = Math.acos(MathUtil.clamp(v3.y / this.radius, -1, 1));\n    }\n    return this;\n  }\n  setToVec3(v3) {\n    const sinPhiRadius = Math.sin(this.phi) * this.radius;\n    v3.x = sinPhiRadius * Math.sin(this.theta);\n    v3.y = Math.cos(this.phi) * this.radius;\n    v3.z = sinPhiRadius * Math.cos(this.theta);\n    return this;\n  }\n}\n\nclass Vector2 {\n  static add(left, right, out) {\n    out.x = left.x + right.x;\n    out.y = left.y + right.y;\n  }\n  static subtract(left, right, out) {\n    out.x = left.x - right.x;\n    out.y = left.y - right.y;\n  }\n  static multiply(left, right, out) {\n    out.x = left.x * right.x;\n    out.y = left.y * right.y;\n  }\n  static divide(left, right, out) {\n    out.x = left.x / right.x;\n    out.y = left.y / right.y;\n  }\n  static dot(left, right) {\n    return left.x * right.x + left.y * right.y;\n  }\n  static distance(left, right) {\n    const x = right.x - left.x;\n    const y = right.y - left.y;\n    return Math.sqrt(x * x + y * y);\n  }\n  static distanceSquared(left, right) {\n    const x = right.x - left.x;\n    const y = right.y - left.y;\n    return x * x + y * y;\n  }\n  static equals(left, right) {\n    return MathUtil.equals(left.x, right.x) && MathUtil.equals(left.y, right.y);\n  }\n  static lerp(left, right, t, out) {\n    const {x, y} = left;\n    out.x = x + (right.x - x) * t;\n    out.y = y + (right.y - y) * t;\n  }\n  static max(left, right, out) {\n    out.x = Math.max(left.x, right.x);\n    out.y = Math.max(left.y, right.y);\n  }\n  static min(left, right, out) {\n    out.x = Math.min(left.x, right.x);\n    out.y = Math.min(left.y, right.y);\n  }\n  static negate(left, out) {\n    out.x = -left.x;\n    out.y = -left.y;\n  }\n  static normalize(left, out) {\n    const {x, y} = left;\n    let len = Math.sqrt(x * x + y * y);\n    if (len > MathUtil.zeroTolerance) {\n      len = 1 / len;\n      out.x = x * len;\n      out.y = y * len;\n    }\n  }\n  static scale(left, s, out) {\n    out.x = left.x * s;\n    out.y = left.y * s;\n  }\n  constructor(x = 0, y = 0) {\n    this.x = x;\n    this.y = y;\n  }\n  setValue(x, y) {\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n  setValueByArray(array, offset = 0) {\n    this.x = array[offset];\n    this.y = array[offset + 1];\n    return this;\n  }\n  add(right) {\n    this.x += right.x;\n    this.y += right.y;\n    return this;\n  }\n  subtract(right) {\n    this.x -= right.x;\n    this.y -= right.y;\n    return this;\n  }\n  multiply(right) {\n    this.x *= right.x;\n    this.y *= right.y;\n    return this;\n  }\n  divide(right) {\n    this.x /= right.x;\n    this.y /= right.y;\n    return this;\n  }\n  length() {\n    const {x, y} = this;\n    return Math.sqrt(x * x + y * y);\n  }\n  lengthSquared() {\n    const {x, y} = this;\n    return x * x + y * y;\n  }\n  negate() {\n    this.x = -this.x;\n    this.y = -this.y;\n    return this;\n  }\n  normalize() {\n    Vector2.normalize(this, this);\n    return this;\n  }\n  scale(s) {\n    this.x *= s;\n    this.y *= s;\n    return this;\n  }\n  toArray(out, outOffset = 0) {\n    out[outOffset] = this.x;\n    out[outOffset + 1] = this.y;\n  }\n  clone() {\n    return new Vector2(this.x, this.y);\n  }\n  cloneTo(out) {\n    out.x = this.x;\n    out.y = this.y;\n    return out;\n  }\n}\nVector2._zero = new Vector2(0, 0);\nVector2._one = new Vector2(1, 1);\n\nclass Vector4 {\n  static add(left, right, out) {\n    out.x = left.x + right.x;\n    out.y = left.y + right.y;\n    out.z = left.z + right.z;\n    out.w = left.w + right.w;\n  }\n  static subtract(left, right, out) {\n    out.x = left.x - right.x;\n    out.y = left.y - right.y;\n    out.z = left.z - right.z;\n    out.w = left.w - right.w;\n  }\n  static multiply(left, right, out) {\n    out.x = left.x * right.x;\n    out.y = left.y * right.y;\n    out.z = left.z * right.z;\n    out.w = left.w * right.w;\n  }\n  static divide(left, right, out) {\n    out.x = left.x / right.x;\n    out.y = left.y / right.y;\n    out.z = left.z / right.z;\n    out.w = left.w / right.w;\n  }\n  static dot(left, right) {\n    return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;\n  }\n  static distance(a, b) {\n    const x = b.x - a.x;\n    const y = b.y - a.y;\n    const z = b.z - a.z;\n    const w = b.w - a.w;\n    return Math.sqrt(x * x + y * y + z * z + w * w);\n  }\n  static distanceSquared(a, b) {\n    const x = b.x - a.x;\n    const y = b.y - a.y;\n    const z = b.z - a.z;\n    const w = b.w - a.w;\n    return x * x + y * y + z * z + w * w;\n  }\n  static equals(left, right) {\n    return MathUtil.equals(left.x, right.x) && MathUtil.equals(left.y, right.y) && MathUtil.equals(left.z, right.z) && MathUtil.equals(left.w, right.w);\n  }\n  static lerp(start, end, t, out) {\n    const {x, y, z, w} = start;\n    out.x = x + (end.x - x) * t;\n    out.y = y + (end.y - y) * t;\n    out.z = z + (end.z - z) * t;\n    out.w = w + (end.w - w) * t;\n  }\n  static max(left, right, out) {\n    out.x = Math.max(left.x, right.x);\n    out.y = Math.max(left.y, right.y);\n    out.z = Math.max(left.z, right.z);\n    out.w = Math.max(left.w, right.w);\n  }\n  static min(left, right, out) {\n    out.x = Math.min(left.x, right.x);\n    out.y = Math.min(left.y, right.y);\n    out.z = Math.min(left.z, right.z);\n    out.w = Math.min(left.w, right.w);\n  }\n  static negate(a, out) {\n    out.x = -a.x;\n    out.y = -a.y;\n    out.z = -a.z;\n    out.w = -a.w;\n  }\n  static normalize(a, out) {\n    const {x, y, z, w} = a;\n    let len = Math.sqrt(x * x + y * y + z * z + w * w);\n    if (len > MathUtil.zeroTolerance) {\n      len = 1 / len;\n      out.x = x * len;\n      out.y = y * len;\n      out.z = z * len;\n      out.w = w * len;\n    }\n  }\n  static scale(a, s, out) {\n    out.x = a.x * s;\n    out.y = a.y * s;\n    out.z = a.z * s;\n    out.w = a.w * s;\n  }\n  static transform(v, m, out) {\n    const {x, y, z, w} = v;\n    const e = m.elements;\n    out.x = x * e[0] + y * e[4] + z * e[8] + w * e[12];\n    out.y = x * e[1] + y * e[5] + z * e[9] + w * e[13];\n    out.z = x * e[2] + y * e[6] + z * e[10] + w * e[14];\n    out.w = x * e[3] + y * e[7] + z * e[11] + w * e[15];\n  }\n  static transformByQuat(v, q, out) {\n    const {x, y, z, w} = v;\n    const qx = q.x;\n    const qy = q.y;\n    const qz = q.z;\n    const qw = q.w;\n    const ix = qw * x + qy * z - qz * y;\n    const iy = qw * y + qz * x - qx * z;\n    const iz = qw * z + qx * y - qy * x;\n    const iw = -qx * x - qy * y - qz * z;\n    out.x = ix * qw - iw * qx - iy * qz + iz * qy;\n    out.y = iy * qw - iw * qy - iz * qx + ix * qz;\n    out.z = iz * qw - iw * qz - ix * qy + iy * qx;\n    out.w = w;\n  }\n  constructor(x = 0, y = 0, z = 0, w = 0) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.w = w;\n  }\n  setValue(x, y, z, w) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.w = w;\n    return this;\n  }\n  setValueByArray(array, offset = 0) {\n    this.x = array[offset];\n    this.y = array[offset + 1];\n    this.z = array[offset + 2];\n    this.w = array[offset + 3];\n    return this;\n  }\n  add(right) {\n    this.x += right.x;\n    this.y += right.y;\n    this.z += right.z;\n    this.w += right.w;\n    return this;\n  }\n  subtract(right) {\n    this.x -= right.x;\n    this.y -= right.y;\n    this.z -= right.z;\n    this.w -= right.w;\n    return this;\n  }\n  multiply(right) {\n    this.x *= right.x;\n    this.y *= right.y;\n    this.z *= right.z;\n    this.w *= right.w;\n    return this;\n  }\n  divide(right) {\n    this.x /= right.x;\n    this.y /= right.y;\n    this.z /= right.z;\n    this.w /= right.w;\n    return this;\n  }\n  length() {\n    const {x, y, z, w} = this;\n    return Math.sqrt(x * x + y * y + z * z + w * w);\n  }\n  lengthSquared() {\n    const {x, y, z, w} = this;\n    return x * x + y * y + z * z + w * w;\n  }\n  negate() {\n    this.x = -this.x;\n    this.y = -this.y;\n    this.z = -this.z;\n    this.w = -this.w;\n    return this;\n  }\n  normalize() {\n    Vector4.normalize(this, this);\n    return this;\n  }\n  scale(s) {\n    this.x *= s;\n    this.y *= s;\n    this.z *= s;\n    this.w *= s;\n    return this;\n  }\n  toArray(out, outOffset = 0) {\n    out[outOffset] = this.x;\n    out[outOffset + 1] = this.y;\n    out[outOffset + 2] = this.z;\n    out[outOffset + 3] = this.w;\n  }\n  clone() {\n    let ret = new Vector4(this.x, this.y, this.z, this.w);\n    return ret;\n  }\n  cloneTo(out) {\n    out.x = this.x;\n    out.y = this.y;\n    out.z = this.z;\n    out.w = this.w;\n    return out;\n  }\n}\nVector4._zero = new Vector4(0, 0, 0, 0);\nVector4._one = new Vector4(1, 1, 1, 1);\n\nexport { BoundingBox, BoundingSphere, MathUtil, Matrix, Matrix3x3, OBB, Quaternion, Ray, RaycastHit, Spherical, Vector2, Vector3, Vector4 };\n//# sourceMappingURL=module.js.map\n","import { Vector3, Quaternion, Matrix, MathUtil, Matrix3x3, BoundingBox, Vector4, Vector2, Ray, RaycastHit } from '@oasis-engine/math';\n\nvar AssetPromiseStatus;\n(function(AssetPromiseStatus2) {\n  AssetPromiseStatus2[AssetPromiseStatus2[\"Success\"] = 0] = \"Success\";\n  AssetPromiseStatus2[AssetPromiseStatus2[\"Pending\"] = 1] = \"Pending\";\n  AssetPromiseStatus2[AssetPromiseStatus2[\"Failed\"] = 2] = \"Failed\";\n})(AssetPromiseStatus || (AssetPromiseStatus = {}));\nclass AssetPromise extends Promise {\n  static all(promises) {\n    return new AssetPromise((resolve, reject, setProgress) => {\n      if (!Array.isArray(promises)) {\n        return resolve([promises]);\n      }\n      let completed = 0;\n      let total = promises.length;\n      let results = new Array(total);\n      promises.forEach((value, index) => {\n        Promise.resolve(value).then((result) => {\n          results[index] = result;\n          completed += 1;\n          setProgress(completed / total);\n          if (completed == total) {\n            resolve(results);\n          }\n        }).catch((err) => reject(err));\n      });\n    });\n  }\n  get status() {\n    return this._status;\n  }\n  get progress() {\n    return this._progress;\n  }\n  onProgress(callback) {\n    this._listeners.add(callback);\n    return this;\n  }\n  cancel() {\n    if (this._status !== 1) {\n      return this;\n    }\n    this._reject(\"Promise Canceled\");\n    return this;\n  }\n  constructor(executor) {\n    let newReject;\n    const setProgress = (progress) => {\n      if (progress <= this._progress) {\n        return;\n      }\n      this._progress = progress;\n      for (const listener of this._listeners) {\n        listener(progress);\n      }\n    };\n    super((resolve, reject) => {\n      newReject = (reason) => {\n        Promise.resolve().then(() => {\n          this._status = 2;\n          reject(reason);\n        });\n      };\n      executor((value) => {\n        Promise.resolve().then(() => {\n          setProgress(1);\n          this._status = 0;\n          resolve(value);\n        });\n      }, newReject, (progress) => {\n        Promise.resolve().then(() => {\n          setProgress(progress);\n        });\n      });\n    });\n    this._reject = newReject;\n    this._listeners = new Set();\n    this._progress = 0;\n    this._status = 1;\n  }\n}\n\nconst Util = {\n  isArray: \"isArray\" in Array ? Array.isArray : (value) => {\n    return toString.call(value) === \"[object Array]\";\n  },\n  isArrayLike(x) {\n    return !!x && typeof x.length === \"number\" && typeof x !== \"function\";\n  },\n  clone(obj) {\n    if (typeof obj !== \"object\" || obj === null) {\n      return obj;\n    }\n    let rst;\n    if (Util.isArrayLike(obj)) {\n      rst = obj.slice();\n      for (let i = 0, l = obj.length; i < l; i++) {\n        rst[i] = Util.clone(obj[i]);\n      }\n    } else {\n      rst = {};\n      for (const k in obj) {\n        if (obj.hasOwnProperty(k)) {\n          rst[k] = Util.clone(obj[k]);\n        }\n      }\n    }\n    return rst;\n  },\n  downloadBlob(blob, fileName = \"\") {\n    if (navigator && navigator.msSaveBlob) {\n      navigator.msSaveBlob(blob, fileName);\n      return;\n    }\n    let url = window.URL.createObjectURL(blob);\n    let a = document.createElement(\"a\");\n    document.body.appendChild(a);\n    a.style.display = \"none\";\n    a.href = url;\n    a.download = fileName;\n    a.addEventListener(\"click\", () => {\n      if (a.parentElement) {\n        a.parentElement.removeChild(a);\n      }\n    });\n    a.click();\n    window.URL.revokeObjectURL(url);\n  }\n};\nfunction removeFromArray(array, item) {\n  const index = array.indexOf(item);\n  if (index < 0) {\n    return false;\n  }\n  const last = array.length - 1;\n  if (index !== last) {\n    const end = array[last];\n    array[index] = end;\n  }\n  array.length--;\n  return true;\n}\nfunction ObjectValues(obj) {\n  return Object.keys(obj).map((key) => obj[key]);\n}\n\nclass ResourceManager {\n  constructor(engine) {\n    this.engine = engine;\n    this.retryCount = 1;\n    this.retryInterval = 0;\n    this.timeout = 2e4;\n    this._assetPool = Object.create(null);\n    this._assetUrlPool = Object.create(null);\n    this._refObjectPool = Object.create(null);\n    this._loadingPromises = {};\n  }\n  static _addLoader(type, loader, extnames) {\n    this._loaders[type] = loader;\n    for (let i = 0, len = extnames.length; i < len; i++) {\n      this._extTypeMapping[extnames[i]] = type;\n    }\n  }\n  static _getTypeByUrl(url) {\n    const path = url.split(\"?\")[0];\n    return this._extTypeMapping[path.substring(path.lastIndexOf(\".\") + 1)];\n  }\n  load(assetInfo) {\n    if (!Array.isArray(assetInfo)) {\n      return this._loadSingleItem(assetInfo);\n    }\n    const promises = assetInfo.map((item) => this._loadSingleItem(item));\n    return AssetPromise.all(promises);\n  }\n  cancelNotLoaded(url) {\n    if (!url) {\n      ObjectValues(this._loadingPromises).forEach((promise) => {\n        promise.cancel();\n      });\n    } else if (typeof url === \"string\") {\n      this._loadingPromises[url]?.cancel();\n    } else {\n      url.forEach((p) => {\n        this._loadingPromises[p]?.cancel();\n      });\n    }\n  }\n  gc() {\n    const objects = ObjectValues(this._refObjectPool);\n    for (let i = 0, len = objects.length; i < len; i++) {\n      if (!objects[i].isGCIgnored) {\n        objects[i].destroy();\n      }\n    }\n  }\n  getAssetPath(instanceId) {\n    return this._assetPool[instanceId];\n  }\n  _addAsset(path, asset) {\n    this._assetPool[asset.instanceId] = path;\n    this._assetUrlPool[path] = asset;\n  }\n  _deleteAsset(asset) {\n    const id = asset.instanceId;\n    const path = this._assetPool[id];\n    if (path) {\n      delete this._assetPool[id];\n      delete this._assetUrlPool[path];\n    }\n  }\n  _addRefObject(id, asset) {\n    this._refObjectPool[id] = asset;\n  }\n  _deleteRefObject(id) {\n    delete this._refObjectPool[id];\n  }\n  _assignDefaultOptions(assetInfo) {\n    assetInfo.type = assetInfo.type ?? ResourceManager._getTypeByUrl(assetInfo.url);\n    if (assetInfo.type === void 0) {\n      throw `asset type should be specified: ${assetInfo.url}`;\n    }\n    assetInfo.retryCount = assetInfo.retryCount ?? this.retryCount;\n    assetInfo.timeout = assetInfo.timeout ?? this.timeout;\n    assetInfo.retryInterval = assetInfo.retryInterval ?? this.retryInterval;\n    assetInfo.url = assetInfo.url ?? assetInfo.urls.join(\",\");\n    return assetInfo;\n  }\n  _loadSingleItem(item) {\n    const info = this._assignDefaultOptions(typeof item === \"string\" ? {url: item} : item);\n    const url = info.url;\n    if (this._assetUrlPool[url]) {\n      return new AssetPromise((resolve) => {\n        resolve(this._assetUrlPool[url]);\n      });\n    }\n    if (this._loadingPromises[url]) {\n      return this._loadingPromises[info.url];\n    }\n    const loader = ResourceManager._loaders[info.type];\n    const promise = loader.load(info, this);\n    this._loadingPromises[url] = promise;\n    promise.then((res) => {\n      if (loader.useCache)\n        this._addAsset(url, res);\n      delete this._loadingPromises[url];\n    }).catch(() => {\n    });\n    return promise;\n  }\n}\nResourceManager._loaders = {};\nResourceManager._extTypeMapping = {};\nfunction resourceLoader(assetType, extnames, useCache = true) {\n  return (Target) => {\n    const loader = new Target(useCache);\n    ResourceManager._addLoader(assetType, loader, extnames);\n  };\n}\n\nclass Event {\n  get propagationStopped() {\n    return this._propagationStopped;\n  }\n  get target() {\n    return this._target;\n  }\n  set target(t) {\n    this._target = t;\n  }\n  get timeStamp() {\n    return this._timeStamp;\n  }\n  get currentTarget() {\n    return this._currentTarget;\n  }\n  set currentTarget(t) {\n    this._currentTarget = t;\n  }\n  get bubbles() {\n    return this._bubbles;\n  }\n  get type() {\n    return this._type;\n  }\n  constructor(type, target = null, data = {}, bubbles = true) {\n    this._timeStamp = new Date().getTime();\n    this._target = target;\n    this.data = data;\n    this._currentTarget = null;\n    this._bubbles = bubbles;\n    this._propagationStopped = false;\n    this._type = type;\n  }\n  stopPropagation() {\n    this._propagationStopped = true;\n  }\n}\n\nvar CloneMode;\n(function(CloneMode2) {\n  CloneMode2[CloneMode2[\"Ignore\"] = 0] = \"Ignore\";\n  CloneMode2[CloneMode2[\"Assignment\"] = 1] = \"Assignment\";\n  CloneMode2[CloneMode2[\"Shallow\"] = 2] = \"Shallow\";\n  CloneMode2[CloneMode2[\"Deep\"] = 3] = \"Deep\";\n})(CloneMode || (CloneMode = {}));\n\nfunction ignoreClone(target, propertyKey) {\n  CloneManager.registerCloneMode(target, propertyKey, CloneMode.Ignore);\n}\nfunction shallowClone(target, propertyKey) {\n  CloneManager.registerCloneMode(target, propertyKey, CloneMode.Shallow);\n}\nfunction deepClone(target, propertyKey) {\n  CloneManager.registerCloneMode(target, propertyKey, CloneMode.Deep);\n}\nclass CloneManager {\n  static registerCloneMode(target, propertyKey, mode) {\n    let targetMap = CloneManager._subCloneModeMap.get(target.constructor);\n    if (!targetMap) {\n      targetMap = Object.create(null);\n      CloneManager._subCloneModeMap.set(target.constructor, targetMap);\n    }\n    targetMap[propertyKey] = mode;\n  }\n  static getCloneModeMode(type) {\n    let cloneModes = CloneManager._cloneModeMap.get(type);\n    if (!cloneModes) {\n      cloneModes = Object.create(null);\n      CloneManager._cloneModeMap.set(type, cloneModes);\n      const obejctType = CloneManager._obejctType;\n      const cloneModeMap = CloneManager._subCloneModeMap;\n      while (type !== obejctType) {\n        const subCloneModes = cloneModeMap.get(type);\n        if (subCloneModes) {\n          Object.assign(cloneModes, subCloneModes);\n        }\n        type = Object.getPrototypeOf(type);\n      }\n    }\n    return cloneModes;\n  }\n}\nCloneManager._subCloneModeMap = new Map();\nCloneManager._cloneModeMap = new Map();\nCloneManager._obejctType = Object.getPrototypeOf(Object);\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __decorate = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result)\n    __defProp(target, key, result);\n  return result;\n};\nclass EngineObject {\n  constructor(engine) {\n    this.instanceId = ++EngineObject._instanceIdCounter;\n    this._engine = engine;\n  }\n}\nEngineObject._instanceIdCounter = 0;\n__decorate([\n  ignoreClone\n], EngineObject.prototype, \"instanceId\", 2);\n__decorate([\n  ignoreClone\n], EngineObject.prototype, \"_engine\", 2);\n\nvar __defProp$1 = Object.defineProperty;\nvar __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor;\nvar __decorate$1 = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$1(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result)\n    __defProp$1(target, key, result);\n  return result;\n};\nclass EventDispatcher extends EngineObject {\n  constructor() {\n    super(...arguments);\n    this._evts = Object.create(null);\n    this._evtCount = 0;\n  }\n  hasEvent(event) {\n    return this._evts[event] != null;\n  }\n  eventNames() {\n    if (this._evtCount === 0)\n      return [];\n    return Object.keys(this._evts);\n  }\n  listenerCount(event) {\n    const listeners = this._evts[event];\n    if (!listeners)\n      return 0;\n    if (listeners.fn)\n      return 1;\n    return listeners.length;\n  }\n  dispatch(event, data) {\n    if (!this._evts[event]) {\n      return false;\n    }\n    const listeners = this._evts[event];\n    if (listeners.fn) {\n      if (listeners.once)\n        this.removeEventListener(event, listeners.fn);\n      listeners.fn(data);\n    } else {\n      const l = listeners.length;\n      for (let i = 0; i < l; i++) {\n        if (listeners[i].once)\n          this.removeEventListener(event, listeners[i].fn);\n        listeners[i].fn(data);\n      }\n    }\n    return true;\n  }\n  on(event, fn) {\n    return this.addEventListener(event, fn);\n  }\n  once(event, fn) {\n    return this.addEventListener(event, fn, true);\n  }\n  addEventListener(event, fn, once) {\n    const listener = {fn, once};\n    const events = this._evts;\n    if (!events[event]) {\n      events[event] = listener;\n      this._evtCount++;\n    } else if (!events[event].fn) {\n      events[event].push(listener);\n    } else {\n      events[event] = [events[event], listener];\n    }\n    return this;\n  }\n  off(event, fn) {\n    if (!this._evts[event])\n      return this;\n    if (!fn) {\n      this._clearEvent(event);\n      return this;\n    }\n    const listeners = this._evts[event];\n    if (listeners.fn && listeners.fn === fn) {\n      this._clearEvent(event);\n    } else {\n      const index = listeners.indexOf(fn);\n      if (index > -1) {\n        const temp = listeners[listeners.length - 1];\n        listeners[index] = temp;\n        listeners.length--;\n        if (listeners.length === 1) {\n          this._evts[event] = listeners[0];\n        }\n      }\n    }\n    return this;\n  }\n  removeEventListener(event, fn) {\n    return this.off(event, fn);\n  }\n  removeAllEventListeners(event) {\n    if (event) {\n      if (this._evts[event])\n        this._clearEvent(event);\n    } else {\n      this._evts = Object.create(null);\n      this._evtCount = 0;\n    }\n  }\n  trigger(e) {\n    this.dispatch(e.type, e.data);\n  }\n  _clearEvent(event) {\n    if (--this._evtCount === 0) {\n      this._evts = Object.create(null);\n    } else {\n      delete this._evts[event];\n    }\n  }\n}\n__decorate$1([\n  ignoreClone\n], EventDispatcher.prototype, \"_evts\", 2);\n\nconst noop = (message, ...optionalParams) => {\n};\nconst debug = console.log.bind(console);\nconst info = console.info.bind(console);\nconst warn = console.warn.bind(console);\nconst error = console.error.bind(console);\nconst Logger = {\n  debug: noop,\n  info: noop,\n  warn: noop,\n  error: noop,\n  isEnabled: false,\n  enable() {\n    this.debug = debug;\n    this.info = info;\n    this.warn = warn;\n    this.error = error;\n    this.isEnabled = true;\n  },\n  disable() {\n    this.debug = noop;\n    this.info = noop;\n    this.warn = noop;\n    this.error = noop;\n    this.isEnabled = false;\n  }\n};\n\nclass Time {\n  constructor() {\n    this._clock = performance ? performance : Date;\n    this._timeScale = 1;\n    this._deltaTime = 1e-4;\n    const now = this._clock.now();\n    this._startTime = now;\n    this._lastTickTime = now;\n  }\n  reset() {\n    this._lastTickTime = this._clock.now();\n  }\n  get nowTime() {\n    return this._clock.now();\n  }\n  get deltaTime() {\n    return this._deltaTime;\n  }\n  get timeScale() {\n    return this._timeScale;\n  }\n  set timeScale(s) {\n    this._timeScale = s;\n  }\n  get unscaledDeltaTime() {\n    return this._deltaTime / this._timeScale;\n  }\n  get timeSinceStartup() {\n    return this.nowTime - this._startTime;\n  }\n  tick() {\n    const now = this.nowTime;\n    this._deltaTime = (now - this._lastTickTime) * this._timeScale;\n    this._lastTickTime = now;\n  }\n}\n\nvar InternalAssetType;\n(function(InternalAssetType2) {\n  InternalAssetType2[InternalAssetType2[\"Scene\"] = 1] = \"Scene\";\n  InternalAssetType2[InternalAssetType2[\"Cache\"] = 2] = \"Cache\";\n})(InternalAssetType || (InternalAssetType = {}));\nvar ClearMode;\n(function(ClearMode2) {\n  ClearMode2[ClearMode2[\"DONT_CLEAR\"] = 0] = \"DONT_CLEAR\";\n  ClearMode2[ClearMode2[\"SOLID_COLOR\"] = 1] = \"SOLID_COLOR\";\n  ClearMode2[ClearMode2[\"DEPTH_ONLY\"] = 2] = \"DEPTH_ONLY\";\n  ClearMode2[ClearMode2[\"COLOR_ONLY\"] = 3] = \"COLOR_ONLY\";\n  ClearMode2[ClearMode2[\"STENCIL_ONLY\"] = 4] = \"STENCIL_ONLY\";\n  ClearMode2[ClearMode2[\"ALL_CLEAR\"] = 5] = \"ALL_CLEAR\";\n})(ClearMode || (ClearMode = {}));\nvar MaterialType;\n(function(MaterialType2) {\n  MaterialType2[MaterialType2[\"OPAQUE\"] = 1e3] = \"OPAQUE\";\n  MaterialType2[MaterialType2[\"TRANSPARENT\"] = 2e3] = \"TRANSPARENT\";\n})(MaterialType || (MaterialType = {}));\nvar RenderState;\n(function(RenderState2) {\n  RenderState2[RenderState2[\"BLEND\"] = 3042] = \"BLEND\";\n  RenderState2[RenderState2[\"CULL_FACE\"] = 2884] = \"CULL_FACE\";\n  RenderState2[RenderState2[\"DEPTH_TEST\"] = 2929] = \"DEPTH_TEST\";\n  RenderState2[RenderState2[\"ALPHA_TEST\"] = 3008] = \"ALPHA_TEST\";\n  RenderState2[RenderState2[\"POLYGON_OFFSET_FILL\"] = 32823] = \"POLYGON_OFFSET_FILL\";\n  RenderState2[RenderState2[\"SAMPLE_ALPHA_TO_COVERAGE\"] = 32926] = \"SAMPLE_ALPHA_TO_COVERAGE\";\n  RenderState2[RenderState2[\"SCISSOR_TEST\"] = 3089] = \"SCISSOR_TEST\";\n})(RenderState || (RenderState = {}));\nvar FrontFace;\n(function(FrontFace2) {\n  FrontFace2[FrontFace2[\"CW\"] = 2304] = \"CW\";\n  FrontFace2[FrontFace2[\"CCW\"] = 2305] = \"CCW\";\n})(FrontFace || (FrontFace = {}));\nvar CullFace;\n(function(CullFace2) {\n  CullFace2[CullFace2[\"FRONT\"] = 1028] = \"FRONT\";\n  CullFace2[CullFace2[\"BACK\"] = 1029] = \"BACK\";\n  CullFace2[CullFace2[\"FRONT_AND_BACK\"] = 1032] = \"FRONT_AND_BACK\";\n})(CullFace || (CullFace = {}));\nvar Side;\n(function(Side2) {\n  Side2[Side2[\"FRONT\"] = 0] = \"FRONT\";\n  Side2[Side2[\"BACK\"] = 1] = \"BACK\";\n  Side2[Side2[\"NONE\"] = 2] = \"NONE\";\n  Side2[Side2[\"DOUBLE\"] = 3] = \"DOUBLE\";\n})(Side || (Side = {}));\nvar CompFunc;\n(function(CompFunc2) {\n  CompFunc2[CompFunc2[\"NEVER\"] = 512] = \"NEVER\";\n  CompFunc2[CompFunc2[\"LESS\"] = 513] = \"LESS\";\n  CompFunc2[CompFunc2[\"EQUAL\"] = 514] = \"EQUAL\";\n  CompFunc2[CompFunc2[\"LEQUAL\"] = 515] = \"LEQUAL\";\n  CompFunc2[CompFunc2[\"GREATER\"] = 516] = \"GREATER\";\n  CompFunc2[CompFunc2[\"NOTEQUAL\"] = 517] = \"NOTEQUAL\";\n  CompFunc2[CompFunc2[\"GEQUAL\"] = 518] = \"GEQUAL\";\n  CompFunc2[CompFunc2[\"ALWAYS\"] = 519] = \"ALWAYS\";\n})(CompFunc || (CompFunc = {}));\nvar TextureFilter;\n(function(TextureFilter2) {\n  TextureFilter2[TextureFilter2[\"NEAREST\"] = 9728] = \"NEAREST\";\n  TextureFilter2[TextureFilter2[\"LINEAR\"] = 9729] = \"LINEAR\";\n  TextureFilter2[TextureFilter2[\"NEAREST_MIPMAP_NEAREST\"] = 9984] = \"NEAREST_MIPMAP_NEAREST\";\n  TextureFilter2[TextureFilter2[\"LINEAR_MIPMAP_NEAREST\"] = 9985] = \"LINEAR_MIPMAP_NEAREST\";\n  TextureFilter2[TextureFilter2[\"NEAREST_MIPMAP_LINEAR\"] = 9986] = \"NEAREST_MIPMAP_LINEAR\";\n  TextureFilter2[TextureFilter2[\"LINEAR_MIPMAP_LINEAR\"] = 9987] = \"LINEAR_MIPMAP_LINEAR\";\n})(TextureFilter || (TextureFilter = {}));\nvar DataType;\n(function(DataType2) {\n  DataType2[DataType2[\"FLOAT\"] = 5126] = \"FLOAT\";\n  DataType2[DataType2[\"FLOAT_VEC2\"] = 35664] = \"FLOAT_VEC2\";\n  DataType2[DataType2[\"FLOAT_VEC3\"] = 35665] = \"FLOAT_VEC3\";\n  DataType2[DataType2[\"FLOAT_VEC4\"] = 35666] = \"FLOAT_VEC4\";\n  DataType2[DataType2[\"INT\"] = 5124] = \"INT\";\n  DataType2[DataType2[\"INT_VEC2\"] = 35667] = \"INT_VEC2\";\n  DataType2[DataType2[\"INT_VEC3\"] = 35668] = \"INT_VEC3\";\n  DataType2[DataType2[\"INT_VEC4\"] = 35669] = \"INT_VEC4\";\n  DataType2[DataType2[\"BOOL\"] = 35670] = \"BOOL\";\n  DataType2[DataType2[\"BOOL_VEC2\"] = 35671] = \"BOOL_VEC2\";\n  DataType2[DataType2[\"BOOL_VEC3\"] = 35672] = \"BOOL_VEC3\";\n  DataType2[DataType2[\"BOOL_VEC4\"] = 35673] = \"BOOL_VEC4\";\n  DataType2[DataType2[\"FLOAT_MAT2\"] = 35674] = \"FLOAT_MAT2\";\n  DataType2[DataType2[\"FLOAT_MAT3\"] = 35675] = \"FLOAT_MAT3\";\n  DataType2[DataType2[\"FLOAT_MAT4\"] = 35676] = \"FLOAT_MAT4\";\n  DataType2[DataType2[\"FLOAT_ARRAY\"] = 35677] = \"FLOAT_ARRAY\";\n  DataType2[DataType2[\"FLOAT_VEC2_ARRAY\"] = 1e5] = \"FLOAT_VEC2_ARRAY\";\n  DataType2[DataType2[\"FLOAT_VEC3_ARRAY\"] = 100001] = \"FLOAT_VEC3_ARRAY\";\n  DataType2[DataType2[\"FLOAT_VEC4_ARRAY\"] = 100002] = \"FLOAT_VEC4_ARRAY\";\n  DataType2[DataType2[\"INT_ARRAY\"] = 100003] = \"INT_ARRAY\";\n  DataType2[DataType2[\"INT_VEC2_ARRAY\"] = 100004] = \"INT_VEC2_ARRAY\";\n  DataType2[DataType2[\"INT_VEC3_ARRAY\"] = 100005] = \"INT_VEC3_ARRAY\";\n  DataType2[DataType2[\"INT_VEC4_ARRAY\"] = 100006] = \"INT_VEC4_ARRAY\";\n  DataType2[DataType2[\"FLOAT_MAT2_ARRAY\"] = 100007] = \"FLOAT_MAT2_ARRAY\";\n  DataType2[DataType2[\"FLOAT_MAT3_ARRAY\"] = 100008] = \"FLOAT_MAT3_ARRAY\";\n  DataType2[DataType2[\"FLOAT_MAT4_ARRAY\"] = 100009] = \"FLOAT_MAT4_ARRAY\";\n  DataType2[DataType2[\"SAMPLER_2D_ARRAY\"] = 100010] = \"SAMPLER_2D_ARRAY\";\n  DataType2[DataType2[\"SAMPLER_CUBE_ARRAY\"] = 100011] = \"SAMPLER_CUBE_ARRAY\";\n  DataType2[DataType2[\"SAMPLER_2D\"] = 35678] = \"SAMPLER_2D\";\n  DataType2[DataType2[\"SAMPLER_CUBE\"] = 35680] = \"SAMPLER_CUBE\";\n  DataType2[DataType2[\"BYTE\"] = 5120] = \"BYTE\";\n  DataType2[DataType2[\"UNSIGNED_BYTE\"] = 5121] = \"UNSIGNED_BYTE\";\n  DataType2[DataType2[\"SHORT\"] = 5122] = \"SHORT\";\n  DataType2[DataType2[\"UNSIGNED_SHORT\"] = 5123] = \"UNSIGNED_SHORT\";\n  DataType2[DataType2[\"UNSIGNED_INT\"] = 5125] = \"UNSIGNED_INT\";\n})(DataType || (DataType = {}));\nvar UniformSemantic;\n(function(UniformSemantic2) {\n  UniformSemantic2[UniformSemantic2[\"LOCAL\"] = 1] = \"LOCAL\";\n  UniformSemantic2[UniformSemantic2[\"MODEL\"] = 2] = \"MODEL\";\n  UniformSemantic2[UniformSemantic2[\"VIEW\"] = 3] = \"VIEW\";\n  UniformSemantic2[UniformSemantic2[\"PROJECTION\"] = 4] = \"PROJECTION\";\n  UniformSemantic2[UniformSemantic2[\"MODELVIEW\"] = 5] = \"MODELVIEW\";\n  UniformSemantic2[UniformSemantic2[\"VIEWPROJECTION\"] = 21] = \"VIEWPROJECTION\";\n  UniformSemantic2[UniformSemantic2[\"MODELVIEWPROJECTION\"] = 6] = \"MODELVIEWPROJECTION\";\n  UniformSemantic2[UniformSemantic2[\"MODELINVERSE\"] = 7] = \"MODELINVERSE\";\n  UniformSemantic2[UniformSemantic2[\"VIEWINVERSE\"] = 8] = \"VIEWINVERSE\";\n  UniformSemantic2[UniformSemantic2[\"PROJECTIONINVERSE\"] = 9] = \"PROJECTIONINVERSE\";\n  UniformSemantic2[UniformSemantic2[\"MODELVIEWINVERSE\"] = 10] = \"MODELVIEWINVERSE\";\n  UniformSemantic2[UniformSemantic2[\"MODELVIEWPROJECTIONINVERSE\"] = 11] = \"MODELVIEWPROJECTIONINVERSE\";\n  UniformSemantic2[UniformSemantic2[\"MODELINVERSETRANSPOSE\"] = 12] = \"MODELINVERSETRANSPOSE\";\n  UniformSemantic2[UniformSemantic2[\"MODELVIEWINVERSETRANSPOSE\"] = 13] = \"MODELVIEWINVERSETRANSPOSE\";\n  UniformSemantic2[UniformSemantic2[\"VIEWPORT\"] = 14] = \"VIEWPORT\";\n  UniformSemantic2[UniformSemantic2[\"JOINTMATRIX\"] = 15] = \"JOINTMATRIX\";\n  UniformSemantic2[UniformSemantic2[\"MORPHWEIGHTS\"] = 16] = \"MORPHWEIGHTS\";\n  UniformSemantic2[UniformSemantic2[\"EYEPOS\"] = 17] = \"EYEPOS\";\n  UniformSemantic2[UniformSemantic2[\"TIME\"] = 18] = \"TIME\";\n  UniformSemantic2[UniformSemantic2[\"JOINTTEXTURE\"] = 19] = \"JOINTTEXTURE\";\n  UniformSemantic2[UniformSemantic2[\"JOINTCOUNT\"] = 20] = \"JOINTCOUNT\";\n})(UniformSemantic || (UniformSemantic = {}));\nvar BlendFunc;\n(function(BlendFunc2) {\n  BlendFunc2[BlendFunc2[\"ZERO\"] = 0] = \"ZERO\";\n  BlendFunc2[BlendFunc2[\"ONE\"] = 1] = \"ONE\";\n  BlendFunc2[BlendFunc2[\"SRC_COLOR\"] = 768] = \"SRC_COLOR\";\n  BlendFunc2[BlendFunc2[\"ONE_MINUS_SRC_COLOR\"] = 769] = \"ONE_MINUS_SRC_COLOR\";\n  BlendFunc2[BlendFunc2[\"SRC_ALPHA\"] = 770] = \"SRC_ALPHA\";\n  BlendFunc2[BlendFunc2[\"ONE_MINUS_SRC_ALPHA\"] = 771] = \"ONE_MINUS_SRC_ALPHA\";\n  BlendFunc2[BlendFunc2[\"DST_ALPHA\"] = 772] = \"DST_ALPHA\";\n  BlendFunc2[BlendFunc2[\"ONE_MINUS_DST_ALPHA\"] = 773] = \"ONE_MINUS_DST_ALPHA\";\n  BlendFunc2[BlendFunc2[\"DST_COLOR\"] = 774] = \"DST_COLOR\";\n  BlendFunc2[BlendFunc2[\"ONE_MINUS_DST_COLOR\"] = 775] = \"ONE_MINUS_DST_COLOR\";\n  BlendFunc2[BlendFunc2[\"SRC_ALPHA_SATURATE\"] = 776] = \"SRC_ALPHA_SATURATE\";\n  BlendFunc2[BlendFunc2[\"enumANT_COLOR\"] = 32769] = \"enumANT_COLOR\";\n  BlendFunc2[BlendFunc2[\"ONE_MINUS_enumANT_COLOR\"] = 32770] = \"ONE_MINUS_enumANT_COLOR\";\n  BlendFunc2[BlendFunc2[\"enumANT_ALPHA\"] = 32771] = \"enumANT_ALPHA\";\n  BlendFunc2[BlendFunc2[\"ONE_MINUS_enumANT_ALPHA\"] = 32772] = \"ONE_MINUS_enumANT_ALPHA\";\n})(BlendFunc || (BlendFunc = {}));\nvar MaskList;\n(function(MaskList2) {\n  MaskList2[MaskList2[\"MASK1\"] = 1] = \"MASK1\";\n  MaskList2[MaskList2[\"MASK2\"] = 2] = \"MASK2\";\n  MaskList2[MaskList2[\"MASK3\"] = 4] = \"MASK3\";\n  MaskList2[MaskList2[\"MASK4\"] = 8] = \"MASK4\";\n  MaskList2[MaskList2[\"MASK5\"] = 16] = \"MASK5\";\n  MaskList2[MaskList2[\"MASK6\"] = 32] = \"MASK6\";\n  MaskList2[MaskList2[\"MASK7\"] = 64] = \"MASK7\";\n  MaskList2[MaskList2[\"MASK8\"] = 128] = \"MASK8\";\n  MaskList2[MaskList2[\"MASK9\"] = 256] = \"MASK9\";\n  MaskList2[MaskList2[\"MASK10\"] = 512] = \"MASK10\";\n  MaskList2[MaskList2[\"MASK11\"] = 1024] = \"MASK11\";\n  MaskList2[MaskList2[\"MASK12\"] = 2048] = \"MASK12\";\n  MaskList2[MaskList2[\"MASK13\"] = 4096] = \"MASK13\";\n  MaskList2[MaskList2[\"MASK14\"] = 8192] = \"MASK14\";\n  MaskList2[MaskList2[\"MASK15\"] = 16384] = \"MASK15\";\n  MaskList2[MaskList2[\"MASK16\"] = 32768] = \"MASK16\";\n  MaskList2[MaskList2[\"MASK17\"] = 65536] = \"MASK17\";\n  MaskList2[MaskList2[\"MASK18\"] = 131072] = \"MASK18\";\n  MaskList2[MaskList2[\"MASK19\"] = 262144] = \"MASK19\";\n  MaskList2[MaskList2[\"MASK20\"] = 524288] = \"MASK20\";\n  MaskList2[MaskList2[\"EVERYTHING\"] = 268435455] = \"EVERYTHING\";\n  MaskList2[MaskList2[\"SHADOW\"] = 268435456] = \"SHADOW\";\n  MaskList2[MaskList2[\"SHADOW_MAP\"] = 536870912] = \"SHADOW_MAP\";\n})(MaskList || (MaskList = {}));\nvar RefreshRate;\n(function(RefreshRate2) {\n  RefreshRate2[RefreshRate2[\"ONCE\"] = 1] = \"ONCE\";\n  RefreshRate2[RefreshRate2[\"EVERYFRAME\"] = 2] = \"EVERYFRAME\";\n})(RefreshRate || (RefreshRate = {}));\nvar BoundingType;\n(function(BoundingType2) {\n  BoundingType2[BoundingType2[\"AABB\"] = 0] = \"AABB\";\n  BoundingType2[BoundingType2[\"OBB\"] = 1] = \"OBB\";\n  BoundingType2[BoundingType2[\"SPHERE\"] = 2] = \"SPHERE\";\n})(BoundingType || (BoundingType = {}));\nvar GLCapabilityType;\n(function(GLCapabilityType2) {\n  GLCapabilityType2[\"standardDerivatives\"] = \"OES_standard_derivatives\";\n  GLCapabilityType2[\"shaderTextureLod\"] = \"EXT_shader_texture_lod\";\n  GLCapabilityType2[\"elementIndexUint\"] = \"OES_element_index_uint\";\n  GLCapabilityType2[\"depthTexture\"] = \"WEBGL_depth_texture\";\n  GLCapabilityType2[\"drawBuffers\"] = \"WEBGL_draw_buffers\";\n  GLCapabilityType2[\"vertexArrayObject\"] = \"OES_vertex_array_object\";\n  GLCapabilityType2[\"instancedArrays\"] = \"ANGLE_instanced_arrays\";\n  GLCapabilityType2[\"multipleSample\"] = \"multipleSampleOnlySupportedInWebGL2\";\n  GLCapabilityType2[\"textureFloat\"] = \"OES_texture_float\";\n  GLCapabilityType2[\"textureFloatLinear\"] = \"OES_texture_float_linear\";\n  GLCapabilityType2[\"textureHalfFloat\"] = \"OES_texture_half_float\";\n  GLCapabilityType2[\"textureHalfFloatLinear\"] = \"OES_texture_half_float_linear\";\n  GLCapabilityType2[\"WEBGL_colorBufferFloat\"] = \"WEBGL_color_buffer_float\";\n  GLCapabilityType2[\"colorBufferFloat\"] = \"EXT_color_buffer_float\";\n  GLCapabilityType2[\"colorBufferHalfFloat\"] = \"EXT_color_buffer_half_float\";\n  GLCapabilityType2[\"textureFilterAnisotropic\"] = \"EXT_texture_filter_anisotropic\";\n  GLCapabilityType2[\"astc\"] = \"WEBGL_compressed_texture_astc\";\n  GLCapabilityType2[\"astc_webkit\"] = \"WEBKIT_WEBGL_compressed_texture_astc\";\n  GLCapabilityType2[\"etc\"] = \"WEBGL_compressed_texture_etc\";\n  GLCapabilityType2[\"etc_webkit\"] = \"WEBKIT_WEBGL_compressed_texture_etc\";\n  GLCapabilityType2[\"etc1\"] = \"WEBGL_compressed_texture_etc1\";\n  GLCapabilityType2[\"etc1_webkit\"] = \"WEBKIT_WEBGL_compressed_texture_etc1\";\n  GLCapabilityType2[\"pvrtc\"] = \"WEBGL_compressed_texture_pvrtc\";\n  GLCapabilityType2[\"pvrtc_webkit\"] = \"WEBKIT_WEBGL_compressed_texture_pvrtc\";\n  GLCapabilityType2[\"s3tc\"] = \"WEBGL_compressed_texture_s3tc\";\n  GLCapabilityType2[\"s3tc_webkit\"] = \"WEBKIT_WEBGL_compressed_texture_s3tc\";\n})(GLCapabilityType || (GLCapabilityType = {}));\nvar OITMode;\n(function(OITMode2) {\n  OITMode2[OITMode2[\"WEIGHTED_AVERAGE\"] = 0] = \"WEIGHTED_AVERAGE\";\n  OITMode2[OITMode2[\"DEPTH_PEEL\"] = 1] = \"DEPTH_PEEL\";\n  OITMode2[OITMode2[\"DUAL_DEPTH_PEEL\"] = 2] = \"DUAL_DEPTH_PEEL\";\n})(OITMode || (OITMode = {}));\n\nclass DisorderedArray {\n  constructor(count = 0) {\n    this.length = 0;\n    this._elements = new Array(count);\n  }\n  add(element) {\n    if (this.length === this._elements.length)\n      this._elements.push(element);\n    else\n      this._elements[this.length] = element;\n    this.length++;\n  }\n  delete(element) {\n    const index = this._elements.indexOf(element);\n    this.deleteByIndex(index);\n  }\n  deleteByIndex(index) {\n    var elements = this._elements;\n    let end = null;\n    const lastIndex = this.length - 1;\n    if (index !== lastIndex) {\n      end = elements[lastIndex];\n      elements[index] = end;\n    }\n    this.length--;\n    return end;\n  }\n  garbageCollection() {\n    this._elements.length = this.length;\n  }\n}\n\nclass ComponentsManager {\n  constructor() {\n    this._onStartScripts = new DisorderedArray();\n    this._onUpdateScripts = new DisorderedArray();\n    this._onLateUpdateScripts = new DisorderedArray();\n    this._destoryComponents = [];\n    this._onUpdateAnimations = new DisorderedArray();\n    this._renderers = new DisorderedArray();\n    this._onUpdateRenderers = new DisorderedArray();\n    this._componentsContainerPool = [];\n  }\n  addRenderer(renderer) {\n    renderer._rendererIndex = this._renderers.length;\n    this._renderers.add(renderer);\n  }\n  removeRenderer(renderer) {\n    const replaced = this._renderers.deleteByIndex(renderer._rendererIndex);\n    replaced && (replaced._rendererIndex = renderer._rendererIndex);\n    renderer._rendererIndex = -1;\n  }\n  addOnStartScript(script) {\n    script._onStartIndex = this._onStartScripts.length;\n    this._onStartScripts.add(script);\n  }\n  removeOnStartScript(script) {\n    const replaced = this._onStartScripts.deleteByIndex(script._onStartIndex);\n    replaced && (replaced._onStartIndex = script._onStartIndex);\n    script._onStartIndex = -1;\n  }\n  addOnUpdateScript(script) {\n    script._onUpdateIndex = this._onUpdateScripts.length;\n    this._onUpdateScripts.add(script);\n  }\n  removeOnUpdateScript(script) {\n    const replaced = this._onUpdateScripts.deleteByIndex(script._onUpdateIndex);\n    replaced && (replaced._onUpdateIndex = script._onUpdateIndex);\n    script._onUpdateIndex = -1;\n  }\n  addOnLateUpdateScript(script) {\n    script._onLateUpdateIndex = this._onLateUpdateScripts.length;\n    this._onLateUpdateScripts.add(script);\n  }\n  removeOnLateUpdateScript(script) {\n    const replaced = this._onLateUpdateScripts.deleteByIndex(script._onLateUpdateIndex);\n    replaced && (replaced._onLateUpdateIndex = script._onLateUpdateIndex);\n    script._onLateUpdateIndex = -1;\n  }\n  addOnUpdateAnimations(animation) {\n    animation._onUpdateIndex = this._onUpdateAnimations.length;\n    this._onUpdateAnimations.add(animation);\n  }\n  removeOnUpdateAnimations(animation) {\n    const replaced = this._onUpdateAnimations.deleteByIndex(animation._onUpdateIndex);\n    replaced && (replaced._onUpdateIndex = animation._onUpdateIndex);\n    animation._onUpdateIndex = -1;\n  }\n  addOnUpdateRenderers(renderer) {\n    renderer._onUpdateIndex = this._onUpdateRenderers.length;\n    this._onUpdateRenderers.add(renderer);\n  }\n  removeOnUpdateRenderers(renderer) {\n    const replaced = this._onUpdateRenderers.deleteByIndex(renderer._onUpdateIndex);\n    replaced && (replaced._onUpdateIndex = renderer._onUpdateIndex);\n    renderer._onUpdateIndex = -1;\n  }\n  addDestoryComponent(component) {\n    this._destoryComponents.push(component);\n  }\n  callScriptOnStart() {\n    const onStartScripts = this._onStartScripts;\n    if (onStartScripts.length > 0) {\n      const elements = onStartScripts._elements;\n      for (let i = 0; i < onStartScripts.length; i++) {\n        const script = elements[i];\n        script._started = true;\n        script._onStartIndex = -1;\n        script.onStart();\n      }\n      onStartScripts.length = 0;\n    }\n  }\n  callScriptOnUpdate(deltaTime) {\n    const elements = this._onUpdateScripts._elements;\n    for (let i = this._onUpdateScripts.length - 1; i >= 0; --i) {\n      const element = elements[i];\n      if (element._started) {\n        element.onUpdate(deltaTime);\n      }\n    }\n  }\n  callScriptOnLateUpdate(deltaTime) {\n    const elements = this._onLateUpdateScripts._elements;\n    for (let i = this._onLateUpdateScripts.length - 1; i >= 0; --i) {\n      const element = elements[i];\n      if (element._started) {\n        element.onLateUpdate(deltaTime);\n      }\n    }\n  }\n  callAnimationUpdate(deltaTime) {\n    const elements = this._onUpdateAnimations._elements;\n    for (let i = this._onUpdateAnimations.length - 1; i >= 0; --i) {\n      elements[i].update(deltaTime);\n    }\n  }\n  callRendererOnUpdate(deltaTime) {\n    const elements = this._onUpdateRenderers._elements;\n    for (let i = this._onUpdateRenderers.length - 1; i >= 0; --i) {\n      elements[i].update(deltaTime);\n    }\n  }\n  callRender(camera) {\n    const elements = this._renderers._elements;\n    for (let i = this._renderers.length - 1; i >= 0; --i) {\n      elements[i]._render(camera);\n    }\n  }\n  callComponentDestory() {\n    const destoryComponents = this._destoryComponents;\n    const length = destoryComponents.length;\n    if (length > 0) {\n      for (let i = length - 1; i >= 0; --i) {\n        destoryComponents[i].onDestroy();\n      }\n      destoryComponents.length = 0;\n    }\n  }\n  callCameraOnBeginRender(camera) {\n    const camComps = camera.entity._components;\n    for (let i = camComps.length - 1; i >= 0; --i) {\n      const camComp = camComps[i];\n      camComp.onBeginRender && camComp.onBeginRender(camera);\n    }\n  }\n  callCameraOnEndRender(camera) {\n    const camComps = camera.entity._components;\n    for (let i = camComps.length - 1; i >= 0; --i) {\n      const camComp = camComps[i];\n      camComp.onBeginRender && camComp.onEndRender(camera);\n    }\n  }\n  getActiveChangedTempList() {\n    return this._componentsContainerPool.length ? this._componentsContainerPool.pop() : [];\n  }\n  putActiveChangedTempList(componentContainer) {\n    componentContainer.length = 0;\n    this._componentsContainerPool.push(componentContainer);\n  }\n}\n\nclass ComponentCloner {\n  static cloneComponent(source, target) {\n    const cloneModes = CloneManager.getCloneModeMode(source.constructor);\n    const keys = Object.keys(source);\n    for (let i = 0, n = keys.length; i < n; i++) {\n      const k = keys[i];\n      const cloneMode = cloneModes[k];\n      switch (cloneMode) {\n        case void 0:\n        case CloneMode.Assignment:\n          target[k] = source[k];\n          break;\n        case CloneMode.Shallow:\n          const sourcePropS = source[k];\n          if (sourcePropS instanceof Object) {\n            let tarProp = target[k];\n            tarProp == null && (tarProp = target[k] = sourcePropS.constructor());\n            Object.assign(tarProp, sourcePropS);\n          } else {\n            target[k] = sourcePropS;\n          }\n          break;\n        case CloneMode.Deep:\n          const sourcePropD = source[k];\n          if (sourcePropD instanceof Object) {\n            let tarProp = target[k];\n            tarProp == null && (tarProp = target[k] = sourcePropD.constructor());\n            ComponentCloner._cloneComponentProp(sourcePropD, tarProp);\n          } else {\n            target[k] = sourcePropD;\n          }\n          break;\n      }\n    }\n  }\n  static _cloneComponentProp(source, target) {\n    const type = source.constructor;\n    if (type === Object) {\n      const keys = Object.keys(source);\n      for (let i = 0, n = keys.length; i < n; i++) {\n        const k = keys[i];\n        const sourceItem = source[k];\n        if (sourceItem instanceof Object) {\n          let targetItem = target[k];\n          targetItem == null && (target[k] = targetItem = sourceItem.constructor());\n          ComponentCloner._cloneComponentProp(sourceItem, targetItem);\n        } else {\n          target[k] = sourceItem;\n        }\n      }\n    } else if (type === Array) {\n      const arraySource = source;\n      const arrayTarget = target;\n      const length = arraySource.length;\n      arrayTarget.length = length;\n      for (let i = 0; i < length; i++) {\n        const sourceItem = arraySource[i];\n        if (sourceItem instanceof Object) {\n          let targetItem = arrayTarget[i];\n          targetItem == null && (arrayTarget[i] = targetItem = sourceItem.constructor());\n          ComponentCloner._cloneComponentProp(sourceItem, targetItem);\n        } else {\n          arrayTarget[i] = sourceItem;\n        }\n      }\n    } else {\n      source.cloneTo(target);\n    }\n  }\n}\n\nclass ComponentsDependencies {\n  static register(currentComponent, dependentComponent) {\n    this._addDependency(currentComponent, dependentComponent, this._dependenciesMap);\n    this._addDependency(dependentComponent, currentComponent, this._invDependenciesMap);\n  }\n  static _addCheck(entity, type) {\n    const dependencies2 = ComponentsDependencies._dependenciesMap.get(type);\n    if (dependencies2) {\n      for (let i = 0, len = dependencies2.length; i < len; i++) {\n        if (!entity.getComponent(dependencies2[i])) {\n          throw `you should add ${dependencies2[i]} before adding ${type}`;\n        }\n      }\n    }\n  }\n  static _removeCheck(entity, type) {\n    const invDenpendencies = ComponentsDependencies._invDependenciesMap.get(type);\n    if (invDenpendencies) {\n      for (let i = 0, len = invDenpendencies.length; i < len; i++) {\n        if (entity.getComponent(invDenpendencies[i])) {\n          throw `you should remove ${invDenpendencies[i]} before adding ${type}`;\n        }\n      }\n    }\n  }\n  static _addDependency(currentComponent, dependentComponent, map) {\n    let components = map.get(currentComponent);\n    if (!components) {\n      components = [];\n      map.set(currentComponent, components);\n    }\n    if (components.indexOf(dependentComponent) === -1) {\n      components.push(dependentComponent);\n    }\n  }\n  constructor() {\n  }\n}\nComponentsDependencies._dependenciesMap = new Map();\nComponentsDependencies._invDependenciesMap = new Map();\nfunction dependencies(...abilityClass) {\n  return function(target) {\n    abilityClass.forEach((ability) => ComponentsDependencies.register(target, ability));\n  };\n}\n\nvar Layer;\n(function(Layer2) {\n  Layer2[Layer2[\"Layer0\"] = 1] = \"Layer0\";\n  Layer2[Layer2[\"Layer1\"] = 2] = \"Layer1\";\n  Layer2[Layer2[\"Layer2\"] = 4] = \"Layer2\";\n  Layer2[Layer2[\"Layer3\"] = 8] = \"Layer3\";\n  Layer2[Layer2[\"Layer4\"] = 16] = \"Layer4\";\n  Layer2[Layer2[\"Layer5\"] = 32] = \"Layer5\";\n  Layer2[Layer2[\"Layer6\"] = 64] = \"Layer6\";\n  Layer2[Layer2[\"Layer7\"] = 128] = \"Layer7\";\n  Layer2[Layer2[\"Layer8\"] = 256] = \"Layer8\";\n  Layer2[Layer2[\"Layer9\"] = 512] = \"Layer9\";\n  Layer2[Layer2[\"Layer10\"] = 1024] = \"Layer10\";\n  Layer2[Layer2[\"Layer11\"] = 2048] = \"Layer11\";\n  Layer2[Layer2[\"Layer12\"] = 4096] = \"Layer12\";\n  Layer2[Layer2[\"Layer13\"] = 8192] = \"Layer13\";\n  Layer2[Layer2[\"Layer14\"] = 16384] = \"Layer14\";\n  Layer2[Layer2[\"Layer15\"] = 32768] = \"Layer15\";\n  Layer2[Layer2[\"Layer16\"] = 65536] = \"Layer16\";\n  Layer2[Layer2[\"Layer17\"] = 131072] = \"Layer17\";\n  Layer2[Layer2[\"Layer18\"] = 262144] = \"Layer18\";\n  Layer2[Layer2[\"Layer19\"] = 524288] = \"Layer19\";\n  Layer2[Layer2[\"Layer20\"] = 1048576] = \"Layer20\";\n  Layer2[Layer2[\"Layer21\"] = 2097152] = \"Layer21\";\n  Layer2[Layer2[\"Layer22\"] = 4194304] = \"Layer22\";\n  Layer2[Layer2[\"Layer23\"] = 8388608] = \"Layer23\";\n  Layer2[Layer2[\"Layer24\"] = 16777216] = \"Layer24\";\n  Layer2[Layer2[\"Layer25\"] = 33554432] = \"Layer25\";\n  Layer2[Layer2[\"Layer26\"] = 67108864] = \"Layer26\";\n  Layer2[Layer2[\"Layer27\"] = 134217728] = \"Layer27\";\n  Layer2[Layer2[\"Layer28\"] = 268435456] = \"Layer28\";\n  Layer2[Layer2[\"Layer29\"] = 536870912] = \"Layer29\";\n  Layer2[Layer2[\"Layer30\"] = 1073741824] = \"Layer30\";\n  Layer2[Layer2[\"Layer31\"] = 2147483648] = \"Layer31\";\n  Layer2[Layer2[\"Everything\"] = 4294967295] = \"Everything\";\n  Layer2[Layer2[\"Nothing\"] = 0] = \"Nothing\";\n})(Layer || (Layer = {}));\n\nvar __defProp$2 = Object.defineProperty;\nvar __getOwnPropDesc$2 = Object.getOwnPropertyDescriptor;\nvar __decorate$2 = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$2(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result)\n    __defProp$2(target, key, result);\n  return result;\n};\nclass Component extends EventDispatcher {\n  constructor(entity) {\n    super(entity.engine);\n    this._destroyed = false;\n    this._enabled = true;\n    this._awaked = false;\n    this._renderPriority = 0;\n    this._cullDistanceSq = 0;\n    this._entity = entity;\n    this._renderPassFlag = MaskList.EVERYTHING;\n    this._passMasks = [MaskList.EVERYTHING];\n  }\n  get enabled() {\n    return this._enabled;\n  }\n  set enabled(value) {\n    if (value === this._enabled) {\n      return;\n    }\n    this._enabled = value;\n    if (value) {\n      this._entity.isActiveInHierarchy && this._onEnable();\n    } else {\n      this._entity.isActiveInHierarchy && this._onDisable();\n    }\n  }\n  get destroyed() {\n    return this._destroyed;\n  }\n  get entity() {\n    return this._entity;\n  }\n  get scene() {\n    return this._entity.scene;\n  }\n  get engine() {\n    return this._entity.engine;\n  }\n  destroy() {\n    if (this._destroyed)\n      return;\n    this._entity._removeComponent(this);\n    if (this._entity.isActiveInHierarchy) {\n      this._enabled && this._onDisable();\n      this._onInActive();\n    }\n    this._destroyed = true;\n    this._onDestroy();\n  }\n  _onAwake() {\n  }\n  _onEnable() {\n  }\n  _onDisable() {\n  }\n  _onDestroy() {\n  }\n  _onActive() {\n  }\n  _onInActive() {\n  }\n  _setActive(value) {\n    if (value) {\n      if (!this._awaked) {\n        this._awaked = true;\n        this._onAwake();\n      }\n      if (this._entity._isActiveInHierarchy) {\n        this._onActive();\n        this._enabled && this._onEnable();\n      }\n    } else {\n      this._enabled && this._onDisable();\n      this._onInActive();\n    }\n  }\n  get renderPriority() {\n    return this._renderPriority;\n  }\n  set renderPriority(val) {\n    this._renderPriority = val;\n  }\n  get cullDistanceSq() {\n    return this._cullDistanceSq;\n  }\n  get cullDistance() {\n    return Math.sqrt(this._cullDistanceSq);\n  }\n  set cullDistance(val) {\n    this._cullDistanceSq = val * val;\n  }\n  get renderPassFlag() {\n    return this._renderPassFlag;\n  }\n  set renderPassFlag(val) {\n    this._renderPassFlag = val;\n  }\n  setPassMasks(...masks) {\n    this._passMasks = masks;\n    this._renderPassFlag = masks.reduce((a, b) => a | b, 0);\n  }\n  addPassMasks(...masks) {\n    for (const mask of masks) {\n      const idx = this._passMasks.indexOf(mask);\n      if (idx < 0) {\n        this._passMasks.push(mask);\n      }\n    }\n    this.setPassMasks(...this._passMasks);\n  }\n  removePassMasks(...masks) {\n    for (const mask of masks) {\n      const idx = this._passMasks.indexOf(mask);\n      if (idx > -1) {\n        this._passMasks.splice(idx, 1);\n      }\n    }\n    this.setPassMasks(...this._passMasks);\n  }\n}\n__decorate$2([\n  ignoreClone\n], Component.prototype, \"_entity\", 2);\n__decorate$2([\n  ignoreClone\n], Component.prototype, \"_destroyed\", 2);\n__decorate$2([\n  ignoreClone\n], Component.prototype, \"_enabled\", 2);\n__decorate$2([\n  ignoreClone\n], Component.prototype, \"_awaked\", 2);\n\nclass UpdateFlag {\n  constructor(_flags = []) {\n    this._flags = _flags;\n    this.flag = true;\n  }\n  destroy() {\n    const flags = this._flags;\n    removeFromArray(flags, this);\n    this._flags = null;\n  }\n}\n\nvar __defProp$3 = Object.defineProperty;\nvar __getOwnPropDesc$3 = Object.getOwnPropertyDescriptor;\nvar __decorate$3 = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$3(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result)\n    __defProp$3(target, key, result);\n  return result;\n};\nclass Transform extends Component {\n  constructor() {\n    super(...arguments);\n    this._position = new Vector3();\n    this._rotation = new Vector3();\n    this._rotationQuaternion = new Quaternion();\n    this._scale = new Vector3(1, 1, 1);\n    this._worldPosition = new Vector3();\n    this._worldRotation = new Vector3();\n    this._worldRotationQuaternion = new Quaternion();\n    this._lossyWorldScale = new Vector3(1, 1, 1);\n    this._localMatrix = new Matrix();\n    this._worldMatrix = new Matrix();\n    this._changeFlags = [];\n    this._isParentDirty = true;\n    this._parentTransformCache = null;\n    this._dirtyFlag = Transform._WM_WP_WE_WQ_WS_FLAGS;\n  }\n  get position() {\n    return this._position;\n  }\n  set position(value) {\n    if (this._position !== value) {\n      value.cloneTo(this._position);\n    }\n    this._setDirtyFlagTrue(Transform._LOCAL_MATRIX_FLAG);\n    this._updateWorldPositionFlag();\n  }\n  get worldPosition() {\n    if (this._isContainDirtyFlag(Transform._WORLD_POSITION_FLAG)) {\n      if (this._getParentTransform()) {\n        this.worldMatrix.getTranslation(this._worldPosition);\n      } else {\n        this._position.cloneTo(this._worldPosition);\n      }\n      this._setDirtyFlagFalse(Transform._WORLD_POSITION_FLAG);\n    }\n    return this._worldPosition;\n  }\n  set worldPosition(value) {\n    if (this._worldPosition !== value) {\n      value.cloneTo(this._worldPosition);\n    }\n    const parent = this._getParentTransform();\n    if (parent) {\n      Matrix.invert(parent.worldMatrix, Transform._tempMat41);\n      Vector3.transformCoordinate(value, Transform._tempMat41, this._position);\n    } else {\n      value.cloneTo(this._position);\n    }\n    this.position = this._position;\n    this._setDirtyFlagFalse(Transform._WORLD_POSITION_FLAG);\n  }\n  get rotation() {\n    if (this._isContainDirtyFlag(Transform._LOCAL_EULER_FLAG)) {\n      this._rotationQuaternion.toEuler(this._rotation);\n      this._rotation.scale(MathUtil.radToDegreeFactor);\n      this._setDirtyFlagFalse(Transform._LOCAL_EULER_FLAG);\n    }\n    return this._rotation;\n  }\n  set rotation(value) {\n    if (this._rotation !== value) {\n      value.cloneTo(this._rotation);\n    }\n    this._setDirtyFlagTrue(Transform._LOCAL_MATRIX_FLAG | Transform._LOCAL_QUAT_FLAG);\n    this._setDirtyFlagFalse(Transform._LOCAL_EULER_FLAG);\n    this._updateWorldRotationFlag();\n  }\n  get worldRotation() {\n    if (this._isContainDirtyFlag(Transform._WORLD_EULER_FLAG)) {\n      this.worldRotationQuaternion.toEuler(this._worldRotation);\n      this._worldRotation.scale(MathUtil.radToDegreeFactor);\n      this._setDirtyFlagFalse(Transform._WORLD_EULER_FLAG);\n    }\n    return this._worldRotation;\n  }\n  set worldRotation(value) {\n    if (this._worldRotation !== value) {\n      value.cloneTo(this._worldRotation);\n    }\n    Quaternion.rotationEuler(MathUtil.degreeToRadian(value.x), MathUtil.degreeToRadian(value.y), MathUtil.degreeToRadian(value.z), this._worldRotationQuaternion);\n    this.worldRotationQuaternion = this._worldRotationQuaternion;\n    this._setDirtyFlagFalse(Transform._WORLD_EULER_FLAG);\n  }\n  get rotationQuaternion() {\n    if (this._isContainDirtyFlag(Transform._LOCAL_QUAT_FLAG)) {\n      Quaternion.rotationEuler(MathUtil.degreeToRadian(this._rotation.x), MathUtil.degreeToRadian(this._rotation.y), MathUtil.degreeToRadian(this._rotation.z), this._rotationQuaternion);\n      this._setDirtyFlagFalse(Transform._LOCAL_QUAT_FLAG);\n    }\n    return this._rotationQuaternion;\n  }\n  set rotationQuaternion(value) {\n    if (this._rotationQuaternion !== value) {\n      value.cloneTo(this._rotationQuaternion);\n    }\n    this._setDirtyFlagTrue(Transform._LOCAL_MATRIX_FLAG | Transform._LOCAL_EULER_FLAG);\n    this._setDirtyFlagFalse(Transform._LOCAL_QUAT_FLAG);\n    this._updateWorldRotationFlag();\n  }\n  get worldRotationQuaternion() {\n    if (this._isContainDirtyFlag(Transform._WORLD_QUAT_FLAG)) {\n      const parent = this._getParentTransform();\n      if (parent != null) {\n        Quaternion.multiply(parent.worldRotationQuaternion, this.rotationQuaternion, this._worldRotationQuaternion);\n      } else {\n        this.rotationQuaternion.cloneTo(this._worldRotationQuaternion);\n      }\n      this._setDirtyFlagFalse(Transform._WORLD_QUAT_FLAG);\n    }\n    return this._worldRotationQuaternion;\n  }\n  set worldRotationQuaternion(value) {\n    if (this._worldRotationQuaternion !== value) {\n      value.cloneTo(this._worldRotationQuaternion);\n    }\n    const parent = this._getParentTransform();\n    if (parent) {\n      Quaternion.invert(parent.worldRotationQuaternion, Transform._tempQuat0);\n      Quaternion.multiply(value, Transform._tempQuat0, this._rotationQuaternion);\n    } else {\n      value.cloneTo(this._rotationQuaternion);\n    }\n    this.rotationQuaternion = this._rotationQuaternion;\n    this._setDirtyFlagFalse(Transform._WORLD_QUAT_FLAG);\n  }\n  get scale() {\n    return this._scale;\n  }\n  set scale(value) {\n    if (this._scale !== value) {\n      value.cloneTo(this._scale);\n    }\n    this._setDirtyFlagTrue(Transform._LOCAL_MATRIX_FLAG);\n    this._updateWorldScaleFlag();\n  }\n  get lossyWorldScale() {\n    if (this._isContainDirtyFlag(Transform._WORLD_SCALE_FLAG)) {\n      if (this._getParentTransform()) {\n        const scaleMat = this._getScaleMatrix();\n        const e = scaleMat.elements;\n        this._lossyWorldScale.setValue(e[0], e[4], e[8]);\n      } else {\n        this._scale.cloneTo(this._lossyWorldScale);\n      }\n      this._setDirtyFlagFalse(Transform._WORLD_SCALE_FLAG);\n    }\n    return this._lossyWorldScale;\n  }\n  get localMatrix() {\n    if (this._isContainDirtyFlag(Transform._LOCAL_MATRIX_FLAG)) {\n      Matrix.affineTransformation(this._scale, this.rotationQuaternion, this._position, this._localMatrix);\n      this._setDirtyFlagFalse(Transform._LOCAL_MATRIX_FLAG);\n    }\n    return this._localMatrix;\n  }\n  set localMatrix(value) {\n    if (this._localMatrix !== value) {\n      value.cloneTo(this._localMatrix);\n    }\n    this._localMatrix.decompose(this._position, this._rotationQuaternion, this._scale);\n    this._setDirtyFlagTrue(Transform._LOCAL_EULER_FLAG);\n    this._setDirtyFlagFalse(Transform._LOCAL_MATRIX_FLAG);\n    this._updateAllWorldFlag();\n  }\n  get worldMatrix() {\n    if (this._isContainDirtyFlag(Transform._WORLD_MATRIX_FLAG)) {\n      const parent = this._getParentTransform();\n      if (parent) {\n        Matrix.multiply(parent.worldMatrix, this.localMatrix, this._worldMatrix);\n      } else {\n        this.localMatrix.cloneTo(this._worldMatrix);\n      }\n      this._setDirtyFlagFalse(Transform._WORLD_MATRIX_FLAG);\n    }\n    return this._worldMatrix;\n  }\n  set worldMatrix(value) {\n    if (this._worldMatrix !== value) {\n      value.cloneTo(this._worldMatrix);\n    }\n    const parent = this._getParentTransform();\n    if (parent) {\n      Matrix.invert(parent.worldMatrix, Transform._tempMat42);\n      Matrix.multiply(value, Transform._tempMat42, this._localMatrix);\n    } else {\n      value.cloneTo(this._localMatrix);\n    }\n    this.localMatrix = this._localMatrix;\n    this._setDirtyFlagFalse(Transform._WORLD_MATRIX_FLAG);\n  }\n  setPosition(x, y, z) {\n    this._position.setValue(x, y, z);\n    this.position = this._position;\n  }\n  setRotation(x, y, z) {\n    this._rotation.setValue(x, y, z);\n    this.rotation = this._rotation;\n  }\n  setRotationQuaternion(x, y, z, w) {\n    this._rotationQuaternion.setValue(x, y, z, w);\n    this.rotationQuaternion = this._rotationQuaternion;\n  }\n  setScale(x, y, z) {\n    this._scale.setValue(x, y, z);\n    this.scale = this._scale;\n  }\n  setWorldPosition(x, y, z) {\n    this._worldPosition.setValue(x, y, z);\n    this.worldPosition = this._worldPosition;\n  }\n  setWorldRotation(x, y, z) {\n    this._worldRotation.setValue(x, y, z);\n    this.worldRotation = this._worldRotation;\n  }\n  setWorldRotationQuaternion(x, y, z, w) {\n    this._worldRotationQuaternion.setValue(x, y, z, w);\n    this.worldRotationQuaternion = this._worldRotationQuaternion;\n  }\n  getWorldForward(forward) {\n    const e = this.worldMatrix.elements;\n    forward.setValue(-e[8], -e[9], -e[10]);\n    return forward.normalize();\n  }\n  getWorldRight(right) {\n    const e = this.worldMatrix.elements;\n    right.setValue(e[0], e[1], e[2]);\n    return right.normalize();\n  }\n  getWorldUp(up) {\n    const e = this.worldMatrix.elements;\n    up.setValue(e[4], e[5], e[6]);\n    return up.normalize();\n  }\n  translate(translation, relativeToLocal = true) {\n    if (relativeToLocal) {\n      const rotationMat = Transform._tempMat40;\n      Matrix.rotationQuaternion(this.rotationQuaternion, rotationMat);\n      Vector3.transformCoordinate(translation, rotationMat, Transform._tempVec3);\n      this.position = this._position.add(Transform._tempVec3);\n    } else {\n      this.worldPosition = this._worldPosition.add(translation);\n    }\n  }\n  translateXYZ(x, y, z, relativeToLocal = true) {\n    const translate = Transform._tempVec3;\n    translate.setValue(x, y, z);\n    this.translate(translate, relativeToLocal);\n  }\n  rotate(rotation, relativeToLocal = true) {\n    this.rotateXYZ(rotation.x, rotation.y, rotation.z, relativeToLocal);\n  }\n  rotateXYZ(x, y, z, relativeToLocal = true) {\n    const radFactor = MathUtil.degreeToRadFactor;\n    const rotQuat = Transform._tempQuat0;\n    Quaternion.rotationEuler(x * radFactor, y * radFactor, z * radFactor, rotQuat);\n    this._rotateByQuat(rotQuat, relativeToLocal);\n  }\n  rotateByAxis(axis, angle, relativeToLocal = true) {\n    const rad = angle * MathUtil.degreeToRadFactor;\n    Quaternion.rotationAxisAngle(axis, rad, Transform._tempQuat0);\n    this._rotateByQuat(Transform._tempQuat0, relativeToLocal);\n  }\n  lookAt(worldPosition, worldUp) {\n    const position = this.worldPosition;\n    const EPSILON = MathUtil.zeroTolerance;\n    if (Math.abs(position.x - worldPosition.x) < EPSILON && Math.abs(position.y - worldPosition.y) < EPSILON && Math.abs(position.z - worldPosition.z) < EPSILON) {\n      return;\n    }\n    const rotMat = Transform._tempMat43;\n    const worldRotationQuaternion = this._worldRotationQuaternion;\n    worldUp = worldUp ?? Transform._tempVec3.setValue(0, 1, 0);\n    Matrix.lookAt(position, worldPosition, worldUp, rotMat);\n    rotMat.getRotation(worldRotationQuaternion).invert();\n    this.worldRotationQuaternion = worldRotationQuaternion;\n  }\n  registerWorldChangeFlag() {\n    const flag = new UpdateFlag(this._changeFlags);\n    this._changeFlags.push(flag);\n    return flag;\n  }\n  _parentChange() {\n    this._isParentDirty = true;\n    this._updateAllWorldFlag();\n  }\n  _updateWorldPositionFlag() {\n    if (!this._isContainDirtyFlags(Transform._WM_WP_FLAGS)) {\n      this._worldAssociatedChange(Transform._WM_WP_FLAGS);\n      const nodeChildren = this._entity._children;\n      for (let i = 0, n = nodeChildren.length; i < n; i++) {\n        nodeChildren[i].transform?._updateWorldPositionFlag();\n      }\n    }\n  }\n  _updateWorldRotationFlag() {\n    if (!this._isContainDirtyFlags(Transform._WM_WE_WQ_FLAGS)) {\n      this._worldAssociatedChange(Transform._WM_WE_WQ_FLAGS);\n      const nodeChildren = this._entity._children;\n      for (let i = 0, n = nodeChildren.length; i < n; i++) {\n        nodeChildren[i].transform?._updateWorldPositionAndRotationFlag();\n      }\n    }\n  }\n  _updateWorldPositionAndRotationFlag() {\n    if (!this._isContainDirtyFlags(Transform._WM_WP_WE_WQ_FLAGS)) {\n      this._worldAssociatedChange(Transform._WM_WP_WE_WQ_FLAGS);\n      const nodeChildren = this._entity._children;\n      for (let i = 0, n = nodeChildren.length; i < n; i++) {\n        nodeChildren[i].transform?._updateWorldPositionAndRotationFlag();\n      }\n    }\n  }\n  _updateWorldScaleFlag() {\n    if (!this._isContainDirtyFlags(Transform._WM_WS_FLAGS)) {\n      this._worldAssociatedChange(Transform._WM_WS_FLAGS);\n      const nodeChildren = this._entity._children;\n      for (let i = 0, n = nodeChildren.length; i < n; i++) {\n        nodeChildren[i].transform?._updateWorldPositionAndScaleFlag();\n      }\n    }\n  }\n  _updateWorldPositionAndScaleFlag() {\n    if (!this._isContainDirtyFlags(Transform._WM_WP_WS_FLAGS)) {\n      this._worldAssociatedChange(Transform._WM_WP_WS_FLAGS);\n      const nodeChildren = this._entity._children;\n      for (let i = 0, n = nodeChildren.length; i < n; i++) {\n        nodeChildren[i].transform?._updateWorldPositionAndScaleFlag();\n      }\n    }\n  }\n  _updateAllWorldFlag() {\n    if (!this._isContainDirtyFlags(Transform._WM_WP_WE_WQ_WS_FLAGS)) {\n      this._worldAssociatedChange(Transform._WM_WP_WE_WQ_WS_FLAGS);\n      const nodeChildren = this._entity._children;\n      for (let i = 0, n = nodeChildren.length; i < n; i++) {\n        nodeChildren[i].transform?._updateAllWorldFlag();\n      }\n    }\n  }\n  _getParentTransform() {\n    if (!this._isParentDirty) {\n      return this._parentTransformCache;\n    }\n    let parentCache = null;\n    let parent = this._entity.parent;\n    while (parent) {\n      const transform = parent.transform;\n      if (transform) {\n        parentCache = transform;\n        break;\n      } else {\n        parent = parent.parent;\n      }\n    }\n    this._parentTransformCache = parentCache;\n    this._isParentDirty = false;\n    return parentCache;\n  }\n  _getScaleMatrix() {\n    const invRotation = Transform._tempQuat0;\n    const invRotationMat = Transform._tempMat30;\n    const worldRotScaMat = Transform._tempMat31;\n    const scaMat = Transform._tempMat32;\n    worldRotScaMat.setValueByMatrix(this.worldMatrix);\n    Quaternion.invert(this.worldRotationQuaternion, invRotation);\n    Matrix3x3.rotationQuaternion(invRotation, invRotationMat);\n    Matrix3x3.multiply(invRotationMat, worldRotScaMat, scaMat);\n    return scaMat;\n  }\n  _isContainDirtyFlags(targetDirtyFlags) {\n    return (this._dirtyFlag & targetDirtyFlags) === targetDirtyFlags;\n  }\n  _isContainDirtyFlag(type) {\n    return (this._dirtyFlag & type) != 0;\n  }\n  _setDirtyFlagTrue(type) {\n    this._dirtyFlag |= type;\n  }\n  _setDirtyFlagFalse(type) {\n    this._dirtyFlag &= ~type;\n  }\n  _worldAssociatedChange(type) {\n    this._dirtyFlag |= type;\n    const len = this._changeFlags.length;\n    for (let i = len - 1; i >= 0; i--) {\n      this._changeFlags[i].flag = true;\n    }\n  }\n  _rotateByQuat(rotateQuat, relativeToLocal) {\n    if (relativeToLocal) {\n      Quaternion.multiply(this.rotationQuaternion, rotateQuat, this._rotationQuaternion);\n      this.rotationQuaternion = this._rotationQuaternion;\n    } else {\n      Quaternion.multiply(this.worldRotationQuaternion, rotateQuat, this._worldRotationQuaternion);\n      this.worldRotationQuaternion = this._worldRotationQuaternion;\n    }\n  }\n}\nTransform._tempQuat0 = new Quaternion();\nTransform._tempVec3 = new Vector3();\nTransform._tempMat30 = new Matrix3x3();\nTransform._tempMat31 = new Matrix3x3();\nTransform._tempMat32 = new Matrix3x3();\nTransform._tempMat40 = new Matrix();\nTransform._tempMat41 = new Matrix();\nTransform._tempMat42 = new Matrix();\nTransform._tempMat43 = new Matrix();\nTransform._LOCAL_EULER_FLAG = 1;\nTransform._LOCAL_QUAT_FLAG = 2;\nTransform._WORLD_POSITION_FLAG = 4;\nTransform._WORLD_EULER_FLAG = 8;\nTransform._WORLD_QUAT_FLAG = 16;\nTransform._WORLD_SCALE_FLAG = 32;\nTransform._LOCAL_MATRIX_FLAG = 64;\nTransform._WORLD_MATRIX_FLAG = 128;\nTransform._WM_WP_FLAGS = 132;\nTransform._WM_WE_WQ_FLAGS = 152;\nTransform._WM_WP_WE_WQ_FLAGS = 156;\nTransform._WM_WS_FLAGS = 160;\nTransform._WM_WP_WS_FLAGS = 164;\nTransform._WM_WP_WE_WQ_WS_FLAGS = 188;\n__decorate$3([\n  deepClone\n], Transform.prototype, \"_position\", 2);\n__decorate$3([\n  deepClone\n], Transform.prototype, \"_rotation\", 2);\n__decorate$3([\n  deepClone\n], Transform.prototype, \"_rotationQuaternion\", 2);\n__decorate$3([\n  deepClone\n], Transform.prototype, \"_scale\", 2);\n__decorate$3([\n  deepClone\n], Transform.prototype, \"_worldPosition\", 2);\n__decorate$3([\n  deepClone\n], Transform.prototype, \"_worldRotation\", 2);\n__decorate$3([\n  deepClone\n], Transform.prototype, \"_worldRotationQuaternion\", 2);\n__decorate$3([\n  deepClone\n], Transform.prototype, \"_lossyWorldScale\", 2);\n__decorate$3([\n  deepClone\n], Transform.prototype, \"_localMatrix\", 2);\n__decorate$3([\n  deepClone\n], Transform.prototype, \"_worldMatrix\", 2);\n__decorate$3([\n  ignoreClone\n], Transform.prototype, \"_changeFlags\", 2);\n__decorate$3([\n  ignoreClone\n], Transform.prototype, \"_isParentDirty\", 2);\n__decorate$3([\n  ignoreClone\n], Transform.prototype, \"_parentTransformCache\", 2);\n\nclass Entity extends EventDispatcher {\n  constructor(engine, name) {\n    super(engine);\n    this.layer = Layer.Layer0;\n    this._isActiveInHierarchy = false;\n    this._components = [];\n    this._children = [];\n    this._isRoot = false;\n    this._isActive = true;\n    this._parent = null;\n    this._invModelMatrix = new Matrix();\n    Entity._entitys.add(this);\n    this.name = name;\n    this.transform = this.addComponent(Transform);\n    this._inverseWorldMatFlag = this.transform.registerWorldChangeFlag();\n  }\n  static findByName(name) {\n    const entitys = Entity._entitys;\n    const elements = entitys._elements;\n    for (let i = entitys.length - 1; i >= 0; i--) {\n      const entity = elements[i];\n      if (entity.name === name) {\n        return entity;\n      }\n    }\n    return null;\n  }\n  static findByPath(scene, path) {\n    return scene.findEntityByPath(path);\n  }\n  static _findChildByName(root, name) {\n    const children = root._children;\n    for (let i = children.length - 1; i >= 0; i--) {\n      const child = children[i];\n      if (child.name === name) {\n        return child;\n      }\n    }\n    return null;\n  }\n  static _traverseSetOwnerScene(entity, scene) {\n    entity._scene = scene;\n    const children = entity._children;\n    for (let i = entity.childCount - 1; i >= 0; i--) {\n      this._traverseSetOwnerScene(children[i], scene);\n    }\n  }\n  get isActive() {\n    return this._isActive;\n  }\n  set isActive(value) {\n    if (value !== this._isActive) {\n      this._isActive = value;\n      if (value) {\n        const parent = this._parent;\n        if (parent?._isActiveInHierarchy || this._isRoot && this._scene._isActiveInEngine) {\n          this._processActive();\n        }\n      } else {\n        if (this._isActiveInHierarchy) {\n          this._processInActive();\n        }\n      }\n    }\n  }\n  get isActiveInHierarchy() {\n    return this._isActiveInHierarchy;\n  }\n  get parent() {\n    return this._parent;\n  }\n  set parent(entity) {\n    if (entity !== this._parent) {\n      const oldParent = this._removeFromParent();\n      const newParent = this._parent = entity;\n      if (newParent) {\n        newParent._children.push(this);\n        const parentScene = newParent._scene;\n        if (this._scene !== parentScene) {\n          Entity._traverseSetOwnerScene(this, parentScene);\n        }\n        if (newParent._isActiveInHierarchy) {\n          !this._isActiveInHierarchy && this._isActive && this._processActive();\n        } else {\n          this._isActiveInHierarchy && this._processInActive();\n        }\n      } else {\n        this._isActiveInHierarchy && this._processInActive();\n        if (oldParent) {\n          Entity._traverseSetOwnerScene(this, null);\n        }\n      }\n      this._setTransformDirty();\n    }\n  }\n  get children() {\n    return this._children;\n  }\n  get childCount() {\n    return this._children.length;\n  }\n  get scene() {\n    return this._scene;\n  }\n  get engine() {\n    return this._engine;\n  }\n  addComponent(type) {\n    ComponentsDependencies._addCheck(this, type);\n    const component = new type(this);\n    this._components.push(component);\n    if (this._isActiveInHierarchy) {\n      component._setActive(true);\n    }\n    return component;\n  }\n  getComponent(type) {\n    for (let i = this._components.length - 1; i >= 0; i--) {\n      const component = this._components[i];\n      if (component instanceof type) {\n        return component;\n      }\n    }\n  }\n  getComponents(type, results) {\n    results.length = 0;\n    for (let i = this._components.length - 1; i >= 0; i--) {\n      const component = this._components[i];\n      if (component instanceof type) {\n        results.push(component);\n      }\n    }\n    return results;\n  }\n  getComponentsIncludeChildren(type, results) {\n    results.length = 0;\n    this._getComponentsIncludeChildren(type, results);\n    return results;\n  }\n  addChild(child) {\n    child.parent = this;\n  }\n  removeChild(child) {\n    child.parent = null;\n  }\n  getChild(index) {\n    return this._children[index];\n  }\n  findByName(name) {\n    const children = this._children;\n    const child = Entity._findChildByName(this, name);\n    if (child)\n      return child;\n    for (let i = children.length - 1; i >= 0; i--) {\n      const child2 = children[i];\n      const grandson = child2.findByName(name);\n      if (grandson) {\n        return grandson;\n      }\n    }\n    return null;\n  }\n  findByPath(path) {\n    const splits = path.split(\"/\");\n    let entity = this;\n    for (let i = 0, length = splits.length; i < length; ++i) {\n      const split = splits[i];\n      if (split) {\n        entity = Entity._findChildByName(entity, split);\n        if (!entity) {\n          return null;\n        }\n      }\n    }\n    return entity;\n  }\n  createChild(name) {\n    const child = new Entity(this.engine, name);\n    child.layer = this.layer;\n    child.parent = this;\n    return child;\n  }\n  clearChildren() {\n    const children = this._children;\n    for (let i = children.length - 1; i >= 0; i--) {\n      const child = children[i];\n      child._parent = null;\n      child._isActiveInHierarchy && child._processInActive();\n      Entity._traverseSetOwnerScene(child, null);\n    }\n    children.length = 0;\n  }\n  clone() {\n    const cloneEntity = new Entity(this._engine, this.name);\n    cloneEntity._isActive = this._isActive;\n    cloneEntity.transform.localMatrix = this.transform.localMatrix;\n    const children = this._children;\n    for (let i = 0, len = this._children.length; i < len; i++) {\n      const child = children[i];\n      cloneEntity.addChild(child.clone());\n    }\n    const components = this._components;\n    for (let i = 0, n = components.length; i < n; i++) {\n      const sourceComp = components[i];\n      if (!(sourceComp instanceof Transform)) {\n        const targetComp = cloneEntity.addComponent(sourceComp.constructor);\n        ComponentCloner.cloneComponent(sourceComp, targetComp);\n      }\n    }\n    return cloneEntity;\n  }\n  destroy() {\n    const abilityArray = this._components;\n    for (let i = abilityArray.length - 1; i >= 0; i--) {\n      abilityArray[i].destroy();\n    }\n    this._components.length = 0;\n    const children = this._children;\n    for (let i = children.length - 1; i >= 0; i--) {\n      children[i].destroy();\n    }\n    this._children.length = 0;\n    if (this._parent != null) {\n      const parentChildren = this._parent._children;\n      parentChildren.splice(parentChildren.indexOf(this), 1);\n    }\n    this._parent = null;\n    Entity._entitys.delete(this);\n  }\n  _removeComponent(component) {\n    ComponentsDependencies._removeCheck(this, component.constructor);\n    const components = this._components;\n    components.splice(components.indexOf(component), 1);\n  }\n  _removeFromParent() {\n    const oldParent = this._parent;\n    if (oldParent != null) {\n      const oldParentChildren = oldParent._children;\n      oldParentChildren.splice(oldParentChildren.indexOf(this), 1);\n      this._parent = null;\n    }\n    return oldParent;\n  }\n  _processActive() {\n    if (this._activeChangedComponents) {\n      throw \"Note: can't set the 'main inActive entity' active in hierarchy, if the operation is in main inActive entity or it's children script's onDisable Event.\";\n    }\n    this._activeChangedComponents = this._engine._componentsManager.getActiveChangedTempList();\n    this._setActiveInHierarchy(this._activeChangedComponents);\n    this._setActiveComponents(true);\n  }\n  _processInActive() {\n    if (this._activeChangedComponents) {\n      throw \"Note: can't set the 'main active entity' inActive in hierarchy, if the operation is in main active entity or it's children script's onEnable Event.\";\n    }\n    this._activeChangedComponents = this._engine._componentsManager.getActiveChangedTempList();\n    this._setInActiveInHierarchy(this._activeChangedComponents);\n    this._setActiveComponents(false);\n  }\n  _getComponentsIncludeChildren(type, results) {\n    for (let i = this._components.length - 1; i >= 0; i--) {\n      const component = this._components[i];\n      if (component instanceof type) {\n        results.push(component);\n      }\n    }\n    for (let i = this._children.length - 1; i >= 0; i--) {\n      this._children[i]._getComponentsIncludeChildren(type, results);\n    }\n  }\n  _setActiveComponents(isActive) {\n    const activeChangedComponents = this._activeChangedComponents;\n    for (let i = 0, length = activeChangedComponents.length; i < length; ++i) {\n      activeChangedComponents[i]._setActive(isActive);\n    }\n    this._engine._componentsManager.putActiveChangedTempList(activeChangedComponents);\n    this._activeChangedComponents = null;\n  }\n  _setActiveInHierarchy(activeChangedComponents) {\n    this._isActiveInHierarchy = true;\n    const components = this._components;\n    for (let i = components.length - 1; i >= 0; i--) {\n      activeChangedComponents.push(components[i]);\n    }\n    const children = this._children;\n    for (let i = children.length - 1; i >= 0; i--) {\n      const child = children[i];\n      child.isActive && child._setActiveInHierarchy(activeChangedComponents);\n    }\n  }\n  _setInActiveInHierarchy(activeChangedComponents) {\n    this._isActiveInHierarchy = false;\n    const components = this._components;\n    for (let i = components.length - 1; i >= 0; i--) {\n      activeChangedComponents.push(components[i]);\n    }\n    const children = this._children;\n    for (let i = children.length - 1; i >= 0; i--) {\n      const child = children[i];\n      child.isActive && child._setInActiveInHierarchy(activeChangedComponents);\n    }\n  }\n  _setTransformDirty() {\n    if (this.transform) {\n      this.transform._parentChange();\n    } else {\n      for (let i = 0, len = this._children.length; i < len; i++) {\n        this._children[i]._setTransformDirty();\n      }\n    }\n  }\n  get position() {\n    return this.transform.position;\n  }\n  set position(val) {\n    this.transform.position = val;\n  }\n  get worldPosition() {\n    return this.transform.worldPosition;\n  }\n  set worldPosition(val) {\n    this.transform.worldPosition = val;\n  }\n  get rotation() {\n    return this.transform.rotationQuaternion;\n  }\n  set rotation(val) {\n    this.transform.rotationQuaternion = val;\n  }\n  get scale() {\n    return this.transform.scale;\n  }\n  set scale(val) {\n    this.transform.scale = val;\n  }\n  getInvModelMatrix() {\n    if (this._inverseWorldMatFlag.flag) {\n      Matrix.invert(this.transform.worldMatrix, this._invModelMatrix);\n      this._inverseWorldMatFlag.flag = false;\n    }\n    return this._invModelMatrix;\n  }\n}\nEntity._entitys = new DisorderedArray();\n\nclass FeatureManager {\n  constructor() {\n    this._features = [];\n    this._objects = [];\n  }\n  registerFeature(IFeature) {\n    const featureArray = this._features;\n    for (let i = 0, len = featureArray.length; i < len; i++) {\n      if (featureArray[i] === IFeature) {\n        return;\n      }\n    }\n    featureArray.push(IFeature);\n    const objectArray = this._objects;\n    for (let i = 0, len = objectArray.length; i < len; i++) {\n      objectArray[i].features.push(new IFeature());\n    }\n  }\n  addObject(obj) {\n    obj.features = [];\n    for (let i = 0, len = this._features.length; i < len; i++) {\n      obj.features.push(new this._features[i](obj.engine ?? obj));\n    }\n    this._objects.push(obj);\n  }\n  callFeatureMethod(obj, method, args) {\n    const features = obj.features;\n    const count = features.length;\n    for (let i = 0; i < count; i++) {\n      const feature = features[i];\n      if (feature[method]) {\n        feature[method].apply(feature, args);\n      }\n    }\n  }\n  findFeature(obj, IFeature) {\n    const features = obj.features;\n    const count = features.length;\n    for (let i = 0; i < count; i++) {\n      const feature = features[i];\n      if (feature.constructor === IFeature) {\n        return feature;\n      }\n    }\n    return void 0;\n  }\n}\n\nclass RenderElement {\n  static getFromPool() {\n    const {_elementPoolIndex: index, _elementPool: pool} = RenderElement;\n    RenderElement._elementPoolIndex++;\n    if (pool.length === index) {\n      const element = new RenderElement();\n      pool.push(element);\n      return element;\n    } else {\n      return pool[index];\n    }\n  }\n  static _restPool() {\n    RenderElement._elementPoolIndex = 0;\n  }\n  setValue(component, primitive, subPrimitive, material) {\n    this.component = component;\n    this.primitive = primitive;\n    this.subPrimitive = subPrimitive;\n    this.material = material;\n  }\n}\nRenderElement._elementPoolIndex = 0;\nRenderElement._elementPool = [];\n\nclass Scene extends EventDispatcher {\n  constructor(engine, name) {\n    super(engine);\n    this.clipPlanes = [];\n    this._activeCameras = [];\n    this._isActiveInEngine = false;\n    this._destroyed = false;\n    this._rootEntities = [];\n    this.features = [];\n    this.name = name || \"\";\n    Scene.sceneFeatureManager.addObject(this);\n  }\n  get engine() {\n    return this._engine;\n  }\n  get rootEntitiesCount() {\n    return this._rootEntities.length;\n  }\n  get rootEntities() {\n    return this._rootEntities;\n  }\n  get destroyed() {\n    return this._destroyed;\n  }\n  createRootEntity(name) {\n    const entity = new Entity(this._engine, name);\n    this.addRootEntity(entity);\n    return entity;\n  }\n  addRootEntity(entity) {\n    const isRoot = entity._isRoot;\n    if (!isRoot) {\n      entity._isRoot = true;\n      entity._removeFromParent();\n    }\n    const oldScene = entity._scene;\n    if (oldScene !== this) {\n      if (oldScene && isRoot) {\n        oldScene._removeEntity(entity);\n      }\n      this._rootEntities.push(entity);\n      Entity._traverseSetOwnerScene(entity, this);\n    } else if (!isRoot) {\n      this._rootEntities.push(entity);\n    }\n    if (this._isActiveInEngine) {\n      !entity._isActiveInHierarchy && entity._isActive && entity._processActive();\n    } else {\n      entity._isActiveInHierarchy && entity._processInActive();\n    }\n  }\n  removeRootEntity(entity) {\n    if (entity._isRoot && entity._scene == this) {\n      this._removeEntity(entity);\n      this._isActiveInEngine && entity._processInActive();\n      Entity._traverseSetOwnerScene(entity, null);\n    }\n  }\n  getRootEntity(index = 0) {\n    return this._rootEntities[index];\n  }\n  findEntityByName(name) {\n    const children = this._rootEntities;\n    for (let i = children.length - 1; i >= 0; i--) {\n      const child = children[i];\n      if (child.name === name) {\n        return child;\n      }\n    }\n    for (let i = children.length - 1; i >= 0; i--) {\n      const child = children[i];\n      const entity = child.findByName(name);\n      if (entity) {\n        return entity;\n      }\n    }\n    return null;\n  }\n  findEntityByPath(path) {\n    const splits = path.split(\"/\").filter(Boolean);\n    for (let i = 0, n = this.rootEntitiesCount; i < n; i++) {\n      let findEntity = this.getRootEntity(i);\n      if (findEntity.name != splits[0])\n        continue;\n      for (let j = 1, m = splits.length; j < m; ++j) {\n        findEntity = Entity._findChildByName(findEntity, splits[j]);\n        if (!findEntity)\n          break;\n      }\n      return findEntity;\n    }\n    return null;\n  }\n  destroy() {\n    this._isActiveInEngine && (this._engine.sceneManager.activeScene = null);\n    Scene.sceneFeatureManager.callFeatureMethod(this, \"destroy\", [this]);\n    for (let i = 0, n = this.rootEntitiesCount; i < n; i++) {\n      this._rootEntities[i].destroy();\n    }\n    this._rootEntities.length = 0;\n    this._activeCameras.length = 0;\n    Scene.sceneFeatureManager._objects = [];\n    this._destroyed = true;\n  }\n  attachRenderCamera(camera) {\n    const index = this._activeCameras.indexOf(camera);\n    if (index === -1) {\n      this._activeCameras.push(camera);\n    } else {\n      Logger.warn(\"Camera already attached.\");\n    }\n  }\n  detachRenderCamera(camera) {\n    const index = this._activeCameras.indexOf(camera);\n    if (index !== -1) {\n      this._activeCameras.splice(index, 1);\n    }\n  }\n  _processActive(active) {\n    this._isActiveInEngine = active;\n    const rootEntities = this._rootEntities;\n    for (let i = rootEntities.length - 1; i >= 0; i--) {\n      const entity = rootEntities[i];\n      if (entity._isActive) {\n        active ? entity._processActive() : entity._processInActive();\n      }\n    }\n  }\n  _removeEntity(entity) {\n    const oldRootEntities = this._rootEntities;\n    oldRootEntities.splice(oldRootEntities.indexOf(entity), 1);\n  }\n  static registerFeature(Feature) {\n    Scene.sceneFeatureManager.registerFeature(Feature);\n  }\n  findFeature(Feature) {\n    return Scene.sceneFeatureManager.findFeature(this, Feature);\n  }\n  raycast(ray, outPos, tag) {\n  }\n}\nScene.sceneFeatureManager = new FeatureManager();\n\nclass SceneManager {\n  constructor(engine) {\n    this.engine = engine;\n  }\n  get activeScene() {\n    return this._activeScene;\n  }\n  set activeScene(scene) {\n    const oldScene = this._activeScene;\n    if (oldScene !== scene) {\n      oldScene && oldScene._processActive(false);\n      scene && scene._processActive(true);\n      this._activeScene = scene;\n    }\n  }\n  loadScene(url, destroyOldScene = true) {\n    const scenePromise = this.engine.resourceManager.load(url);\n    scenePromise.then((scene) => {\n      const oldScene = this._activeScene;\n      this.activeScene = scene;\n      if (oldScene && destroyOldScene) {\n        oldScene.destroy();\n      }\n    });\n    return scenePromise;\n  }\n  mergeScenes(sourceScene, destScene) {\n    const oldRootEntities = sourceScene.rootEntities;\n    for (let i = 0, n = oldRootEntities.length; i < n; i++) {\n      destScene.addRootEntity(oldRootEntities[i]);\n    }\n  }\n}\n\nconst engineFeatureManager = new FeatureManager();\nclass Engine extends EventDispatcher {\n  constructor(canvas, hardwareRenderer) {\n    super(null);\n    this._componentsManager = new ComponentsManager();\n    this._resourceManager = new ResourceManager(this);\n    this._sceneManager = new SceneManager(this);\n    this._vSyncCount = 1;\n    this._targetFrameRate = 60;\n    this._time = new Time();\n    this._isPaused = true;\n    this._loopCounter = 0;\n    this._targetFrameInterval = 1e3 / 60;\n    this._animate = () => {\n      if (this._vSyncCount) {\n        this._requestId = requestAnimationFrame(this._animate);\n        if (this._loopCounter++ % this._vSyncCount === 0) {\n          this.update();\n          this._loopCounter = 1;\n        }\n      } else {\n        this._timeoutId = window.setTimeout(this._animate, this._targetFrameInterval);\n        this.update();\n      }\n    };\n    this.features = [];\n    this._hardwareRenderer = hardwareRenderer;\n    this._hardwareRenderer.init(canvas, this);\n    this._canvas = canvas;\n    engineFeatureManager.addObject(this);\n    this._sceneManager.activeScene = new Scene(this, \"DefaultScene\");\n  }\n  get canvas() {\n    return this._canvas;\n  }\n  get resourceManager() {\n    return this._resourceManager;\n  }\n  get sceneManager() {\n    return this._sceneManager;\n  }\n  get time() {\n    return this._time;\n  }\n  get isPaused() {\n    return this._isPaused;\n  }\n  get vSyncCount() {\n    return this._vSyncCount;\n  }\n  set vSyncCount(value) {\n    this._vSyncCount = Math.max(0, Math.floor(value));\n  }\n  get targetFrameRate() {\n    return this._targetFrameRate;\n  }\n  set targetFrameRate(value) {\n    value = Math.max(1e-6, value);\n    this._targetFrameRate = value;\n    this._targetFrameInterval = 1e3 / value;\n  }\n  get renderhardware() {\n    return this._hardwareRenderer;\n  }\n  createEntity(name) {\n    return new Entity(this, name);\n  }\n  pause() {\n    this._isPaused = true;\n    cancelAnimationFrame(this._requestId);\n    clearTimeout(this._timeoutId);\n  }\n  resume() {\n    if (!this._isPaused)\n      return;\n    this._isPaused = false;\n    this.time.reset();\n    requestAnimationFrame(this._animate);\n  }\n  update() {\n    const time = this._time;\n    const deltaTime = time.deltaTime;\n    time.tick();\n    RenderElement._restPool();\n    engineFeatureManager.callFeatureMethod(this, \"preTick\", [this, this._sceneManager._activeScene]);\n    this._hardwareRenderer.beginFrame();\n    const scene = this._sceneManager._activeScene;\n    const componentsManager = this._componentsManager;\n    if (scene) {\n      componentsManager.callScriptOnStart();\n      componentsManager.callScriptOnUpdate(deltaTime);\n      componentsManager.callAnimationUpdate(deltaTime);\n      componentsManager.callScriptOnLateUpdate(deltaTime);\n      this._render(scene);\n    }\n    this._componentsManager.callComponentDestory();\n    this._hardwareRenderer.endFrame();\n    engineFeatureManager.callFeatureMethod(this, \"postTick\", [this, this._sceneManager._activeScene]);\n  }\n  run() {\n    engineFeatureManager.callFeatureMethod(this, \"preLoad\", [this]);\n    this.resume();\n    this.trigger(new Event(\"run\", this));\n  }\n  destroy() {\n    if (this._sceneManager) {\n      this.trigger(new Event(\"shutdown\", this));\n      engineFeatureManager.callFeatureMethod(this, \"shutdown\", [this]);\n      this.pause();\n      this._animate = null;\n      this._sceneManager._activeScene.destroy();\n      this._sceneManager = null;\n      this._resourceManager.gc();\n      this._resourceManager = null;\n      this._canvas = null;\n      this.features = [];\n      this._time = null;\n      engineFeatureManager._objects = [];\n    }\n  }\n  _render(scene) {\n    const cameras = scene._activeCameras;\n    const componentsManager = this._componentsManager;\n    const deltaTime = this.time.deltaTime;\n    componentsManager.callRendererOnUpdate(deltaTime);\n    if (cameras.length > 0) {\n      cameras.sort((camera1, camera2) => camera1.priority - camera2.priority);\n      for (let i = 0, l = cameras.length; i < l; i++) {\n        const camera = cameras[i];\n        const cameraEntity = camera.entity;\n        if (camera.enabled && cameraEntity.isActiveInHierarchy) {\n          componentsManager.callCameraOnBeginRender(camera);\n          Scene.sceneFeatureManager.callFeatureMethod(scene, \"preRender\", [this, camera]);\n          camera.render();\n          Scene.sceneFeatureManager.callFeatureMethod(scene, \"postRender\", [this, camera]);\n          componentsManager.callCameraOnEndRender(camera);\n        }\n      }\n    } else {\n      Logger.debug(\"NO active camera.\");\n    }\n  }\n  findFeature(Feature) {\n    return engineFeatureManager.findFeature(this, Feature);\n  }\n  static registerFeature(Feature) {\n    engineFeatureManager.registerFeature(Feature);\n  }\n}\n\nclass SystemInfo {\n  static get devicePixelRatio() {\n    return window.devicePixelRatio;\n  }\n}\n\nclass EngineFeature {\n  preLoad(engine) {\n  }\n  preTick(engine, currentScene) {\n  }\n  postTick(engine, currentScene) {\n  }\n  shutdown(engine) {\n  }\n}\n\nclass AssetObject extends EngineObject {\n}\n\nclass SceneVisitor {\n}\n\nclass SceneFeature {\n  preUpdate(scene) {\n  }\n  postUpdate(scene) {\n  }\n  preRender(scene, camera) {\n  }\n  postRender(scene, camera) {\n  }\n  destroy(scene) {\n  }\n}\n\nvar __defProp$4 = Object.defineProperty;\nvar __getOwnPropDesc$4 = Object.getOwnPropertyDescriptor;\nvar __decorate$4 = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$4(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result)\n    __defProp$4(target, key, result);\n  return result;\n};\nclass Script extends Component {\n  constructor() {\n    super(...arguments);\n    this._started = false;\n    this._onStartIndex = -1;\n    this._onUpdateIndex = -1;\n    this._onLateUpdateIndex = -1;\n    this._onPreRenderIndex = -1;\n    this._onPostRenderIndex = -1;\n  }\n  onAwake() {\n  }\n  onEnable() {\n  }\n  onStart() {\n  }\n  onUpdate(deltaTime) {\n  }\n  onLateUpdate(deltaTime) {\n  }\n  onBeginRender(camera) {\n  }\n  onEndRender(camera) {\n  }\n  onDisable() {\n  }\n  onDestroy() {\n  }\n  _onAwake() {\n    this.onAwake();\n  }\n  _onEnable() {\n    const componentsManager = this.engine._componentsManager;\n    const prototype = Script.prototype;\n    if (!this._started) {\n      componentsManager.addOnStartScript(this);\n    }\n    if (this.onUpdate !== prototype.onUpdate) {\n      componentsManager.addOnUpdateScript(this);\n    }\n    if (this.onLateUpdate !== prototype.onLateUpdate) {\n      componentsManager.addOnLateUpdateScript(this);\n    }\n    this.onEnable();\n  }\n  _onDisable() {\n    const componentsManager = this.engine._componentsManager;\n    if (this._onStartIndex !== -1) {\n      componentsManager.removeOnStartScript(this);\n    }\n    if (this._onUpdateIndex !== -1) {\n      componentsManager.removeOnUpdateScript(this);\n    }\n    if (this._onLateUpdateIndex !== -1) {\n      componentsManager.removeOnLateUpdateScript(this);\n    }\n    this.onDisable();\n  }\n  _onDestroy() {\n    this.engine._componentsManager.addDestoryComponent(this);\n  }\n}\n__decorate$4([\n  ignoreClone\n], Script.prototype, \"_started\", 2);\n__decorate$4([\n  ignoreClone\n], Script.prototype, \"_onStartIndex\", 2);\n__decorate$4([\n  ignoreClone\n], Script.prototype, \"_onUpdateIndex\", 2);\n__decorate$4([\n  ignoreClone\n], Script.prototype, \"_onLateUpdateIndex\", 2);\n__decorate$4([\n  ignoreClone\n], Script.prototype, \"_onPreRenderIndex\", 2);\n__decorate$4([\n  ignoreClone\n], Script.prototype, \"_onPostRenderIndex\", 2);\n\nvar __defProp$5 = Object.defineProperty;\nvar __getOwnPropDesc$5 = Object.getOwnPropertyDescriptor;\nvar __decorate$5 = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$5(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result)\n    __defProp$5(target, key, result);\n  return result;\n};\nclass RenderableComponent extends Component {\n  constructor(entity) {\n    super(entity);\n    this._onUpdateIndex = -1;\n    this._rendererIndex = -1;\n    this._overrideUpdate = false;\n    this._bounds = new BoundingBox(new Vector3(), new Vector3());\n    const prototype = RenderableComponent.prototype;\n    this._overrideUpdate = this.update !== prototype.update;\n    this._transformChangeFlag = this.entity.transform.registerWorldChangeFlag();\n  }\n  get bounds() {\n    const changeFlag = this._transformChangeFlag;\n    if (changeFlag.flag) {\n      this._updateBounds(this._bounds);\n      changeFlag.flag = false;\n    }\n    return this._bounds;\n  }\n  destroy() {\n    super.destroy();\n    const flag = this._transformChangeFlag;\n    if (flag) {\n      flag.destroy();\n      this._transformChangeFlag = null;\n    }\n  }\n  update(deltaTime) {\n  }\n  _updateBounds(worldBounds) {\n  }\n  _onEnable() {\n    const componentsManager = this.engine._componentsManager;\n    if (this._overrideUpdate) {\n      componentsManager.addOnUpdateRenderers(this);\n    }\n    componentsManager.addRenderer(this);\n  }\n  _onDisable() {\n    const componentsManager = this.engine._componentsManager;\n    if (this._overrideUpdate) {\n      componentsManager.removeOnUpdateRenderers(this);\n    }\n    componentsManager.removeRenderer(this);\n  }\n  _render(camera) {\n    let culled = false;\n    if (this.cullDistanceSq > 0) {\n      const distanceSq = Vector3.distanceSquared(camera._entity.transform.worldPosition, this.entity.transform.worldPosition);\n      culled = this.cullDistanceSq < distanceSq;\n    }\n    if (!culled) {\n      this.render(camera);\n    }\n  }\n}\n__decorate$5([\n  ignoreClone\n], RenderableComponent.prototype, \"_onUpdateIndex\", 2);\n__decorate$5([\n  ignoreClone\n], RenderableComponent.prototype, \"_rendererIndex\", 2);\n__decorate$5([\n  ignoreClone\n], RenderableComponent.prototype, \"_overrideUpdate\", 2);\n__decorate$5([\n  ignoreClone\n], RenderableComponent.prototype, \"_transformChangeFlag\", 2);\n__decorate$5([\n  deepClone\n], RenderableComponent.prototype, \"_bounds\", 2);\n\nlet passNum = 0;\nclass RenderPass {\n  constructor(name = `RENDER_PASS${passNum++}`, priority = 0, renderTarget = null, replaceMaterial = null, mask = null, clearParam = new Vector4(0, 0, 0, 0)) {\n    this.name = name;\n    this.enabled = true;\n    this.priority = priority;\n    this.renderTarget = renderTarget;\n    this.replaceMaterial = replaceMaterial;\n    this.mask = mask || MaskList.EVERYTHING;\n    this.renderOverride = false;\n    this.clearMode = ClearMode.SOLID_COLOR;\n    this._clearParam = clearParam;\n  }\n  get clearParam() {\n    return this._clearParam;\n  }\n  set clearParam(v) {\n    this._clearParam = v;\n  }\n  render(camera, opaqueQueue, transparentQueue) {\n  }\n  preRender(camera, opaqueQueue, transparentQueue) {\n  }\n  postRender(camera, opaqueQueue, transparentQueue) {\n  }\n}\n\nclass RenderContext {\n  constructor() {\n    this.viewProjectMatrix = new Matrix();\n  }\n  static _getRenderContext(camera) {\n    const context = RenderContext._renderContext;\n    context.camera = camera;\n    context.viewport = camera.viewport;\n    context.cameraPosition = camera.entity.transform.worldPosition;\n    context.inverseViewMatrix = camera.inverseViewMatrix;\n    context.inverseProjectionMatrix = camera.inverseProjectionMatrix;\n    context.viewMatrix = camera.viewMatrix;\n    context.projectionMatrix = camera.projectionMatrix;\n    Matrix.multiply(context.projectionMatrix, context.viewMatrix, context.viewProjectMatrix);\n    return this._renderContext;\n  }\n}\nRenderContext._renderContext = new RenderContext();\n\nclass RenderQueue {\n  constructor() {\n    this._items = [];\n  }\n  get items() {\n    return this._items;\n  }\n  clear() {\n    this._items = [];\n  }\n  pushPrimitive(element) {\n    this._items.push(element);\n  }\n  sortByDistance(eyePos) {\n    const items = this._items;\n    if (items.length > 1) {\n      this._items = items.sort(function(item1, item2) {\n        if (item1.component.renderPriority === item2.component.renderPriority) {\n          const pos1 = item1.component.entity.transform.worldPosition;\n          const pos2 = item2.component.entity.transform.worldPosition;\n          const dis = Vector3.distanceSquared(pos2, eyePos) - Vector3.distanceSquared(pos1, eyePos);\n          return dis;\n        } else {\n          return item1.component.renderPriority - item2.component.renderPriority;\n        }\n      });\n    }\n  }\n  sortByTechnique() {\n    const items = this._items;\n    if (items.length > 1) {\n      this._items = items.sort(function(item1, item2) {\n        if (item1.component.renderPriority === item2.component.renderPriority) {\n          const tech1 = item1.material.technique;\n          const tech2 = item2.material.technique;\n          if (tech1 && tech2) {\n            return tech1.name.localeCompare(tech2.name);\n          } else {\n            return 0;\n          }\n        } else {\n          return item1.component.renderPriority - item2.component.renderPriority;\n        }\n      });\n    }\n  }\n  pushSprite(component, positionQuad, uvRect, tintColor, texture, renderMode, camera) {\n    const element = {\n      component,\n      positionQuad,\n      uvRect,\n      tintColor,\n      texture,\n      renderMode,\n      camera\n    };\n    this._items.push(element);\n  }\n  render(camera, replaceMaterial, mask) {\n    const rhi = camera.scene.engine._hardwareRenderer;\n    const items = this._items;\n    if (items.length === 0) {\n      return;\n    }\n    this.updateMaxJointsNum(this._items, replaceMaterial);\n    const context = RenderContext._getRenderContext(camera);\n    const {cullingMask} = camera;\n    for (let i = 0, len = items.length; i < len; i++) {\n      const item = items[i];\n      const {component} = item;\n      if (!(cullingMask & component._entity.layer))\n        continue;\n      const renderPassFlag = component.renderPassFlag;\n      if (!(renderPassFlag & mask))\n        continue;\n      if (this._isPrimitive(item)) {\n        const element = item;\n        rhi.flushSprite();\n        const material = replaceMaterial ? replaceMaterial : element.material;\n        material.preRender?.(element.component, element.primitive);\n        material.prepareDrawing(context, element.component, element.primitive, element.material);\n        rhi.drawPrimitive(element.primitive, element.subPrimitive, material);\n        material.postRender?.(element.component, element.primitive);\n      } else {\n        const spirteElement = item;\n        rhi.drawSprite(spirteElement.positionQuad, spirteElement.uvRect, spirteElement.tintColor, spirteElement.texture, spirteElement.renderMode, spirteElement.camera);\n      }\n    }\n    rhi.flushSprite();\n  }\n  updateMaxJointsNum(items, replaceMaterial) {\n    for (let i = 0, len = items.length; i < len; i++) {\n      const {component, material} = items[i];\n      const materialControl = replaceMaterial ? replaceMaterial : material;\n      if (component.jointNodes) {\n        materialControl.maxJointsNum = Math.max(materialControl.maxJointsNum, component.jointNodes.length);\n      }\n    }\n  }\n  _isPrimitive(item) {\n    return !!item.primitive;\n  }\n}\n\nclass SeparateSpritePass extends RenderPass {\n  constructor(name = \"SeparateSprite\", priority = 10) {\n    super(name, priority);\n    this.clearMode = ClearMode.DONT_CLEAR;\n    this.renderOverride = true;\n    this._spriteItems = [];\n  }\n  get isUsed() {\n    return this._spriteItems.length > 0;\n  }\n  preRender() {\n    this.enabled = this.isUsed;\n  }\n  render(camera) {\n    const rhi = camera.renderHardware;\n    this._sortByDistance(camera.eyePos);\n    const items = this._spriteItems;\n    for (let i = 0; i < items.length; i++) {\n      const item = items[i];\n      rhi.drawSprite(item.positionQuad, item.uvRect, item.tintColor, item.texture, item.renderMode, item.camera);\n    }\n    items.length = 0;\n  }\n  postRender(camera) {\n    if (this.enabled) {\n      camera.renderHardware.flushSprite();\n    }\n  }\n  _sortByDistance(eyePos) {\n    if (this._spriteItems.length > 1) {\n      this._spriteItems = this._spriteItems.sort(function(item1, item2) {\n        if (item1.component.renderPriority === item2.component.renderPriority) {\n          const pos1 = item1.component.node.worldPosition;\n          const pos2 = item2.component.node.worldPosition;\n          const dis = Vector3.distanceSquared(pos2, eyePos) - Vector3.distanceSquared(pos1, eyePos);\n          return dis;\n        } else {\n          return item1.component.renderPriority - item2.component.renderPriority;\n        }\n      });\n    }\n  }\n  pushSprite(component, positionQuad, uvRect, tintColor, texture, renderMode, camera) {\n    this._spriteItems.push({\n      component,\n      positionQuad,\n      uvRect,\n      tintColor,\n      texture,\n      renderMode,\n      camera\n    });\n  }\n}\n\nclass BasicRenderPipeline extends SceneVisitor {\n  constructor(camera) {\n    super();\n    this._camera = camera;\n    this._opaqueQueue = new RenderQueue();\n    this._transparentQueue = new RenderQueue();\n    this._renderPassArray = [];\n    this._defaultPass = new RenderPass(\"default\", 0, null, null, 0);\n    this.addRenderPass(this._defaultPass);\n  }\n  get defaultRenderPass() {\n    return this._defaultPass;\n  }\n  addRenderPass(nameOrPass, priority = null, renderTarget = null, replaceMaterial = null, mask = null, clearParam = new Vector4(0, 0, 0, 0)) {\n    if (typeof nameOrPass === \"string\") {\n      const renderPass = new RenderPass(nameOrPass, priority, renderTarget, replaceMaterial, mask, clearParam);\n      this._renderPassArray.push(renderPass);\n    } else if (nameOrPass instanceof RenderPass) {\n      this._renderPassArray.push(nameOrPass);\n    }\n    this._renderPassArray.sort(function(p1, p2) {\n      return p1.priority - p2.priority;\n    });\n  }\n  removeRenderPass(nameOrPass) {\n    let pass;\n    if (typeof nameOrPass === \"string\")\n      pass = this.getRenderPass(nameOrPass);\n    else if (nameOrPass instanceof RenderPass)\n      pass = nameOrPass;\n    if (pass) {\n      const idx = this._renderPassArray.indexOf(pass);\n      this._renderPassArray.splice(idx, 1);\n    }\n  }\n  getRenderPass(name) {\n    for (let i = 0, len = this._renderPassArray.length; i < len; i++) {\n      const pass = this._renderPassArray[i];\n      if (pass.name === name)\n        return pass;\n    }\n    return null;\n  }\n  get opaqueQueue() {\n    return this._opaqueQueue;\n  }\n  get transparentQueue() {\n    return this._transparentQueue;\n  }\n  destroy() {\n  }\n  render() {\n    const camera = this._camera;\n    const opaqueQueue = this._opaqueQueue;\n    const transparentQueue = this._transparentQueue;\n    opaqueQueue.clear();\n    transparentQueue.clear();\n    camera.engine._componentsManager.callRender(camera);\n    opaqueQueue.sortByTechnique();\n    transparentQueue.sortByDistance(camera.entity.transform.worldPosition);\n    if (this._canvasDepthPass)\n      this._canvasDepthPass.enabled = false;\n    if (this._separateSpritePass && this._separateSpritePass.isUsed) {\n      if (this._defaultPass.renderTarget) {\n        if (!this._canvasDepthPass) {\n          this._canvasDepthPass = new RenderPass(\"CanvasDepthRenderPass\", 0, null, null, 0);\n          this._canvasDepthPass.clearMode = ClearMode.DONT_CLEAR;\n          this.addRenderPass(this._canvasDepthPass);\n        }\n        this._canvasDepthPass.enabled = true;\n      }\n    }\n    for (let i = 0, len = this._renderPassArray.length; i < len; i++) {\n      this._drawRenderPass(this._renderPassArray[i], camera);\n    }\n  }\n  _drawRenderPass(pass, camera) {\n    pass.preRender(camera, this.opaqueQueue, this.transparentQueue);\n    const rhi = camera.scene.engine._hardwareRenderer;\n    const renderTarget = camera.renderTarget || pass.renderTarget;\n    rhi.activeRenderTarget(renderTarget, camera);\n    if (pass.enabled) {\n      rhi.clearRenderTarget(pass.clearMode, pass.clearParam);\n      if (pass.renderOverride) {\n        pass.render(camera, this.opaqueQueue, this.transparentQueue);\n      } else {\n        this.opaqueQueue.render(camera, pass.replaceMaterial, pass.mask);\n        this.transparentQueue.render(camera, pass.replaceMaterial, pass.mask);\n      }\n    }\n    rhi.blitRenderTarget(renderTarget);\n    pass.postRender(camera, this.opaqueQueue, this.transparentQueue);\n  }\n  pushPrimitive(element) {\n    if (element.material.renderType === MaterialType.TRANSPARENT) {\n      this._transparentQueue.pushPrimitive(element);\n    } else {\n      this._opaqueQueue.pushPrimitive(element);\n    }\n  }\n  pushSprite(component, positionQuad, uvRect, tintColor, texture, renderMode, camera) {\n    if (component.separateDraw) {\n      if (!this._separateSpritePass) {\n        this._separateSpritePass = new SeparateSpritePass();\n        this.addRenderPass(this._separateSpritePass);\n      }\n      this._separateSpritePass.pushSprite(component, positionQuad, uvRect, tintColor, texture, renderMode, camera);\n      return;\n    }\n    this._transparentQueue.pushSprite(component, positionQuad, uvRect, tintColor, texture, renderMode, camera);\n  }\n}\n\nvar __defProp$6 = Object.defineProperty;\nvar __getOwnPropDesc$6 = Object.getOwnPropertyDescriptor;\nvar __decorate$6 = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$6(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result)\n    __defProp$6(target, key, result);\n  return result;\n};\nclass MathTemp {\n}\nMathTemp.tempMat4 = new Matrix();\nMathTemp.tempVec4 = new Vector4();\nMathTemp.tempVec3 = new Vector3();\nvar ClearFlags;\n(function(ClearFlags2) {\n  ClearFlags2[ClearFlags2[\"DepthSky\"] = 0] = \"DepthSky\";\n  ClearFlags2[ClearFlags2[\"DepthColor\"] = 1] = \"DepthColor\";\n  ClearFlags2[ClearFlags2[\"Depth\"] = 2] = \"Depth\";\n  ClearFlags2[ClearFlags2[\"None\"] = 3] = \"None\";\n})(ClearFlags || (ClearFlags = {}));\nlet Camera = class extends Component {\n  constructor(entity) {\n    super(entity);\n    this.priority = 0;\n    this.cullingMask = Layer.Everything;\n    this._isOrthographic = false;\n    this._isProjMatSetting = false;\n    this._clearMode = ClearMode.SOLID_COLOR;\n    this._nearClipPlane = 0.1;\n    this._farClipPlane = 100;\n    this._fieldOfView = 45;\n    this._orthographicSize = 10;\n    this._isProjectionDirty = true;\n    this._isInvProjMatDirty = true;\n    this._customAspectRatio = void 0;\n    this._renderTarget = null;\n    this._projectionMatrix = new Matrix();\n    this._viewMatrix = new Matrix();\n    this._backgroundColor = new Vector4();\n    this._viewport = new Vector4(0, 0, 1, 1);\n    this._inverseProjectionMatrix = new Matrix();\n    this._inverseViewMatrix = new Matrix();\n    this._lastAspectSize = new Vector2(0, 0);\n    this._invViewProjMat = new Matrix();\n    this._transform = this.entity.transform;\n    this._isViewMatrixDirty = this._transform.registerWorldChangeFlag();\n    this._isInvViewProjDirty = this._transform.registerWorldChangeFlag();\n    this._renderPipeline = new BasicRenderPipeline(this);\n    this.setClearMode();\n  }\n  get nearClipPlane() {\n    return this._nearClipPlane;\n  }\n  set nearClipPlane(value) {\n    this._nearClipPlane = value;\n    this._projMatChange();\n  }\n  get farClipPlane() {\n    return this._farClipPlane;\n  }\n  set farClipPlane(value) {\n    this._farClipPlane = value;\n    this._projMatChange();\n  }\n  get fieldOfView() {\n    return this._fieldOfView;\n  }\n  set fieldOfView(value) {\n    this._fieldOfView = value;\n    this._projMatChange();\n  }\n  get aspectRatio() {\n    const canvas = this._entity.engine.canvas;\n    return this._customAspectRatio ?? canvas.width * this._viewport.z / (canvas.height * this._viewport.w);\n  }\n  set aspectRatio(value) {\n    this._customAspectRatio = value;\n    this._projMatChange();\n  }\n  get viewport() {\n    return this._viewport;\n  }\n  set viewport(value) {\n    if (value !== this._viewport) {\n      value.cloneTo(this._viewport);\n    }\n    this._projMatChange();\n  }\n  get isOrthographic() {\n    return this._isOrthographic;\n  }\n  set isOrthographic(value) {\n    this._isOrthographic = value;\n    this._projMatChange();\n  }\n  get orthographicSize() {\n    return this._orthographicSize;\n  }\n  set orthographicSize(value) {\n    this._orthographicSize = value;\n    this._projMatChange();\n  }\n  get clearFlags() {\n    throw \"not implemented\";\n  }\n  set clearFlags(value) {\n    throw \"not implemented\";\n  }\n  get backgroundColor() {\n    return this._backgroundColor;\n  }\n  set backgroundColor(value) {\n    this.setClearMode(this._clearMode, value);\n  }\n  get backgroundSky() {\n    throw new Error(\"\\u63A5\\u53E3\\u672A\\u5B9E\\u73B0\");\n  }\n  get viewMatrix() {\n    if (this._isViewMatrixDirty.flag) {\n      this._isViewMatrixDirty.flag = false;\n      Matrix.invert(this._transform.worldMatrix, this._viewMatrix);\n    }\n    return this._viewMatrix;\n  }\n  set projectionMatrix(value) {\n    this._projectionMatrix = value;\n    this._isProjMatSetting = true;\n    this._projMatChange();\n  }\n  get projectionMatrix() {\n    const canvas = this._entity.engine.canvas;\n    if ((!this._isProjectionDirty || this._isProjMatSetting) && this._lastAspectSize.x === canvas.width && this._lastAspectSize.y === canvas.height) {\n      return this._projectionMatrix;\n    }\n    this._isProjectionDirty = false;\n    this._lastAspectSize.x = canvas.width;\n    this._lastAspectSize.y = canvas.height;\n    const aspectRatio = this.aspectRatio;\n    if (!this._isOrthographic) {\n      Matrix.perspective(MathUtil.degreeToRadian(this._fieldOfView), aspectRatio, this._nearClipPlane, this._farClipPlane, this._projectionMatrix);\n    } else {\n      const width = this._orthographicSize * aspectRatio;\n      const height = this._orthographicSize;\n      Matrix.ortho(-width, width, -height, height, this._nearClipPlane, this._farClipPlane, this._projectionMatrix);\n    }\n    return this._projectionMatrix;\n  }\n  get enableHDR() {\n    console.log(\"not implemention\");\n    return false;\n  }\n  set enableHDR(value) {\n    console.log(\"not implemention\");\n  }\n  get renderTarget() {\n    return this._renderTarget;\n  }\n  set renderTarget(value) {\n    this._renderTarget = value;\n  }\n  resetProjectionMatrix() {\n    this._isProjMatSetting = false;\n    this._projMatChange();\n  }\n  resetAspectRatio() {\n    this._customAspectRatio = void 0;\n    this._projMatChange();\n  }\n  worldToViewportPoint(point, out) {\n    Matrix.multiply(this.projectionMatrix, this.viewMatrix, MathTemp.tempMat4);\n    MathTemp.tempVec4.setValue(point.x, point.y, point.z, 1);\n    Vector4.transform(MathTemp.tempVec4, MathTemp.tempMat4, MathTemp.tempVec4);\n    const w = MathTemp.tempVec4.w;\n    const nx = MathTemp.tempVec4.x / w;\n    const ny = MathTemp.tempVec4.y / w;\n    const nz = MathTemp.tempVec4.z / w;\n    out.x = (nx + 1) * 0.5;\n    out.y = (1 - ny) * 0.5;\n    out.z = nz;\n    out.w = w;\n    return out;\n  }\n  viewportToWorldPoint(point, out) {\n    const invViewProjMat = this.invViewProjMat;\n    return this._innerViewportToWorldPoint(point, invViewProjMat, out);\n  }\n  viewportPointToRay(point, out) {\n    const clipPoint = MathTemp.tempVec3;\n    clipPoint.setValue(point.x, point.y, 0);\n    const origin = this.viewportToWorldPoint(clipPoint, out.origin);\n    clipPoint.z = 1;\n    const farPoint = this._innerViewportToWorldPoint(clipPoint, this._invViewProjMat, clipPoint);\n    Vector3.subtract(farPoint, origin, out.direction);\n    out.direction.normalize();\n    return out;\n  }\n  screenToViewportPoint(point, out) {\n    const canvas = this.engine.canvas;\n    const viewport = this.viewport;\n    out.x = (point.x / canvas.width - viewport.x) / viewport.z;\n    out.y = (point.y / canvas.height - viewport.y) / viewport.w;\n    return out;\n  }\n  viewportToScreenPoint(point, out) {\n    const canvas = this.engine.canvas;\n    const viewport = this.viewport;\n    out.x = (viewport.x + point.x * viewport.z) * canvas.width;\n    out.y = (viewport.y + point.y * viewport.w) * canvas.height;\n    return out;\n  }\n  worldToScreenPoint(point, out) {\n    this.worldToViewportPoint(point, out);\n    return this.viewportToScreenPoint(out, out);\n  }\n  screenToWorldPoint(point, out) {\n    this.screenToViewportPoint(point, out);\n    return this.viewportToWorldPoint(out, out);\n  }\n  render(cubeFaces) {\n    this._renderPipeline.render();\n  }\n  _onActive() {\n    this.entity.scene.attachRenderCamera(this);\n  }\n  _onInActive() {\n    this.entity.scene.detachRenderCamera(this);\n  }\n  _onDestroy() {\n    this._renderPipeline?.destroy();\n    this._isInvViewProjDirty.destroy();\n    this._isViewMatrixDirty.destroy();\n  }\n  _projMatChange() {\n    this._isProjectionDirty = true;\n    this._isInvProjMatDirty = true;\n    this._isInvViewProjDirty.flag = true;\n  }\n  _innerViewportToWorldPoint(point, invViewProjMat, out) {\n    const depth = point.z * 2 - 1;\n    const clipPoint = MathTemp.tempVec4;\n    clipPoint.setValue(point.x * 2 - 1, 1 - point.y * 2, depth, 1);\n    Vector4.transform(clipPoint, invViewProjMat, clipPoint);\n    const invW = 1 / clipPoint.w;\n    out.x = clipPoint.x * invW;\n    out.y = clipPoint.y * invW;\n    out.z = clipPoint.z * invW;\n    return out;\n  }\n  get invViewProjMat() {\n    if (this._isInvViewProjDirty.flag) {\n      this._isInvViewProjDirty.flag = false;\n      Matrix.multiply(this.inverseViewMatrix, this.inverseProjectionMatrix, this._invViewProjMat);\n    }\n    return this._invViewProjMat;\n  }\n  get inverseProjectionMatrix() {\n    if (this._isInvProjMatDirty) {\n      this._isInvProjMatDirty = false;\n      Matrix.invert(this.projectionMatrix, this._inverseProjectionMatrix);\n    }\n    return this._inverseProjectionMatrix;\n  }\n  get inverseViewMatrix() {\n    this._transform.worldMatrix.cloneTo(this._inverseViewMatrix);\n    return this._inverseViewMatrix;\n  }\n  setClearMode(clearMode = ClearMode.SOLID_COLOR, backgroundColor = new Vector4(0.25, 0.25, 0.25, 1)) {\n    this._clearMode = clearMode;\n    this._backgroundColor = backgroundColor;\n    this._renderPipeline.defaultRenderPass.clearParam = backgroundColor;\n    this._renderPipeline.defaultRenderPass.clearMode = clearMode;\n  }\n};\n__decorate$6([\n  ignoreClone\n], Camera.prototype, \"_renderPipeline\", 2);\n__decorate$6([\n  ignoreClone\n], Camera.prototype, \"_transform\", 2);\n__decorate$6([\n  ignoreClone\n], Camera.prototype, \"_isViewMatrixDirty\", 2);\n__decorate$6([\n  ignoreClone\n], Camera.prototype, \"_isInvViewProjDirty\", 2);\n__decorate$6([\n  deepClone\n], Camera.prototype, \"_projectionMatrix\", 2);\n__decorate$6([\n  deepClone\n], Camera.prototype, \"_viewMatrix\", 2);\n__decorate$6([\n  deepClone\n], Camera.prototype, \"_backgroundColor\", 2);\n__decorate$6([\n  deepClone\n], Camera.prototype, \"_viewport\", 2);\n__decorate$6([\n  deepClone\n], Camera.prototype, \"_inverseProjectionMatrix\", 2);\n__decorate$6([\n  deepClone\n], Camera.prototype, \"_inverseViewMatrix\", 2);\n__decorate$6([\n  deepClone\n], Camera.prototype, \"_lastAspectSize\", 2);\n__decorate$6([\n  deepClone\n], Camera.prototype, \"_invViewProjMat\", 2);\nCamera = __decorate$6([\n  dependencies(Transform)\n], Camera);\n\nconst mimeType = {\n  json: \"json\",\n  gltf: \"json\",\n  mtl: \"json\",\n  prefab: \"json\",\n  txt: \"text\",\n  bin: \"arraybuffer\",\n  png: \"image\",\n  webp: \"image\",\n  jpg: \"image\"\n};\nconst defaultRetryCount = 4;\nconst defaultTimeout = 15e3;\nconst defaultInterval = 500;\nfunction request(url, config = {}) {\n  return new AssetPromise((resolve, reject, setProgress) => {\n    const retryCount = config.retryCount ?? defaultRetryCount;\n    const retryInterval = config.retryInterval ?? defaultInterval;\n    config.timeout = config.timeout ?? defaultTimeout;\n    config.type = config.type ?? getMimeTypeFromUrl(url);\n    const realRequest = config.type === \"image\" ? requestImage : requestRes;\n    let lastError;\n    const executor = new MultiExecutor(() => {\n      return realRequest(url, config).onProgress(setProgress).then((res) => {\n        resolve(res);\n        executor.stop();\n      }).catch((err) => lastError = err);\n    }, retryCount, retryInterval);\n    executor.start(() => {\n      reject(lastError);\n    });\n  });\n}\nfunction requestImage(url, config) {\n  return new AssetPromise((resolve, reject) => {\n    const {timeout} = config;\n    const img = new Image();\n    const onerror = () => {\n      reject(new Error(`request ${url} fail`));\n    };\n    img.onerror = onerror;\n    img.onabort = onerror;\n    const timeoutId = setTimeout(() => {\n      reject(new Error(`request ${url} timeout`));\n    }, timeout);\n    img.onload = ((timeoutId2) => {\n      return () => {\n        resolve(img);\n        clearTimeout(timeoutId2);\n      };\n    })(timeoutId);\n    img.crossOrigin = \"anonymous\";\n    img.src = url;\n  });\n}\nfunction requestRes(url, config) {\n  return new AssetPromise((resolve, reject, setProgress) => {\n    const xhr = new XMLHttpRequest();\n    xhr.timeout = config.timeout;\n    config.method = config.method ?? \"get\";\n    xhr.onload = () => {\n      if (xhr.status < 200 || xhr.status >= 300) {\n        reject(new Error(`request failed from: ${url}`));\n        return;\n      }\n      const result = xhr.response ?? xhr.responseText;\n      resolve(result);\n    };\n    xhr.onerror = () => {\n      reject(new Error(`request failed from: ${url}`));\n    };\n    xhr.ontimeout = () => {\n      reject(new Error(`request timeout from: ${url}`));\n    };\n    xhr.onprogress = (e) => {\n      setProgress(e.loaded / e.total);\n    };\n    xhr.open(config.method, url, true);\n    xhr.withCredentials = config.credentials === \"include\";\n    xhr.responseType = config.type;\n    const headers = config.headers;\n    if (headers) {\n      Object.keys(headers).forEach((name) => {\n        xhr.setRequestHeader(name, headers[name]);\n      });\n    }\n    xhr.send(config.body);\n  });\n}\nfunction getMimeTypeFromUrl(url) {\n  const extname = url.substring(url.lastIndexOf(\".\") + 1);\n  return mimeType[extname];\n}\nclass MultiExecutor {\n  constructor(execFunc, totalCount, interval) {\n    this.execFunc = execFunc;\n    this.totalCount = totalCount;\n    this.interval = interval;\n    this._timeoutId = -100;\n    this._currentCount = 0;\n    this.exec = this.exec.bind(this);\n  }\n  start(done) {\n    this.done = done;\n    this.exec();\n  }\n  stop() {\n    clearTimeout(this._timeoutId);\n  }\n  exec() {\n    if (this._currentCount >= this.totalCount) {\n      this.done && this.done();\n      return;\n    }\n    this._currentCount++;\n    this.execFunc(this._currentCount).then(() => {\n      this._timeoutId = setTimeout(this.exec, this.interval);\n    });\n  }\n}\n\nclass Loader {\n  constructor(useCache) {\n    this.useCache = useCache;\n    this.request = request;\n  }\n}\n\nvar AssetType;\n(function(AssetType2) {\n  AssetType2[AssetType2[\"Text\"] = 0] = \"Text\";\n  AssetType2[AssetType2[\"JSON\"] = 1] = \"JSON\";\n  AssetType2[AssetType2[\"Buffer\"] = 2] = \"Buffer\";\n  AssetType2[AssetType2[\"Texture2D\"] = 3] = \"Texture2D\";\n  AssetType2[AssetType2[\"TextureCube\"] = 4] = \"TextureCube\";\n  AssetType2[AssetType2[\"Material\"] = 5] = \"Material\";\n  AssetType2[AssetType2[\"Mesh\"] = 6] = \"Mesh\";\n  AssetType2[AssetType2[\"AnimationClip\"] = 7] = \"AnimationClip\";\n  AssetType2[AssetType2[\"Perfab\"] = 8] = \"Perfab\";\n  AssetType2[AssetType2[\"KTX\"] = 9] = \"KTX\";\n  AssetType2[AssetType2[\"KTXCube\"] = 10] = \"KTXCube\";\n})(AssetType || (AssetType = {}));\n\nclass RefObject extends EngineObject {\n  constructor(engine) {\n    super(engine);\n    this.isGCIgnored = false;\n    this._refCount = 0;\n    this._refChildren = [];\n    this._refParent = null;\n    this._destroyed = false;\n    engine.resourceManager._addRefObject(this.instanceId, this);\n  }\n  get refCount() {\n    return this._refCount;\n  }\n  get destroyed() {\n    return this._destroyed;\n  }\n  destroy(force = false) {\n    if (this._destroyed)\n      return true;\n    if (!force && this._refCount !== 0)\n      return false;\n    const resourceManager = this._engine.resourceManager;\n    if (resourceManager) {\n      resourceManager._deleteAsset(this);\n      resourceManager._deleteRefObject(this.instanceId);\n    }\n    if (this._refParent) {\n      removeFromArray(this._refParent._refChildren, this);\n    }\n    this._engine = null;\n    this._onDestroy();\n    this._destroyed = true;\n    return true;\n  }\n  _addToResourceManager(path) {\n    this._engine.resourceManager._addAsset(path, this);\n  }\n  _addRefCount(refCount) {\n    this._refCount += refCount;\n    const refChildren = this._refChildren;\n    for (const item of refChildren) {\n      item._addRefCount(refCount);\n    }\n  }\n  _addRefChild(obj) {\n    this._refChildren.push(obj);\n    obj._refParent = this;\n    obj._addRefCount(this._refCount);\n  }\n  _removeRefChild(obj) {\n    const refChildren = this._refChildren;\n    if (removeFromArray(refChildren, obj)) {\n      obj._refParent = null;\n      obj._addRefCount(-this._refCount);\n    }\n  }\n}\n\nconst _tempVec3 = new Vector3(0, 1, 0);\nclass Light extends Component {\n  static getUniformDefine(uniformName) {\n    return {};\n  }\n  constructor(entity) {\n    super(entity);\n    entity.addEventListener(\"removedFromScene\", this._onDisable.bind(this));\n  }\n  _onEnable() {\n    this.scene.findFeature(LightFeature).attachRenderLight(this);\n  }\n  _onDisable() {\n    this.scene.findFeature(LightFeature).detachRenderLight(this);\n  }\n  get viewMatrix() {\n    if (!this._viewMat)\n      this._viewMat = new Matrix();\n    Matrix.invert(this.inverseViewMatrix, this._viewMat);\n    return this._viewMat;\n  }\n  get inverseViewMatrix() {\n    if (!this._modelMat)\n      this._modelMat = new Matrix();\n    Matrix.rotateAxisAngle(this.entity.transform.worldMatrix, _tempVec3, Math.PI, this._modelMat);\n    return this._modelMat;\n  }\n}\n\nclass AmbientLight extends Light {\n  static getUniformDefine(uniformName) {\n    return {\n      [uniformName + \".color\"]: {\n        name: uniformName + \".color\",\n        type: DataType.FLOAT_VEC3\n      },\n      [uniformName + \".lightColor\"]: {\n        name: uniformName + \".lightColor\",\n        type: DataType.FLOAT_VEC3\n      },\n      [uniformName + \".intensity\"]: {\n        name: uniformName + \".intensity\",\n        type: DataType.FLOAT\n      }\n    };\n  }\n  constructor(entity) {\n    super(entity);\n    this.color = new Vector3(1, 1, 1);\n    this.intensity = 1;\n    this._lightColor = new Vector3();\n  }\n  get lightColor() {\n    Vector3.scale(this.color, this.intensity, this._lightColor);\n    return this._lightColor;\n  }\n  bindMaterialValues(mtl, uniformName) {\n    mtl.setValue(uniformName + \".color\", this.color);\n    mtl.setValue(uniformName + \".lightColor\", this.lightColor);\n    mtl.setValue(uniformName + \".intensity\", this.intensity);\n  }\n}\n\nclass DirectLight extends Light {\n  constructor(entity) {\n    super(entity);\n    this._forward = new Vector3();\n    this.color = new Vector3(1, 1, 1);\n    this.intensity = 1;\n    this._lightColor = new Vector3();\n    this._reverseDirection = new Vector3();\n  }\n  get direction() {\n    this.entity.transform.getWorldForward(this._forward);\n    return this._forward;\n  }\n  get lightColor() {\n    Vector3.scale(this.color, this.intensity, this._lightColor);\n    return this._lightColor;\n  }\n  get reverseDirection() {\n    Vector3.scale(this.direction, -1, this._reverseDirection);\n    return this._reverseDirection;\n  }\n  static getUniformDefine(uniformName) {\n    const uniforms = {};\n    uniforms[uniformName + \".color\"] = {\n      name: uniformName + \".color\",\n      type: DataType.FLOAT_VEC3\n    };\n    uniforms[uniformName + \".lightColor\"] = {\n      name: uniformName + \".lightColor\",\n      type: DataType.FLOAT_VEC3\n    };\n    uniforms[uniformName + \".intensity\"] = {\n      name: uniformName + \".intensity\",\n      type: DataType.FLOAT\n    };\n    uniforms[uniformName + \".direction\"] = {\n      name: uniformName + \".direction\",\n      type: DataType.FLOAT_VEC3\n    };\n    return uniforms;\n  }\n  bindMaterialValues(mtl, uniformName) {\n    mtl.setValue(uniformName + \".color\", this.color);\n    mtl.setValue(uniformName + \".lightColor\", this.lightColor);\n    mtl.setValue(uniformName + \".intensity\", this.intensity);\n    mtl.setValue(uniformName + \".direction\", this.direction);\n  }\n}\n\nconst cacheMat3 = new Matrix3x3();\nclass EnvironmentMapLight extends Light {\n  static getUniformDefine(uniformName) {\n    const uniforms = {};\n    uniforms[\"u_env_diffuseSampler\"] = {\n      name: \"u_env_diffuseSampler\",\n      type: DataType.SAMPLER_CUBE\n    };\n    uniforms[\"u_env_specularSampler\"] = {\n      name: \"u_env_specularSampler\",\n      type: DataType.SAMPLER_CUBE\n    };\n    uniforms[uniformName + \".diffuse\"] = {\n      name: uniformName + \".diffuse\",\n      type: DataType.FLOAT_VEC3\n    };\n    uniforms[uniformName + \".specular\"] = {\n      name: uniformName + \".specular\",\n      type: DataType.FLOAT_VEC3\n    };\n    uniforms[uniformName + \".mipMapLevel\"] = {\n      name: uniformName + \".mipMapLevel\",\n      type: DataType.FLOAT\n    };\n    uniforms[uniformName + \".transformMatrix\"] = {\n      name: uniformName + \".transformMatrix\",\n      type: DataType.FLOAT_MAT3\n    };\n    uniforms[uniformName + \".diffuseIntensity\"] = {\n      name: uniformName + \".diffuseIntensity\",\n      type: DataType.FLOAT\n    };\n    uniforms[uniformName + \".specularIntensity\"] = {\n      name: uniformName + \".specularIntensity\",\n      type: DataType.FLOAT\n    };\n    return uniforms;\n  }\n  constructor(entity) {\n    super(entity);\n    this.diffuse = new Vector3(0.3, 0.3, 0.3);\n    this.specular = new Vector3(0.5, 0.5, 0.5);\n    this.diffuseIntensity = 1;\n    this.specularIntensity = 1;\n  }\n  get useDiffuseMap() {\n    return !!this.diffuseMap;\n  }\n  get useSpecularMap() {\n    return !!this.specularMap;\n  }\n  bindMaterialValues(mtl, uniformName) {\n    mtl.setValue(uniformName + \".diffuseIntensity\", this.diffuseIntensity);\n    mtl.setValue(uniformName + \".specularIntensity\", this.specularIntensity);\n    if (this.useDiffuseMap) {\n      mtl.setValue(\"u_env_diffuseSampler\", this.diffuseMap);\n    } else {\n      mtl.setValue(uniformName + \".diffuse\", this.diffuse);\n    }\n    if (this.useSpecularMap) {\n      mtl.setValue(\"u_env_specularSampler\", this.specularMap);\n      mtl.setValue(uniformName + \".mipMapLevel\", this.specularMap.mipmapCount);\n    } else {\n      mtl.setValue(uniformName + \".specular\", this.specular);\n    }\n    const transformMatrix = this.entity.transform.worldMatrix;\n    cacheMat3.setValueByMatrix(transformMatrix);\n    mtl.setValue(uniformName + \".transformMatrix\", cacheMat3);\n  }\n}\n\nclass PointLight extends Light {\n  constructor() {\n    super(...arguments);\n    this.color = new Vector3(1, 1, 1);\n    this.intensity = 1;\n    this.distance = 0;\n    this.decay = 0;\n    this._lightColor = new Vector3();\n  }\n  get position() {\n    return this.entity.worldPosition;\n  }\n  get lightColor() {\n    Vector3.scale(this.color, this.intensity, this._lightColor);\n    return this._lightColor;\n  }\n  static getUniformDefine(uniformName) {\n    const uniforms = {};\n    uniforms[uniformName + \".position\"] = {\n      name: uniformName + \".position\",\n      type: DataType.FLOAT_VEC3\n    };\n    uniforms[uniformName + \".color\"] = {\n      name: uniformName + \".color\",\n      type: DataType.FLOAT_VEC3\n    };\n    uniforms[uniformName + \".lightColor\"] = {\n      name: uniformName + \".lightColor\",\n      type: DataType.FLOAT_VEC3\n    };\n    uniforms[uniformName + \".intensity\"] = {\n      name: uniformName + \".intensity\",\n      type: DataType.FLOAT\n    };\n    uniforms[uniformName + \".distance\"] = {\n      name: uniformName + \".distance\",\n      type: DataType.FLOAT\n    };\n    uniforms[uniformName + \".decay\"] = {\n      name: uniformName + \".decay\",\n      type: DataType.FLOAT\n    };\n    return uniforms;\n  }\n  bindMaterialValues(mtl, uniformName) {\n    mtl.setValue(uniformName + \".position\", this.position);\n    mtl.setValue(uniformName + \".color\", this.color);\n    mtl.setValue(uniformName + \".lightColor\", this.lightColor);\n    mtl.setValue(uniformName + \".intensity\", this.intensity);\n    mtl.setValue(uniformName + \".distance\", this.distance);\n    mtl.setValue(uniformName + \".decay\", this.decay);\n  }\n}\n\nclass SpotLight extends Light {\n  constructor(entity) {\n    super(entity);\n    this._forward = new Vector3();\n    this.color = new Vector3(1, 1, 1);\n    this.penumbra = 0;\n    this.distance = 0;\n    this.intensity = 1;\n    this.decay = 0;\n    this.angle = Math.PI / 6;\n    this._lightColor = new Vector3();\n    this._inverseDirection = new Vector3();\n  }\n  get position() {\n    return this.entity.worldPosition;\n  }\n  get direction() {\n    this.entity.transform.getWorldForward(this._forward);\n    return this._forward;\n  }\n  get reverseDirection() {\n    Vector3.scale(this.direction, -1, this._inverseDirection);\n    return this._inverseDirection;\n  }\n  get lightColor() {\n    Vector3.scale(this.color, this.intensity, this._lightColor);\n    return this._lightColor;\n  }\n  static getUniformDefine(uniformName) {\n    const uniforms = {};\n    uniforms[uniformName + \".position\"] = {\n      name: uniformName + \".position\",\n      type: DataType.FLOAT_VEC3\n    };\n    uniforms[uniformName + \".direction\"] = {\n      name: uniformName + \".direction\",\n      type: DataType.FLOAT_VEC3\n    };\n    uniforms[uniformName + \".color\"] = {\n      name: uniformName + \".color\",\n      type: DataType.FLOAT_VEC3\n    };\n    uniforms[uniformName + \".lightColor\"] = {\n      name: uniformName + \".lightColor\",\n      type: DataType.FLOAT_VEC3\n    };\n    uniforms[uniformName + \".intensity\"] = {\n      name: uniformName + \".intensity\",\n      type: DataType.FLOAT\n    };\n    uniforms[uniformName + \".distance\"] = {\n      name: uniformName + \".distance\",\n      type: DataType.FLOAT\n    };\n    uniforms[uniformName + \".decay\"] = {\n      name: uniformName + \".decay\",\n      type: DataType.FLOAT\n    };\n    uniforms[uniformName + \".angle\"] = {\n      name: uniformName + \".angle\",\n      type: DataType.FLOAT\n    };\n    uniforms[uniformName + \".penumbra\"] = {\n      name: uniformName + \".penumbra\",\n      type: DataType.FLOAT\n    };\n    uniforms[uniformName + \".coneCos\"] = {\n      name: uniformName + \".coneCos\",\n      type: DataType.FLOAT\n    };\n    uniforms[uniformName + \".penumbraCos\"] = {\n      name: uniformName + \".penumbraCos\",\n      type: DataType.FLOAT\n    };\n    return uniforms;\n  }\n  bindMaterialValues(mtl, uniformName) {\n    mtl.setValue(uniformName + \".position\", this.position);\n    mtl.setValue(uniformName + \".direction\", this.direction);\n    mtl.setValue(uniformName + \".color\", this.color);\n    mtl.setValue(uniformName + \".lightColor\", this.lightColor);\n    mtl.setValue(uniformName + \".intensity\", this.intensity);\n    mtl.setValue(uniformName + \".distance\", this.distance);\n    mtl.setValue(uniformName + \".decay\", this.decay);\n    mtl.setValue(uniformName + \".angle\", this.angle);\n    mtl.setValue(uniformName + \".penumbra\", this.penumbra);\n    mtl.setValue(uniformName + \".coneCos\", Math.cos(this.angle));\n    mtl.setValue(uniformName + \".penumbraCos\", Math.cos(this.angle * (1 - this.penumbra)));\n  }\n}\n\nfunction hasLight() {\n  return this.findFeature(LightFeature).visibleLights.length > 0;\n}\nclass LightFeature extends SceneFeature {\n  get lightSortAmount() {\n    let ambientLightCount = 0;\n    let directLightCount = 0;\n    let pointLightCount = 0;\n    let spotLightCount = 0;\n    let envMapLightCount = 0;\n    let useDiffuseEnv = false;\n    let useSpecularEnv = false;\n    let lights = this.visibleLights;\n    for (let i = 0, len = lights.length; i < len; i++) {\n      const light = lights[i];\n      if (light instanceof AmbientLight) {\n        ambientLightCount++;\n      } else if (light instanceof DirectLight) {\n        directLightCount++;\n      } else if (light instanceof PointLight) {\n        pointLightCount++;\n      } else if (light instanceof SpotLight) {\n        spotLightCount++;\n      } else if (light instanceof EnvironmentMapLight) {\n        envMapLightCount++;\n        useDiffuseEnv = light.useDiffuseMap;\n        useSpecularEnv = light.useSpecularMap;\n      }\n    }\n    return {\n      ambientLightCount,\n      directLightCount,\n      pointLightCount,\n      spotLightCount,\n      envMapLightCount,\n      useDiffuseEnv,\n      useSpecularEnv\n    };\n  }\n  constructor() {\n    super();\n    this.visibleLights = [];\n  }\n  attachRenderLight(light) {\n    const index = this.visibleLights.indexOf(light);\n    if (index == -1) {\n      this.visibleLights.push(light);\n    } else {\n      Logger.warn(\"Light already attached.\");\n    }\n  }\n  detachRenderLight(light) {\n    const index = this.visibleLights.indexOf(light);\n    if (index != -1) {\n      this.visibleLights.splice(index, 1);\n    }\n  }\n  bindMaterialValues(mtl) {\n    let directLightCount = 0;\n    let pointLightCount = 0;\n    let spotLightCount = 0;\n    let lights = this.visibleLights;\n    for (let i = 0, len = lights.length; i < len; i++) {\n      const light = lights[i];\n      if (light instanceof AmbientLight) {\n        light.bindMaterialValues(mtl, `u_ambientLight`);\n      } else if (light instanceof DirectLight) {\n        light.bindMaterialValues(mtl, `u_directLights[${directLightCount++}]`);\n      } else if (light instanceof PointLight) {\n        light.bindMaterialValues(mtl, `u_pointLights[${pointLightCount++}]`);\n      } else if (light instanceof SpotLight) {\n        light.bindMaterialValues(mtl, `u_spotLights[${spotLightCount++}]`);\n      } else if (light instanceof EnvironmentMapLight) {\n        light.bindMaterialValues(mtl, `u_envMapLight`);\n      }\n    }\n  }\n  getUniformDefine() {\n    let uniforms = {};\n    let ambientLightCount = 0;\n    let directLightCount = 0;\n    let pointLightCount = 0;\n    let spotLightCount = 0;\n    let envMapLightCount = 0;\n    let lights = this.visibleLights;\n    for (let i = 0, len = lights.length; i < len; i++) {\n      const light = lights[i];\n      if (light instanceof AmbientLight && !ambientLightCount++) {\n        uniforms = {...uniforms, ...AmbientLight.getUniformDefine(`u_ambientLight`)};\n      } else if (light instanceof DirectLight) {\n        uniforms = {...uniforms, ...DirectLight.getUniformDefine(`u_directLights[${directLightCount++}]`)};\n      } else if (light instanceof PointLight) {\n        uniforms = {...uniforms, ...PointLight.getUniformDefine(`u_pointLights[${pointLightCount++}]`)};\n      } else if (light instanceof SpotLight) {\n        uniforms = {...uniforms, ...SpotLight.getUniformDefine(`u_spotLights[${spotLightCount++}]`)};\n      } else if (light instanceof EnvironmentMapLight && !envMapLightCount++) {\n        uniforms = {...uniforms, ...EnvironmentMapLight.getUniformDefine(`u_envMapLight`)};\n      }\n    }\n    return uniforms;\n  }\n}\n\nclass ColliderFeature extends SceneFeature {\n  constructor() {\n    super();\n    this.colliders = [];\n  }\n  attachCollider(collider) {\n    this.colliders.push(collider);\n  }\n  detachCollider(collider) {\n    const index = this.colliders.indexOf(collider);\n    if (index != -1) {\n      this.colliders.splice(index, 1);\n    }\n  }\n}\n\nclass Collider extends Component {\n  constructor(entity) {\n    super(entity);\n    this.tag = MaskList.EVERYTHING;\n  }\n  _onEnable() {\n    this.scene.findFeature(ColliderFeature).attachCollider(this);\n  }\n  _onDisable() {\n    this.scene.findFeature(ColliderFeature).detachCollider(this);\n  }\n}\n\nclass ABoxCollider extends Collider {\n  constructor(entity) {\n    super(entity);\n    this._corners = [];\n    this._cornerFlag = false;\n    this.boxMin = new Vector3(-0.5, -0.5, -0.5);\n    this.boxMax = new Vector3(0.5, 0.5, 0.5);\n  }\n  setBoxMinMax(min, max) {\n    this.boxMin = min;\n    this.boxMax = max;\n    this._cornerFlag = true;\n  }\n  setBoxCenterSize(center, size) {\n    const halfSize = ABoxCollider._tempVec3;\n    Vector3.scale(size, 0.5, halfSize);\n    Vector3.add(center, halfSize, this.boxMax);\n    Vector3.subtract(center, halfSize, this.boxMin);\n    this._cornerFlag = true;\n  }\n  getCorners() {\n    if (this._cornerFlag) {\n      const minX = this.boxMin.x;\n      const minY = this.boxMin.y;\n      const minZ = this.boxMin.z;\n      const w = this.boxMax.x - minX;\n      const h = this.boxMax.y - minY;\n      const d = this.boxMax.z - minZ;\n      if (this._corners.length === 0) {\n        for (let i = 0; i < 8; ++i) {\n          this._corners.push(new Vector3());\n        }\n      }\n      this._corners[0].setValue(minX + w, minY + h, minZ + d);\n      this._corners[1].setValue(minX, minY + h, minZ + d);\n      this._corners[2].setValue(minX, minY, minZ + d);\n      this._corners[3].setValue(minX + w, minY, minZ + d);\n      this._corners[4].setValue(minX + w, minY + h, minZ);\n      this._corners[5].setValue(minX, minY + h, minZ);\n      this._corners[6].setValue(minX, minY, minZ);\n      this._corners[7].setValue(minX + w, minY, minZ);\n      this._cornerFlag = false;\n    }\n    return this._corners;\n  }\n}\nABoxCollider._tempVec3 = new Vector3();\n\nclass ASphereCollider extends Collider {\n  constructor(entity) {\n    super(entity);\n    this.center = new Vector3();\n    this.radius = 1;\n  }\n  raycast(ray, hit) {\n  }\n  setSphere(center, radius) {\n    this.center = center;\n    this.radius = radius;\n  }\n}\n\nclass PlaneCollider extends Collider {\n  constructor(entity) {\n    super(entity);\n    this.planePoint = new Vector3();\n    this.normal = new Vector3(0, 1, 0);\n  }\n  setPlane(point, normal) {\n    this.planePoint = point;\n    this.normal = normal;\n  }\n}\n\nScene.prototype.raycast = function(_ray, _outPos, tag = MaskList.EVERYTHING) {\n  const ray = new Ray(_ray.origin, _ray.direction);\n  const cf = this.findFeature(ColliderFeature);\n  const colliders = cf.colliders;\n  let nearestHit = new RaycastHit();\n  for (let i = 0, len = colliders.length; i < len; i++) {\n    const collider = colliders[i];\n    if (!collider.entity.isActiveInHierarchy) {\n      continue;\n    }\n    if (!(collider.tag & tag)) {\n      continue;\n    }\n    const hit = new RaycastHit();\n    if (collider.raycast(ray, hit)) {\n      if (hit.distance < nearestHit.distance) {\n        nearestHit = hit;\n      }\n    }\n  }\n  if (_outPos && nearestHit.collider) {\n    nearestHit.point.cloneTo(_outPos);\n  }\n  return nearestHit.collider;\n};\nABoxCollider.prototype.raycast = function(ray, hit) {\n  const localRay = _getLocalRay(this, ray);\n  const intersect = localRay.intersectAABB(this.boxMax, this.boxMin);\n  if (intersect) {\n    _updateHitResult(this, localRay, intersect, hit, ray.origin);\n    return true;\n  } else {\n    return false;\n  }\n};\nASphereCollider.prototype.raycast = function(ray, hit) {\n  const localRay = _getLocalRay(this, ray);\n  const intersect = localRay.intersectSphere(this.center, this.radius);\n  if (intersect) {\n    _updateHitResult(this, localRay, intersect, hit, ray.origin);\n    return true;\n  } else {\n    return false;\n  }\n};\nPlaneCollider.prototype.raycast = function(ray, hit) {\n  const localRay = _getLocalRay(this, ray);\n  const intersect = localRay.intersectPlane(this.planePoint, this.normal);\n  if (intersect) {\n    _updateHitResult(this, localRay, intersect, hit, ray.origin);\n    return true;\n  } else {\n    return false;\n  }\n};\nfunction _updateHitResult(collider, ray, distance, outHit, origin) {\n  const hitPos = ray.getPoint(distance);\n  Vector3.transformCoordinate(hitPos, collider.entity.transform.worldMatrix, hitPos);\n  outHit.distance = Vector3.distance(origin, hitPos);\n  outHit.collider = collider;\n  outHit.point = hitPos;\n}\nfunction _getLocalRay(collider, ray) {\n  const worldToLocal = collider.entity.getInvModelMatrix();\n  const o = new Vector3();\n  Vector3.transformCoordinate(ray.origin, worldToLocal, o);\n  const d = new Vector3();\n  _transformDirection(d, ray.direction, worldToLocal);\n  return new Ray(o, d);\n}\nfunction _transformDirection(out, a, m) {\n  const x = a.x;\n  const y = a.y;\n  const z = a.z;\n  const e = m.elements;\n  out.x = x * e[0] + y * e[4] + z * e[8];\n  out.y = x * e[1] + y * e[5] + z * e[9];\n  out.z = x * e[2] + y * e[6] + z * e[10];\n  return out;\n}\n\nclass Mesh extends EngineObject {\n  constructor(engine, name) {\n    super(engine);\n    this.primitives = [];\n    this.groups = [];\n    this.bounds = new BoundingBox(new Vector3(), new Vector3());\n    this.name = name;\n  }\n  updatePrimitiveWeightsIndices(weightsIndices) {\n  }\n  destroy() {\n    this.primitives = null;\n  }\n}\n\nclass Skin extends AssetObject {\n  constructor(name) {\n    super(null);\n    this.inverseBindMatrices = [];\n    this.joints = [];\n    this.skeleton = \"none\";\n  }\n}\n\nvar __defProp$7 = Object.defineProperty;\nvar __getOwnPropDesc$7 = Object.getOwnPropertyDescriptor;\nvar __decorate$7 = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$7(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result)\n    __defProp$7(target, key, result);\n  return result;\n};\nfunction addPrimitivesRefCount(mesh, refCount) {\n  const primitives = mesh.primitives;\n  for (let i = 0, l = primitives.length; i < l; i++) {\n    primitives[i]._addRefCount(refCount);\n  }\n}\nclass MeshRenderer extends RenderableComponent {\n  constructor(entity) {\n    super(entity);\n    this._instanceMaterials = [];\n    this._sharedMaterials = [];\n    this._mesh = null;\n  }\n  get mesh() {\n    return this._mesh;\n  }\n  set mesh(mesh) {\n    if (this._mesh) {\n      addPrimitivesRefCount(this._mesh, -1);\n    }\n    addPrimitivesRefCount(mesh, 1);\n    this._mesh = mesh;\n    this._sharedMaterials = [];\n    this._instanceMaterials = [];\n  }\n  setSharedMaterial(primitiveIndex, material) {\n    if (this._sharedMaterials[primitiveIndex]) {\n      this._sharedMaterials[primitiveIndex]._addRefCount(-1);\n    }\n    material._addRefCount(1);\n    this._sharedMaterials[primitiveIndex] = material;\n  }\n  setMaterial(primitiveIndex, material) {\n    if (this._instanceMaterials[primitiveIndex]) {\n      this._instanceMaterials[primitiveIndex]._addRefCount(-1);\n    }\n    material._addRefCount(1);\n    this._instanceMaterials[primitiveIndex] = material;\n  }\n  getInstanceMaterial(primitiveIndex) {\n    return this._instanceMaterials[primitiveIndex];\n  }\n  getSharedMaterial(primitiveIndex) {\n    return this._sharedMaterials[primitiveIndex];\n  }\n  render(camera) {\n    const mesh = this._mesh;\n    if (!mesh) {\n      return;\n    }\n    const renderPipeline = camera._renderPipeline;\n    const {primitives, groups} = mesh;\n    for (let i = 0, len = primitives.length; i < len; i++) {\n      const primitive = primitives[i];\n      const material = this._instanceMaterials[i] || this._sharedMaterials[i];\n      if (material) {\n        const element = RenderElement.getFromPool();\n        element.setValue(this, primitive, groups[i], material);\n        renderPipeline.pushPrimitive(element);\n      } else {\n        Logger.error(\"Primitive has no material: \" + primitive.name);\n      }\n    }\n  }\n  destroy() {\n    super.destroy();\n    this._mesh = null;\n    this._instanceMaterials = [];\n    this._sharedMaterials = [];\n    for (let i = 0; i < this._instanceMaterials.length; i++) {\n      this._instanceMaterials[i]._addRefCount(-1);\n    }\n    for (let i = 0; i < this._sharedMaterials.length; i++) {\n      this._sharedMaterials[i]._addRefCount(-1);\n    }\n    if (this._mesh) {\n      addPrimitivesRefCount(this._mesh, -1);\n    }\n  }\n  _updateBounds(worldBounds) {\n    const localBounds = this.mesh.bounds;\n    const worldMatrix = this._entity.transform.worldMatrix;\n    Vector3.transformCoordinate(localBounds.min, worldMatrix, worldBounds.min);\n    Vector3.transformCoordinate(localBounds.max, worldMatrix, worldBounds.max);\n  }\n}\n__decorate$7([\n  ignoreClone\n], MeshRenderer.prototype, \"_instanceMaterials\", 2);\n__decorate$7([\n  shallowClone\n], MeshRenderer.prototype, \"_sharedMaterials\", 2);\n\nvar TextureFilterMode;\n(function(TextureFilterMode2) {\n  TextureFilterMode2[TextureFilterMode2[\"Point\"] = 0] = \"Point\";\n  TextureFilterMode2[TextureFilterMode2[\"Bilinear\"] = 1] = \"Bilinear\";\n  TextureFilterMode2[TextureFilterMode2[\"Trilinear\"] = 2] = \"Trilinear\";\n})(TextureFilterMode || (TextureFilterMode = {}));\n\nvar TextureFormat;\n(function(TextureFormat2) {\n  TextureFormat2[TextureFormat2[\"R8G8B8\"] = 0] = \"R8G8B8\";\n  TextureFormat2[TextureFormat2[\"R8G8B8A8\"] = 1] = \"R8G8B8A8\";\n  TextureFormat2[TextureFormat2[\"R4G4B4A4\"] = 2] = \"R4G4B4A4\";\n  TextureFormat2[TextureFormat2[\"R5G5B5A1\"] = 3] = \"R5G5B5A1\";\n  TextureFormat2[TextureFormat2[\"R5G6B5\"] = 4] = \"R5G6B5\";\n  TextureFormat2[TextureFormat2[\"Alpha8\"] = 5] = \"Alpha8\";\n  TextureFormat2[TextureFormat2[\"R32G32B32A32\"] = 6] = \"R32G32B32A32\";\n  TextureFormat2[TextureFormat2[\"DXT1\"] = 7] = \"DXT1\";\n  TextureFormat2[TextureFormat2[\"DXT5\"] = 8] = \"DXT5\";\n  TextureFormat2[TextureFormat2[\"ETC1_RGB\"] = 9] = \"ETC1_RGB\";\n  TextureFormat2[TextureFormat2[\"ETC2_RGB\"] = 10] = \"ETC2_RGB\";\n  TextureFormat2[TextureFormat2[\"ETC2_RGBA5\"] = 11] = \"ETC2_RGBA5\";\n  TextureFormat2[TextureFormat2[\"ETC2_RGBA8\"] = 12] = \"ETC2_RGBA8\";\n  TextureFormat2[TextureFormat2[\"PVRTC_RGB2\"] = 13] = \"PVRTC_RGB2\";\n  TextureFormat2[TextureFormat2[\"PVRTC_RGBA2\"] = 14] = \"PVRTC_RGBA2\";\n  TextureFormat2[TextureFormat2[\"PVRTC_RGB4\"] = 15] = \"PVRTC_RGB4\";\n  TextureFormat2[TextureFormat2[\"PVRTC_RGBA4\"] = 16] = \"PVRTC_RGBA4\";\n  TextureFormat2[TextureFormat2[\"ASTC_4x4\"] = 17] = \"ASTC_4x4\";\n  TextureFormat2[TextureFormat2[\"ASTC_5x5\"] = 18] = \"ASTC_5x5\";\n  TextureFormat2[TextureFormat2[\"ASTC_6x6\"] = 19] = \"ASTC_6x6\";\n  TextureFormat2[TextureFormat2[\"ASTC_8x8\"] = 20] = \"ASTC_8x8\";\n  TextureFormat2[TextureFormat2[\"ASTC_10x10\"] = 21] = \"ASTC_10x10\";\n  TextureFormat2[TextureFormat2[\"ASTC_12x12\"] = 22] = \"ASTC_12x12\";\n})(TextureFormat || (TextureFormat = {}));\n\nvar TextureWrapMode;\n(function(TextureWrapMode2) {\n  TextureWrapMode2[TextureWrapMode2[\"Clamp\"] = 0] = \"Clamp\";\n  TextureWrapMode2[TextureWrapMode2[\"Repeat\"] = 1] = \"Repeat\";\n  TextureWrapMode2[TextureWrapMode2[\"Mirror\"] = 2] = \"Mirror\";\n})(TextureWrapMode || (TextureWrapMode = {}));\n\nvar GLCompressedTextureInternalFormat;\n(function(GLCompressedTextureInternalFormat2) {\n  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2[\"RGBA_ASTC_4X4_KHR\"] = 37808] = \"RGBA_ASTC_4X4_KHR\";\n  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2[\"RGBA_ASTC_5X4_KHR\"] = 37809] = \"RGBA_ASTC_5X4_KHR\";\n  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2[\"RGBA_ASTC_5X5_KHR\"] = 37810] = \"RGBA_ASTC_5X5_KHR\";\n  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2[\"RGBA_ASTC_6X5_KHR\"] = 37811] = \"RGBA_ASTC_6X5_KHR\";\n  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2[\"RGBA_ASTC_6X6_KHR\"] = 37812] = \"RGBA_ASTC_6X6_KHR\";\n  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2[\"RGBA_ASTC_8X5_KHR\"] = 37813] = \"RGBA_ASTC_8X5_KHR\";\n  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2[\"RGBA_ASTC_8X6_KHR\"] = 37814] = \"RGBA_ASTC_8X6_KHR\";\n  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2[\"RGBA_ASTC_8X8_KHR\"] = 37815] = \"RGBA_ASTC_8X8_KHR\";\n  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2[\"RGBA_ASTC_10X5_KHR\"] = 37816] = \"RGBA_ASTC_10X5_KHR\";\n  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2[\"RGBA_ASTC_10X6_KHR\"] = 37817] = \"RGBA_ASTC_10X6_KHR\";\n  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2[\"RGBA_ASTC_10X8_KHR\"] = 37818] = \"RGBA_ASTC_10X8_KHR\";\n  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2[\"RGBA_ASTC_10X10_KHR\"] = 37819] = \"RGBA_ASTC_10X10_KHR\";\n  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2[\"RGBA_ASTC_12X10_KHR\"] = 37820] = \"RGBA_ASTC_12X10_KHR\";\n  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2[\"RGBA_ASTC_12X12_KHR\"] = 37821] = \"RGBA_ASTC_12X12_KHR\";\n  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2[\"SRGB8_ALPHA8_ASTC_4X4_KHR\"] = 37840] = \"SRGB8_ALPHA8_ASTC_4X4_KHR\";\n  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2[\"SRGB8_ALPHA8_ASTC_5X4_KHR\"] = 37841] = \"SRGB8_ALPHA8_ASTC_5X4_KHR\";\n  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2[\"SRGB8_ALPHA8_ASTC_5X5_KHR\"] = 37842] = \"SRGB8_ALPHA8_ASTC_5X5_KHR\";\n  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2[\"SRGB8_ALPHA8_ASTC_6X5_KHR\"] = 37843] = \"SRGB8_ALPHA8_ASTC_6X5_KHR\";\n  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2[\"SRGB8_ALPHA8_ASTC_6X6_KHR\"] = 37844] = \"SRGB8_ALPHA8_ASTC_6X6_KHR\";\n  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2[\"SRGB8_ALPHA8_ASTC_8X5_KHR\"] = 37845] = \"SRGB8_ALPHA8_ASTC_8X5_KHR\";\n  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2[\"SRGB8_ALPHA8_ASTC_8X6_KHR\"] = 37846] = \"SRGB8_ALPHA8_ASTC_8X6_KHR\";\n  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2[\"SRGB8_ALPHA8_ASTC_8X8_KHR\"] = 37847] = \"SRGB8_ALPHA8_ASTC_8X8_KHR\";\n  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2[\"SRGB8_ALPHA8_ASTC_10X5_KHR\"] = 37848] = \"SRGB8_ALPHA8_ASTC_10X5_KHR\";\n  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2[\"SRGB8_ALPHA8_ASTC_10X6_KHR\"] = 37849] = \"SRGB8_ALPHA8_ASTC_10X6_KHR\";\n  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2[\"SRGB8_ALPHA8_ASTC_10X8_KHR\"] = 37850] = \"SRGB8_ALPHA8_ASTC_10X8_KHR\";\n  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2[\"SRGB8_ALPHA8_ASTC_10X10_KHR\"] = 37851] = \"SRGB8_ALPHA8_ASTC_10X10_KHR\";\n  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2[\"SRGB8_ALPHA8_ASTC_12X10_KHR\"] = 37852] = \"SRGB8_ALPHA8_ASTC_12X10_KHR\";\n  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2[\"SRGB8_ALPHA8_ASTC_12X12_KHR\"] = 37853] = \"SRGB8_ALPHA8_ASTC_12X12_KHR\";\n  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2[\"RGB_ETC1_WEBGL\"] = 36196] = \"RGB_ETC1_WEBGL\";\n  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2[\"R11_EAC\"] = 37488] = \"R11_EAC\";\n  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2[\"SIGNED_R11_EAC\"] = 37489] = \"SIGNED_R11_EAC\";\n  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2[\"RG11_EAC\"] = 37490] = \"RG11_EAC\";\n  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2[\"SIGNED_RG11_EAC\"] = 37491] = \"SIGNED_RG11_EAC\";\n  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2[\"RGB8_ETC2\"] = 37492] = \"RGB8_ETC2\";\n  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2[\"SRGB8_ETC2\"] = 37493] = \"SRGB8_ETC2\";\n  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2[\"RGB8_PUNCHTHROUGH_ALPHA1_ETC2\"] = 37494] = \"RGB8_PUNCHTHROUGH_ALPHA1_ETC2\";\n  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2[\"SRGB8_PUNCHTHROUGH_ALPHA1_ETC2\"] = 37495] = \"SRGB8_PUNCHTHROUGH_ALPHA1_ETC2\";\n  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2[\"RGBA8_ETC2_EAC\"] = 37496] = \"RGBA8_ETC2_EAC\";\n  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2[\"SRGB8_ALPHA8_ETC2_EAC\"] = 37497] = \"SRGB8_ALPHA8_ETC2_EAC\";\n  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2[\"RGB_PVRTC_4BPPV1_IMG\"] = 35840] = \"RGB_PVRTC_4BPPV1_IMG\";\n  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2[\"RGB_PVRTC_2BPPV1_IMG\"] = 35841] = \"RGB_PVRTC_2BPPV1_IMG\";\n  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2[\"RGBA_PVRTC_4BPPV1_IMG\"] = 35842] = \"RGBA_PVRTC_4BPPV1_IMG\";\n  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2[\"RGBA_PVRTC_2BPPV1_IMG\"] = 35843] = \"RGBA_PVRTC_2BPPV1_IMG\";\n  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2[\"RGB_S3TC_DXT1_EXT\"] = 33776] = \"RGB_S3TC_DXT1_EXT\";\n  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2[\"RGBA_S3TC_DXT1_EXT\"] = 33777] = \"RGBA_S3TC_DXT1_EXT\";\n  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2[\"RGBA_S3TC_DXT3_EXT\"] = 33778] = \"RGBA_S3TC_DXT3_EXT\";\n  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2[\"RGBA_S3TC_DXT5_EXT\"] = 33779] = \"RGBA_S3TC_DXT5_EXT\";\n})(GLCompressedTextureInternalFormat || (GLCompressedTextureInternalFormat = {}));\n\nvar RenderBufferColorFormat;\n(function(RenderBufferColorFormat2) {\n  RenderBufferColorFormat2[RenderBufferColorFormat2[\"R8G8B8\"] = 0] = \"R8G8B8\";\n  RenderBufferColorFormat2[RenderBufferColorFormat2[\"R8G8B8A8\"] = 1] = \"R8G8B8A8\";\n  RenderBufferColorFormat2[RenderBufferColorFormat2[\"R4G4B4A4\"] = 2] = \"R4G4B4A4\";\n  RenderBufferColorFormat2[RenderBufferColorFormat2[\"R5G5B5A1\"] = 3] = \"R5G5B5A1\";\n  RenderBufferColorFormat2[RenderBufferColorFormat2[\"R5G6B5\"] = 4] = \"R5G6B5\";\n  RenderBufferColorFormat2[RenderBufferColorFormat2[\"Alpha8\"] = 5] = \"Alpha8\";\n  RenderBufferColorFormat2[RenderBufferColorFormat2[\"R16G16B16A16\"] = 6] = \"R16G16B16A16\";\n  RenderBufferColorFormat2[RenderBufferColorFormat2[\"R32G32B32A32\"] = 7] = \"R32G32B32A32\";\n})(RenderBufferColorFormat || (RenderBufferColorFormat = {}));\n\nvar RenderBufferDepthFormat;\n(function(RenderBufferDepthFormat2) {\n  RenderBufferDepthFormat2[RenderBufferDepthFormat2[\"Depth\"] = 0] = \"Depth\";\n  RenderBufferDepthFormat2[RenderBufferDepthFormat2[\"DepthStencil\"] = 1] = \"DepthStencil\";\n  RenderBufferDepthFormat2[RenderBufferDepthFormat2[\"Stencil\"] = 2] = \"Stencil\";\n  RenderBufferDepthFormat2[RenderBufferDepthFormat2[\"Depth16\"] = 3] = \"Depth16\";\n  RenderBufferDepthFormat2[RenderBufferDepthFormat2[\"Depth24\"] = 4] = \"Depth24\";\n  RenderBufferDepthFormat2[RenderBufferDepthFormat2[\"Depth32\"] = 5] = \"Depth32\";\n  RenderBufferDepthFormat2[RenderBufferDepthFormat2[\"Depth24Stencil8\"] = 6] = \"Depth24Stencil8\";\n  RenderBufferDepthFormat2[RenderBufferDepthFormat2[\"Depth32Stencil8\"] = 7] = \"Depth32Stencil8\";\n})(RenderBufferDepthFormat || (RenderBufferDepthFormat = {}));\n\nclass Texture extends RefObject {\n  constructor(engine) {\n    super(engine);\n    this._anisoLevel = 1;\n  }\n  static _isPowerOf2(v) {\n    return (v & v - 1) === 0;\n  }\n  static _getFormatDetail(format, gl, isWebGL2) {\n    switch (format) {\n      case TextureFormat.R8G8B8:\n        return {\n          internalFormat: isWebGL2 ? gl.RGB8 : gl.RGB,\n          baseFormat: gl.RGB,\n          dataType: gl.UNSIGNED_BYTE,\n          isCompressed: false\n        };\n      case TextureFormat.R8G8B8A8:\n        return {\n          internalFormat: isWebGL2 ? gl.RGBA8 : gl.RGBA,\n          baseFormat: gl.RGBA,\n          dataType: gl.UNSIGNED_BYTE,\n          isCompressed: false\n        };\n      case TextureFormat.R4G4B4A4:\n        return {\n          internalFormat: isWebGL2 ? gl.RGBA4 : gl.RGBA,\n          baseFormat: gl.RGBA,\n          dataType: gl.UNSIGNED_SHORT_4_4_4_4,\n          isCompressed: false\n        };\n      case TextureFormat.R5G5B5A1:\n        return {\n          internalFormat: isWebGL2 ? gl.RGB5_A1 : gl.RGBA,\n          baseFormat: gl.RGBA,\n          dataType: gl.UNSIGNED_SHORT_5_5_5_1,\n          isCompressed: false\n        };\n      case TextureFormat.R5G6B5:\n        return {\n          internalFormat: isWebGL2 ? gl.RGB565 : gl.RGB,\n          baseFormat: gl.RGB,\n          dataType: gl.UNSIGNED_SHORT_5_6_5,\n          isCompressed: false\n        };\n      case TextureFormat.Alpha8:\n        return {\n          internalFormat: gl.ALPHA,\n          baseFormat: gl.ALPHA,\n          dataType: gl.UNSIGNED_BYTE,\n          isCompressed: false\n        };\n      case TextureFormat.R32G32B32A32:\n        return {\n          internalFormat: gl.RGBA32F,\n          baseFormat: gl.RGBA,\n          dataType: gl.FLOAT,\n          isCompressed: false\n        };\n      case TextureFormat.DXT1:\n        return {\n          internalFormat: GLCompressedTextureInternalFormat.RGB_S3TC_DXT1_EXT,\n          isCompressed: true\n        };\n      case TextureFormat.DXT5:\n        return {\n          internalFormat: GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT,\n          isCompressed: true\n        };\n      case TextureFormat.ETC1_RGB:\n        return {\n          internalFormat: GLCompressedTextureInternalFormat.RGB_ETC1_WEBGL,\n          isCompressed: true\n        };\n      case TextureFormat.ETC2_RGB:\n        return {\n          internalFormat: GLCompressedTextureInternalFormat.RGB8_ETC2,\n          isCompressed: true\n        };\n      case TextureFormat.ETC2_RGBA5:\n        return {\n          internalFormat: GLCompressedTextureInternalFormat.RGB8_PUNCHTHROUGH_ALPHA1_ETC2,\n          isCompressed: true\n        };\n      case TextureFormat.ETC2_RGBA8:\n        return {\n          internalFormat: GLCompressedTextureInternalFormat.RGBA8_ETC2_EAC,\n          isCompressed: true\n        };\n      case TextureFormat.PVRTC_RGB2:\n        return {\n          internalFormat: GLCompressedTextureInternalFormat.RGB_PVRTC_2BPPV1_IMG,\n          isCompressed: true\n        };\n      case TextureFormat.PVRTC_RGBA2:\n        return {\n          internalFormat: GLCompressedTextureInternalFormat.RGBA_PVRTC_2BPPV1_IMG,\n          isCompressed: true\n        };\n      case TextureFormat.PVRTC_RGB4:\n        return {\n          internalFormat: GLCompressedTextureInternalFormat.RGB_PVRTC_4BPPV1_IMG,\n          isCompressed: true\n        };\n      case TextureFormat.PVRTC_RGBA4:\n        return {\n          internalFormat: GLCompressedTextureInternalFormat.RGBA_PVRTC_4BPPV1_IMG,\n          isCompressed: true\n        };\n      case TextureFormat.ASTC_4x4:\n        return {\n          internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_4X4_KHR,\n          isCompressed: true\n        };\n      case TextureFormat.ASTC_5x5:\n        return {\n          internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_5X5_KHR,\n          isCompressed: true\n        };\n      case TextureFormat.ASTC_6x6:\n        return {\n          internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_6X6_KHR,\n          isCompressed: true\n        };\n      case TextureFormat.ASTC_8x8:\n        return {\n          internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_8X8_KHR,\n          isCompressed: true\n        };\n      case TextureFormat.ASTC_10x10:\n        return {\n          internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_10X10_KHR,\n          isCompressed: true\n        };\n      case TextureFormat.ASTC_12x12:\n        return {\n          internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_12X12_KHR,\n          isCompressed: true\n        };\n      default:\n        throw new Error(`this TextureFormat is not supported in Oasis Engine: ${format}`);\n    }\n  }\n  static _getRenderBufferColorFormatDetail(format, gl, isWebGL2) {\n    switch (format) {\n      case RenderBufferColorFormat.R8G8B8:\n        return {\n          internalFormat: isWebGL2 ? gl.RGB8 : gl.RGB,\n          baseFormat: gl.RGB,\n          dataType: gl.UNSIGNED_BYTE,\n          isCompressed: false\n        };\n      case RenderBufferColorFormat.R8G8B8A8:\n        return {\n          internalFormat: isWebGL2 ? gl.RGBA8 : gl.RGBA,\n          baseFormat: gl.RGBA,\n          dataType: gl.UNSIGNED_BYTE,\n          isCompressed: false\n        };\n      case RenderBufferColorFormat.R4G4B4A4:\n        return {\n          internalFormat: isWebGL2 ? gl.RGBA4 : gl.RGBA,\n          baseFormat: gl.RGBA,\n          dataType: gl.UNSIGNED_SHORT_4_4_4_4,\n          isCompressed: false\n        };\n      case RenderBufferColorFormat.R5G5B5A1:\n        return {\n          internalFormat: isWebGL2 ? gl.RGB5_A1 : gl.RGBA,\n          baseFormat: gl.RGBA,\n          dataType: gl.UNSIGNED_SHORT_5_5_5_1,\n          isCompressed: false\n        };\n      case RenderBufferColorFormat.R5G6B5:\n        return {\n          internalFormat: isWebGL2 ? gl.RGB565 : gl.RGB,\n          baseFormat: gl.RGB,\n          dataType: gl.UNSIGNED_SHORT_5_6_5,\n          isCompressed: false\n        };\n      case RenderBufferColorFormat.Alpha8:\n        return {\n          internalFormat: gl.ALPHA,\n          baseFormat: gl.ALPHA,\n          dataType: gl.UNSIGNED_BYTE,\n          isCompressed: false\n        };\n      case RenderBufferColorFormat.R16G16B16A16:\n        return {\n          internalFormat: gl.RGBA16F,\n          baseFormat: gl.RGBA,\n          dataType: gl.HALF_FLOAT,\n          isCompressed: false\n        };\n      case RenderBufferColorFormat.R32G32B32A32:\n        return {\n          internalFormat: gl.RGBA32F,\n          baseFormat: gl.RGBA,\n          dataType: gl.FLOAT,\n          isCompressed: false\n        };\n      default:\n        throw new Error(`this RenderBufferColorFormat is not supported in Oasis Engine: ${format}`);\n    }\n  }\n  static _getRenderBufferDepthFormatDetail(format, gl, isWebGL2) {\n    switch (format) {\n      case RenderBufferDepthFormat.Depth:\n        return {\n          internalFormat: isWebGL2 ? gl.DEPTH_COMPONENT32F : gl.DEPTH_COMPONENT16,\n          baseFormat: gl.DEPTH_COMPONENT,\n          dataType: isWebGL2 ? gl.FLOAT : gl.UNSIGNED_INT,\n          isCompressed: false,\n          attachment: gl.DEPTH_ATTACHMENT\n        };\n      case RenderBufferDepthFormat.DepthStencil:\n        return {\n          internalFormat: isWebGL2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL,\n          baseFormat: gl.DEPTH_STENCIL,\n          dataType: gl.UNSIGNED_INT_24_8,\n          isCompressed: false,\n          attachment: gl.DEPTH_STENCIL_ATTACHMENT\n        };\n      case RenderBufferDepthFormat.Stencil:\n        return {\n          internalFormat: gl.STENCIL_INDEX8,\n          baseFormat: gl.STENCIL_ATTACHMENT,\n          dataType: gl.UNSIGNED_BYTE,\n          isCompressed: false,\n          attachment: gl.STENCIL_ATTACHMENT\n        };\n      case RenderBufferDepthFormat.Depth16:\n        return {\n          internalFormat: isWebGL2 ? gl.DEPTH_COMPONENT16 : gl.DEPTH_COMPONENT16,\n          baseFormat: gl.DEPTH_COMPONENT,\n          dataType: gl.UNSIGNED_INT,\n          isCompressed: false,\n          attachment: gl.DEPTH_ATTACHMENT\n        };\n      case RenderBufferDepthFormat.Depth24:\n        return {\n          internalFormat: gl.DEPTH_COMPONENT24,\n          baseFormat: gl.DEPTH_COMPONENT,\n          dataType: gl.UNSIGNED_INT,\n          isCompressed: false,\n          attachment: gl.DEPTH_ATTACHMENT\n        };\n      case RenderBufferDepthFormat.Depth32:\n        return {\n          internalFormat: gl.DEPTH_COMPONENT32F,\n          baseFormat: gl.DEPTH_COMPONENT,\n          dataType: gl.FLOAT,\n          isCompressed: false,\n          attachment: gl.DEPTH_ATTACHMENT\n        };\n      case RenderBufferDepthFormat.Depth24Stencil8:\n        return {\n          internalFormat: isWebGL2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL,\n          baseFormat: gl.DEPTH_STENCIL,\n          dataType: gl.UNSIGNED_INT_24_8,\n          isCompressed: false,\n          attachment: gl.DEPTH_STENCIL_ATTACHMENT\n        };\n      case RenderBufferDepthFormat.Depth32Stencil8:\n        return {\n          internalFormat: gl.DEPTH32F_STENCIL8,\n          baseFormat: gl.DEPTH_STENCIL,\n          dataType: gl.FLOAT_32_UNSIGNED_INT_24_8_REV,\n          isCompressed: false,\n          attachment: gl.DEPTH_STENCIL_ATTACHMENT\n        };\n      default:\n        throw new Error(`this RenderBufferDepthFormat is not supported in Oasis Engine: ${format}`);\n    }\n  }\n  static _supportTextureFormat(format, rhi) {\n    let isSupported = true;\n    switch (format) {\n      case TextureFormat.R32G32B32A32:\n        {\n          if (!rhi.canIUse(GLCapabilityType.textureFloat)) {\n            isSupported = false;\n          }\n        }\n        break;\n    }\n    return isSupported;\n  }\n  static _supportRenderBufferColorFormat(format, rhi) {\n    let isSupported = true;\n    switch (format) {\n      case RenderBufferColorFormat.R32G32B32A32:\n        {\n          if (!rhi.canIUse(GLCapabilityType.colorBufferFloat) || !rhi.canIUse(GLCapabilityType.textureFloat)) {\n            isSupported = false;\n          }\n        }\n        break;\n      case RenderBufferColorFormat.R16G16B16A16:\n        {\n          if (!rhi.canIUse(GLCapabilityType.colorBufferHalfFloat) || !rhi.canIUse(GLCapabilityType.textureHalfFloat)) {\n            isSupported = false;\n          }\n        }\n        break;\n    }\n    return isSupported;\n  }\n  static _supportRenderBufferDepthFormat(format, rhi, isTexture) {\n    const isWebGL2 = rhi.isWebGL2;\n    let isSupported = true;\n    if (isTexture && !rhi.canIUse(GLCapabilityType.depthTexture)) {\n      return false;\n    }\n    switch (format) {\n      case RenderBufferDepthFormat.Stencil:\n        {\n          isSupported = false;\n        }\n        break;\n      case RenderBufferDepthFormat.Depth24:\n      case RenderBufferDepthFormat.Depth32:\n      case RenderBufferDepthFormat.Depth32Stencil8:\n        {\n          if (!isWebGL2) {\n            isSupported = false;\n          }\n        }\n        break;\n    }\n    return isSupported;\n  }\n  get width() {\n    return this._width;\n  }\n  get height() {\n    return this._height;\n  }\n  get wrapModeU() {\n    return this._wrapModeU;\n  }\n  set wrapModeU(value) {\n    if (value === this._wrapModeU)\n      return;\n    const gl = this._rhi.gl;\n    this._wrapModeU = value;\n    this._bind();\n    this._setWrapMode(value, gl.TEXTURE_WRAP_S);\n    this._unbind();\n  }\n  get wrapModeV() {\n    return this._wrapModeV;\n  }\n  set wrapModeV(value) {\n    if (value === this._wrapModeV)\n      return;\n    const gl = this._rhi.gl;\n    this._wrapModeV = value;\n    this._bind();\n    this._setWrapMode(value, gl.TEXTURE_WRAP_T);\n    this._unbind();\n  }\n  get mipmapCount() {\n    return this._mipmapCount;\n  }\n  get filterMode() {\n    return this._filterMode;\n  }\n  set filterMode(value) {\n    if (value === this._filterMode)\n      return;\n    const gl = this._rhi.gl;\n    this._filterMode = value;\n    this._bind();\n    switch (value) {\n      case TextureFilterMode.Point:\n        gl.texParameteri(this._target, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n        gl.texParameteri(this._target, gl.TEXTURE_MIN_FILTER, this._mipmap ? gl.NEAREST_MIPMAP_NEAREST : gl.NEAREST);\n        break;\n      case TextureFilterMode.Bilinear:\n        gl.texParameteri(this._target, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n        gl.texParameteri(this._target, gl.TEXTURE_MIN_FILTER, this._mipmap ? gl.LINEAR_MIPMAP_NEAREST : gl.LINEAR);\n        break;\n      case TextureFilterMode.Trilinear:\n        gl.texParameteri(this._target, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n        gl.texParameteri(this._target, gl.TEXTURE_MIN_FILTER, this._mipmap ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);\n        break;\n    }\n    this._unbind();\n  }\n  get anisoLevel() {\n    return this._anisoLevel;\n  }\n  set anisoLevel(value) {\n    const max = this._rhi.capability.maxAnisoLevel;\n    if (value > max) {\n      Logger.warn(`anisoLevel:${value}, exceeds the limit and is automatically downgraded to:${max}`);\n      value = max;\n    }\n    if (value < 1) {\n      Logger.warn(`anisoLevel:${value}, must be greater than 0, and is automatically downgraded to 1`);\n      value = 1;\n    }\n    if (value === this._anisoLevel)\n      return;\n    const gl = this._rhi.gl;\n    this._anisoLevel = value;\n    this._bind();\n    gl.texParameterf(this._target, gl.TEXTURE_MAX_ANISOTROPY_EXT, value);\n    this._unbind();\n  }\n  generateMipmaps() {\n    if (!this._mipmap)\n      return;\n    const gl = this._rhi.gl;\n    this._bind();\n    gl.generateMipmap(this._target);\n    this._unbind();\n  }\n  _onDestroy() {\n    const gl = this._rhi.gl;\n    gl.deleteTexture(this._glTexture);\n    this._glTexture = null;\n    this._formatDetail = null;\n    this._rhi = null;\n  }\n  _bind() {\n    const gl = this._rhi.gl;\n    gl.bindTexture(this._target, this._glTexture);\n  }\n  _unbind() {\n    const gl = this._rhi.gl;\n    gl.bindTexture(this._target, null);\n  }\n  _getPixelBuffer(face, x, y, width, height, out) {\n    const gl = this._rhi.gl;\n    const {baseFormat, dataType} = this._formatDetail;\n    if (!Texture._readFrameBuffer) {\n      Texture._readFrameBuffer = gl.createFramebuffer();\n    }\n    gl.bindFramebuffer(gl.FRAMEBUFFER, Texture._readFrameBuffer);\n    if (face != null) {\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, this._glTexture, 0);\n    } else {\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._glTexture, 0);\n    }\n    gl.readPixels(x, y, width, height, baseFormat, dataType, out);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n  }\n  _initMipmap(isCube) {\n    const gl = this._rhi.gl;\n    const isWebGL2 = this._rhi.isWebGL2;\n    let {internalFormat, baseFormat, dataType} = this._formatDetail;\n    this._bind();\n    if (isWebGL2) {\n      gl.texStorage2D(this._target, this._mipmapCount, internalFormat, this._width, this._height);\n    } else {\n      if (baseFormat !== internalFormat) {\n        internalFormat = baseFormat;\n      }\n      if (!isCube) {\n        for (let i = 0; i < this._mipmapCount; i++) {\n          const width = Math.max(1, this._width >> i);\n          const height = Math.max(1, this._height >> i);\n          gl.texImage2D(this._target, i, internalFormat, width, height, 0, baseFormat, dataType, null);\n        }\n      } else {\n        for (let i = 0; i < this._mipmapCount; i++) {\n          const size = Math.max(1, this._width >> i);\n          for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\n            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, i, internalFormat, size, size, 0, baseFormat, dataType, null);\n          }\n        }\n      }\n    }\n    this._unbind();\n  }\n  _getMaxMiplevel(size) {\n    return Math.floor(Math.log2(size));\n  }\n  _getMipmapCount() {\n    return this._mipmap ? Math.floor(Math.log2(Math.max(this._width, this._height))) + 1 : 1;\n  }\n  _setWrapMode(value, pname) {\n    const gl = this._rhi.gl;\n    const isWebGL2 = this._rhi.isWebGL2;\n    if (!isWebGL2 && value !== TextureWrapMode.Clamp && (!Texture._isPowerOf2(this._width) || !Texture._isPowerOf2(this._height))) {\n      Logger.warn(\"non-power-2 texture is not supported for REPEAT or MIRRORED_REPEAT in WebGL1,and has automatically downgraded to CLAMP_TO_EDGE\");\n      value = TextureWrapMode.Clamp;\n    }\n    switch (value) {\n      case TextureWrapMode.Clamp:\n        gl.texParameteri(this._target, pname, gl.CLAMP_TO_EDGE);\n        break;\n      case TextureWrapMode.Repeat:\n        gl.texParameteri(this._target, pname, gl.REPEAT);\n        break;\n      case TextureWrapMode.Mirror:\n        gl.texParameteri(this._target, pname, gl.MIRRORED_REPEAT);\n        break;\n    }\n  }\n}\nTexture._readFrameBuffer = null;\n\nclass Texture2D extends Texture {\n  constructor(engine, width, height, format = TextureFormat.R8G8B8A8, mipmap = true) {\n    super(engine);\n    this._compressedMipFilled = 0;\n    const rhi = engine._hardwareRenderer;\n    const gl = rhi.gl;\n    const isWebGL2 = rhi.isWebGL2;\n    if (!Texture._supportTextureFormat(format, rhi)) {\n      throw new Error(`Texture format is not supported:${TextureFormat[format]}`);\n    }\n    if (mipmap && !isWebGL2 && (!Texture._isPowerOf2(width) || !Texture._isPowerOf2(height))) {\n      Logger.warn(\"non-power-2 texture is not supported for mipmap in WebGL1,and has automatically downgraded to non-mipmap\");\n      mipmap = false;\n    }\n    const formatDetail = Texture._getFormatDetail(format, gl, isWebGL2);\n    this._glTexture = gl.createTexture();\n    this._formatDetail = formatDetail;\n    this._rhi = rhi;\n    this._target = gl.TEXTURE_2D;\n    this._mipmap = mipmap;\n    this._width = width;\n    this._height = height;\n    this._format = format;\n    this._mipmapCount = this._getMipmapCount();\n    formatDetail.isCompressed && !isWebGL2 || this._initMipmap(false);\n    this.filterMode = TextureFilterMode.Bilinear;\n    this.wrapModeU = this.wrapModeV = TextureWrapMode.Repeat;\n  }\n  get format() {\n    return this._format;\n  }\n  setPixelBuffer(colorBuffer, mipLevel = 0, x, y, width, height) {\n    const gl = this._rhi.gl;\n    const isWebGL2 = this._rhi.isWebGL2;\n    const {internalFormat, baseFormat, dataType, isCompressed} = this._formatDetail;\n    const mipWidth = Math.max(1, this._width >> mipLevel);\n    const mipHeight = Math.max(1, this._height >> mipLevel);\n    x = x || 0;\n    y = y || 0;\n    width = width || mipWidth - x;\n    height = height || mipHeight - y;\n    this._bind();\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0);\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);\n    if (isCompressed) {\n      const mipBit = 1 << mipLevel;\n      if (isWebGL2 || this._compressedMipFilled & mipBit) {\n        gl.compressedTexSubImage2D(this._target, mipLevel, x, y, width, height, internalFormat, colorBuffer);\n      } else {\n        gl.compressedTexImage2D(this._target, mipLevel, internalFormat, width, height, 0, colorBuffer);\n        this._compressedMipFilled |= mipBit;\n      }\n    } else {\n      gl.texSubImage2D(this._target, mipLevel, x, y, width, height, baseFormat, dataType, colorBuffer);\n    }\n    this._unbind();\n  }\n  setImageSource(imageSource, mipLevel = 0, flipY = false, premultiplyAlpha = false, x, y) {\n    const gl = this._rhi.gl;\n    const {baseFormat, dataType} = this._formatDetail;\n    this._bind();\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, +flipY);\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, +premultiplyAlpha);\n    gl.texSubImage2D(this._target, mipLevel, x || 0, y || 0, baseFormat, dataType, imageSource);\n    this._unbind();\n  }\n  getPixelBuffer(x, y, width, height, out) {\n    if (this._formatDetail.isCompressed) {\n      throw new Error(\"Unable to read compressed texture\");\n    }\n    super._getPixelBuffer(null, x, y, width, height, out);\n  }\n}\n\nvar __defProp$8 = Object.defineProperty;\nvar __getOwnPropDesc$8 = Object.getOwnPropertyDescriptor;\nvar __decorate$8 = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$8(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result)\n    __defProp$8(target, key, result);\n  return result;\n};\nclass SkinnedMeshRenderer extends MeshRenderer {\n  constructor(entity) {\n    super(entity);\n    this._hasInitJoints = false;\n    this.weightsIndices = [];\n    this._useJointTexture = false;\n    this._mat = new Matrix();\n    this._weights = null;\n    this._skin = null;\n  }\n  setWeights(weights) {\n    this._weights = weights;\n    if (!weights) {\n      return;\n    }\n    const len = weights.length;\n    for (let i = 0; i < len; i++) {\n      this.weightsIndices[i] = i;\n    }\n    const weightsIndices = this.weightsIndices;\n    for (let i = 0; i < len - 1; i++) {\n      for (let j = i + 1; j < len; j++) {\n        if (weights[j] > weights[i]) {\n          let t = weights[i];\n          weights[i] = weights[j];\n          weights[j] = t;\n          t = weightsIndices[i];\n          weightsIndices[i] = weightsIndices[j];\n          weightsIndices[j] = t;\n        }\n      }\n    }\n    this.mesh.updatePrimitiveWeightsIndices(weightsIndices);\n  }\n  get skin() {\n    return this._skin;\n  }\n  set skin(skin) {\n    this._skin = skin;\n  }\n  get weights() {\n    return this._weights;\n  }\n  _initJoints() {\n    if (!this._skin)\n      return;\n    const skin = this._skin;\n    const joints = skin.joints;\n    const jointNodes = [];\n    for (let i = joints.length - 1; i >= 0; i--) {\n      jointNodes[i] = this.findByNodeName(this.entity, joints[i]);\n    }\n    this.matrixPalette = new Float32Array(jointNodes.length * 16);\n    this.jointNodes = jointNodes;\n    const rhi = this.entity.engine._hardwareRenderer;\n    if (!rhi)\n      return;\n    const maxAttribUniformVec4 = rhi.renderStates.getParameter(rhi.gl.MAX_VERTEX_UNIFORM_VECTORS);\n    const maxJoints = Math.floor((maxAttribUniformVec4 - 20) / 4);\n    if (joints.length > maxJoints && rhi.canIUseMoreJoints) {\n      this._useJointTexture = true;\n    }\n  }\n  findByNodeName(entity, nodeName) {\n    if (!entity)\n      return null;\n    const n = entity.findByName(nodeName);\n    if (n)\n      return n;\n    return this.findByNodeName(entity.parent, nodeName);\n  }\n  _findParent(entity, nodeName) {\n    if (entity) {\n      const parent = entity.parent;\n      if (!parent)\n        return null;\n      if (parent.name === nodeName)\n        return parent;\n      const brother = parent.findByName(nodeName);\n      if (brother)\n        return brother;\n      return this._findParent(parent, nodeName);\n    }\n    return null;\n  }\n  update() {\n    if (!this._hasInitJoints) {\n      this._initJoints();\n      this._hasInitJoints = true;\n    }\n    if (this._skin) {\n      const joints = this.jointNodes;\n      const ibms = this._skin.inverseBindMatrices;\n      const matrixPalette = this.matrixPalette;\n      const worldToLocal = this.entity.getInvModelMatrix();\n      const mat = this._mat;\n      for (let i = joints.length - 1; i >= 0; i--) {\n        mat.identity();\n        if (joints[i]) {\n          Matrix.multiply(joints[i].transform.worldMatrix, ibms[i], mat);\n        } else {\n          ibms[i].cloneTo(mat);\n        }\n        Matrix.multiply(worldToLocal, mat, mat);\n        matrixPalette.set(mat.elements, i * 16);\n      }\n      if (this._useJointTexture) {\n        this.createJointTexture();\n      }\n    }\n  }\n  createJointTexture() {\n    if (!this.jointTexture) {\n      const engine = this.engine;\n      const rhi = engine._hardwareRenderer;\n      if (!rhi)\n        return;\n      this.jointTexture = new Texture2D(engine, 4, this.jointNodes.length, TextureFormat.R32G32B32A32, false);\n      this.jointTexture.filterMode = TextureFilterMode.Point;\n    }\n    this.jointTexture.setPixelBuffer(this.matrixPalette);\n  }\n}\n__decorate$8([\n  ignoreClone\n], SkinnedMeshRenderer.prototype, \"matrixPalette\", 2);\n__decorate$8([\n  ignoreClone\n], SkinnedMeshRenderer.prototype, \"jointNodes\", 2);\n__decorate$8([\n  ignoreClone\n], SkinnedMeshRenderer.prototype, \"jointTexture\", 2);\n__decorate$8([\n  ignoreClone\n], SkinnedMeshRenderer.prototype, \"_hasInitJoints\", 2);\n__decorate$8([\n  ignoreClone\n], SkinnedMeshRenderer.prototype, \"_mat\", 2);\n__decorate$8([\n  ignoreClone\n], SkinnedMeshRenderer.prototype, \"_weights\", 2);\n__decorate$8([\n  ignoreClone\n], SkinnedMeshRenderer.prototype, \"weightsIndices\", 2);\n__decorate$8([\n  ignoreClone\n], SkinnedMeshRenderer.prototype, \"_useJointTexture\", 2);\n\nclass LODGroup extends RenderableComponent {\n  constructor() {\n    super(...arguments);\n    this._lods = [];\n  }\n  addLod(distance, rendererAbility) {\n    rendererAbility.enabled = false;\n    this._lods.push({\n      distance,\n      rendererAbility\n    });\n    this._lods.sort((a, b) => b.distance - a.distance);\n  }\n  render(camera) {\n    if (this._lods.length <= 0)\n      return;\n    const dist = Vector3.distance(camera.eyePos, this.entity.worldPosition);\n    const lods = this._lods;\n    let activeLevel = 0;\n    for (let i = lods.length - 1; i >= 0; i--) {\n      const lod2 = lods[i];\n      if (dist < lod2.distance) {\n        activeLevel = i;\n        break;\n      }\n    }\n    const lod = lods[activeLevel];\n    lod.rendererAbility.render(camera);\n  }\n}\n\nclass Material extends RefObject {\n  constructor(engine, name) {\n    super(engine);\n    this.name = name;\n    this.renderType = MaterialType.OPAQUE;\n    this.useFog = true;\n    this.maxJointsNum = 0;\n    this._technique = null;\n    this._values = {};\n  }\n  clone(name = this.name, cloneTexture = false) {\n    const newMtl = new this.constructor(name);\n    newMtl.renderType = this.renderType;\n    newMtl.useFog = this.useFog;\n    for (const name2 in this._values) {\n      if (this._values.hasOwnProperty(name2)) {\n        const val = this._values[name2];\n        if (val instanceof Texture) {\n          newMtl.setValue(name2, val);\n        } else {\n          newMtl.setValue(name2, Util.clone(val));\n        }\n      }\n    }\n    return newMtl;\n  }\n  get transparent() {\n    return this.renderType === MaterialType.TRANSPARENT;\n  }\n  set transparent(val) {\n    this.renderType = val ? MaterialType.TRANSPARENT : MaterialType.OPAQUE;\n  }\n  get technique() {\n    return this._technique;\n  }\n  set technique(tech) {\n    this._technique = tech;\n    this._values = {};\n  }\n  setValue(name, value) {\n    const oriValue = this.getValue(name);\n    const oriIsTexture = oriValue instanceof Texture;\n    const curIsTexture = value instanceof Texture;\n    if (oriIsTexture) {\n      this._removeRefChild(oriValue);\n    }\n    if (curIsTexture) {\n      this._addRefChild(value);\n    }\n    if (this._generateTechnique && oriIsTexture !== curIsTexture) {\n      this._technique = null;\n    }\n    if (value != null) {\n      this._values[name] = value;\n    } else {\n      this.delValue(name);\n    }\n  }\n  delValue(name) {\n    delete this._values[name];\n  }\n  getValue(name) {\n    return this._values[name];\n  }\n  prepareDrawing(context, component, primitive, originalMaterial) {\n    const camera = context.camera;\n    const uniforms = this._technique.uniforms;\n    for (const name in uniforms) {\n      const uniform = uniforms[name];\n      this._updateValueBySemantic(uniform, context, component);\n    }\n    const scene = camera.scene;\n    if (scene.hasFogFeature) {\n      scene.bindFogToMaterial(this);\n    }\n    this._technique.compile(camera, component, primitive, this);\n  }\n  preCompile(tech) {\n  }\n  postCompile(tech) {\n  }\n  preRender(component, primitive) {\n  }\n  postRender(component, primitive) {\n  }\n  _updateValueBySemantic(uniform, context, component) {\n    const values = this._values;\n    switch (uniform.semantic) {\n      case UniformSemantic.LOCAL: {\n        values[uniform.name] = component._entity.transform.localMatrix;\n        break;\n      }\n      case UniformSemantic.MODEL:\n        values[uniform.name] = component._entity.transform.worldMatrix;\n        break;\n      case UniformSemantic.VIEW:\n        values[uniform.name] = context.viewMatrix;\n        break;\n      case UniformSemantic.PROJECTION:\n        values[uniform.name] = context.projectionMatrix;\n        break;\n      case UniformSemantic.MODELVIEW: {\n        const view = context.viewMatrix;\n        const model = component._entity.transform.worldMatrix;\n        let modelView = values[uniform.name];\n        if (!modelView)\n          modelView = new Matrix();\n        Matrix.multiply(view, model, modelView);\n        values[uniform.name] = modelView;\n        break;\n      }\n      case UniformSemantic.VIEWPROJECTION: {\n        const viewProj = context.viewProjectMatrix;\n        values[uniform.name] = viewProj;\n        break;\n      }\n      case UniformSemantic.MODELVIEWPROJECTION: {\n        const viewProj = context.viewProjectMatrix;\n        const model = component._entity.transform.worldMatrix;\n        let MVP = values[uniform.name];\n        if (!MVP)\n          MVP = new Matrix();\n        Matrix.multiply(viewProj, model, MVP);\n        values[uniform.name] = MVP;\n        break;\n      }\n      case UniformSemantic.MODELINVERSE:\n        values[uniform.name] = component.invModelMatrixs;\n        break;\n      case UniformSemantic.VIEWINVERSE:\n        values[uniform.name] = context.inverseViewMatrix;\n        break;\n      case UniformSemantic.PROJECTIONINVERSE:\n        values[uniform.name] = context.inverseProjectionMatrix;\n        break;\n      case UniformSemantic.MODELVIEWINVERSE: {\n        const view = context.viewMatrix;\n        const model = component._entity.transform.worldMatrix;\n        let invMV = values[uniform.name];\n        if (!invMV)\n          invMV = new Matrix();\n        Matrix.multiply(view, model, invMV);\n        Matrix.invert(invMV, invMV);\n        values[uniform.name] = invMV;\n        break;\n      }\n      case UniformSemantic.MODELVIEWPROJECTIONINVERSE: {\n        const viewProj = context.viewProjectMatrix;\n        const model = component._entity.transform.worldMatrix;\n        let invMVP = values[uniform.name];\n        if (!invMVP)\n          invMVP = new Matrix();\n        Matrix.multiply(viewProj, model, invMVP);\n        Matrix.invert(invMVP, invMVP);\n        values[uniform.name] = invMVP;\n        break;\n      }\n      case UniformSemantic.MODELINVERSETRANSPOSE: {\n        let modelIT = values[uniform.name];\n        if (!modelIT)\n          modelIT = new Matrix3x3();\n        Matrix3x3.normalMatrix(component._entity.transform.worldMatrix, modelIT);\n        values[uniform.name] = modelIT;\n        break;\n      }\n      case UniformSemantic.MODELVIEWINVERSETRANSPOSE: {\n        let modelViewIT = values[uniform.name];\n        if (!modelViewIT)\n          modelViewIT = new Matrix();\n        Matrix.multiply(context.viewMatrix, component._entity.transform.worldMatrix, modelViewIT);\n        Matrix.invert(modelViewIT, modelViewIT);\n        Matrix.transpose(modelViewIT, modelViewIT);\n        values[uniform.name] = modelViewIT;\n        break;\n      }\n      case UniformSemantic.VIEWPORT:\n        values[uniform.name] = context.viewport;\n        break;\n      case UniformSemantic.JOINTMATRIX:\n        values[uniform.name] = component.matrixPalette;\n        break;\n      case UniformSemantic.JOINTTEXTURE:\n        values[uniform.name] = component.jointTexture;\n        break;\n      case UniformSemantic.JOINTCOUNT:\n        values[uniform.name] = component.jointNodes?.length;\n        break;\n      case UniformSemantic.MORPHWEIGHTS:\n        values[uniform.name] = component.weights;\n        break;\n      case UniformSemantic.EYEPOS:\n        values[uniform.name] = context.cameraPosition;\n        break;\n      case UniformSemantic.TIME:\n        values[uniform.name] = component.engine.time.timeSinceStartup * 1e-3;\n        break;\n    }\n  }\n  _onDestroy() {\n    if (this._technique) {\n      const values = ObjectValues(this._values);\n      for (let i = 0, len = values.length; i < len; i++) {\n        const value = values[i];\n        if (value instanceof Texture) {\n          value._addRefCount(-1);\n        }\n      }\n      this._technique._finalize();\n      this._technique = null;\n    }\n  }\n}\n\nclass ComplexMaterial extends Material {\n  constructor(engine, name) {\n    super(engine, name);\n    this._techniquePool = {};\n  }\n  prepareDrawing(context, component, primitive) {\n    const camera = context.camera;\n    const tech = this._requireTechnique(camera, component, primitive);\n    if (tech) {\n      this._technique = tech;\n      super.prepareDrawing(context, component, primitive);\n    }\n  }\n  clearTechniques() {\n    this._techniquePool = {};\n  }\n  _requireTechnique(camera, component, primitive) {\n    const key = this._getTechniqueKey(camera, component, primitive);\n    let tech = this._techniquePool[key];\n    if (!tech) {\n      tech = this._generateTechnique(camera, component, primitive);\n      this._techniquePool[key] = tech;\n    }\n    return tech;\n  }\n  _generateTechnique(camera, component, primitive) {\n  }\n  _getTechniqueKey(camera, component, primitive) {\n    const isSkin = component.skin != null;\n    const jontCount = isSkin ? component.skin.joints.length : 0;\n    let key = isSkin ? \"skin_\" : \"static_\";\n    if (isSkin) {\n      key += \"jont\" + jontCount;\n    }\n    return key;\n  }\n}\n\nvar BufferUsage;\n(function(BufferUsage2) {\n  BufferUsage2[BufferUsage2[\"Static\"] = 0] = \"Static\";\n  BufferUsage2[BufferUsage2[\"Dynamic\"] = 1] = \"Dynamic\";\n  BufferUsage2[BufferUsage2[\"Stream\"] = 2] = \"Stream\";\n})(BufferUsage || (BufferUsage = {}));\n\nvar VertexElementFormat;\n(function(VertexElementFormat2) {\n  VertexElementFormat2[VertexElementFormat2[\"Float\"] = 0] = \"Float\";\n  VertexElementFormat2[VertexElementFormat2[\"Vector2\"] = 1] = \"Vector2\";\n  VertexElementFormat2[VertexElementFormat2[\"Vector3\"] = 2] = \"Vector3\";\n  VertexElementFormat2[VertexElementFormat2[\"Vector4\"] = 3] = \"Vector4\";\n  VertexElementFormat2[VertexElementFormat2[\"Byte4\"] = 4] = \"Byte4\";\n  VertexElementFormat2[VertexElementFormat2[\"UByte4\"] = 5] = \"UByte4\";\n  VertexElementFormat2[VertexElementFormat2[\"NormalizedByte4\"] = 6] = \"NormalizedByte4\";\n  VertexElementFormat2[VertexElementFormat2[\"NormalizedUByte4\"] = 7] = \"NormalizedUByte4\";\n  VertexElementFormat2[VertexElementFormat2[\"Short2\"] = 8] = \"Short2\";\n  VertexElementFormat2[VertexElementFormat2[\"UShort2\"] = 9] = \"UShort2\";\n  VertexElementFormat2[VertexElementFormat2[\"NormalizedShort2\"] = 10] = \"NormalizedShort2\";\n  VertexElementFormat2[VertexElementFormat2[\"NormalizedUShort2\"] = 11] = \"NormalizedUShort2\";\n  VertexElementFormat2[VertexElementFormat2[\"Short4\"] = 12] = \"Short4\";\n  VertexElementFormat2[VertexElementFormat2[\"UShort4\"] = 13] = \"UShort4\";\n  VertexElementFormat2[VertexElementFormat2[\"NormalizedShort4\"] = 14] = \"NormalizedShort4\";\n  VertexElementFormat2[VertexElementFormat2[\"NormalizedUShort4\"] = 15] = \"NormalizedUShort4\";\n})(VertexElementFormat || (VertexElementFormat = {}));\n\nvar IndexFormat;\n(function(IndexFormat2) {\n  IndexFormat2[IndexFormat2[\"UInt8\"] = 0] = \"UInt8\";\n  IndexFormat2[IndexFormat2[\"UInt16\"] = 1] = \"UInt16\";\n  IndexFormat2[IndexFormat2[\"UInt32\"] = 2] = \"UInt32\";\n})(IndexFormat || (IndexFormat = {}));\n\nclass BufferUtil {\n  static _getGLBufferUsage(gl, bufferUsage) {\n    switch (bufferUsage) {\n      case BufferUsage.Static:\n        return gl.STATIC_DRAW;\n      case BufferUsage.Dynamic:\n        return gl.DYNAMIC_DRAW;\n      case BufferUsage.Stream:\n        return gl.STREAM_DRAW;\n    }\n  }\n  static _getGLIndexType(indexFormat) {\n    switch (indexFormat) {\n      case IndexFormat.UInt8:\n        return DataType.UNSIGNED_BYTE;\n      case IndexFormat.UInt16:\n        return DataType.UNSIGNED_SHORT;\n      case IndexFormat.UInt32:\n        return DataType.UNSIGNED_INT;\n    }\n  }\n  static _getElementInfo(format) {\n    let size;\n    let type;\n    switch (format) {\n      case VertexElementFormat.Float:\n        size = 1;\n        type = DataType.FLOAT;\n        break;\n      case VertexElementFormat.Vector2:\n        size = 2;\n        type = DataType.FLOAT;\n        break;\n      case VertexElementFormat.Vector3:\n        size = 3;\n        type = DataType.FLOAT;\n        break;\n      case VertexElementFormat.Vector4:\n        size = 4;\n        type = DataType.FLOAT;\n        break;\n      case VertexElementFormat.Byte4:\n        size = 4;\n        type = DataType.UNSIGNED_BYTE;\n        break;\n      case VertexElementFormat.Short2:\n        size = 2;\n        type = DataType.SHORT;\n        break;\n      case VertexElementFormat.Short4:\n        size = 4;\n        type = DataType.SHORT;\n        break;\n      case VertexElementFormat.UShort2:\n        size = 2;\n        type = DataType.UNSIGNED_SHORT;\n        break;\n      case VertexElementFormat.UShort4:\n        size = 4;\n        type = DataType.UNSIGNED_SHORT;\n        break;\n    }\n    return {size, type};\n  }\n}\n\nvar BufferBindFlag;\n(function(BufferBindFlag2) {\n  BufferBindFlag2[BufferBindFlag2[\"VertexBuffer\"] = 0] = \"VertexBuffer\";\n  BufferBindFlag2[BufferBindFlag2[\"IndexBuffer\"] = 1] = \"IndexBuffer\";\n})(BufferBindFlag || (BufferBindFlag = {}));\n\nvar SetDataOptions;\n(function(SetDataOptions2) {\n  SetDataOptions2[SetDataOptions2[\"None\"] = 0] = \"None\";\n  SetDataOptions2[SetDataOptions2[\"Discard\"] = 1] = \"Discard\";\n})(SetDataOptions || (SetDataOptions = {}));\n\nclass Buffer extends RefObject {\n  get engine() {\n    return this._engine;\n  }\n  get type() {\n    return this._type;\n  }\n  get byteLength() {\n    return this._byteLength;\n  }\n  get bufferUsage() {\n    return this._bufferUsage;\n  }\n  constructor(engine, type, byteLengthOrData, bufferUsage = BufferUsage.Static) {\n    super(engine);\n    this._engine = engine;\n    this._type = type;\n    this._bufferUsage = bufferUsage;\n    const hardwareRenderer = engine._hardwareRenderer;\n    const gl = hardwareRenderer.gl;\n    const glBufferUsage = BufferUtil._getGLBufferUsage(gl, bufferUsage);\n    const glBindTarget = type === BufferBindFlag.VertexBuffer ? gl.ARRAY_BUFFER : gl.ELEMENT_ARRAY_BUFFER;\n    this._nativeBuffer = gl.createBuffer();\n    this._hardwareRenderer = hardwareRenderer;\n    this._glBufferUsage = glBufferUsage;\n    this._glBindTarget = glBindTarget;\n    this.bind();\n    if (typeof byteLengthOrData === \"number\") {\n      this._byteLength = byteLengthOrData;\n      gl.bufferData(glBindTarget, byteLengthOrData, glBufferUsage);\n    } else {\n      this._byteLength = byteLengthOrData.byteLength;\n      gl.bufferData(glBindTarget, byteLengthOrData, glBufferUsage);\n    }\n    gl.bindBuffer(glBindTarget, null);\n  }\n  bind() {\n    const gl = this._hardwareRenderer.gl;\n    gl.bindBuffer(this._glBindTarget, this._nativeBuffer);\n  }\n  setData(data, bufferByteOffset = 0, dataOffset = 0, dataLength, options = SetDataOptions.None) {\n    const gl = this._hardwareRenderer.gl;\n    const isWebGL2 = this._hardwareRenderer.isWebGL2;\n    const glBindTarget = this._glBindTarget;\n    this.bind();\n    if (options === SetDataOptions.Discard) {\n      gl.bufferData(glBindTarget, this._byteLength, this._glBufferUsage);\n    }\n    const byteSize = data.BYTES_PER_ELEMENT || 1;\n    const dataByteLength = dataLength ? byteSize * dataLength : data.byteLength;\n    if (dataOffset !== 0 || dataByteLength < data.byteLength) {\n      const isArrayBufferView = data.byteOffset !== void 0;\n      if (isWebGL2 && isArrayBufferView) {\n        gl.bufferSubData(glBindTarget, bufferByteOffset, data, dataOffset, dataByteLength / byteSize);\n      } else {\n        const subData = new Uint8Array(isArrayBufferView ? data.buffer : data, dataOffset * byteSize, dataByteLength);\n        gl.bufferSubData(glBindTarget, bufferByteOffset, subData);\n      }\n    } else {\n      gl.bufferSubData(glBindTarget, bufferByteOffset, data);\n    }\n    gl.bindBuffer(glBindTarget, null);\n  }\n  getData(data, bufferByteOffset = 0, dataOffset = 0, dataLength) {\n    const isWebGL2 = this._hardwareRenderer.isWebGL2;\n    if (isWebGL2) {\n      const gl = this._hardwareRenderer.gl;\n      this.bind();\n      gl.getBufferSubData(this._glBindTarget, bufferByteOffset, data, dataOffset, dataLength);\n    } else {\n      throw \"Buffer is write-only on WebGL1.0 platforms.\";\n    }\n  }\n  _onDestroy() {\n    const gl = this._hardwareRenderer.gl;\n    gl.deleteBuffer(this._nativeBuffer);\n    this._nativeBuffer = null;\n    this._hardwareRenderer = null;\n  }\n  resize(dataLength) {\n    this.bind();\n    const gl = this._hardwareRenderer.gl;\n    gl.bufferData(this._glBindTarget, dataLength, this._glBufferUsage);\n    this._byteLength = dataLength;\n  }\n}\n\nvar PrimitiveTopology;\n(function(PrimitiveTopology2) {\n  PrimitiveTopology2[PrimitiveTopology2[\"Points\"] = 0] = \"Points\";\n  PrimitiveTopology2[PrimitiveTopology2[\"Lines\"] = 1] = \"Lines\";\n  PrimitiveTopology2[PrimitiveTopology2[\"LineLoop\"] = 2] = \"LineLoop\";\n  PrimitiveTopology2[PrimitiveTopology2[\"LineStrip\"] = 3] = \"LineStrip\";\n  PrimitiveTopology2[PrimitiveTopology2[\"Triangles\"] = 4] = \"Triangles\";\n  PrimitiveTopology2[PrimitiveTopology2[\"TriangleStrip\"] = 5] = \"TriangleStrip\";\n  PrimitiveTopology2[PrimitiveTopology2[\"TriangleFan\"] = 6] = \"TriangleFan\";\n})(PrimitiveTopology || (PrimitiveTopology = {}));\n\nclass IndexBufferBinding {\n  get buffer() {\n    return this._buffer;\n  }\n  get format() {\n    return this._format;\n  }\n  constructor(buffer, format) {\n    this._buffer = buffer;\n    this._format = format;\n  }\n}\n\nclass VertexBufferBinding {\n  get buffer() {\n    return this._buffer;\n  }\n  get stride() {\n    return this._stride;\n  }\n  constructor(buffer, stride) {\n    this._buffer = buffer;\n    this._stride = stride;\n  }\n}\n\nclass Primitive extends RefObject {\n  constructor(engine, name) {\n    super(engine);\n    this.instanceCount = 0;\n    this._vertexElementMap = {};\n    this._vertexBufferBindings = [];\n    this._indexBufferBinding = null;\n    this._vertexElements = [];\n    this.targets = [];\n    this.boundingBox = null;\n    this.boundingSphere = null;\n    this.isInFrustum = true;\n    this.name = name;\n    this._platformPrimitive = this._engine._hardwareRenderer.createPlatformPrimitive(this);\n  }\n  get vertexBufferBindings() {\n    return this._vertexBufferBindings;\n  }\n  get vertexElements() {\n    return this._vertexElements;\n  }\n  get indexBufferBinding() {\n    return this._indexBufferBinding;\n  }\n  setVertexBufferBinding(bufferOrBinding, strideOrFirstIndex = 0, firstIndex = 0) {\n    let binding = bufferOrBinding;\n    const isBinding = binding.buffer !== void 0;\n    isBinding || (binding = new VertexBufferBinding(bufferOrBinding, strideOrFirstIndex));\n    const bindings = this._vertexBufferBindings;\n    bindings.length <= firstIndex && (bindings.length = firstIndex + 1);\n    this._setVertexBufferBinding(isBinding ? strideOrFirstIndex : firstIndex, binding);\n  }\n  setVertexBufferBindings(bufferBindings, firstIndex = 0) {\n    const bindings = this._vertexBufferBindings;\n    const multiBindings = bufferBindings;\n    const count = multiBindings.length;\n    const needLength = firstIndex + count;\n    bindings.length < needLength && (bindings.length = needLength);\n    for (let i = 0; i < count; i++) {\n      this._setVertexBufferBinding(firstIndex + i, multiBindings[i]);\n    }\n  }\n  setIndexBufferBinding(bufferOrBinding, format) {\n    let binding = bufferOrBinding;\n    const isBinding = binding.buffer !== void 0;\n    isBinding || (binding = new IndexBufferBinding(bufferOrBinding, format));\n    this._indexBufferBinding = binding;\n    this._glIndexType = BufferUtil._getGLIndexType(binding.format);\n  }\n  setVertexElements(elements) {\n    this._clearVertexElements();\n    for (let i = 0, n = elements.length; i < n; i++) {\n      this._addVertexElement(elements[i]);\n    }\n  }\n  draw(tech, subPrimitive) {\n    this._platformPrimitive.draw(tech, subPrimitive);\n  }\n  _onDestroy() {\n    this._vertexBufferBindings = null;\n    this._indexBufferBinding = null;\n    this._vertexElements = null;\n    this._vertexElementMap = null;\n    this._platformPrimitive.destroy();\n  }\n  _clearVertexElements() {\n    this._vertexElements.length = 0;\n    const vertexElementMap = this._vertexElementMap;\n    for (var k in vertexElementMap) {\n      delete vertexElementMap[k];\n    }\n  }\n  _addVertexElement(element) {\n    this._vertexElementMap[element.semantic] = element;\n    this._vertexElements.push(element);\n  }\n  _setVertexBufferBinding(index, buffer) {\n    const originBufferBinding = this._vertexBufferBindings[index];\n    if (originBufferBinding) {\n      this._removeRefChild(originBufferBinding._buffer);\n    }\n    this._addRefChild(buffer._buffer);\n    this._vertexBufferBindings[index] = buffer;\n  }\n}\n\nclass VertexElement {\n  constructor(semantic, offset, format, bindingIndex, instanceStepRate = 0) {\n    this.normalized = false;\n    this._semantic = semantic;\n    this._offset = offset;\n    this._format = format;\n    this._bindingIndex = bindingIndex;\n    this._glElementInfo = BufferUtil._getElementInfo(this.format);\n    this._instanceStepRate = Math.floor(instanceStepRate);\n  }\n  get semantic() {\n    return this._semantic;\n  }\n  get offset() {\n    return this._offset;\n  }\n  get format() {\n    return this._format;\n  }\n  get bindingIndex() {\n    return this._bindingIndex;\n  }\n  get instanceStepRate() {\n    return this._instanceStepRate;\n  }\n  get elementInfo() {\n    return this._glElementInfo;\n  }\n}\n\nclass SubPrimitive {\n  constructor(start = 0, count = 0, topology = PrimitiveTopology.Triangles) {\n    this.start = start;\n    this.count = count;\n    this.topology = topology;\n  }\n}\n\nvar common2 = \"#define PI 3.14159265359\\n#define LOG2 1.442695\\n\\n#define saturate( a ) clamp( a, 0.0, 1.0 )\\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\n\\n// nosie common\\n#include <noise_common>\\n\";\n\nvar common_vert2 = \"attribute vec3 a_position;\\n\\n#ifdef O3_HAS_UV\\n\\nattribute vec2 a_uv;\\n\\n#endif\\n\\n#ifdef O3_HAS_NORMAL\\n\\nattribute vec3 a_normal;\\n\\n#endif\\n\\n#ifdef O3_HAS_TANGENT\\n\\nattribute vec4 a_tangent;\\n\\n#endif\\n\\n#ifdef O3_HAS_VERTEXCOLOR\\n\\nattribute vec4 a_color;\\n\\n#endif\\n\\n#if defined( O3_HAS_SKIN ) && ( defined( O3_JOINTS_NUM ) || defined( O3_USE_JOINT_TEXTURE ) )\\n    attribute vec4 a_joint;\\n    attribute vec4 a_weight;\\n\\n    #ifdef O3_USE_JOINT_TEXTURE\\n        uniform sampler2D u_jointSampler;\\n        uniform float u_jointCount;\\n\\n        mat4 getJointMatrix(sampler2D smp, float index)\\n        {\\n            float base = index / u_jointCount;\\n            float hf = 0.5 / u_jointCount;\\n            float v = base + hf;\\n\\n            vec4 m0 = texture2D(smp, vec2(0.125, v ));\\n            vec4 m1 = texture2D(smp, vec2(0.375, v ));\\n            vec4 m2 = texture2D(smp, vec2(0.625, v ));\\n            vec4 m3 = texture2D(smp, vec2(0.875, v ));\\n\\n            return mat4(m0, m1, m2, m3);\\n\\n        }\\n\\n    #elif defined( O3_JOINTS_NUM )\\n        uniform mat4 u_jointMatrix[ O3_JOINTS_NUM ];\\n    #endif\\n#endif\\n\\nuniform mat4 u_localMat;\\nuniform mat4 u_modelMat;\\nuniform mat4 u_viewMat;\\nuniform mat4 u_projMat;\\nuniform mat4 u_MVMat;\\nuniform mat4 u_MVPMat;\\nuniform mat3 u_normalMat;\\nuniform vec3 u_cameraPos;\\nuniform float u_time;\\n\";\n\nvar common_frag2 = \"uniform O3_VERTEX_PRECISION mat4 u_localMat;\\nuniform O3_VERTEX_PRECISION mat4 u_modelMat;\\nuniform O3_VERTEX_PRECISION mat4 u_viewMat;\\nuniform O3_VERTEX_PRECISION mat4 u_projMat;\\nuniform O3_VERTEX_PRECISION mat4 u_MVMat;\\nuniform O3_VERTEX_PRECISION mat4 u_MVPMat;\\nuniform O3_VERTEX_PRECISION mat3 u_normalMat;\\nuniform O3_VERTEX_PRECISION vec3 u_cameraPos;\\nuniform O3_VERTEX_PRECISION float u_time;\\n\";\n\nvar color_share2 = \"#ifdef O3_HAS_VERTEXCOLOR\\n\\nvarying vec4 v_color;\\n\\n#endif\\n\";\n\nvar normal_share2 = \"#ifdef O3_HAS_NORMAL\\n\\n    #if defined( O3_HAS_TANGENT ) && defined( O3_HAS_NORMALMAP )\\n\\n    varying mat3 v_TBN;\\n\\n    #else\\n\\n    varying vec3 v_normal;\\n\\n    #endif\\n\\n#endif\\n\";\n\nvar uv_share2 = \"varying vec2 v_uv;\\n\";\n\nvar worldpos_share2 = \"#if defined( O3_NEED_WORLDPOS ) || defined( O3_HAS_ENVMAP ) || defined( O3_HAS_LIGHTMAP ) || defined(O3_CLIPPLANE_NUM)\\n\\nvarying vec3 v_pos;\\n\\n#endif\\n\";\n\nvar shadow_share2 = \"#ifdef O3_GENERATE_SHADOW_MAP\\n\\nuniform mat4 u_viewMatFromLight;\\nuniform mat4 u_projMatFromLight;\\n\\n#endif\\n\\n#ifdef O3_SHADOW_MAP_COUNT\\n\\nuniform mat4 u_viewMatFromLight[O3_SHADOW_MAP_COUNT];\\nuniform mat4 u_projMatFromLight[O3_SHADOW_MAP_COUNT];\\nvarying vec4 v_PositionFromLight[O3_SHADOW_MAP_COUNT];\\n\\n#endif\\n\";\n\nvar fog_share2 = \"#ifdef O3_HAS_FOG\\n\\nvarying vec3 v_fogDepth;\\n\\nuniform O3_VERTEX_PRECISION vec3 u_fogColor;\\n\\n    #ifdef O3_FOG_EXP2\\n\\n        uniform O3_VERTEX_PRECISION float u_fogDensity;\\n\\n    #else\\n\\n        uniform O3_VERTEX_PRECISION float u_fogNear;\\n        uniform O3_VERTEX_PRECISION float u_fogFar;\\n\\n    #endif\\n\\n#endif\\n\";\n\nvar begin_normal_vert2 = \"    #ifdef O3_HAS_NORMAL\\n\\n    vec3 normal = vec3( a_normal );\\n\\n        #if defined( O3_HAS_TANGENT ) && defined( O3_HAS_NORMALMAP )\\n\\n        vec4 tangent = vec4( a_tangent );\\n\\n        #endif\\n\\n    #endif\\n\";\n\nvar begin_position_vert2 = \"    vec4 position = vec4( a_position , 1.0 );\\n\";\n\nvar morph_target_vert2 = \"#ifdef O3_HAS_MORPH\\n\\n    uniform float u_morphWeights[ O3_MORPH_NUM ];\\n\\n    #ifdef O3_MORPH_POSITION\\n\\n    attribute vec3 a_position0;\\n\\n    #endif\\n\\n    #ifdef O3_MORPH_NORMAL\\n\\n    attribute vec3 a_normal0;\\n\\n    #endif\\n\\n    #ifdef O3_MORPH_TANGENT\\n\\n    attribute vec3 a_tangent0;\\n\\n    #endif\\n\\n    #if O3_MORPH_NUM > 1\\n\\n        #ifdef O3_MORPH_POSITION\\n\\n        attribute vec3 a_position1;\\n\\n        #endif\\n\\n        #ifdef O3_MORPH_NORMAL\\n\\n        attribute vec3 a_normal1;\\n\\n        #endif\\n\\n        #ifdef O3_MORPH_TANGENT\\n\\n        attribute vec3 a_tangent1;\\n\\n        #endif\\n\\n    #endif\\n\\n    #if O3_MORPH_NUM > 2\\n\\n        #ifdef O3_MORPH_POSITION\\n\\n        attribute vec3 a_position2;\\n\\n        #endif\\n\\n        #ifdef O3_MORPH_NORMAL\\n\\n        attribute vec3 a_normal2;\\n\\n        #endif\\n\\n        #ifdef O3_MORPH_TANGENT\\n\\n        attribute vec3 a_tangent2;\\n\\n        #endif\\n\\n    #endif\\n\\n    #if O3_MORPH_NUM > 3\\n\\n        #ifdef O3_MORPH_POSITION\\n\\n        attribute vec3 a_position3;\\n\\n        #endif\\n\\n        #ifdef O3_MORPH_NORMAL\\n\\n        attribute vec3 a_normal3;\\n\\n        #endif\\n\\n        #ifdef O3_MORPH_TANGENT\\n\\n        attribute vec3 a_tangent3;\\n\\n        #endif\\n\\n    #endif\\n\\n    #if O3_MORPH_NUM > 4\\n\\n        #ifdef O3_MORPH_POSITION\\n\\n        attribute vec3 a_position4;\\n\\n        #endif\\n\\n        #ifdef O3_MORPH_NORMAL\\n\\n        attribute vec3 a_normal4;\\n\\n        #endif\\n\\n        #ifdef O3_MORPH_TANGENT\\n\\n        attribute vec3 a_tangent4;\\n\\n        #endif\\n\\n    #endif\\n\\n    #if O3_MORPH_NUM > 5\\n\\n        #ifdef O3_MORPH_POSITION\\n\\n        attribute vec3 a_position5;\\n\\n        #endif\\n\\n        #ifdef O3_MORPH_NORMAL\\n\\n        attribute vec3 a_normal5;\\n\\n        #endif\\n\\n        #ifdef O3_MORPH_TANGENT\\n\\n        attribute vec3 a_tangent5;\\n\\n        #endif\\n\\n    #endif\\n\\n    #if O3_MORPH_NUM > 6\\n\\n        #ifdef O3_MORPH_POSITION\\n\\n        attribute vec3 a_position6;\\n\\n        #endif\\n\\n        #ifdef O3_MORPH_NORMAL\\n\\n        attribute vec3 a_normal6;\\n\\n        #endif\\n\\n        #ifdef O3_MORPH_TANGENT\\n\\n        attribute vec3 a_tangent6;\\n\\n        #endif\\n\\n    #endif\\n\\n    #if O3_MORPH_NUM > 7\\n\\n        #ifdef O3_MORPH_POSITION\\n\\n        attribute vec3 a_position7;\\n\\n        #endif\\n\\n        #ifdef O3_MORPH_NORMAL\\n\\n        attribute vec3 a_normal7;\\n\\n        #endif\\n\\n        #ifdef O3_MORPH_TANGENT\\n\\n        attribute vec3 a_tangent7;\\n\\n        #endif\\n\\n    #endif\\n\\n#endif\\n\";\n\nvar position_vert2 = \"    #ifndef O3_GENERATE_SHADOW_MAP\\n\\n    gl_Position = u_MVPMat * position;\\n\\n    #endif\\n\";\n\nvar color_vert2 = \"    #ifdef O3_HAS_VERTEXCOLOR\\n\\n    v_color = a_color;\\n\\n    #endif\\n\";\n\nvar normal_vert2 = \"    #ifdef O3_HAS_NORMAL\\n\\n        #if defined( O3_HAS_TANGENT ) && defined( O3_HAS_NORMALMAP )\\n\\n        vec3 normalW = normalize( u_normalMat * normal.xyz );\\n        vec3 tangentW = normalize( u_normalMat * tangent.xyz );\\n        vec3 bitangentW = cross( normalW, tangentW ) * tangent.w;\\n        v_TBN = mat3( tangentW, bitangentW, normalW );\\n\\n        #else\\n\\n        v_normal = normalize( u_normalMat * normal );\\n\\n        #endif\\n\\n    #endif\\n\";\n\nvar skinning_vert2 = \"#if defined( O3_HAS_SKIN ) && ( defined( O3_JOINTS_NUM ) || defined( O3_USE_JOINT_TEXTURE ) )\\n\\n        #ifdef O3_USE_JOINT_TEXTURE\\n            mat4 skinMatrix =\\n                a_weight.x * getJointMatrix(u_jointSampler, a_joint.x ) +\\n                a_weight.y * getJointMatrix(u_jointSampler, a_joint.y ) +\\n                a_weight.z * getJointMatrix(u_jointSampler, a_joint.z ) +\\n                a_weight.w * getJointMatrix(u_jointSampler, a_joint.w );\\n\\n        #elif defined( O3_JOINTS_NUM )\\n            mat4 skinMatrix =\\n                a_weight.x * u_jointMatrix[ int( a_joint.x ) ] +\\n                a_weight.y * u_jointMatrix[ int( a_joint.y ) ] +\\n                a_weight.z * u_jointMatrix[ int( a_joint.z ) ] +\\n                a_weight.w * u_jointMatrix[ int( a_joint.w ) ];\\n        #endif\\n\\n        position = skinMatrix * position;\\n\\n        #ifdef O3_HAS_NORMAL\\n            normal = vec4( skinMatrix * vec4( normal, 0.0 ) ).xyz;\\n            #if defined( O3_HAS_TANGENT ) && defined( O3_HAS_NORMALMAP )\\n                tangent.xyz = vec4( skinMatrix * vec4( tangent.xyz, 0.0 ) ).xyz;\\n            #endif\\n\\n        #endif\\n\\n#endif\\n\";\n\nvar uv_vert2 = \"    #ifdef O3_HAS_UV\\n\\n    v_uv = a_uv;\\n\\n    #else\\n\\n    // may need this calculate normal\\n    v_uv = vec2( 0., 0. );\\n\\n    #endif\\n\";\n\nvar worldpos_vert2 = \"    #if defined( O3_NEED_WORLDPOS ) || defined( O3_HAS_ENVMAP ) || defined( O3_HAS_LIGHTMAP ) || defined(O3_CLIPPLANE_NUM)\\n\\n    vec4 temp_pos = u_modelMat * position;\\n    v_pos = temp_pos.xyz / temp_pos.w;\\n\\n    #endif\\n\";\n\nvar shadow_vert2 = \"    #ifdef O3_GENERATE_SHADOW_MAP\\n\\n    gl_Position = u_projMatFromLight * u_viewMatFromLight * u_modelMat * position;\\n\\n    #endif\\n\\n    #ifdef O3_SHADOW_MAP_COUNT\\n\\n    for (int i = 0; i < O3_SHADOW_MAP_COUNT; i++) {\\n\\n        v_PositionFromLight[i] = u_projMatFromLight[i] * u_viewMatFromLight[i] * u_modelMat * vec4( a_position, 1.0 );\\n\\n    }\\n\\n    #endif\\n\";\n\nvar morph_vert2 = \"    #ifdef O3_HAS_MORPH\\n\\n        #if defined( O3_MORPH_POSITION )\\n\\n        position.xyz += u_morphWeights[ 0 ] * a_position0;\\n\\n            #if O3_MORPH_NUM > 1\\n\\n            position.xyz += u_morphWeights[ 1 ] * a_position1;\\n\\n            #endif\\n\\n            #if O3_MORPH_NUM > 2\\n\\n            position.xyz += u_morphWeights[ 2 ] * a_position2;\\n\\n            #endif\\n\\n            #if O3_MORPH_NUM > 3\\n\\n            position.xyz += u_morphWeights[ 3 ] * a_position3;\\n\\n            #endif\\n\\n            #if O3_MORPH_NUM > 4\\n\\n            position.xyz += u_morphWeights[ 4 ] * a_position4;\\n\\n            #endif\\n\\n            #if O3_MORPH_NUM > 5\\n\\n            position.xyz += u_morphWeights[ 5 ] * a_position5;\\n\\n            #endif\\n\\n            #if O3_MORPH_NUM > 6\\n\\n            position.xyz += u_morphWeights[ 6 ] * a_position6;\\n\\n            #endif\\n\\n            #if O3_MORPH_NUM > 7\\n\\n            position.xyz += u_morphWeights[ 7 ] * a_position7;\\n\\n            #endif\\n\\n        #endif\\n\\n        #if defined( O3_HAS_NORMAL ) && defined( O3_MORPH_NORMAL )\\n\\n        normal.xyz += u_morphWeights[ 0 ] * a_normal0;\\n\\n            #if O3_MORPH_NUM > 1\\n\\n            normal.xyz += u_morphWeights[ 1 ] * a_normal1;\\n\\n            #endif\\n\\n            #if O3_MORPH_NUM > 2\\n\\n            normal.xyz += u_morphWeights[ 2 ] * a_normal2;\\n\\n            #endif\\n\\n            #if O3_MORPH_NUM > 3\\n\\n            normal.xyz += u_morphWeights[ 3 ] * a_normal3;\\n\\n            #endif\\n\\n            #if O3_MORPH_NUM > 4\\n\\n            normal.xyz += u_morphWeights[ 4 ] * a_normal4;\\n\\n            #endif\\n\\n            #if O3_MORPH_NUM > 5\\n\\n            normal.xyz += u_morphWeights[ 5 ] * a_normal5;\\n\\n            #endif\\n\\n            #if O3_MORPH_NUM > 6\\n\\n            normal.xyz += u_morphWeights[ 6 ] * a_normal6;\\n\\n            #endif\\n\\n            #if O3_MORPH_NUM > 7\\n\\n            normal.xyz += u_morphWeights[ 7 ] * a_normal7;\\n\\n            #endif\\n\\n        #endif\\n\\n        #if defined( O3_HAS_TANGENT ) && defined( O3_MORPH_TANGENT ) && defined( O3_HAS_NORMALMAP )\\n\\n        tangent.xyz += u_morphWeights[ 0 ] * a_tangent0;\\n\\n            #if O3_MORPH_NUM > 1\\n\\n            tangent.xyz += u_morphWeights[ 1 ] * a_tangent1;\\n\\n            #endif\\n\\n            #if O3_MORPH_NUM > 2\\n\\n            tangent.xyz += u_morphWeights[ 2 ] * a_tangent2;\\n\\n            #endif\\n\\n            #if O3_MORPH_NUM > 3\\n\\n            tangent.xyz += u_morphWeights[ 3 ] * a_tangent3;\\n\\n            #endif\\n\\n            #if O3_MORPH_NUM > 4\\n\\n            tangent.xyz += u_morphWeights[ 4 ] * a_tangent4;\\n\\n            #endif\\n\\n            #if O3_MORPH_NUM > 5\\n\\n            tangent.xyz += u_morphWeights[ 5 ] * a_tangent5;\\n\\n            #endif\\n\\n            #if O3_MORPH_NUM > 6\\n\\n            tangent.xyz += u_morphWeights[ 6 ] * a_tangent6;\\n\\n            #endif\\n\\n            #if O3_MORPH_NUM > 7\\n\\n            tangent.xyz += u_morphWeights[ 7 ] * a_tangent7;\\n\\n            #endif\\n\\n        #endif\\n\\n    #endif\\n\";\n\nvar fog_vert2 = \"    #ifdef O3_HAS_FOG\\n\\n    v_fogDepth = ( u_MVMat * position ).xyz;\\n\\n    #endif\\n\";\n\nvar ambient_light_frag2 = \"#ifdef O3_HAS_AMBIENT_LIGHT\\n\\nstruct AmbientLight {\\n    vec3 color;\\n    vec3 lightColor;\\n    float intensity;\\n};\\nuniform AmbientLight u_ambientLight;\\n\\n#endif\\n\";\n\nvar direct_light_frag2 = \"#ifdef O3_DIRECT_LIGHT_COUNT\\n\\nstruct DirectLight {\\n    vec3 color;\\n    vec3 lightColor;\\n    float intensity;\\n    vec3 direction;\\n};\\nuniform DirectLight u_directLights[ O3_DIRECT_LIGHT_COUNT ];\\n\\n#endif\\n\";\n\nvar point_light_frag2 = \"#ifdef O3_POINT_LIGHT_COUNT\\n\\nstruct PointLight {\\n    vec3 color;\\n    vec3 lightColor;\\n    vec3 position;\\n    float intensity;\\n    float distance;\\n    float decay;\\n};\\nuniform PointLight u_pointLights[ O3_POINT_LIGHT_COUNT ];\\n\\n#endif\\n\";\n\nvar spot_light_frag2 = \"#ifdef O3_SPOT_LIGHT_COUNT\\n\\nstruct SpotLight {\\n    vec3 color;\\n    vec3 lightColor;\\n    vec3 position;\\n    vec3 direction;\\n    float intensity;\\n    float distance;\\n    float decay;\\n    float angle;\\n    float penumbra;\\n    float coneCos;\\n    float penumbraCos;\\n};\\nuniform SpotLight u_spotLights[ O3_SPOT_LIGHT_COUNT ];\\n\\n#endif\\n\";\n\nvar mobile_material_frag2 = \"uniform float u_shininess;\\n\\n#ifdef O3_EMISSION_TEXTURE\\n\\nuniform sampler2D u_emission;\\n\\n#else\\n\\nuniform vec4 u_emission;\\n\\n#endif\\n\\n#ifdef O3_AMBIENT_TEXTURE\\n\\nuniform sampler2D u_ambient;\\n\\n#else\\n\\nuniform vec4 u_ambient;\\n\\n#endif\\n\\n#ifdef O3_DIFFUSE_TEXTURE\\n\\nuniform sampler2D u_diffuse;\\n\\n#else\\n\\nuniform vec4 u_diffuse;\\n\\n#endif\\n\\n#ifdef O3_SPECULAR_TEXTURE\\n\\nuniform sampler2D u_specular;\\n\\n#else\\n\\nuniform vec4 u_specular;\\n\\n#endif\\n\";\n\nvar fog_frag2 = \"    #ifdef O3_HAS_FOG\\n\\n    float fogDepth = length( v_fogDepth );\\n\\n        #ifdef O3_FOG_EXP2\\n\\n            float fogFactor = whiteCompliment( exp2( - u_fogDensity * u_fogDensity * fogDepth * fogDepth * LOG2 ) );\\n\\n        #else\\n\\n            float fogFactor = smoothstep( u_fogNear, u_fogFar, fogDepth );\\n\\n        #endif\\n\\n\\tgl_FragColor.rgb = mix( gl_FragColor.rgb, u_fogColor, fogFactor );\\n\\n    #endif\\n\";\n\nvar begin_mobile_frag2 = \"    #ifdef O3_EMISSION_TEXTURE\\n\\n    vec4 emission = texture2D(u_emission, v_uv);\\n\\n    #else\\n\\n    vec4 emission = u_emission;\\n\\n    #endif\\n\\n    vec4 ambient = vec4(0);\\n    #ifdef O3_HAS_AMBIENT_LIGHT\\n        #ifdef O3_AMBIENT_TEXTURE\\n            ambient = texture2D(u_ambient, v_uv) * vec4(u_ambientLight.lightColor, 1.0);\\n         #else\\n            ambient = u_ambient * vec4(u_ambientLight.lightColor, 1.0);\\n         #endif\\n    #endif\\n\\n    #ifdef O3_DIFFUSE_TEXTURE\\n\\n    vec4 diffuse = texture2D(u_diffuse, v_uv);\\n\\n    #else\\n\\n    vec4 diffuse = u_diffuse;\\n\\n    #endif\\n\\n    #ifdef O3_SPECULAR_TEXTURE\\n\\n    vec4 specular = texture2D(u_specular, v_uv);\\n\\n    #else\\n\\n    vec4 specular = u_specular;\\n\\n    #endif\\n\";\n\nvar begin_normal_frag2 = \"    #ifdef O3_HAS_NORMAL\\n\\n        #if defined( O3_HAS_TANGENT ) && defined( O3_HAS_NORMALMAP )\\n\\n        vec3 N = normalize( v_TBN[ 2 ] );\\n\\n        #else\\n\\n        vec3 N = normalize( v_normal );\\n\\n        #endif\\n\\n    #endif\\n\";\n\nvar begin_viewdir_frag2 = \"    #if defined( O3_NEED_WORLDPOS ) || defined( O3_HAS_ENVMAP ) || defined( O3_HAS_LIGHTMAP )\\n\\n    vec3 V =  normalize( u_cameraPos - v_pos );\\n\\n    #endif\\n\";\n\nvar mobile_blinnphong_frag2 = \"    #ifdef O3_HAS_NORMAL\\n         N *= float( gl_FrontFacing ) * 2.0 - 1.0;\\n    #else\\n         vec3 N = vec3(0, 0, 1);\\n    #endif\\n\\n\\n    vec3 lightDiffuse = vec3( 0.0, 0.0, 0.0 );\\n    vec3 lightSpecular = vec3( 0.0, 0.0, 0.0 );\\n\\n    #ifdef O3_DIRECT_LIGHT_COUNT\\n\\n    for( int i = 0; i < O3_DIRECT_LIGHT_COUNT; i++ ) {\\n        DirectLight lgt = u_directLights[ i ];\\n\\n        float d = max(dot(N, -lgt.direction), 0.0)*lgt.intensity;\\n        lightDiffuse += lgt.color*d;\\n\\n        vec3 halfDir = normalize( V - lgt.direction );\\n        float s = pow( clamp( dot( N, halfDir ), 0.0, 1.0 ), u_shininess ) * lgt.intensity;\\n        lightSpecular += lgt.color * s;\\n    }\\n\\n    #endif\\n\\n    #ifdef O3_POINT_LIGHT_COUNT\\n\\n    for( int i = 0; i < O3_POINT_LIGHT_COUNT; i++ ) {\\n        PointLight lgt = u_pointLights[ i ];\\n        vec3 direction = v_pos - lgt.position;\\n        float dist = length( direction );\\n        direction /= dist;\\n        float decay = pow( max( 0.0, 1.0-dist/lgt.distance ), 2.0 );\\n\\n        float d =  max( dot( N, -direction ), 0.0 )*lgt.intensity*decay;\\n        lightDiffuse += lgt.color*d;\\n\\n        vec3 halfDir = normalize( V - direction );\\n        float s = pow( clamp( dot( N, halfDir ), 0.0, 1.0 ), u_shininess ) * lgt.intensity * decay;\\n        lightSpecular += lgt.color * s;\\n\\n    }\\n\\n    #endif\\n\\n    #ifdef O3_SPOT_LIGHT_COUNT\\n\\n    for( int i = 0; i < O3_SPOT_LIGHT_COUNT; i++) {\\n        SpotLight lgt = u_spotLights[ i ];\\n        vec3 direction = v_pos - lgt.position;\\n        float angle = acos( dot( normalize( direction ), normalize( lgt.direction ) ) );\\n        float dist = length( direction );\\n        direction /= dist;\\n        float decay = pow( max( 0.0, 1.0 - dist / lgt.distance ), 2.0 );\\n\\n        float hasLight = step( angle, lgt.angle );\\n        float hasPenumbra = step( lgt.angle, angle ) * step( angle, lgt.angle * ( 1.0 + lgt.penumbra ) );\\n        float penumbra = hasPenumbra * ( 1.0 - ( angle - lgt.angle ) / ( lgt.angle * lgt.penumbra ) );\\n        float d = max( dot( N, -direction ), 0.0 ) * lgt.intensity * decay * ( penumbra + hasLight );\\n        lightDiffuse += lgt.color * d;\\n\\n        vec3 halfDir = normalize( V - direction );\\n        float s = pow( clamp( dot( N, halfDir ), 0.0, 1.0 ), u_shininess ) * lgt.intensity * decay * ( penumbra + hasLight );\\n        lightSpecular += lgt.color * s;\\n\\n    }\\n\\n    #endif\\n\\n    diffuse *= vec4( lightDiffuse, 1.0 );\\n    specular *= vec4( lightSpecular, 1.0 );\\n\";\n\nvar mobile_lambert_frag2 = \"    vec3 totalLight = vec3(0.0, 0.0, 0.0);\\n    #ifdef O3_DIRECT_LIGHT_COUNT\\n    for( int i = 0; i < O3_DIRECT_LIGHT_COUNT; i++ ){\\n        vec3 lightColor = u_directLights[ i ].color * u_directLights[ i ].intensity;\\n        lightColor *= max( dot( N, -u_directLights[ i ].direction ), 0.0 );\\n\\n        totalLight += lightColor;\\n    }\\n    #endif\\n    diffuse *= vec4( totalLight, 1.0 );\\n\";\n\nvar noise_common2 = \"// Modulo 289 without a division (only multiplications)\\nvec4 mod289( vec4 x ) {\\n\\n    return x - floor( x * ( 1.0 / 289.0 ) ) * 289.0;\\n\\n}\\n\\nvec3 mod289( vec3 x ) {\\n\\n    return x - floor( x * ( 1.0 / 289.0 ) ) * 289.0;\\n\\n}\\n\\nvec2 mod289( vec2 x ) {\\n\\n    return x - floor( x * ( 1.0 / 289.0 ) ) * 289.0;\\n\\n}\\n\\nfloat mod289( float x ) {\\n\\n    return x - floor( x * ( 1.0 / 289.0 ) ) * 289.0;\\n\\n}\\n\\n// Modulo 7 without a division\\nvec4 mod7( vec4 x ) {\\n\\n    return x - floor( x * ( 1.0 / 7.0 ) ) * 7.0;\\n\\n}\\n\\nvec3 mod7( vec3 x ) {\\n\\n    return x - floor( x * ( 1.0 / 7.0 ) ) * 7.0;\\n\\n}\\n\\n// Permutation polynomial: (34x^2 + x) mod 289\\nvec4 permute( vec4 x ) {\\n\\n    return mod289( ( 34.0 * x + 1.0 ) * x);\\n\\n}\\n\\nvec3 permute( vec3 x ) {\\n\\n    return mod289( ( 34.0 * x + 1.0 ) * x );\\n\\n}\\n\\nfloat permute( float x ) {\\n\\n  return mod289( ( ( x * 34.0 ) + 1.0 ) * x );\\n\\n}\\n\\nvec4 taylorInvSqrt( vec4 r ) {\\n\\n    return 1.79284291400159 - 0.85373472095314 * r;\\n\\n}\\n\\nfloat taylorInvSqrt( float r ) {\\n\\n    return 1.79284291400159 - 0.85373472095314 * r;\\n\\n}\\n\\nvec4 fade( vec4 t ) {\\n\\n    return t * t * t * ( t * ( t * 6.0 - 15.0 ) + 10.0 );\\n\\n}\\n\\nvec3 fade( vec3 t ) {\\n\\n    return t * t * t * ( t * ( t * 6.0 - 15.0 ) + 10.0 );\\n\\n}\\n\\nvec2 fade( vec2 t ) {\\n\\n    return t * t * t * ( t * ( t * 6.0 - 15.0 ) + 10.0 );\\n\\n}\\n\\n#define K 0.142857142857 // 1/7\\n#define Ko 0.428571428571 // 1/2-K/2\\n#define K2 0.020408163265306 // 1/(7*7)\\n#define Kd2 0.0714285714285 // K/2\\n#define Kz 0.166666666667 // 1/6\\n#define Kzo 0.416666666667 // 1/2-1/6*2\\n#define jitter 1.0 // smaller jitter gives more regular pattern\\n#define jitter1 0.8 // smaller jitter gives less errors in F1 F2\\n\";\n\nvar noise_cellular_2D2 = \"\\n// Cellular noise (\\\"Worley noise\\\") in 2D in GLSL.\\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\\n// This code is released under the conditions of the MIT license.\\n// See LICENSE file for details.\\n// https://github.com/stegu/webgl-noise\\n\\n// Cellular noise, returning F1 and F2 in a vec2.\\n// Standard 3x3 search window for good F1 and F2 values\\nvec2 cellular( vec2 P ) {\\n\\n\\tvec2 Pi = mod289( floor( P ) );\\n \\tvec2 Pf = fract( P );\\n\\tvec3 oi = vec3( -1.0, 0.0, 1.0);\\n\\tvec3 of = vec3( -0.5, 0.5, 1.5);\\n\\tvec3 px = permute( Pi.x + oi );\\n\\tvec3 p = permute( px.x + Pi.y + oi ); // p11, p12, p13\\n\\tvec3 ox = fract( p * K ) - Ko;\\n\\tvec3 oy = mod7( floor( p * K ) ) * K - Ko;\\n\\tvec3 dx = Pf.x + 0.5 + jitter * ox;\\n\\tvec3 dy = Pf.y - of + jitter * oy;\\n\\tvec3 d1 = dx * dx + dy * dy; // d11, d12 and d13, squared\\n\\tp = permute( px.y + Pi.y + oi ); // p21, p22, p23\\n\\tox = fract( p * K ) - Ko;\\n\\toy = mod7( floor( p * K ) ) * K - Ko;\\n\\tdx = Pf.x - 0.5 + jitter * ox;\\n\\tdy = Pf.y - of + jitter * oy;\\n\\tvec3 d2 = dx * dx + dy * dy; // d21, d22 and d23, squared\\n\\tp = permute( px.z + Pi.y + oi ); // p31, p32, p33\\n\\tox = fract( p * K ) - Ko;\\n\\toy = mod7( floor( p * K ) ) * K - Ko;\\n\\tdx = Pf.x - 1.5 + jitter * ox;\\n\\tdy = Pf.y - of + jitter * oy;\\n\\tvec3 d3 = dx * dx + dy * dy; // d31, d32 and d33, squared\\n\\t// Sort out the two smallest distances (F1, F2)\\n\\tvec3 d1a = min( d1, d2 );\\n\\td2 = max( d1, d2 ); // Swap to keep candidates for F2\\n\\td2 = min( d2, d3 ); // neither F1 nor F2 are now in d3\\n\\td1 = min( d1a, d2 ); // F1 is now in d1\\n\\td2 = max( d1a, d2 ); // Swap to keep candidates for F2\\n\\td1.xy = ( d1.x < d1.y ) ? d1.xy : d1.yx; // Swap if smaller\\n\\td1.xz = ( d1.x < d1.z ) ? d1.xz : d1.zx; // F1 is in d1.x\\n\\td1.yz = min( d1.yz, d2.yz ); // F2 is now not in d2.yz\\n\\td1.y = min( d1.y, d1.z ); // nor in  d1.z\\n\\td1.y = min( d1.y, d2.x ); // F2 is in d1.y, we're done.\\n\\treturn sqrt( d1.xy );\\n\\n}\\n\";\n\nvar noise_cellular_2x22 = \"\\n// Cellular noise (\\\"Worley noise\\\") in 2D in GLSL.\\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\\n// This code is released under the conditions of the MIT license.\\n// See LICENSE file for details.\\n// https://github.com/stegu/webgl-noise\\n\\n// Cellular noise, returning F1 and F2 in a vec2.\\n// Speeded up by using 2x2 search window instead of 3x3,\\n// at the expense of some strong pattern artifacts.\\n// F2 is often wrong and has sharp discontinuities.\\n// If you need a smooth F2, use the slower 3x3 version.\\n// F1 is sometimes wrong, too, but OK for most purposes.\\nvec2 cellular2x2( vec2 P ) {\\n\\n\\tvec2 Pi = mod289( floor( P ) );\\n \\tvec2 Pf = fract( P );\\n\\tvec4 Pfx = Pf.x + vec4( -0.5, -1.5, -0.5, -1.5 );\\n\\tvec4 Pfy = Pf.y + vec4( -0.5, -0.5, -1.5, -1.5 );\\n\\tvec4 p = permute( Pi.x + vec4( 0.0, 1.0, 0.0, 1.0 ) );\\n\\tp = permute( p + Pi.y + vec4( 0.0, 0.0, 1.0, 1.0 ) );\\n\\tvec4 ox = mod7( p ) * K + Kd2;\\n\\tvec4 oy = mod7( floor( p * K ) ) * K + Kd2;\\n\\tvec4 dx = Pfx + jitter1 * ox;\\n\\tvec4 dy = Pfy + jitter1 * oy;\\n\\tvec4 d = dx * dx + dy * dy; // d11, d12, d21 and d22, squared\\n\\n\\t// Do it right and find both F1 and F2\\n\\td.xy = ( d.x < d.y ) ? d.xy : d.yx; // Swap if smaller\\n\\td.xz = ( d.x < d.z ) ? d.xz : d.zx;\\n\\td.xw = ( d.x < d.w ) ? d.xw : d.wx;\\n\\td.y = min( d.y, d.z );\\n\\td.y = min( d.y, d.w );\\n\\treturn sqrt( d.xy );\\n\\n}\\n\";\n\nvar noise_cellular_2x2x22 = \"\\n// Cellular noise (\\\"Worley noise\\\") in 3D in GLSL.\\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\\n// This code is released under the conditions of the MIT license.\\n// See LICENSE file for details.\\n// https://github.com/stegu/webgl-noise\\n\\n// Cellular noise, returning F1 and F2 in a vec2.\\n// Speeded up by using 2x2x2 search window instead of 3x3x3,\\n// at the expense of some pattern artifacts.\\n// F2 is often wrong and has sharp discontinuities.\\n// If you need a good F2, use the slower 3x3x3 version.\\nvec2 cellular2x2x2(vec3 P) {\\n\\n\\tvec3 Pi = mod289( floor( P ) );\\n \\tvec3 Pf = fract( P );\\n\\tvec4 Pfx = Pf.x + vec4( 0.0, -1.0, 0.0, -1.0 );\\n\\tvec4 Pfy = Pf.y + vec4( 0.0, 0.0, -1.0, -1.0 );\\n\\tvec4 p = permute( Pi.x + vec4( 0.0, 1.0, 0.0, 1.0 ) );\\n\\tp = permute( p + Pi.y + vec4( 0.0, 0.0, 1.0, 1.0 ) );\\n\\tvec4 p1 = permute( p + Pi.z ); // z+0\\n\\tvec4 p2 = permute( p + Pi.z + vec4( 1.0 ) ); // z+1\\n\\tvec4 ox1 = fract( p1 * K ) - Ko;\\n\\tvec4 oy1 = mod7( floor( p1 * K ) ) * K - Ko;\\n\\tvec4 oz1 = floor( p1 * K2 ) * Kz - Kzo; // p1 < 289 guaranteed\\n\\tvec4 ox2 = fract( p2 * K ) - Ko;\\n\\tvec4 oy2 = mod7( floor( p2 * K ) ) * K - Ko;\\n\\tvec4 oz2 = floor( p2 * K2 ) * Kz - Kzo;\\n\\tvec4 dx1 = Pfx + jitter1 * ox1;\\n\\tvec4 dy1 = Pfy + jitter1 * oy1;\\n\\tvec4 dz1 = Pf.z + jitter1 * oz1;\\n\\tvec4 dx2 = Pfx + jitter1 * ox2;\\n\\tvec4 dy2 = Pfy + jitter1 * oy2;\\n\\tvec4 dz2 = Pf.z - 1.0 + jitter1 * oz2;\\n\\tvec4 d1 = dx1 * dx1 + dy1 * dy1 + dz1 * dz1; // z+0\\n\\tvec4 d2 = dx2 * dx2 + dy2 * dy2 + dz2 * dz2; // z+1\\n\\n\\t// Do it right and sort out both F1 and F2\\n\\tvec4 d = min( d1, d2 ); // F1 is now in d\\n\\td2 = max( d1, d2 ); // Make sure we keep all candidates for F2\\n\\td.xy = ( d.x < d.y ) ? d.xy : d.yx; // Swap smallest to d.x\\n\\td.xz = ( d.x < d.z ) ? d.xz : d.zx;\\n\\td.xw = ( d.x < d.w ) ? d.xw : d.wx; // F1 is now in d.x\\n\\td.yzw = min( d.yzw, d2.yzw ); // F2 now not in d2.yzw\\n\\td.y = min( d.y, d.z ); // nor in d.z\\n\\td.y = min( d.y, d.w ); // nor in d.w\\n\\td.y = min( d.y, d2.x ); // F2 is now in d.y\\n\\treturn sqrt( d.xy ); // F1 and F2\\n\\n}\\n\";\n\nvar noise_cellular_3D2 = \"\\n// Cellular noise (\\\"Worley noise\\\") in 3D in GLSL.\\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\\n// This code is released under the conditions of the MIT license.\\n// See LICENSE file for details.\\n// https://github.com/stegu/webgl-noise\\n\\n// Cellular noise, returning F1 and F2 in a vec2.\\n// 3x3x3 search region for good F2 everywhere, but a lot\\n// slower than the 2x2x2 version.\\n// The code below is a bit scary even to its author,\\n// but it has at least half decent performance on a\\n// modern GPU. In any case, it beats any software\\n// implementation of Worley noise hands down.\\n\\nvec2 cellular( vec3 P ) {\\n\\n\\tvec3 Pi = mod289( floor( P ) );\\n \\tvec3 Pf = fract( P ) - 0.5;\\n\\n\\tvec3 Pfx = Pf.x + vec3( 1.0, 0.0, -1.0 );\\n\\tvec3 Pfy = Pf.y + vec3( 1.0, 0.0, -1.0 );\\n\\tvec3 Pfz = Pf.z + vec3( 1.0, 0.0, -1.0 );\\n\\n\\tvec3 p = permute( Pi.x + vec3( -1.0, 0.0, 1.0 ) );\\n\\tvec3 p1 = permute( p + Pi.y - 1.0 );\\n\\tvec3 p2 = permute( p + Pi.y );\\n\\tvec3 p3 = permute( p + Pi.y + 1.0 );\\n\\n\\tvec3 p11 = permute( p1 + Pi.z - 1.0 );\\n\\tvec3 p12 = permute( p1 + Pi.z );\\n\\tvec3 p13 = permute( p1 + Pi.z + 1.0 );\\n\\n\\tvec3 p21 = permute( p2 + Pi.z - 1.0 );\\n\\tvec3 p22 = permute( p2 + Pi.z );\\n\\tvec3 p23 = permute( p2 + Pi.z + 1.0 );\\n\\n\\tvec3 p31 = permute( p3 + Pi.z - 1.0 );\\n\\tvec3 p32 = permute( p3 + Pi.z );\\n\\tvec3 p33 = permute( p3 + Pi.z + 1.0 );\\n\\n\\tvec3 ox11 = fract( p11 * K ) - Ko;\\n\\tvec3 oy11 = mod7( floor( p11 * K ) ) * K - Ko;\\n\\tvec3 oz11 = floor( p11 * K2 ) * Kz - Kzo; // p11 < 289 guaranteed\\n\\n\\tvec3 ox12 = fract( p12 * K ) - Ko;\\n\\tvec3 oy12 = mod7( floor( p12 * K ) ) * K - Ko;\\n\\tvec3 oz12 = floor( p12 * K2 ) * Kz - Kzo;\\n\\n\\tvec3 ox13 = fract( p13 * K ) - Ko;\\n\\tvec3 oy13 = mod7( floor( p13 * K ) ) * K - Ko;\\n\\tvec3 oz13 = floor( p13 * K2 ) * Kz - Kzo;\\n\\n\\tvec3 ox21 = fract( p21 * K ) - Ko;\\n\\tvec3 oy21 = mod7( floor( p21 * K ) ) * K - Ko;\\n\\tvec3 oz21 = floor( p21 * K2 ) * Kz - Kzo;\\n\\n\\tvec3 ox22 = fract( p22 * K ) - Ko;\\n\\tvec3 oy22 = mod7( floor( p22 * K ) ) * K - Ko;\\n\\tvec3 oz22 = floor( p22 * K2 ) * Kz - Kzo;\\n\\n\\tvec3 ox23 = fract( p23 * K ) - Ko;\\n\\tvec3 oy23 = mod7( floor( p23 * K ) ) * K - Ko;\\n\\tvec3 oz23 = floor( p23 * K2 ) * Kz - Kzo;\\n\\n\\tvec3 ox31 = fract( p31 * K ) - Ko;\\n\\tvec3 oy31 = mod7( floor( p31 * K ) ) * K - Ko;\\n\\tvec3 oz31 = floor( p31 * K2 ) * Kz - Kzo;\\n\\n\\tvec3 ox32 = fract( p32 * K ) - Ko;\\n\\tvec3 oy32 = mod7( floor( p32 * K ) ) * K - Ko;\\n\\tvec3 oz32 = floor( p32 * K2 ) * Kz - Kzo;\\n\\n\\tvec3 ox33 = fract( p33 * K ) - Ko;\\n\\tvec3 oy33 = mod7( floor( p33 * K ) ) * K - Ko;\\n\\tvec3 oz33 = floor( p33 * K2 ) * Kz - Kzo;\\n\\n\\tvec3 dx11 = Pfx + jitter * ox11;\\n\\tvec3 dy11 = Pfy.x + jitter * oy11;\\n\\tvec3 dz11 = Pfz.x + jitter * oz11;\\n\\n\\tvec3 dx12 = Pfx + jitter * ox12;\\n\\tvec3 dy12 = Pfy.x + jitter * oy12;\\n\\tvec3 dz12 = Pfz.y + jitter * oz12;\\n\\n\\tvec3 dx13 = Pfx + jitter * ox13;\\n\\tvec3 dy13 = Pfy.x + jitter * oy13;\\n\\tvec3 dz13 = Pfz.z + jitter * oz13;\\n\\n\\tvec3 dx21 = Pfx + jitter * ox21;\\n\\tvec3 dy21 = Pfy.y + jitter * oy21;\\n\\tvec3 dz21 = Pfz.x + jitter * oz21;\\n\\n\\tvec3 dx22 = Pfx + jitter * ox22;\\n\\tvec3 dy22 = Pfy.y + jitter * oy22;\\n\\tvec3 dz22 = Pfz.y + jitter * oz22;\\n\\n\\tvec3 dx23 = Pfx + jitter * ox23;\\n\\tvec3 dy23 = Pfy.y + jitter * oy23;\\n\\tvec3 dz23 = Pfz.z + jitter * oz23;\\n\\n\\tvec3 dx31 = Pfx + jitter * ox31;\\n\\tvec3 dy31 = Pfy.z + jitter * oy31;\\n\\tvec3 dz31 = Pfz.x + jitter * oz31;\\n\\n\\tvec3 dx32 = Pfx + jitter * ox32;\\n\\tvec3 dy32 = Pfy.z + jitter * oy32;\\n\\tvec3 dz32 = Pfz.y + jitter * oz32;\\n\\n\\tvec3 dx33 = Pfx + jitter * ox33;\\n\\tvec3 dy33 = Pfy.z + jitter * oy33;\\n\\tvec3 dz33 = Pfz.z + jitter * oz33;\\n\\n\\tvec3 d11 = dx11 * dx11 + dy11 * dy11 + dz11 * dz11;\\n\\tvec3 d12 = dx12 * dx12 + dy12 * dy12 + dz12 * dz12;\\n\\tvec3 d13 = dx13 * dx13 + dy13 * dy13 + dz13 * dz13;\\n\\tvec3 d21 = dx21 * dx21 + dy21 * dy21 + dz21 * dz21;\\n\\tvec3 d22 = dx22 * dx22 + dy22 * dy22 + dz22 * dz22;\\n\\tvec3 d23 = dx23 * dx23 + dy23 * dy23 + dz23 * dz23;\\n\\tvec3 d31 = dx31 * dx31 + dy31 * dy31 + dz31 * dz31;\\n\\tvec3 d32 = dx32 * dx32 + dy32 * dy32 + dz32 * dz32;\\n\\tvec3 d33 = dx33 * dx33 + dy33 * dy33 + dz33 * dz33;\\n\\n\\t// Do it right and sort out both F1 and F2\\n\\tvec3 d1a = min( d11, d12 );\\n\\td12 = max( d11, d12 );\\n\\td11 = min( d1a, d13 ); // Smallest now not in d12 or d13\\n\\td13 = max( d1a, d13 );\\n\\td12 = min( d12, d13 ); // 2nd smallest now not in d13\\n\\tvec3 d2a = min( d21, d22 );\\n\\td22 = max( d21, d22 );\\n\\td21 = min( d2a, d23 ); // Smallest now not in d22 or d23\\n\\td23 = max( d2a, d23 );\\n\\td22 = min( d22, d23 ); // 2nd smallest now not in d23\\n\\tvec3 d3a = min( d31, d32 );\\n\\td32 = max( d31, d32 );\\n\\td31 = min( d3a, d33 ); // Smallest now not in d32 or d33\\n\\td33 = max( d3a, d33 );\\n\\td32 = min( d32, d33 ); // 2nd smallest now not in d33\\n\\tvec3 da = min( d11, d21 );\\n\\td21 = max( d11, d21 );\\n\\td11 = min( da, d31 ); // Smallest now in d11\\n\\td31 = max( da, d31 ); // 2nd smallest now not in d31\\n\\td11.xy = ( d11.x < d11.y ) ? d11.xy : d11.yx;\\n\\td11.xz = ( d11.x < d11.z ) ? d11.xz : d11.zx; // d11.x now smallest\\n\\td12 = min( d12, d21 ); // 2nd smallest now not in d21\\n\\td12 = min( d12, d22 ); // nor in d22\\n\\td12 = min( d12, d31 ); // nor in d31\\n\\td12 = min( d12, d32 ); // nor in d32\\n\\td11.yz = min( d11.yz, d12.xy ); // nor in d12.yz\\n\\td11.y = min( d11.y, d12.z ); // Only two more to go\\n\\td11.y = min( d11.y, d11.z ); // Done! (Phew! )\\n\\treturn sqrt( d11.xy ); // F1, F2\\n\\n}\\n\";\n\nvar noise_cellular2 = \"#include <noise_cellular_2D>\\n#include <noise_cellular_3D>\\n#include <noise_cellular_2x2>\\n#include <noise_cellular_2x2x2>\\n\";\n\nvar noise_perlin_2D2 = \"//\\n// GLSL textureless classic 2D noise \\\"cnoise\\\",\\n// with an RSL-style periodic variant \\\"pnoise\\\".\\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\\n// Version: 2011-08-22\\n//\\n// Many thanks to Ian McEwan of Ashima Arts for the\\n// ideas for permutation and gradient selection.\\n//\\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\\n// Distributed under the MIT license. See LICENSE file.\\n// https://github.com/stegu/webgl-noise\\n//\\n\\n// Classic Perlin noise\\nfloat perlin( vec2 P ) {\\n\\n    vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\\n    vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\\n    Pi = mod289(Pi); // To avoid truncation effects in permutation\\n    vec4 ix = Pi.xzxz;\\n    vec4 iy = Pi.yyww;\\n    vec4 fx = Pf.xzxz;\\n    vec4 fy = Pf.yyww;\\n\\n    vec4 i = permute(permute(ix) + iy);\\n\\n    vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\\n    vec4 gy = abs(gx) - 0.5 ;\\n    vec4 tx = floor(gx + 0.5);\\n    gx = gx - tx;\\n\\n    vec2 g00 = vec2(gx.x,gy.x);\\n    vec2 g10 = vec2(gx.y,gy.y);\\n    vec2 g01 = vec2(gx.z,gy.z);\\n    vec2 g11 = vec2(gx.w,gy.w);\\n\\n    vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\\n    g00 *= norm.x;\\n    g01 *= norm.y;\\n    g10 *= norm.z;\\n    g11 *= norm.w;\\n\\n    float n00 = dot(g00, vec2(fx.x, fy.x));\\n    float n10 = dot(g10, vec2(fx.y, fy.y));\\n    float n01 = dot(g01, vec2(fx.z, fy.z));\\n    float n11 = dot(g11, vec2(fx.w, fy.w));\\n\\n    vec2 fade_xy = fade(Pf.xy);\\n    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\\n    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\\n    return 2.3 * n_xy;\\n\\n}\\n\\n// Classic Perlin noise, periodic variant\\nfloat perlin( vec2 P, vec2 rep ) {\\n\\n    vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\\n    vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\\n    Pi = mod(Pi, rep.xyxy); // To create noise with explicit period\\n    Pi = mod289(Pi);        // To avoid truncation effects in permutation\\n    vec4 ix = Pi.xzxz;\\n    vec4 iy = Pi.yyww;\\n    vec4 fx = Pf.xzxz;\\n    vec4 fy = Pf.yyww;\\n\\n    vec4 i = permute(permute(ix) + iy);\\n\\n    vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\\n    vec4 gy = abs(gx) - 0.5 ;\\n    vec4 tx = floor(gx + 0.5);\\n    gx = gx - tx;\\n\\n    vec2 g00 = vec2(gx.x,gy.x);\\n    vec2 g10 = vec2(gx.y,gy.y);\\n    vec2 g01 = vec2(gx.z,gy.z);\\n    vec2 g11 = vec2(gx.w,gy.w);\\n\\n    vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\\n    g00 *= norm.x;\\n    g01 *= norm.y;\\n    g10 *= norm.z;\\n    g11 *= norm.w;\\n\\n    float n00 = dot(g00, vec2(fx.x, fy.x));\\n    float n10 = dot(g10, vec2(fx.y, fy.y));\\n    float n01 = dot(g01, vec2(fx.z, fy.z));\\n    float n11 = dot(g11, vec2(fx.w, fy.w));\\n\\n    vec2 fade_xy = fade(Pf.xy);\\n    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\\n    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\\n    return 2.3 * n_xy;\\n\\n}\\n\";\n\nvar noise_perlin_3D2 = \"//\\n// GLSL textureless classic 3D noise \\\"cnoise\\\",\\n// with an RSL-style periodic variant \\\"pnoise\\\".\\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\\n// Version: 2011-10-11\\n//\\n// Many thanks to Ian McEwan of Ashima Arts for the\\n// ideas for permutation and gradient selection.\\n//\\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\\n// Distributed under the MIT license. See LICENSE file.\\n// https://github.com/stegu/webgl-noise\\n//\\n\\n// Classic Perlin noise\\nfloat perlin( vec3 P ) {\\n\\n    vec3 Pi0 = floor(P); // Integer part for indexing\\n    vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\\n    Pi0 = mod289(Pi0);\\n    Pi1 = mod289(Pi1);\\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\\n    vec4 iz0 = Pi0.zzzz;\\n    vec4 iz1 = Pi1.zzzz;\\n\\n    vec4 ixy = permute(permute(ix) + iy);\\n    vec4 ixy0 = permute(ixy + iz0);\\n    vec4 ixy1 = permute(ixy + iz1);\\n\\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\\n    gx0 = fract(gx0);\\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\\n    vec4 sz0 = step(gz0, vec4(0.0));\\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\\n\\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\\n    gx1 = fract(gx1);\\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\\n    vec4 sz1 = step(gz1, vec4(0.0));\\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\\n\\n    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\\n    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\\n    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\\n    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\\n    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\\n    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\\n    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\\n    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\\n\\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\\n    g000 *= norm0.x;\\n    g010 *= norm0.y;\\n    g100 *= norm0.z;\\n    g110 *= norm0.w;\\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\\n    g001 *= norm1.x;\\n    g011 *= norm1.y;\\n    g101 *= norm1.z;\\n    g111 *= norm1.w;\\n\\n    float n000 = dot(g000, Pf0);\\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\\n    float n111 = dot(g111, Pf1);\\n\\n    vec3 fade_xyz = fade(Pf0);\\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\\n    return 2.2 * n_xyz;\\n\\n}\\n\\n// Classic Perlin noise, periodic variant\\nfloat perlin( vec3 P, vec3 rep ) {\\n\\n    vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\\n    vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\\n    Pi0 = mod289(Pi0);\\n    Pi1 = mod289(Pi1);\\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\\n    vec4 iz0 = Pi0.zzzz;\\n    vec4 iz1 = Pi1.zzzz;\\n\\n    vec4 ixy = permute(permute(ix) + iy);\\n    vec4 ixy0 = permute(ixy + iz0);\\n    vec4 ixy1 = permute(ixy + iz1);\\n\\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\\n    gx0 = fract(gx0);\\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\\n    vec4 sz0 = step(gz0, vec4(0.0));\\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\\n\\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\\n    gx1 = fract(gx1);\\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\\n    vec4 sz1 = step(gz1, vec4(0.0));\\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\\n\\n    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\\n    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\\n    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\\n    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\\n    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\\n    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\\n    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\\n    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\\n\\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\\n    g000 *= norm0.x;\\n    g010 *= norm0.y;\\n    g100 *= norm0.z;\\n    g110 *= norm0.w;\\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\\n    g001 *= norm1.x;\\n    g011 *= norm1.y;\\n    g101 *= norm1.z;\\n    g111 *= norm1.w;\\n\\n    float n000 = dot(g000, Pf0);\\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\\n    float n111 = dot(g111, Pf1);\\n\\n    vec3 fade_xyz = fade(Pf0);\\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\\n    return 2.2 * n_xyz;\\n\\n}\\n\";\n\nvar noise_perlin_4D2 = \"//\\n// GLSL textureless classic 4D noise \\\"cnoise\\\",\\n// with an RSL-style periodic variant \\\"pnoise\\\".\\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\\n// Version: 2011-08-22\\n//\\n// Many thanks to Ian McEwan of Ashima Arts for the\\n// ideas for permutation and gradient selection.\\n//\\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\\n// Distributed under the MIT license. See LICENSE file.\\n// https://github.com/stegu/webgl-noise\\n//\\n\\n// Classic Perlin noise\\nfloat perlin( vec4 P ) {\\n\\n    vec4 Pi0 = floor(P); // Integer part for indexing\\n    vec4 Pi1 = Pi0 + 1.0; // Integer part + 1\\n    Pi0 = mod289(Pi0);\\n    Pi1 = mod289(Pi1);\\n    vec4 Pf0 = fract(P); // Fractional part for interpolation\\n    vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0\\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\\n    vec4 iz0 = vec4(Pi0.zzzz);\\n    vec4 iz1 = vec4(Pi1.zzzz);\\n    vec4 iw0 = vec4(Pi0.wwww);\\n    vec4 iw1 = vec4(Pi1.wwww);\\n\\n    vec4 ixy = permute(permute(ix) + iy);\\n    vec4 ixy0 = permute(ixy + iz0);\\n    vec4 ixy1 = permute(ixy + iz1);\\n    vec4 ixy00 = permute(ixy0 + iw0);\\n    vec4 ixy01 = permute(ixy0 + iw1);\\n    vec4 ixy10 = permute(ixy1 + iw0);\\n    vec4 ixy11 = permute(ixy1 + iw1);\\n\\n    vec4 gx00 = ixy00 * (1.0 / 7.0);\\n    vec4 gy00 = floor(gx00) * (1.0 / 7.0);\\n    vec4 gz00 = floor(gy00) * (1.0 / 6.0);\\n    gx00 = fract(gx00) - 0.5;\\n    gy00 = fract(gy00) - 0.5;\\n    gz00 = fract(gz00) - 0.5;\\n    vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\\n    vec4 sw00 = step(gw00, vec4(0.0));\\n    gx00 -= sw00 * (step(0.0, gx00) - 0.5);\\n    gy00 -= sw00 * (step(0.0, gy00) - 0.5);\\n\\n    vec4 gx01 = ixy01 * (1.0 / 7.0);\\n    vec4 gy01 = floor(gx01) * (1.0 / 7.0);\\n    vec4 gz01 = floor(gy01) * (1.0 / 6.0);\\n    gx01 = fract(gx01) - 0.5;\\n    gy01 = fract(gy01) - 0.5;\\n    gz01 = fract(gz01) - 0.5;\\n    vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\\n    vec4 sw01 = step(gw01, vec4(0.0));\\n    gx01 -= sw01 * (step(0.0, gx01) - 0.5);\\n    gy01 -= sw01 * (step(0.0, gy01) - 0.5);\\n\\n    vec4 gx10 = ixy10 * (1.0 / 7.0);\\n    vec4 gy10 = floor(gx10) * (1.0 / 7.0);\\n    vec4 gz10 = floor(gy10) * (1.0 / 6.0);\\n    gx10 = fract(gx10) - 0.5;\\n    gy10 = fract(gy10) - 0.5;\\n    gz10 = fract(gz10) - 0.5;\\n    vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\\n    vec4 sw10 = step(gw10, vec4(0.0));\\n    gx10 -= sw10 * (step(0.0, gx10) - 0.5);\\n    gy10 -= sw10 * (step(0.0, gy10) - 0.5);\\n\\n    vec4 gx11 = ixy11 * (1.0 / 7.0);\\n    vec4 gy11 = floor(gx11) * (1.0 / 7.0);\\n    vec4 gz11 = floor(gy11) * (1.0 / 6.0);\\n    gx11 = fract(gx11) - 0.5;\\n    gy11 = fract(gy11) - 0.5;\\n    gz11 = fract(gz11) - 0.5;\\n    vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\\n    vec4 sw11 = step(gw11, vec4(0.0));\\n    gx11 -= sw11 * (step(0.0, gx11) - 0.5);\\n    gy11 -= sw11 * (step(0.0, gy11) - 0.5);\\n\\n    vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);\\n    vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);\\n    vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);\\n    vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);\\n    vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);\\n    vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);\\n    vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);\\n    vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);\\n    vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);\\n    vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);\\n    vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);\\n    vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);\\n    vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);\\n    vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);\\n    vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);\\n    vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);\\n\\n    vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\\n    g0000 *= norm00.x;\\n    g0100 *= norm00.y;\\n    g1000 *= norm00.z;\\n    g1100 *= norm00.w;\\n\\n    vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\\n    g0001 *= norm01.x;\\n    g0101 *= norm01.y;\\n    g1001 *= norm01.z;\\n    g1101 *= norm01.w;\\n\\n    vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\\n    g0010 *= norm10.x;\\n    g0110 *= norm10.y;\\n    g1010 *= norm10.z;\\n    g1110 *= norm10.w;\\n\\n    vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\\n    g0011 *= norm11.x;\\n    g0111 *= norm11.y;\\n    g1011 *= norm11.z;\\n    g1111 *= norm11.w;\\n\\n    float n0000 = dot(g0000, Pf0);\\n    float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));\\n    float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));\\n    float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));\\n    float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));\\n    float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\\n    float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));\\n    float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));\\n    float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));\\n    float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));\\n    float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\\n    float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));\\n    float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));\\n    float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));\\n    float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));\\n    float n1111 = dot(g1111, Pf1);\\n\\n    vec4 fade_xyzw = fade(Pf0);\\n    vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\\n    vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\\n    vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);\\n    vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);\\n    float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\\n    return 2.2 * n_xyzw;\\n\\n}\\n\\n// Classic Perlin noise, periodic version\\nfloat perlin( vec4 P, vec4 rep ) {\\n\\n    vec4 Pi0 = mod(floor(P), rep); // Integer part modulo rep\\n    vec4 Pi1 = mod(Pi0 + 1.0, rep); // Integer part + 1 mod rep\\n    Pi0 = mod289(Pi0);\\n    Pi1 = mod289(Pi1);\\n    vec4 Pf0 = fract(P); // Fractional part for interpolation\\n    vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0\\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\\n    vec4 iz0 = vec4(Pi0.zzzz);\\n    vec4 iz1 = vec4(Pi1.zzzz);\\n    vec4 iw0 = vec4(Pi0.wwww);\\n    vec4 iw1 = vec4(Pi1.wwww);\\n\\n    vec4 ixy = permute(permute(ix) + iy);\\n    vec4 ixy0 = permute(ixy + iz0);\\n    vec4 ixy1 = permute(ixy + iz1);\\n    vec4 ixy00 = permute(ixy0 + iw0);\\n    vec4 ixy01 = permute(ixy0 + iw1);\\n    vec4 ixy10 = permute(ixy1 + iw0);\\n    vec4 ixy11 = permute(ixy1 + iw1);\\n\\n    vec4 gx00 = ixy00 * (1.0 / 7.0);\\n    vec4 gy00 = floor(gx00) * (1.0 / 7.0);\\n    vec4 gz00 = floor(gy00) * (1.0 / 6.0);\\n    gx00 = fract(gx00) - 0.5;\\n    gy00 = fract(gy00) - 0.5;\\n    gz00 = fract(gz00) - 0.5;\\n    vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\\n    vec4 sw00 = step(gw00, vec4(0.0));\\n    gx00 -= sw00 * (step(0.0, gx00) - 0.5);\\n    gy00 -= sw00 * (step(0.0, gy00) - 0.5);\\n\\n    vec4 gx01 = ixy01 * (1.0 / 7.0);\\n    vec4 gy01 = floor(gx01) * (1.0 / 7.0);\\n    vec4 gz01 = floor(gy01) * (1.0 / 6.0);\\n    gx01 = fract(gx01) - 0.5;\\n    gy01 = fract(gy01) - 0.5;\\n    gz01 = fract(gz01) - 0.5;\\n    vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\\n    vec4 sw01 = step(gw01, vec4(0.0));\\n    gx01 -= sw01 * (step(0.0, gx01) - 0.5);\\n    gy01 -= sw01 * (step(0.0, gy01) - 0.5);\\n\\n    vec4 gx10 = ixy10 * (1.0 / 7.0);\\n    vec4 gy10 = floor(gx10) * (1.0 / 7.0);\\n    vec4 gz10 = floor(gy10) * (1.0 / 6.0);\\n    gx10 = fract(gx10) - 0.5;\\n    gy10 = fract(gy10) - 0.5;\\n    gz10 = fract(gz10) - 0.5;\\n    vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\\n    vec4 sw10 = step(gw10, vec4(0.0));\\n    gx10 -= sw10 * (step(0.0, gx10) - 0.5);\\n    gy10 -= sw10 * (step(0.0, gy10) - 0.5);\\n\\n    vec4 gx11 = ixy11 * (1.0 / 7.0);\\n    vec4 gy11 = floor(gx11) * (1.0 / 7.0);\\n    vec4 gz11 = floor(gy11) * (1.0 / 6.0);\\n    gx11 = fract(gx11) - 0.5;\\n    gy11 = fract(gy11) - 0.5;\\n    gz11 = fract(gz11) - 0.5;\\n    vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\\n    vec4 sw11 = step(gw11, vec4(0.0));\\n    gx11 -= sw11 * (step(0.0, gx11) - 0.5);\\n    gy11 -= sw11 * (step(0.0, gy11) - 0.5);\\n\\n    vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);\\n    vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);\\n    vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);\\n    vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);\\n    vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);\\n    vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);\\n    vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);\\n    vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);\\n    vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);\\n    vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);\\n    vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);\\n    vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);\\n    vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);\\n    vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);\\n    vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);\\n    vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);\\n\\n    vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\\n    g0000 *= norm00.x;\\n    g0100 *= norm00.y;\\n    g1000 *= norm00.z;\\n    g1100 *= norm00.w;\\n\\n    vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\\n    g0001 *= norm01.x;\\n    g0101 *= norm01.y;\\n    g1001 *= norm01.z;\\n    g1101 *= norm01.w;\\n\\n    vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\\n    g0010 *= norm10.x;\\n    g0110 *= norm10.y;\\n    g1010 *= norm10.z;\\n    g1110 *= norm10.w;\\n\\n    vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\\n    g0011 *= norm11.x;\\n    g0111 *= norm11.y;\\n    g1011 *= norm11.z;\\n    g1111 *= norm11.w;\\n\\n    float n0000 = dot(g0000, Pf0);\\n    float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));\\n    float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));\\n    float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));\\n    float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));\\n    float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\\n    float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));\\n    float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));\\n    float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));\\n    float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));\\n    float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\\n    float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));\\n    float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));\\n    float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));\\n    float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));\\n    float n1111 = dot(g1111, Pf1);\\n\\n    vec4 fade_xyzw = fade(Pf0);\\n    vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\\n    vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\\n    vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);\\n    vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);\\n    float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\\n    return 2.2 * n_xyzw;\\n\\n}\\n\";\n\nvar noise_perlin2 = \"#include <noise_perlin_2D>\\n#include <noise_perlin_3D>\\n#include <noise_perlin_4D>\\n\";\n\nvar noise_psrd_2D2 = \"// Periodic (tiling) 2-D simplex noise (hexagonal lattice gradient noise)\\n// with rotating gradients and analytic derivatives.\\n// Variants also without the derivative (no \\\"d\\\" in the name), without\\n// the tiling property (no \\\"p\\\" in the name) and without the rotating\\n// gradients (no \\\"r\\\" in the name).\\n//\\n// This is (yet) another variation on simplex noise. It's similar to the\\n// version presented by Ken Perlin, but the grid is axis-aligned and\\n// slightly stretched in the y direction to permit rectangular tiling.\\n//\\n// The noise can be made to tile seamlessly to any integer period in x and\\n// any even integer period in y. Odd periods may be specified for y, but\\n// then the actual tiling period will be twice that number.\\n//\\n// The rotating gradients give the appearance of a swirling motion, and can\\n// serve a similar purpose for animation as motion along z in 3-D noise.\\n// The rotating gradients in conjunction with the analytic derivatives\\n// can make \\\"flow noise\\\" effects as presented by Perlin and Neyret.\\n//\\n// vec3 {p}s{r}dnoise(vec2 pos {, vec2 per} {, float rot})\\n// \\\"pos\\\" is the input (x,y) coordinate\\n// \\\"per\\\" is the x and y period, where per.x is a positive integer\\n//    and per.y is a positive even integer\\n// \\\"rot\\\" is the angle to rotate the gradients (any float value,\\n//    where 0.0 is no rotation and 1.0 is one full turn)\\n// The first component of the 3-element return vector is the noise value.\\n// The second and third components are the x and y partial derivatives.\\n//\\n// float {p}s{r}noise(vec2 pos {, vec2 per} {, float rot})\\n// \\\"pos\\\" is the input (x,y) coordinate\\n// \\\"per\\\" is the x and y period, where per.x is a positive integer\\n//    and per.y is a positive even integer\\n// \\\"rot\\\" is the angle to rotate the gradients (any float value,\\n//    where 0.0 is no rotation and 1.0 is one full turn)\\n// The return value is the noise value.\\n// Partial derivatives are not computed, making these functions faster.\\n//\\n// Author: Stefan Gustavson (stefan.gustavson@gmail.com)\\n// Version 2016-05-10.\\n//\\n// Many thanks to Ian McEwan of Ashima Arts for the\\n// idea of using a permutation polynomial.\\n//\\n// Copyright (c) 2016 Stefan Gustavson. All rights reserved.\\n// Distributed under the MIT license. See LICENSE file.\\n// https://github.com/stegu/webgl-noise\\n//\\n\\n// Hashed 2-D gradients with an extra rotation.\\n// (The constant 0.0243902439 is 1/41)\\nvec2 rgrad2( vec2 p, float rot ) {\\n\\n    // For more isotropic gradients, sin/cos can be used instead.\\n    float u = permute( permute( p.x ) + p.y ) * 0.0243902439 + rot; // Rotate by shift\\n    u = fract( u ) * 6.28318530718; // 2*pi\\n    return vec2( cos( u ), sin( u ));\\n\\n}\\n\\n//\\n// 2-D tiling simplex noise with rotating gradients and analytical derivative.\\n// The first component of the 3-element return vector is the noise value,\\n// and the second and third components are the x and y partial derivatives.\\n//\\nvec3 psrdnoise(vec2 pos, vec2 per, float rot) {\\n  // Hack: offset y slightly to hide some rare artifacts\\n  pos.y += 0.01;\\n  // Skew to hexagonal grid\\n  vec2 uv = vec2(pos.x + pos.y*0.5, pos.y);\\n\\n  vec2 i0 = floor(uv);\\n  vec2 f0 = fract(uv);\\n  // Traversal order\\n  vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\\n\\n  // Unskewed grid points in (x,y) space\\n  vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y);\\n  vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y);\\n  vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);\\n\\n  // Integer grid point indices in (u,v) space\\n  i1 = i0 + i1;\\n  vec2 i2 = i0 + vec2(1.0, 1.0);\\n\\n  // Vectors in unskewed (x,y) coordinates from\\n  // each of the simplex corners to the evaluation point\\n  vec2 d0 = pos - p0;\\n  vec2 d1 = pos - p1;\\n  vec2 d2 = pos - p2;\\n\\n  // Wrap i0, i1 and i2 to the desired period before gradient hashing:\\n  // wrap points in (x,y), map to (u,v)\\n  vec3 xw = mod(vec3(p0.x, p1.x, p2.x), per.x);\\n  vec3 yw = mod(vec3(p0.y, p1.y, p2.y), per.y);\\n  vec3 iuw = xw + 0.5 * yw;\\n  vec3 ivw = yw;\\n\\n  // Create gradients from indices\\n  vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), rot);\\n  vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), rot);\\n  vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), rot);\\n\\n  // Gradients dot vectors to corresponding corners\\n  // (The derivatives of this are simply the gradients)\\n  vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2));\\n\\n  // Radial weights from corners\\n  // 0.8 is the square of 2/sqrt(5), the distance from\\n  // a grid point to the nearest simplex boundary\\n  vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2));\\n\\n  // Partial derivatives for analytical gradient computation\\n  vec3 dtdx = -2.0 * vec3(d0.x, d1.x, d2.x);\\n  vec3 dtdy = -2.0 * vec3(d0.y, d1.y, d2.y);\\n\\n  // Set influence of each surflet to zero outside radius sqrt(0.8)\\n  if (t.x < 0.0) {\\n    dtdx.x = 0.0;\\n    dtdy.x = 0.0;\\n\\tt.x = 0.0;\\n  }\\n  if (t.y < 0.0) {\\n    dtdx.y = 0.0;\\n    dtdy.y = 0.0;\\n\\tt.y = 0.0;\\n  }\\n  if (t.z < 0.0) {\\n    dtdx.z = 0.0;\\n    dtdy.z = 0.0;\\n\\tt.z = 0.0;\\n  }\\n\\n  // Fourth power of t (and third power for derivative)\\n  vec3 t2 = t * t;\\n  vec3 t4 = t2 * t2;\\n  vec3 t3 = t2 * t;\\n\\n  // Final noise value is:\\n  // sum of ((radial weights) times (gradient dot vector from corner))\\n  float n = dot(t4, w);\\n\\n  // Final analytical derivative (gradient of a sum of scalar products)\\n  vec2 dt0 = vec2(dtdx.x, dtdy.x) * 4.0 * t3.x;\\n  vec2 dn0 = t4.x * g0 + dt0 * w.x;\\n  vec2 dt1 = vec2(dtdx.y, dtdy.y) * 4.0 * t3.y;\\n  vec2 dn1 = t4.y * g1 + dt1 * w.y;\\n  vec2 dt2 = vec2(dtdx.z, dtdy.z) * 4.0 * t3.z;\\n  vec2 dn2 = t4.z * g2 + dt2 * w.z;\\n\\n  return 11.0*vec3(n, dn0 + dn1 + dn2);\\n}\\n\\n//\\n// 2-D tiling simplex noise with fixed gradients\\n// and analytical derivative.\\n// This function is implemented as a wrapper to \\\"psrdnoise\\\",\\n// at the minimal cost of three extra additions.\\n//\\nvec3 psdnoise(vec2 pos, vec2 per) {\\n  return psrdnoise(pos, per, 0.0);\\n}\\n\\n//\\n// 2-D tiling simplex noise with rotating gradients,\\n// but without the analytical derivative.\\n//\\nfloat psrnoise(vec2 pos, vec2 per, float rot) {\\n  // Offset y slightly to hide some rare artifacts\\n  pos.y += 0.001;\\n  // Skew to hexagonal grid\\n  vec2 uv = vec2(pos.x + pos.y*0.5, pos.y);\\n\\n  vec2 i0 = floor(uv);\\n  vec2 f0 = fract(uv);\\n  // Traversal order\\n  vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\\n\\n  // Unskewed grid points in (x,y) space\\n  vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y);\\n  vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y);\\n  vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);\\n\\n  // Integer grid point indices in (u,v) space\\n  i1 = i0 + i1;\\n  vec2 i2 = i0 + vec2(1.0, 1.0);\\n\\n  // Vectors in unskewed (x,y) coordinates from\\n  // each of the simplex corners to the evaluation point\\n  vec2 d0 = pos - p0;\\n  vec2 d1 = pos - p1;\\n  vec2 d2 = pos - p2;\\n\\n  // Wrap i0, i1 and i2 to the desired period before gradient hashing:\\n  // wrap points in (x,y), map to (u,v)\\n  vec3 xw = mod(vec3(p0.x, p1.x, p2.x), per.x);\\n  vec3 yw = mod(vec3(p0.y, p1.y, p2.y), per.y);\\n  vec3 iuw = xw + 0.5 * yw;\\n  vec3 ivw = yw;\\n\\n  // Create gradients from indices\\n  vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), rot);\\n  vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), rot);\\n  vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), rot);\\n\\n  // Gradients dot vectors to corresponding corners\\n  // (The derivatives of this are simply the gradients)\\n  vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2));\\n\\n  // Radial weights from corners\\n  // 0.8 is the square of 2/sqrt(5), the distance from\\n  // a grid point to the nearest simplex boundary\\n  vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2));\\n\\n  // Set influence of each surflet to zero outside radius sqrt(0.8)\\n  t = max(t, 0.0);\\n\\n  // Fourth power of t\\n  vec3 t2 = t * t;\\n  vec3 t4 = t2 * t2;\\n\\n  // Final noise value is:\\n  // sum of ((radial weights) times (gradient dot vector from corner))\\n  float n = dot(t4, w);\\n\\n  // Rescale to cover the range [-1,1] reasonably well\\n  return 11.0*n;\\n}\\n\\n//\\n// 2-D tiling simplex noise with fixed gradients,\\n// without the analytical derivative.\\n// This function is implemented as a wrapper to \\\"psrnoise\\\",\\n// at the minimal cost of three extra additions.\\n//\\nfloat psnoise(vec2 pos, vec2 per) {\\n  return psrnoise(pos, per, 0.0);\\n}\\n\\n//\\n// 2-D non-tiling simplex noise with rotating gradients and analytical derivative.\\n// The first component of the 3-element return vector is the noise value,\\n// and the second and third components are the x and y partial derivatives.\\n//\\nvec3 srdnoise(vec2 pos, float rot) {\\n  // Offset y slightly to hide some rare artifacts\\n  pos.y += 0.001;\\n  // Skew to hexagonal grid\\n  vec2 uv = vec2(pos.x + pos.y*0.5, pos.y);\\n\\n  vec2 i0 = floor(uv);\\n  vec2 f0 = fract(uv);\\n  // Traversal order\\n  vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\\n\\n  // Unskewed grid points in (x,y) space\\n  vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y);\\n  vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y);\\n  vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);\\n\\n  // Integer grid point indices in (u,v) space\\n  i1 = i0 + i1;\\n  vec2 i2 = i0 + vec2(1.0, 1.0);\\n\\n  // Vectors in unskewed (x,y) coordinates from\\n  // each of the simplex corners to the evaluation point\\n  vec2 d0 = pos - p0;\\n  vec2 d1 = pos - p1;\\n  vec2 d2 = pos - p2;\\n\\n  vec3 x = vec3(p0.x, p1.x, p2.x);\\n  vec3 y = vec3(p0.y, p1.y, p2.y);\\n  vec3 iuw = x + 0.5 * y;\\n  vec3 ivw = y;\\n\\n  // Avoid precision issues in permutation\\n  iuw = mod289(iuw);\\n  ivw = mod289(ivw);\\n\\n  // Create gradients from indices\\n  vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), rot);\\n  vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), rot);\\n  vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), rot);\\n\\n  // Gradients dot vectors to corresponding corners\\n  // (The derivatives of this are simply the gradients)\\n  vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2));\\n\\n  // Radial weights from corners\\n  // 0.8 is the square of 2/sqrt(5), the distance from\\n  // a grid point to the nearest simplex boundary\\n  vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2));\\n\\n  // Partial derivatives for analytical gradient computation\\n  vec3 dtdx = -2.0 * vec3(d0.x, d1.x, d2.x);\\n  vec3 dtdy = -2.0 * vec3(d0.y, d1.y, d2.y);\\n\\n  // Set influence of each surflet to zero outside radius sqrt(0.8)\\n  if (t.x < 0.0) {\\n    dtdx.x = 0.0;\\n    dtdy.x = 0.0;\\n\\tt.x = 0.0;\\n  }\\n  if (t.y < 0.0) {\\n    dtdx.y = 0.0;\\n    dtdy.y = 0.0;\\n\\tt.y = 0.0;\\n  }\\n  if (t.z < 0.0) {\\n    dtdx.z = 0.0;\\n    dtdy.z = 0.0;\\n\\tt.z = 0.0;\\n  }\\n\\n  // Fourth power of t (and third power for derivative)\\n  vec3 t2 = t * t;\\n  vec3 t4 = t2 * t2;\\n  vec3 t3 = t2 * t;\\n\\n  // Final noise value is:\\n  // sum of ((radial weights) times (gradient dot vector from corner))\\n  float n = dot(t4, w);\\n\\n  // Final analytical derivative (gradient of a sum of scalar products)\\n  vec2 dt0 = vec2(dtdx.x, dtdy.x) * 4.0 * t3.x;\\n  vec2 dn0 = t4.x * g0 + dt0 * w.x;\\n  vec2 dt1 = vec2(dtdx.y, dtdy.y) * 4.0 * t3.y;\\n  vec2 dn1 = t4.y * g1 + dt1 * w.y;\\n  vec2 dt2 = vec2(dtdx.z, dtdy.z) * 4.0 * t3.z;\\n  vec2 dn2 = t4.z * g2 + dt2 * w.z;\\n\\n  return 11.0*vec3(n, dn0 + dn1 + dn2);\\n}\\n\\n//\\n// 2-D non-tiling simplex noise with fixed gradients and analytical derivative.\\n// This function is implemented as a wrapper to \\\"srdnoise\\\",\\n// at the minimal cost of three extra additions.\\n//\\nvec3 sdnoise(vec2 pos) {\\n  return srdnoise(pos, 0.0);\\n}\\n\\n//\\n// 2-D non-tiling simplex noise with rotating gradients,\\n// without the analytical derivative.\\n//\\nfloat srnoise(vec2 pos, float rot) {\\n  // Offset y slightly to hide some rare artifacts\\n  pos.y += 0.001;\\n  // Skew to hexagonal grid\\n  vec2 uv = vec2(pos.x + pos.y*0.5, pos.y);\\n\\n  vec2 i0 = floor(uv);\\n  vec2 f0 = fract(uv);\\n  // Traversal order\\n  vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\\n\\n  // Unskewed grid points in (x,y) space\\n  vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y);\\n  vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y);\\n  vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);\\n\\n  // Integer grid point indices in (u,v) space\\n  i1 = i0 + i1;\\n  vec2 i2 = i0 + vec2(1.0, 1.0);\\n\\n  // Vectors in unskewed (x,y) coordinates from\\n  // each of the simplex corners to the evaluation point\\n  vec2 d0 = pos - p0;\\n  vec2 d1 = pos - p1;\\n  vec2 d2 = pos - p2;\\n\\n  // Wrap i0, i1 and i2 to the desired period before gradient hashing:\\n  // wrap points in (x,y), map to (u,v)\\n  vec3 x = vec3(p0.x, p1.x, p2.x);\\n  vec3 y = vec3(p0.y, p1.y, p2.y);\\n  vec3 iuw = x + 0.5 * y;\\n  vec3 ivw = y;\\n\\n  // Avoid precision issues in permutation\\n  iuw = mod289(iuw);\\n  ivw = mod289(ivw);\\n\\n  // Create gradients from indices\\n  vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), rot);\\n  vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), rot);\\n  vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), rot);\\n\\n  // Gradients dot vectors to corresponding corners\\n  // (The derivatives of this are simply the gradients)\\n  vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2));\\n\\n  // Radial weights from corners\\n  // 0.8 is the square of 2/sqrt(5), the distance from\\n  // a grid point to the nearest simplex boundary\\n  vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2));\\n\\n  // Set influence of each surflet to zero outside radius sqrt(0.8)\\n  t = max(t, 0.0);\\n\\n  // Fourth power of t\\n  vec3 t2 = t * t;\\n  vec3 t4 = t2 * t2;\\n\\n  // Final noise value is:\\n  // sum of ((radial weights) times (gradient dot vector from corner))\\n  float n = dot(t4, w);\\n\\n  // Rescale to cover the range [-1,1] reasonably well\\n  return 11.0*n;\\n}\\n\\n//\\n// 2-D non-tiling simplex noise with fixed gradients,\\n// without the analytical derivative.\\n// This function is implemented as a wrapper to \\\"srnoise\\\",\\n// at the minimal cost of three extra additions.\\n// Note: if this kind of noise is all you want, there are faster\\n// GLSL implementations of non-tiling simplex noise out there.\\n// This one is included mainly for completeness and compatibility\\n// with the other functions in the file.\\n//\\nfloat snoise(vec2 pos) {\\n  return srnoise(pos, 0.0);\\n}\\n\";\n\nvar noise_simplex_2D2 = \"//\\n// Description : Array and textureless GLSL 2D simplex noise function.\\n//      Author : Ian McEwan, Ashima Arts.\\n//  Maintainer : stegu\\n//     Lastmod : 20110822 (ijm)\\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\\n//               Distributed under the MIT License. See LICENSE file.\\n//               https://github.com/ashima/webgl-noise\\n//               https://github.com/stegu/webgl-noise\\n//\\n\\nfloat simplex( vec2 v ) {\\n\\n    const vec4 C = vec4( 0.211324865405187,  // (3.0-sqrt(3.0))/6.0\\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\\n                        0.024390243902439 ); // 1.0 / 41.0\\n    // First corner\\n    vec2 i  = floor( v + dot( v, C.yy ) );\\n    vec2 x0 = v - i + dot( i, C.xx );\\n\\n    // Other corners\\n    vec2 i1;\\n    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\\n    //i1.y = 1.0 - i1.x;\\n    i1 = ( x0.x > x0.y ) ? vec2( 1.0, 0.0 ) : vec2( 0.0, 1.0 );\\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\\n    // x1 = x0 - i1 + 1.0 * C.xx ;\\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\\n    vec4 x12 = x0.xyxy + C.xxzz;\\n    x12.xy -= i1;\\n\\n    // Permutations\\n    i = mod289( i ); // Avoid truncation effects in permutation\\n    vec3 p = permute( permute( i.y + vec3( 0.0, i1.y, 1.0 ) )\\n        + i.x + vec3( 0.0, i1.x, 1.0 ) );\\n\\n    vec3 m = max( 0.5 - vec3( dot( x0, x0 ), dot( x12.xy, x12.xy ), dot( x12.zw, x12.zw ) ), 0.0 );\\n    m = m*m ;\\n    m = m*m ;\\n\\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\\n    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\\n\\n    vec3 x = 2.0 * fract( p * C.www ) - 1.0;\\n    vec3 h = abs( x ) - 0.5;\\n    vec3 ox = floor( x + 0.5 );\\n    vec3 a0 = x - ox;\\n\\n    // Normalise gradients implicitly by scaling m\\n    // Approximation of: m *= inversesqrt( a0*a0 + h*h );\\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0 * a0 + h * h );\\n\\n    // Compute final noise value at P\\n    vec3 g;\\n    g.x  = a0.x * x0.x + h.x * x0.y;\\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\\n    return 130.0 * dot( m, g );\\n\\n}\\n\";\n\nvar noise_simplex_3D_grad2 = \"//\\n// Description : Array and textureless GLSL 2D/3D/4D simplex\\n//               noise functions.\\n//      Author : Ian McEwan, Ashima Arts.\\n//  Maintainer : stegu\\n//     Lastmod : 20150104 (JcBernack)\\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\\n//               Distributed under the MIT License. See LICENSE file.\\n//               https://github.com/ashima/webgl-noise\\n//               https://github.com/stegu/webgl-noise\\n//\\n\\nfloat simplex( vec3 v, out vec3 gradient ) {\\n\\n    const vec2  C = vec2( 1.0 / 6.0, 1.0 / 3.0 );\\n    const vec4  D = vec4( 0.0, 0.5, 1.0, 2.0 );\\n\\n    // First corner\\n    vec3 i  = floor( v + dot( v, C.yyy ) );\\n    vec3 x0 = v - i + dot( i, C.xxx ) ;\\n\\n    // Other corners\\n    vec3 g = step( x0.yzx, x0.xyz );\\n    vec3 l = 1.0 - g;\\n    vec3 i1 = min( g.xyz, l.zxy );\\n    vec3 i2 = max( g.xyz, l.zxy );\\n\\n    vec3 x1 = x0 - i1 + C.xxx;\\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\\n    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\\n\\n    // Permutations\\n    i = mod289( i );\\n    vec4 p = permute( permute( permute(\\n                i.z + vec4( 0.0, i1.z, i2.z, 1.0 ) )\\n            + i.y + vec4( 0.0, i1.y, i2.y, 1.0 ) )\\n            + i.x + vec4( 0.0, i1.x, i2.x, 1.0 ) );\\n\\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\\n    float n_ = 0.142857142857; // 1.0/7.0\\n    vec3 ns = n_ * D.wyz - D.xzx;\\n\\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\\n\\n    vec4 x_ = floor(j * ns.z);\\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\\n\\n    vec4 x = x_ * ns.x + ns.yyyy;\\n    vec4 y = y_ * ns.x + ns.yyyy;\\n    vec4 h = 1.0 - abs( x ) - abs( y );\\n\\n    vec4 b0 = vec4( x.xy, y.xy );\\n    vec4 b1 = vec4( x.zw, y.zw );\\n\\n    vec4 s0 = floor( b0 ) * 2.0 + 1.0;\\n    vec4 s1 = floor( b1 ) * 2.0 + 1.0;\\n    vec4 sh = - step( h, vec4( 0.0 ) );\\n\\n    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy ;\\n    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww ;\\n\\n    vec3 p0 = vec3( a0.xy, h.x );\\n    vec3 p1 = vec3( a0.zw, h.y );\\n    vec3 p2 = vec3( a1.xy, h.z );\\n    vec3 p3 = vec3( a1.zw, h.w );\\n\\n    //Normalise gradients\\n    vec4 norm = taylorInvSqrt( vec4( dot( p0, p0 ), dot( p1, p1 ), dot( p2, p2 ), dot( p3, p3 ) ) );\\n    p0 *= norm.x;\\n    p1 *= norm.y;\\n    p2 *= norm.z;\\n    p3 *= norm.w;\\n\\n    // Mix final noise value\\n    vec4 m = max( 0.6 - vec4( dot( x0, x0 ), dot( x1, x1 ), dot( x2, x2 ), dot( x3, x3 ) ), 0.0 );\\n    vec4 m2 = m * m;\\n    vec4 m4 = m2 * m2;\\n    vec4 pdotx = vec4( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 ), dot( p3, x3 ) );\\n\\n    // Determine noise gradient\\n    vec4 temp = m2 * m * pdotx;\\n    gradient = - 8.0 * ( temp.x * x0 + temp.y * x1 + temp.z * x2 + temp.w * x3 );\\n    gradient += m4.x * p0 + m4.y * p1 + m4.z * p2 + m4.w * p3;\\n    gradient *= 42.0;\\n\\n    return 42.0 * dot( m4, pdotx );\\n\\n}\\n\";\n\nvar noise_simplex_3D2 = \"//\\n// Description : Array and textureless GLSL 2D/3D/4D simplex\\n//               noise functions.\\n//      Author : Ian McEwan, Ashima Arts.\\n//  Maintainer : stegu\\n//     Lastmod : 20110822 (ijm)\\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\\n//               Distributed under the MIT License. See LICENSE file.\\n//               https://github.com/ashima/webgl-noise\\n//               https://github.com/stegu/webgl-noise\\n//\\n\\nfloat simplex( vec3 v ) {\\n\\n    const vec2 C = vec2( 1.0 / 6.0, 1.0 / 3.0 );\\n    const vec4 D = vec4( 0.0, 0.5, 1.0, 2.0 );\\n\\n    // First corner\\n    vec3 i  = floor( v + dot( v, C.yyy ) );\\n    vec3 x0 = v - i + dot( i, C.xxx );\\n\\n    // Other corners\\n    vec3 g = step( x0.yzx, x0.xyz );\\n    vec3 l = 1.0 - g;\\n    vec3 i1 = min( g.xyz, l.zxy );\\n    vec3 i2 = max( g.xyz, l.zxy );\\n\\n    vec3 x1 = x0 - i1 + C.xxx;\\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\\n    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\\n\\n    // Permutations\\n    i = mod289( i );\\n    vec4 p = permute( permute( permute(\\n                i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\\n            + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\\n            + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\\n\\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\\n    float n_ = 0.142857142857; // 1.0/7.0\\n    vec3 ns = n_ * D.wyz - D.xzx;\\n\\n    vec4 j = p - 49.0 * floor( p * ns.z * ns.z );  //  mod(p,7*7)\\n\\n    vec4 x_ = floor(j * ns.z);\\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\\n\\n    vec4 x = x_ *ns.x + ns.yyyy;\\n    vec4 y = y_ *ns.x + ns.yyyy;\\n    vec4 h = 1.0 - abs( x ) - abs( y );\\n\\n    vec4 b0 = vec4( x.xy, y.xy );\\n    vec4 b1 = vec4( x.zw, y.zw );\\n\\n    vec4 s0 = floor( b0 ) * 2.0 + 1.0;\\n    vec4 s1 = floor( b1 ) * 2.0 + 1.0;\\n    vec4 sh = - step( h, vec4( 0.0 ) );\\n\\n    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy ;\\n    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww ;\\n\\n    vec3 p0 = vec3( a0.xy, h.x );\\n    vec3 p1 = vec3( a0.zw, h.y );\\n    vec3 p2 = vec3( a1.xy, h.z );\\n    vec3 p3 = vec3( a1.zw, h.w );\\n\\n    //Normalise gradients\\n    vec4 norm = taylorInvSqrt( vec4( dot( p0, p0 ), dot( p1, p1 ), dot( p2, p2 ), dot( p3, p3 ) ) );\\n    p0 *= norm.x;\\n    p1 *= norm.y;\\n    p2 *= norm.z;\\n    p3 *= norm.w;\\n\\n    // Mix final noise value\\n    vec4 m = max( 0.6 - vec4( dot( x0, x0 ), dot( x1, x1 ), dot( x2, x2 ), dot( x3, x3 ) ), 0.0 );\\n    m = m * m;\\n    return 42.0 * dot( m*m, vec4( dot( p0, x0 ), dot( p1, x1 ),\\n                                dot( p2, x2 ), dot( p3, x3 ) ) );\\n\\n}\\n\";\n\nvar noise_simplex_4D2 = \"//\\n// Description : Array and textureless GLSL 2D/3D/4D simplex\\n//               noise functions.\\n//      Author : Ian McEwan, Ashima Arts.\\n//  Maintainer : stegu\\n//     Lastmod : 20110822 (ijm)\\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\\n//               Distributed under the MIT License. See LICENSE file.\\n//               https://github.com/ashima/webgl-noise\\n//               https://github.com/stegu/webgl-noise\\n//\\n\\nvec4 grad4( float j, vec4 ip ) {\\n\\n    const vec4 ones = vec4( 1.0, 1.0, 1.0, -1.0 );\\n    vec4 p, s;\\n\\n    p.xyz = floor( fract( vec3( j ) * ip.xyz ) * 7.0 ) * ip.z - 1.0;\\n    p.w = 1.5 - dot( abs( p.xyz ), ones.xyz );\\n    s = vec4( lessThan( p, vec4( 0.0 ) ) );\\n    p.xyz = p.xyz + ( s.xyz * 2.0 - 1.0 ) * s.www;\\n\\n    return p;\\n\\n}\\n\\n// (sqrt(5) - 1)/4 = F4, used once below\\n#define F4 0.309016994374947451\\n\\nfloat simplex(vec4 v) {\\n\\n    const vec4 C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\\n                        0.276393202250021,  // 2 * G4\\n                        0.414589803375032,  // 3 * G4\\n                        -0.447213595499958); // -1 + 4 * G4\\n\\n    // First corner\\n    vec4 i  = floor( v + dot( v, vec4( F4 ) ) );\\n    vec4 x0 = v - i + dot( i, C.xxxx );\\n\\n    // Other corners\\n\\n    // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\\n    vec4 i0;\\n    vec3 isX = step( x0.yzw, x0.xxx );\\n    vec3 isYZ = step( x0.zww, x0.yyz );\\n    i0.x = isX.x + isX.y + isX.z;\\n    i0.yzw = 1.0 - isX;\\n    i0.y += isYZ.x + isYZ.y;\\n    i0.zw += 1.0 - isYZ.xy;\\n    i0.z += isYZ.z;\\n    i0.w += 1.0 - isYZ.z;\\n\\n    vec4 i3 = clamp( i0, 0.0, 1.0 );\\n    vec4 i2 = clamp( i0 - 1.0, 0.0, 1.0 );\\n    vec4 i1 = clamp( i0 - 2.0, 0.0, 1.0 );\\n\\n    vec4 x1 = x0 - i1 + C.xxxx;\\n    vec4 x2 = x0 - i2 + C.yyyy;\\n    vec4 x3 = x0 - i3 + C.zzzz;\\n    vec4 x4 = x0 + C.wwww;\\n\\n    // Permutations\\n    i = mod289( i );\\n    float j0 = permute( permute( permute( permute( i.w ) + i.z ) + i.y ) + i.x );\\n    vec4 j1 = permute( permute( permute( permute (\\n                i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\\n            + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\\n            + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\\n            + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\\n\\n    // Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\\n    // 7*7*6 = 294, which is close to the ring size 17*17 = 289.\\n    vec4 ip = vec4( 1.0 / 294.0, 1.0 / 49.0, 1.0 / 7.0, 0.0 );\\n\\n    vec4 p0 = grad4(j0,   ip);\\n    vec4 p1 = grad4(j1.x, ip);\\n    vec4 p2 = grad4(j1.y, ip);\\n    vec4 p3 = grad4(j1.z, ip);\\n    vec4 p4 = grad4(j1.w, ip);\\n\\n    // Normalise gradients\\n    vec4 norm = taylorInvSqrt( vec4( dot( p0, p0 ), dot( p1, p1 ), dot( p2, p2 ), dot( p3, p3 ) ) );\\n    p0 *= norm.x;\\n    p1 *= norm.y;\\n    p2 *= norm.z;\\n    p3 *= norm.w;\\n    p4 *= taylorInvSqrt( dot( p4, p4 ) );\\n\\n    // Mix contributions from the five corners\\n    vec3 m0 = max( 0.6 - vec3( dot( x0, x0 ), dot( x1, x1 ), dot( x2, x2 ) ), 0.0 );\\n    vec2 m1 = max( 0.6 - vec2( dot( x3, x3 ), dot( x4, x4 ) ), 0.0 );\\n    m0 = m0 * m0;\\n    m1 = m1 * m1;\\n    return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\\n                + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\\n\\n}\\n\";\n\nvar noise_simplex2 = \"#include <noise_simplex_2D>\\n#include <noise_simplex_3D>\\n#include <noise_simplex_3D_grad>\\n#include <noise_simplex_4D>\\n\";\n\nvar perturbation_share2 = \"#ifdef HAS_PERTURBATIONMAP\\n  uniform sampler2D u_perturbationSampler;\\n  uniform float u_perturbationUOffset;\\n  uniform float u_perturbationVOffset;\\n#endif\\n\";\n\nvar perturbation_frag2 = \"#ifdef HAS_PERTURBATIONMAP\\n  vec2 getScreenUv(){\\n    return gl_FragCoord.xy / u_resolution;\\n  }\\n\\n  vec4 screenColor = texture2D(u_perturbationSampler, getScreenUv() + normalize(u_viewMat * vec4(normal, 1.)).xy * vec2(u_perturbationUOffset, u_perturbationVOffset));\\n  gl_FragColor = mix(screenColor, gl_FragColor, gl_FragColor.a);\\n\\n#endif\\n\";\n\nvar refraction_share2 = \"#ifdef HAS_REFRACTIONMAP\\n\\n    uniform sampler2D u_refractionSampler;\\n    uniform mat4 u_PTMMatrix;\\n    uniform float u_refractionDepth;\\n\\n#endif\\n\";\n\nvar refraction_frag2 = \"#ifdef HAS_REFRACTIONMAP\\n  vec4 refractionColor = vec4(0.);\\n  vec3 refractDir = normalize(refract(-geometry.viewDir, geometry.normal, u_refractionRatio));\\n  vec3 newPos = v_pos + refractDir * u_refractionDepth;\\n  vec4 projectionPos = u_PTMMatrix * u_projMat * u_viewMat * vec4(newPos, 1.0);\\n  vec2 projectionUv = projectionPos.xy / projectionPos.w;\\n  refractionColor = texture2D(u_refractionSampler, projectionUv);\\n  gl_FragColor = mix(refractionColor, gl_FragColor, gl_FragColor.a);\\n\\n#endif\\n\";\n\nvar clipPlane_vert_define2 = \"#ifdef O3_CLIPPLANE_NUM\\n    uniform vec4 u_clipPlanes[O3_CLIPPLANE_NUM];\\n    varying float v_clipDistances[O3_CLIPPLANE_NUM];\\n#endif\\n\";\n\nvar clipPlane_vert2 = \"#ifdef O3_CLIPPLANE_NUM\\n    for(int i = 0; i < O3_CLIPPLANE_NUM; i++){\\n        v_clipDistances[i] = dot(vec4(v_pos,1.0), u_clipPlanes[i]);\\n    }\\n#endif\\n\";\n\nvar clipPlane_frag_define2 = \"#ifdef O3_CLIPPLANE_NUM\\n    varying float v_clipDistances[O3_CLIPPLANE_NUM];\\n#endif\\n\";\n\nvar clipPlane_frag2 = \"#ifdef O3_CLIPPLANE_NUM\\n    for(int i = 0; i < O3_CLIPPLANE_NUM; i++){\\n        if(v_clipDistances[i] < 0.0){\\n            discard;\\n        }\\n    }\\n#endif\\n\";\n\nvar gamma_frag2 = \"#ifdef GAMMA\\n    float gamma = 2.2;\\n    gl_FragColor.rgb = pow(gl_FragColor.rgb, vec3(1.0 / gamma));\\n#endif\\n\";\n\nvar pbr_common_frag_define = \"#ifndef EPSILON\\n#define EPSILON 1e-6\\n#endif\\n\\n#ifndef RECIPROCAL_PI\\n    #define RECIPROCAL_PI 0.31830988618\\n#endif\\n\\n\\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\\n\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Physical\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\\t\\tRE_IndirectSpecular_Physical\\n\\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\\n\";\n\nvar pbr_util_frag_define = \"vec4 SRGBtoLINEAR(vec4 srgbIn)\\n{\\n    #ifdef MANUAL_SRGB\\n\\n        #ifdef SRGB_FAST_APPROXIMATION\\n\\n            vec3 linOut = pow(srgbIn.xyz, vec3(2.2));\\n        #else\\n\\n         vec3 bLess = step(vec3(0.04045), srgbIn.xyz);\\n         vec3 linOut = mix(srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055), vec3(2.4)), bLess);\\n\\n        #endif\\n\\n    return vec4(linOut, srgbIn.w);;\\n\\n    #else\\n\\n    return srgbIn;\\n\\n    #endif\\n}\\n\\nfloat pow2( const in float x ) {\\n    return x * x;\\n}\\n\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n    return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\n\\n// todo: enhance\\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n\\n    if( decayExponent > 0.0 ) {\\n\\n        #if defined ( PHYSICALLY_CORRECT_LIGHTS )\\n\\n        // based upon Frostbite 3 Moving to Physically-based Rendering\\n        // page 32, equation 26: E[window1]\\n        // https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\\n        // this is intended to be used on spot and point lights who are represented as luminous intensity\\n        // but who must be converted to luminous irradiance for surface lighting calculation\\n        float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n        float maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n        return distanceFalloff * maxDistanceCutoffFactor;\\n\\n        #else\\n\\n        return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n\\n        #endif\\n\\n    }\\n\\n    return 1.0;\\n\\n}\\n\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\n\\n\\treturn RECIPROCAL_PI * diffuseColor;\\n\\n}\\n\\n// source: http://simonstechblog.blogspot.ca/2011/12/microfacet-brdf.html\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\n    return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\\n}\\n\\n\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\\n    return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n\\n}\\n\\n// \\nfloat getLuminance(vec3 color)\\n{\\n    return dot(color, vec3(0.2126, 0.7152, 0.0722));\\n}\\n\";\n\nvar pbr_envmap_light_frag_define = \"#ifdef O3_HAS_ENVMAP_LIGHT\\n\\nstruct EnvMapLight {\\n    vec3 diffuse;\\n    vec3 specular;\\n    float mipMapLevel;\\n    float diffuseIntensity;\\n    float specularIntensity;\\n    mat3 transformMatrix;\\n};\\n\\n\\nuniform EnvMapLight u_envMapLight;\\n\\n#ifdef O3_USE_DIFFUSE_ENV\\n    uniform samplerCube u_env_diffuseSampler;\\n#endif\\n\\n#ifdef O3_USE_SPECULAR_ENV\\n    uniform samplerCube u_env_specularSampler;\\n#endif\\n\\n#endif\\n\";\n\nvar pbr_base_frag_define = \"#ifdef ALPHA_MASK\\nuniform float u_alphaCutoff;\\n#endif\\n\\nuniform vec4 u_baseColorFactor;\\nuniform vec2 u_metallicRoughnessValue;\\nuniform vec3 u_specularFactor;\\nuniform float u_glossinessFactor;\\n\\nuniform float u_envMapIntensity;\\nuniform float u_refractionRatio;\\n\\nuniform vec2 u_resolution;\\n\\n// todo: delete\\nuniform float u_normalScale;\\nuniform float u_occlusionStrength;\\n\\n\";\n\nvar pbr_texture_frag_define = \"#ifdef HAS_BASECOLORMAP\\n\\nuniform sampler2D u_baseColorSampler;\\n\\n#endif\\n\\n#ifdef O3_HAS_NORMALMAP\\n\\nuniform sampler2D u_normalSampler;\\n\\n#endif\\n\\n#ifdef HAS_EMISSIVEMAP\\n\\nuniform sampler2D u_emissiveSampler;\\nuniform vec3 u_emissiveFactor;\\n\\n#endif\\n\\n#ifdef HAS_METALMAP\\n\\nuniform sampler2D u_metallicSampler;\\n\\n#endif\\n\\n#ifdef HAS_ROUGHNESSMAP\\n\\nuniform sampler2D u_roughnessSampler;\\n\\n#endif\\n\\n#ifdef HAS_METALROUGHNESSMAP\\n\\nuniform sampler2D u_metallicRoughnessSampler;\\n\\n#endif\\n\\n\\n#ifdef HAS_SPECULARGLOSSINESSMAP\\n\\nuniform sampler2D u_specularGlossinessSampler;\\n\\n#endif\\n\\n#ifdef HAS_OCCLUSIONMAP\\n\\nuniform sampler2D u_occlusionSampler;\\n\\n#endif\\n\\n#ifdef HAS_OPACITYMAP\\n\\nuniform sampler2D u_opacitySampler;\\n\\n#endif\\n\\n#ifdef HAS_REFLECTIONMAP\\n\\nuniform samplerCube u_reflectionSampler;\\n\\n#endif\\n\";\n\nvar pbr_runtime_frag_define = \"struct IncidentLight {\\n    vec3 color;\\n    vec3 direction;\\n    bool visible;\\n};\\nstruct ReflectedLight {\\n    vec3 directDiffuse;\\n    vec3 directSpecular;\\n    vec3 indirectDiffuse;\\n    vec3 indirectSpecular;\\n};\\nstruct GeometricContext {\\n    vec3 position;\\n    vec3 normal;\\n    vec3 viewDir;\\n};\\nstruct PhysicalMaterial {\\n    vec3    diffuseColor;\\n    float   specularRoughness;\\n    vec3    specularColor;\\n};\\n\";\n\nvar pbr_normal_frag_define = \"vec3 getNormal()\\n{\\n  #ifdef O3_HAS_NORMALMAP\\n    #ifndef O3_HAS_TANGENT\\n        #ifdef HAS_DERIVATIVES\\n            vec3 pos_dx = dFdx(v_pos);\\n            vec3 pos_dy = dFdy(v_pos);\\n            vec3 tex_dx = dFdx(vec3(v_uv, 0.0));\\n            vec3 tex_dy = dFdy(vec3(v_uv, 0.0));\\n            vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\\n            #ifdef O3_HAS_NORMAL\\n                vec3 ng = normalize(v_normal);\\n            #else\\n                vec3 ng = normalize( cross(pos_dx, pos_dy) );\\n            #endif\\n            t = normalize(t - ng * dot(ng, t));\\n            vec3 b = normalize(cross(ng, t));\\n            mat3 tbn = mat3(t, b, ng);\\n        #else\\n            #ifdef O3_HAS_NORMAL\\n                vec3 ng = normalize(v_normal);\\n            #else\\n                vec3 ng = vec3(0.0, 0.0, 1.0);\\n            #endif\\n            mat3 tbn = mat3(vec3(0.0), vec3(0.0), ng);\\n        #endif\\n    #else\\n        mat3 tbn = v_TBN;\\n    #endif\\n        vec3 n = texture2D(u_normalSampler, v_uv ).rgb;\\n        n = normalize(tbn * ((2.0 * n - 1.0) * vec3(u_normalScale, u_normalScale, 1.0)));\\n  #else\\n    #ifdef O3_HAS_NORMAL\\n        vec3 n = normalize(v_normal);\\n    #elif defined(HAS_DERIVATIVES)\\n        vec3 pos_dx = dFdx(v_pos);\\n        vec3 pos_dy = dFdy(v_pos);\\n        vec3 n = normalize( cross(pos_dx, pos_dy) );\\n    #else\\n        vec3 n= vec3(0.0,0.0,1.0);\\n    #endif\\n  #endif\\n\\n  n *= float( gl_FrontFacing ) * 2.0 - 1.0;\\n\\n  return n;\\n}\\n\";\n\nvar pbr_brdf_cook_torrance_frag_define = \"vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\\n\\n\\t// Original approximation by Christophe Schlick '94\\n\\t// float fresnel = pow( 1.0 - dotLH, 5.0 );\\n\\n\\t// Optimized variant (presented by Epic at SIGGRAPH '13)\\n\\t// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\\n\\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\\n\\n\\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\\n\\n} // validated\\n\\n// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\\n// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\n\\tfloat a2 = pow2( alpha );\\n\\n\\t// dotNL and dotNV are explicitly swapped. This is not a mistake.\\n\\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\n\\treturn 0.5 / max( gv + gl, EPSILON );\\n\\n}\\n\\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\\n// alpha is \\\"roughness squared\\\" in Disneys reparameterization\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\\n\\tfloat a2 = pow2( alpha );\\n\\n\\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1\\n\\n\\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n\\n}\\n\\n// GGX Distribution, Schlick Fresnel, GGX-Smith Visibility\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\\n\\tfloat alpha = pow2( roughness ); // UE4's roughness\\n\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\n\\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\n\\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\\n\\tfloat D = D_GGX( alpha, dotNH );\\n\\n\\treturn F * ( G * D );\\n\\n} // validated\\n\";\n\nvar pbr_direct_irradiance_frag_define = \"void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\n    float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\n    vec3 irradiance = dotNL * directLight.color;\\n\\n    #ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\n        irradiance *= PI; // punctual light\\n\\n    #endif\\n\\n\\n\\n    reflectedLight.directSpecular += irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\\n\\n    reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\n}\\n\\n\\n\\n#ifdef O3_DIRECT_LIGHT_COUNT\\n\\n    void getDirectionalDirectLightIrradiance( const in DirectLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n        directLight.color = directionalLight.lightColor;\\n        directLight.direction = -directionalLight.direction;\\n        directLight.visible = true;\\n    }\\n\\n#endif\\n\\n#ifdef O3_POINT_LIGHT_COUNT\\n\\n\\t// directLight is an out parameter as having it as a return value caused compiler errors on some devices\\n\\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\n\\t\\tvec3 lVector = pointLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\n\\t\\tfloat lightDistance = length( lVector );\\n\\n\\t\\tdirectLight.color = pointLight.lightColor;\\n\\t\\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\\n\\t\\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\\n\\n\\t}\\n\\n#endif\\n\\n#ifdef O3_SPOT_LIGHT_COUNT\\n\\n\\t// directLight is an out parameter as having it as a return value caused compiler errors on some devices\\n\\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\\n\\n\\t\\tvec3 lVector = spotLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tfloat angleCos = dot( directLight.direction, spotLight.direction );\\n\\n\\t\\tif ( angleCos > spotLight.coneCos ) {\\n\\n\\t\\t\\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\\n\\t\\t\\tdirectLight.color = spotLight.lightColor;\\n\\t\\t\\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\\n\\t\\t\\tdirectLight.visible = true;\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tdirectLight.color = vec3( 0.0 );\\n\\t\\t\\tdirectLight.visible = false;\\n\\n\\t\\t}\\n\\t}\\n\\n\\n#endif\\n\";\n\nvar pbr_ibl_specular_frag_define = \"// ref: https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile\\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\\n    float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\n    const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\\n    const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\\n    vec4 r = roughness * c0 + c1;\\n\\n    float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\\n    vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\\n\\n    return specularColor * AB.x + AB.y;\\n\\n} // validated\\n\\n\\n// taken from here: http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html\\nfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\\n    //float envMapWidth = pow( 2.0, maxMIPLevelScalar );\\n    //float desiredMIPLevel = log2( envMapWidth * sqrt( 3.0 ) ) - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\\n\\n    float maxMIPLevelScalar = float( maxMIPLevel );\\n    float desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\\n\\n    // clamp to allowable LOD ranges.\\n    return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\\n\\n}\\n\\n#ifdef O3_HAS_ENVMAP_LIGHT\\n\\nvec3 getLightProbeIndirectRadiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\\n    #if !defined(O3_USE_SPECULAR_ENV) && !defined(HAS_REFLECTIONMAP)\\n\\n        return u_envMapLight.specular * u_envMapLight.specularIntensity * u_envMapIntensity;\\n\\n    #else\\n\\n    #ifdef ENVMAPMODE_REFRACT\\n\\n        vec3 reflectVec = refract( -geometry.viewDir, geometry.normal, u_refractionRatio );\\n\\n    #else\\n\\n        vec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\\n\\n    #endif\\n//        reflectVec = inverseTransformDirection( reflectVec, u_viewMat );\\n\\n        reflectVec =  u_envMapLight.transformMatrix * reflectVec;\\n\\n        float specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\\n\\n        #ifdef HAS_TEX_LOD\\n            #ifdef HAS_REFLECTIONMAP\\n                 vec4 envMapColor = textureCubeLodEXT( u_reflectionSampler, reflectVec, specularMIPLevel );\\n            #else\\n                vec4 envMapColor = textureCubeLodEXT( u_env_specularSampler, reflectVec, specularMIPLevel );\\n            #endif\\n\\n        #else\\n            #ifdef HAS_REFLECTIONMAP\\n                 vec4 envMapColor = textureCube( u_reflectionSampler, reflectVec, specularMIPLevel );\\n            #else\\n                 vec4 envMapColor = textureCube( u_env_specularSampler, reflectVec, specularMIPLevel );\\n            #endif\\n        #endif\\n\\n        envMapColor.rgb = SRGBtoLINEAR( envMapColor * u_envMapLight.specularIntensity * u_envMapIntensity).rgb;\\n\\n        return envMapColor.rgb;\\n\\n    #endif\\n\\n}\\n#endif\\n\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\n    float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n    float dotNL = dotNV;\\n\\n\\treflectedLight.indirectSpecular += radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\\n\\n}\\n\";\n\nvar pbr_ibl_diffuse_frag_define = \"void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\n    reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\n}\\n\\n#ifdef O3_HAS_AMBIENT_LIGHT\\n\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\\n    vec3 irradiance = ambientLightColor;\\n\\n    #ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\n        irradiance *= PI;\\n\\n    #endif\\n\\n    return irradiance;\\n\\n}\\n\\n#endif\\n\";\n\nvar pbr_begin_frag = \"    vec3 normal = getNormal();\\n    vec4 diffuseColor = u_baseColorFactor;\\n    vec3 totalEmissiveRadiance = vec3(0.0);\\n    float metalnessFactor = u_metallicRoughnessValue.r;\\n    float roughnessFactor = u_metallicRoughnessValue.g;\\n    vec3 specularFactor = u_specularFactor;\\n    float glossinessFactor = u_glossinessFactor;\\n\\n    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n    PhysicalMaterial material;\\n    GeometricContext geometry;\\n    IncidentLight directLight;\\n\\n    #ifdef HAS_BASECOLORMAP\\n\\n        vec4 baseMapColor = texture2D( u_baseColorSampler, v_uv );\\n        baseMapColor = SRGBtoLINEAR( baseMapColor );\\n        diffuseColor *= baseMapColor;\\n\\n    #endif\\n\\n    #ifdef O3_HAS_VERTEXCOLOR\\n\\n        diffuseColor.rgb *= v_color.rgb;\\n\\n        #ifdef O3_HAS_VERTEXALPHA\\n\\n            diffuseColor.a *= v_color.a;\\n\\n        #endif\\n\\n    #endif\\n\\n    #ifdef ALPHA_MASK\\n\\n        if( diffuseColor.a < u_alphaCutoff ) {\\n            discard;\\n        }\\n\\n    #endif\\n\\n\\n    #if defined(ALPHA_BLEND) && defined(HAS_OPACITYMAP)\\n\\n        #ifdef GETOPACITYFROMRGB\\n            diffuseColor.a *= getLuminance(texture2D( u_opacitySampler, v_uv ).rgb);\\n        #else\\n            diffuseColor.a *= texture2D( u_opacitySampler, v_uv ).a;\\n        #endif\\n\\n    #endif\\n\\n    #ifdef UNLIT\\n\\n        gl_FragColor = vec4( diffuseColor.rgb, diffuseColor.a );\\n\\n    #else\\n\\n\\n\\n        #ifdef HAS_METALROUGHNESSMAP\\n\\n            vec4 metalRoughMapColor = texture2D( u_metallicRoughnessSampler, v_uv );\\n            metalnessFactor *= metalRoughMapColor.b;\\n            roughnessFactor *= metalRoughMapColor.g;\\n\\n        #else\\n            #ifdef HAS_METALMAP\\n\\n            vec4 metalMapColor = texture2D( u_metallicSampler, v_uv );\\n            metalnessFactor *= metalMapColor.b;\\n\\n            #endif\\n\\n            #ifdef HAS_ROUGHNESSMAP\\n\\n            vec4 roughMapColor = texture2D( u_roughnessSampler, v_uv );\\n            roughnessFactor *= roughMapColor.g;\\n\\n            #endif\\n        #endif\\n\\n        #ifdef HAS_SPECULARGLOSSINESSMAP\\n\\n            vec4 specularGlossinessColor = texture2D(u_specularGlossinessSampler, v_uv );\\n            specularFactor *= specularGlossinessColor.rgb;\\n            glossinessFactor *= specularGlossinessColor.a;\\n\\n        #endif\\n\\n\\n        #ifdef IS_METALLIC_WORKFLOW\\n            material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\n            material.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\\n//          material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\\n            material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT /* pow2( reflectivity )*/ ), diffuseColor.rgb, metalnessFactor );\\n        #else\\n            float specularStrength = max( max( specularFactor.r, specularFactor.g ), specularFactor.b );\\n            material.diffuseColor = diffuseColor.rgb * ( 1.0 - specularStrength );\\n            material.specularRoughness = clamp( 1.0 - glossinessFactor, 0.04, 1.0 );\\n            material.specularColor = specularFactor;\\n        #endif\\n\\n        geometry.position = v_pos;\\n        geometry.normal = normal;\\n        geometry.viewDir = normalize( u_cameraPos - v_pos );\\n\";\n\nvar pbr_direct_irradiance_frag = \"        #if defined( O3_DIRECT_LIGHT_COUNT ) && defined( RE_Direct )\\n\\n            DirectLight directionalLight;\\n\\n            for ( int i = 0; i < O3_DIRECT_LIGHT_COUNT; i ++ ) {\\n\\n                directionalLight = u_directLights[ i ];\\n\\n                getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\\n                RE_Direct( directLight, geometry, material, reflectedLight );\\n\\n            }\\n\\n        #endif\\n\\n        #if defined( O3_POINT_LIGHT_COUNT ) && defined( RE_Direct )\\n\\n            PointLight pointLight;\\n\\n            for ( int i = 0; i < O3_POINT_LIGHT_COUNT; i ++ ) {\\n\\n                pointLight = u_pointLights[ i ];\\n\\n                getPointDirectLightIrradiance( pointLight, geometry, directLight );\\n\\n                RE_Direct( directLight, geometry, material, reflectedLight );\\n\\n            }\\n\\n        #endif\\n\\n        #if defined( O3_SPOT_LIGHT_COUNT ) && defined( RE_Direct )\\n\\n            SpotLight spotLight;\\n\\n            for ( int i = 0; i < O3_SPOT_LIGHT_COUNT; i ++ ) {\\n\\n                spotLight = u_spotLights[ i ];\\n\\n                getSpotDirectLightIrradiance( spotLight, geometry, directLight );\\n\\n                RE_Direct( directLight, geometry, material, reflectedLight );\\n\\n            }\\n\\n        #endif\\n\";\n\nvar pbr_ibl_diffuse_frag = \"#if defined(RE_IndirectDiffuse)\\n\\n    vec3 irradiance = vec3(0);\\n\\n    #if defined(O3_HAS_AMBIENT_LIGHT)\\n        irradiance += getAmbientLightIrradiance(u_ambientLight.lightColor);\\n    #endif\\n\\n    #if defined(O3_HAS_ENVMAP_LIGHT)\\n\\n        #ifdef O3_USE_DIFFUSE_ENV\\n            vec3 lightMapIrradiance = textureCube(u_env_diffuseSampler, geometry.normal).rgb * u_envMapLight.diffuseIntensity;\\n        #else\\n            vec3 lightMapIrradiance = u_envMapLight.diffuse * u_envMapLight.diffuseIntensity;\\n        #endif\\n\\n        #ifndef PHYSICALLY_CORRECT_LIGHTS\\n            lightMapIrradiance *= PI;\\n        #endif\\n\\n        irradiance += lightMapIrradiance;\\n\\n    #endif\\n\\n    RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\n\\n#endif\\n\\n\\n\";\n\nvar pbr_ibl_specular_frag = \"#if defined( RE_IndirectSpecular )\\n\\n    vec3 radiance = vec3( 0.0 );\\n\\n#endif\\n\\n\\n\\n#if defined( O3_HAS_ENVMAP_LIGHT ) && defined( RE_IndirectSpecular )\\n\\n    radiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), int(u_envMapLight.mipMapLevel) );\\n\\n#endif\\n\\n\\n#if defined( RE_IndirectSpecular )\\n\\n    RE_IndirectSpecular( radiance, geometry, material, reflectedLight );\\n\\n#endif\\n\";\n\nvar pbr_end_frag = \"#ifdef HAS_OCCLUSIONMAP\\n\\n    float ambientOcclusion = (texture2D(u_occlusionSampler, v_uv).r - 1.0) * u_occlusionStrength + 1.0;\\n    reflectedLight.indirectDiffuse *= ambientOcclusion;\\n\\n    #if defined(O3_USE_SPECULAR_ENV)\\n\\n        float dotNV = saturate(dot(geometry.normal, geometry.viewDir));\\n        reflectedLight.indirectSpecular *= computeSpecularOcclusion(dotNV, ambientOcclusion, material.specularRoughness);\\n\\n    #endif\\n\\n#endif\\n\\n#ifdef HAS_EMISSIVEMAP\\n\\n    vec4 emissiveMapColor = texture2D(u_emissiveSampler, v_uv);\\n    emissiveMapColor = SRGBtoLINEAR(emissiveMapColor);\\n    totalEmissiveRadiance += u_emissiveFactor * emissiveMapColor.rgb;\\n\\n#endif\\n\\nvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\ngl_FragColor = vec4(outgoingLight, diffuseColor.a);\\n\\n#endif\\n\";\n\nvar PBRShaderLib = {\n  pbr_common_frag_define,\n  pbr_util_frag_define,\n  pbr_envmap_light_frag_define,\n  pbr_base_frag_define,\n  pbr_texture_frag_define,\n  pbr_runtime_frag_define,\n  pbr_normal_frag_define,\n  pbr_brdf_cook_torrance_frag_define,\n  pbr_direct_irradiance_frag_define,\n  pbr_ibl_specular_frag_define,\n  pbr_ibl_diffuse_frag_define,\n  pbr_begin_frag,\n  pbr_direct_irradiance_frag,\n  pbr_ibl_diffuse_frag,\n  pbr_ibl_specular_frag,\n  pbr_end_frag\n};\n\nvar oit_frag2 = \"#if defined(ALPHA_BLEND) && defined(OIT_ENABLE)\\n    if(gl_FragCoord.z > texture2D(u_depthSampler, gl_FragCoord.xy / u_resolution).r){\\n        discard;\\n    }\\n    vec4 oitColor = gl_FragColor;\\n\\n    // Bavoil and Myers Method\\n    gl_FragData[0]= vec4(oitColor.rgb * oitColor.a, oitColor.a);\\n    gl_FragData[1]= vec4(1)/ 255.0; // \\n\\n\\n    // Depth Weights Improve Occlusion\\n//    float w = weight(gl_FragCoord.z, oitColor.a);\\n//    gl_FragData[0] = vec4(oitColor.rgb * oitColor.a * w, oitColor.a);\\n//    gl_FragData[1].r =oitColor.a * w;\\n#endif\\n\";\n\nvar oit_frag_define2 = \"#if defined(ALPHA_BLEND) && defined(OIT_ENABLE)\\n\\n    uniform sampler2D u_depthSampler;\\n\\n    float weight(float z, float a) {\\n        return a * clamp(3e3 * pow(1.0 - z, 3.0), 1e-2, 3e3);\\n//          return pow(z,-5.0);\\n    }\\n#endif\\n\";\n\nconst ShaderLib = {\n  common: common2,\n  common_vert: common_vert2,\n  common_frag: common_frag2,\n  color_share: color_share2,\n  normal_share: normal_share2,\n  uv_share: uv_share2,\n  worldpos_share: worldpos_share2,\n  shadow_share: shadow_share2,\n  fog_share: fog_share2,\n  begin_normal_vert: begin_normal_vert2,\n  begin_position_vert: begin_position_vert2,\n  morph_target_vert: morph_target_vert2,\n  position_vert: position_vert2,\n  color_vert: color_vert2,\n  normal_vert: normal_vert2,\n  skinning_vert: skinning_vert2,\n  uv_vert: uv_vert2,\n  worldpos_vert: worldpos_vert2,\n  shadow_vert: shadow_vert2,\n  morph_vert: morph_vert2,\n  fog_vert: fog_vert2,\n  ambient_light_frag: ambient_light_frag2,\n  direct_light_frag: direct_light_frag2,\n  point_light_frag: point_light_frag2,\n  spot_light_frag: spot_light_frag2,\n  mobile_material_frag: mobile_material_frag2,\n  fog_frag: fog_frag2,\n  begin_mobile_frag: begin_mobile_frag2,\n  begin_normal_frag: begin_normal_frag2,\n  begin_viewdir_frag: begin_viewdir_frag2,\n  mobile_blinnphong_frag: mobile_blinnphong_frag2,\n  mobile_lambert_frag: mobile_lambert_frag2,\n  noise_common: noise_common2,\n  noise_cellular_2D: noise_cellular_2D2,\n  noise_cellular_2x2: noise_cellular_2x22,\n  noise_cellular_2x2x2: noise_cellular_2x2x22,\n  noise_cellular_3D: noise_cellular_3D2,\n  noise_cellular: noise_cellular2,\n  noise_perlin_2D: noise_perlin_2D2,\n  noise_perlin_3D: noise_perlin_3D2,\n  noise_perlin_4D: noise_perlin_4D2,\n  noise_perlin: noise_perlin2,\n  noise_psrd_2D: noise_psrd_2D2,\n  noise_simplex_2D: noise_simplex_2D2,\n  noise_simplex_3D_grad: noise_simplex_3D_grad2,\n  noise_simplex_3D: noise_simplex_3D2,\n  noise_simplex_4D: noise_simplex_4D2,\n  noise_simplex: noise_simplex2,\n  perturbation_share: perturbation_share2,\n  perturbation_frag: perturbation_frag2,\n  refraction_share: refraction_share2,\n  refraction_frag: refraction_frag2,\n  clipPlane_vert_define: clipPlane_vert_define2,\n  clipPlane_vert: clipPlane_vert2,\n  clipPlane_frag_define: clipPlane_frag_define2,\n  clipPlane_frag: clipPlane_frag2,\n  gamma_frag: gamma_frag2,\n  oit_frag: oit_frag2,\n  oit_frag_define: oit_frag_define2,\n  ...PBRShaderLib\n};\nfunction InjectShaderSlices(obj) {\n  Object.assign(ShaderLib, obj);\n}\n\nclass ShaderFactory {\n  static parseVersion(version = \"100\") {\n    return `#version ${version}\n`;\n  }\n  static parsePrecision(vertP, fragP, compileVert) {\n    const downgrade = \"mediump\";\n    return `\n        #ifdef GL_FRAGMENT_PRECISION_HIGH\n          precision ${compileVert ? vertP : fragP} float;\n          precision ${compileVert ? vertP : fragP} int;\n\n          #define O3_VERTEX_PRECISION ${vertP}\n          #define O3_FRAGMENT_PRECISION ${fragP}\n        #else\n          precision ${downgrade} float;\n          precision ${downgrade} int;\n\n          #define O3_VERTEX_PRECISION ${downgrade}\n          #define O3_FRAGMENT_PRECISION ${downgrade}\n        #endif\n      `;\n  }\n  static parseShaderName(name) {\n    return `#define O3_SHADER_NAME ${name}\n`;\n  }\n  static parseAttributeMacros(macros) {\n    return \"#define O3_ATTRIBUTE_MACROS_START\\n\" + macros.map((m) => `#define ${m}\n`).join(\"\") + \"#define O3_ATTRIBUTE_MACROS_END\\n\";\n  }\n  static parseCustomMacros(macros) {\n    return \"#define O3_CUSTOM_MACROS_START\\n\" + macros.map((m) => `#define ${m}\n`).join(\"\") + \"#define O3_CUSTOM_MACROS_END\\n\";\n  }\n  static parseShader(src) {\n    return ShaderFactory.parseIncludes(src);\n  }\n  static parseIncludes(src) {\n    const regex = /^[ \\t]*#include +<([\\w\\d.]+)>/gm;\n    function replace(match, slice) {\n      var replace2 = ShaderLib[slice];\n      if (replace2 === void 0) {\n        Logger.error(`Shader slice \"${match.trim()}\" not founded.`);\n        return \"\";\n      }\n      return ShaderFactory.parseIncludes(replace2);\n    }\n    return src.replace(regex, replace);\n  }\n  static InjectShaderSlices(slices) {\n    InjectShaderSlices(slices);\n  }\n  static parseExtension(extensions) {\n    return `#define O3_EXTENSION_START\n` + extensions.map((e) => `#extension ${e} : enable\n`).join(\"\") + `#define O3_EXTENSION_END\n`;\n  }\n  static convertTo300(shader, isFrag) {\n    const isGLSL300 = shader.includes(\"#version 300 es\");\n    if (isGLSL300)\n      return shader;\n    shader = shader.replace(/#version 100/, \"#version 300 es\");\n    shader = shader.replace(/\\battribute\\b/g, \"in\");\n    shader = shader.replace(/\\bvarying\\b/g, isFrag ? \"in\" : \"out\");\n    shader = shader.replace(/\\btexture(2D|Cube)\\s*\\(/g, \"texture(\");\n    shader = shader.replace(/\\btexture(2D|Cube)LodEXT\\s*\\(/g, \"textureLod(\");\n    if (isFrag) {\n      const isMRT = /\\bgl_FragData\\[.+?\\]/g.test(shader);\n      if (isMRT) {\n        shader = shader.replace(/\\bgl_FragColor\\b/g, \"gl_FragData[0]\");\n        const result = shader.match(/\\bgl_FragData\\[.+?\\]/g);\n        shader = this.replaceMRTShader(shader, result);\n      } else {\n        shader = shader.replace(/void\\s+?main\\s*\\(/g, `out vec4 glFragColor;\nvoid main(`);\n        shader = shader.replace(/\\bgl_FragColor\\b/g, \"glFragColor\");\n      }\n    }\n    return shader;\n  }\n  static getMaxDrawBuffers(shader) {\n    const mrtIndexSet = new Set();\n    const result = shader.match(/\\bgl_FragData\\[.+?\\]/g) || [];\n    for (let i = 0; i < result.length; i++) {\n      const res = result[i].match(/\\bgl_FragData\\[(.+?)\\]/);\n      mrtIndexSet.add(res[1]);\n    }\n    return mrtIndexSet.size;\n  }\n  static compatible(fragmentShader) {\n    const hasFragData = /\\bgl_FragData\\[.+?\\]/g.test(fragmentShader);\n    if (hasFragData) {\n      fragmentShader = fragmentShader.replace(/\\bgl_FragColor\\b/g, \"gl_FragData[0]\");\n    }\n    return fragmentShader;\n  }\n  static replaceMRTShader(shader, result) {\n    let declaration = \"\";\n    const mrtIndexSet = new Set();\n    for (let i = 0; i < result.length; i++) {\n      const res = result[i].match(/\\bgl_FragData\\[(.+?)\\]/);\n      mrtIndexSet.add(res[1]);\n    }\n    mrtIndexSet.forEach((index) => {\n      declaration += `layout(location=${index}) out vec4 fragOutColor${index};\n`;\n    });\n    declaration += `void main(`;\n    shader = shader.replace(/\\bgl_FragData\\[(.+?)\\]/g, \"fragOutColor$1\");\n    shader = shader.replace(/void\\s+?main\\s*\\(/g, declaration);\n    return shader;\n  }\n}\n\nclass RenderTechnique extends AssetObject {\n  constructor(name) {\n    super(null);\n    this.name = name;\n    this.isValid = false;\n    this._uniforms = RenderTechnique.commonUniforms;\n    this._attributes = RenderTechnique.commonAttributes;\n    this.states = null;\n    this.vertexShader = \"\";\n    this.fragmentShader = \"\";\n    this.version = \"100\";\n    this.autoConvert = true;\n    this.vertexPrecision = \"highp\";\n    this.fragmentPrecision = \"mediump\";\n    this.customMacros = [];\n    this.shaderExtension100 = [\"GL_EXT_shader_texture_lod\", \"GL_OES_standard_derivatives\", \"GL_EXT_draw_buffers\"];\n    this.shaderExtension300 = [];\n    this._needCompile = true;\n  }\n  get attributes() {\n    return this._attributes;\n  }\n  set attributes(v) {\n    this._attributes = Object.assign({}, RenderTechnique.commonAttributes, v);\n  }\n  get uniforms() {\n    return this._uniforms;\n  }\n  set uniforms(v) {\n    this._uniforms = Object.assign({}, RenderTechnique.commonUniforms, v);\n  }\n  compile(camera, component, primitive, material) {\n    this.parseFog(camera);\n    if (this._needCompile) {\n      const rhi = camera.engine._hardwareRenderer;\n      const isWebGL2 = rhi?.isWebGL2;\n      material.preCompile?.(this);\n      const attribMacros = this.getAttributeDefines(camera, component, primitive, material);\n      if (this._recreateHeader) {\n        this.attributes = this.attributes;\n        this.uniforms = this.uniforms;\n      }\n      if (!this._vsHeader || this._recreateHeader)\n        this._vsHeader = ShaderFactory.parseVersion(this.version) + ShaderFactory.parseShaderName((this.name || \"VOID\").toUpperCase() + \"_VERT\") + \"\\n\" + ShaderFactory.parsePrecision(this.vertexPrecision, this.fragmentPrecision, true) + \"\\n\" + ShaderFactory.parseAttributeMacros(attribMacros) + \"\\n\" + ShaderFactory.parseCustomMacros(this.customMacros) + \"\\n\";\n      if (!this._vsCode)\n        this._vsCode = ShaderFactory.parseShader(this.vertexShader);\n      this.vertexShader = this._vsHeader + this._vsCode;\n      if (!this._fsHeader || this._recreateHeader)\n        this._fsHeader = ShaderFactory.parseVersion(this.version) + ShaderFactory.parseShaderName((this.name || \"VOID\").toUpperCase() + \"_FRAG\") + \"\\n\" + ShaderFactory.parseExtension(isWebGL2 ? this.shaderExtension300 : this.shaderExtension100) + ShaderFactory.parsePrecision(this.vertexPrecision, this.fragmentPrecision) + \"\\n\" + ShaderFactory.parseAttributeMacros(attribMacros) + \"\\n\" + ShaderFactory.parseCustomMacros(this.customMacros) + \"\\n\";\n      if (!this._fsCode)\n        this._fsCode = ShaderFactory.parseShader(this.fragmentShader);\n      this.fragmentShader = this._fsHeader + this._fsCode;\n      if (this.autoConvert && isWebGL2 && this.version !== \"300 es\") {\n        const maxDrawBuffers = rhi.capability.maxDrawBuffers;\n        const shaderMaxDrawBuffers = ShaderFactory.getMaxDrawBuffers(this.fragmentShader);\n        if (shaderMaxDrawBuffers <= maxDrawBuffers) {\n          this.vertexShader = ShaderFactory.convertTo300(this.vertexShader);\n          this.fragmentShader = ShaderFactory.convertTo300(this.fragmentShader, true);\n        }\n      } else if (!isWebGL2 && this.version !== \"300es\") {\n        this.fragmentShader = ShaderFactory.compatible(this.fragmentShader);\n      }\n      this._needCompile = false;\n      this._recreateHeader = false;\n      material.postCompile?.(this);\n    }\n  }\n  getAttributeDefines(camera, component, primitive, material) {\n    const rhi = camera.scene.engine._hardwareRenderer;\n    const gl = rhi.gl;\n    const _macros = [];\n    if (!primitive)\n      return _macros;\n    const attribNames = Object.keys(primitive._vertexElementMap);\n    if (attribNames.indexOf(\"TEXCOORD_0\") > -1)\n      _macros.push(\"O3_HAS_UV\");\n    if (attribNames.indexOf(\"NORMAL\") > -1)\n      _macros.push(\"O3_HAS_NORMAL\");\n    if (attribNames.indexOf(\"TANGENT\") > -1)\n      _macros.push(\"O3_HAS_TANGENT\");\n    if (attribNames.indexOf(\"JOINTS_0\") > -1) {\n      _macros.push(\"O3_HAS_SKIN\");\n      if (component.jointNodes?.length) {\n        const maxAttribUniformVec4 = rhi.renderStates.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);\n        const maxJoints = Math.floor((maxAttribUniformVec4 - 20) / 4);\n        const joints = component.jointNodes.length;\n        if (joints > maxJoints) {\n          if (rhi.canIUseMoreJoints) {\n            _macros.push(\"O3_USE_JOINT_TEXTURE\");\n          } else {\n            Logger.error(`component's joints count(${joints}) greater than device's MAX_VERTEX_UNIFORM_VECTORS number ${maxAttribUniformVec4}, suggest joint count less than ${maxJoints}.`, component);\n          }\n        } else if (material.maxJointsNum > 0) {\n          _macros.push(`O3_JOINTS_NUM ${material.maxJointsNum}`);\n        }\n      }\n    }\n    if (attribNames.indexOf(\"COLOR_0\") > -1) {\n      _macros.push(\"O3_HAS_VERTEXCOLOR\");\n      if (primitive._vertexElementMap[\"COLOR_0\"].format === VertexElementFormat.Vector4)\n        _macros.push(\"O3_HAS_VERTEXALPHA\");\n    }\n    const scene = camera.scene;\n    if (scene.hasFogFeature) {\n      _macros.push(...scene.getFogMacro());\n    }\n    return _macros;\n  }\n  parseFog(camera) {\n    const scene = camera.scene;\n    if (scene.hasFogFeature) {\n      const fogMacro = scene.getFogMacro();\n      if (this._fogMacro !== fogMacro) {\n        this._needCompile = true;\n        this._recreateHeader = true;\n        this._fogMacro = fogMacro;\n      }\n    }\n  }\n  createMorphConfig(primitive, targetNum) {\n    const attributes = Object.keys(primitive._vertexElementMap);\n    const morphConfig = {};\n    for (let i = 0; i < targetNum; i++) {\n      if (attributes.indexOf(`POSITION_${i}`) > -1)\n        morphConfig[`a_position${i}`] = {\n          name: `a_position${i}`,\n          semantic: `POSITION_${i}`,\n          type: DataType.FLOAT_VEC3\n        };\n      if (attributes.indexOf(`NORMAL_${i}`) > -1)\n        morphConfig[`a_normal${i}`] = {\n          name: `a_normal${i}`,\n          semantic: `NORMAL_${i}`,\n          type: DataType.FLOAT_VEC3\n        };\n      if (attributes.indexOf(`TANGENT_${i}`) > -1)\n        morphConfig[`a_tangent${i}`] = {\n          name: `a_tangent${i}`,\n          semantic: `TANGENT_${i}`,\n          type: DataType.FLOAT_VEC3\n        };\n    }\n    return morphConfig;\n  }\n  _finalize() {\n    if (this._glTechnique) {\n      this._glTechnique.finalize(true);\n      this._glTechnique = null;\n    }\n  }\n}\nRenderTechnique.commonAttributes = {\n  a_position: {\n    name: \"a_position\",\n    semantic: \"POSITION\",\n    type: DataType.FLOAT_VEC3\n  },\n  a_uv: {\n    name: \"a_uv\",\n    semantic: \"TEXCOORD_0\",\n    type: DataType.FLOAT_VEC2\n  },\n  a_normal: {\n    name: \"a_noraml\",\n    semantic: \"NORMAL\",\n    type: DataType.FLOAT_VEC3\n  },\n  a_tangent: {\n    name: \"a_tangent\",\n    semantic: \"TANGENT\",\n    type: DataType.FLOAT_VEC4\n  },\n  a_color: {\n    name: \"a_color\",\n    semantic: \"COLOR_0\",\n    type: DataType.FLOAT_VEC4\n  },\n  a_joint: {\n    name: \"a_joint\",\n    semantic: \"JOINTS_0\",\n    type: DataType.FLOAT_VEC4\n  },\n  a_weight: {\n    name: \"a_weight\",\n    semantic: \"WEIGHTS_0\",\n    type: DataType.FLOAT_VEC4\n  }\n};\nRenderTechnique.commonUniforms = {\n  u_localMat: {\n    name: \"u_localMat\",\n    semantic: UniformSemantic.LOCAL,\n    type: DataType.FLOAT_MAT4\n  },\n  u_modelMat: {\n    name: \"u_modelMat\",\n    semantic: UniformSemantic.MODEL,\n    type: DataType.FLOAT_MAT4\n  },\n  u_viewMat: {\n    name: \"u_viewMat\",\n    semantic: UniformSemantic.VIEW,\n    type: DataType.FLOAT_MAT4\n  },\n  u_projMat: {\n    name: \"u_projMat\",\n    semantic: UniformSemantic.PROJECTION,\n    type: DataType.FLOAT_MAT4\n  },\n  u_MVMat: {\n    name: \"u_MVMat\",\n    semantic: UniformSemantic.MODELVIEW,\n    type: DataType.FLOAT_MAT4\n  },\n  u_MVPMat: {\n    name: \"u_MVPMat\",\n    semantic: UniformSemantic.MODELVIEWPROJECTION,\n    type: DataType.FLOAT_MAT4\n  },\n  u_normalMat: {\n    name: \"u_normalMat\",\n    semantic: UniformSemantic.MODELINVERSETRANSPOSE,\n    type: DataType.FLOAT_MAT3\n  },\n  u_cameraPos: {\n    name: \"u_cameraPos\",\n    type: DataType.FLOAT_VEC3,\n    semantic: UniformSemantic.EYEPOS\n  },\n  u_time: {\n    name: \"u_time\",\n    type: DataType.FLOAT,\n    semantic: UniformSemantic.TIME\n  },\n  u_jointMatrix: {\n    name: \"u_jointMatrix\",\n    semantic: UniformSemantic.JOINTMATRIX,\n    type: DataType.FLOAT_MAT4_ARRAY\n  },\n  u_jointSampler: {\n    name: \"u_jointSampler\",\n    semantic: UniformSemantic.JOINTTEXTURE,\n    type: DataType.SAMPLER_2D\n  },\n  u_jointCount: {\n    name: \"u_jointCount\",\n    semantic: UniformSemantic.JOINTCOUNT,\n    type: DataType.FLOAT\n  },\n  u_fogColor: {\n    name: \"u_fogColor\",\n    type: DataType.FLOAT_VEC3\n  },\n  u_fogDensity: {\n    name: \"u_fogDensity\",\n    type: DataType.FLOAT\n  },\n  u_fogNear: {\n    name: \"u_fogNear\",\n    type: DataType.FLOAT\n  },\n  u_fogFar: {\n    name: \"u_fogFar\",\n    type: DataType.FLOAT\n  }\n};\n\nvar TextureCubeFace;\n(function(TextureCubeFace2) {\n  TextureCubeFace2[TextureCubeFace2[\"PositiveX\"] = 0] = \"PositiveX\";\n  TextureCubeFace2[TextureCubeFace2[\"NegativeX\"] = 1] = \"NegativeX\";\n  TextureCubeFace2[TextureCubeFace2[\"PositiveY\"] = 2] = \"PositiveY\";\n  TextureCubeFace2[TextureCubeFace2[\"NegativeY\"] = 3] = \"NegativeY\";\n  TextureCubeFace2[TextureCubeFace2[\"PositiveZ\"] = 4] = \"PositiveZ\";\n  TextureCubeFace2[TextureCubeFace2[\"NegativeZ\"] = 5] = \"NegativeZ\";\n})(TextureCubeFace || (TextureCubeFace = {}));\n\nclass TextureCubeMap extends Texture {\n  constructor(engine, size, format = TextureFormat.R8G8B8A8, mipmap = true) {\n    super(engine);\n    this._compressedFaceFilled = [0, 0, 0, 0, 0, 0];\n    const rhi = engine._hardwareRenderer;\n    const gl = rhi.gl;\n    const isWebGL2 = rhi.isWebGL2;\n    if (!Texture._supportTextureFormat(format, rhi)) {\n      throw new Error(`Texture format is not supported:${TextureFormat[format]}`);\n    }\n    if (mipmap && !isWebGL2 && !Texture._isPowerOf2(size)) {\n      Logger.warn(\"non-power-2 texture is not supported for mipmap in WebGL1,and has automatically downgraded to non-mipmap\");\n      mipmap = false;\n    }\n    const formatDetail = Texture._getFormatDetail(format, gl, isWebGL2);\n    this._glTexture = gl.createTexture();\n    this._formatDetail = formatDetail;\n    this._rhi = rhi;\n    this._target = gl.TEXTURE_CUBE_MAP;\n    this._mipmap = mipmap;\n    this._width = size;\n    this._height = size;\n    this._format = format;\n    this._mipmapCount = this._getMipmapCount();\n    formatDetail.isCompressed && !isWebGL2 || this._initMipmap(true);\n    this.filterMode = TextureFilterMode.Bilinear;\n    this.wrapModeU = this.wrapModeV = TextureWrapMode.Clamp;\n  }\n  get format() {\n    return this._format;\n  }\n  setPixelBuffer(face, colorBuffer, mipLevel = 0, x, y, width, height) {\n    const gl = this._rhi.gl;\n    const isWebGL2 = this._rhi.isWebGL2;\n    const {internalFormat, baseFormat, dataType, isCompressed} = this._formatDetail;\n    const mipSize = Math.max(1, this._width >> mipLevel);\n    x = x || 0;\n    y = y || 0;\n    width = width || mipSize - x;\n    height = height || mipSize - y;\n    this._bind();\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0);\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);\n    if (isCompressed) {\n      const mipBit = 1 << mipLevel;\n      if (isWebGL2 || this._compressedFaceFilled[face] & mipBit) {\n        gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, x, y, width, height, internalFormat, colorBuffer);\n      } else {\n        gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, internalFormat, width, height, 0, colorBuffer);\n        this._compressedFaceFilled[face] |= mipBit;\n      }\n    } else {\n      gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, x, y, width, height, baseFormat, dataType, colorBuffer);\n    }\n    this._unbind();\n  }\n  setImageSource(face, imageSource, mipLevel = 0, flipY = false, premultiplyAlpha = false, x, y) {\n    const gl = this._rhi.gl;\n    const {baseFormat, dataType} = this._formatDetail;\n    this._bind();\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, +flipY);\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, +premultiplyAlpha);\n    gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, x || 0, y || 0, baseFormat, dataType, imageSource);\n    this._unbind();\n  }\n  getPixelBuffer(face, x, y, width, height, out) {\n    if (this._formatDetail.isCompressed) {\n      throw new Error(\"Unable to read compressed texture\");\n    }\n    super._getPixelBuffer(face, x, y, width, height, out);\n  }\n}\n\nclass RenderDepthTexture extends Texture {\n  constructor(engine, width, height, format = RenderBufferDepthFormat.Depth, mipmap = false, isCube = false) {\n    super(engine);\n    this._isCube = false;\n    this._autoMipmap = false;\n    const rhi = engine._hardwareRenderer;\n    const gl = rhi.gl;\n    const isWebGL2 = rhi.isWebGL2;\n    if (!Texture._supportRenderBufferDepthFormat(format, rhi, true)) {\n      throw new Error(`RenderBufferDepthFormat is not supported:${RenderBufferDepthFormat[format]}`);\n    }\n    if (isCube && width !== height) {\n      throw new Error(\"The cube texture must have the same width and height\");\n    }\n    if (mipmap && !isWebGL2 && (!Texture._isPowerOf2(width) || !Texture._isPowerOf2(height))) {\n      Logger.warn(\"non-power-2 texture is not supported for mipmap in WebGL1,and has automatically downgraded to non-mipmap\");\n      mipmap = false;\n    }\n    this._glTexture = gl.createTexture();\n    this._formatDetail = Texture._getRenderBufferDepthFormatDetail(format, gl, isWebGL2);\n    this._isCube = isCube;\n    this._rhi = rhi;\n    this._target = isCube ? gl.TEXTURE_CUBE_MAP : gl.TEXTURE_2D;\n    this._mipmap = mipmap;\n    this._width = width;\n    this._height = height;\n    this._format = format;\n    this._mipmapCount = this._getMipmapCount();\n    this._initMipmap(isCube);\n    this.filterMode = TextureFilterMode.Bilinear;\n    this.wrapModeU = this.wrapModeV = TextureWrapMode.Clamp;\n  }\n  get format() {\n    return this._format;\n  }\n  get autoGenerateMipmaps() {\n    return this._autoMipmap;\n  }\n  set autoGenerateMipmaps(value) {\n    this._autoMipmap = value;\n  }\n}\n\nclass RenderTarget extends EngineObject {\n  constructor(engine, width, height, renderTexture, depth = RenderBufferDepthFormat.Depth, antiAliasing = 1) {\n    super(engine);\n    this._MSAAColorRenderBuffers = [];\n    const rhi = engine._hardwareRenderer;\n    const gl = rhi.gl;\n    if (!(depth instanceof RenderDepthTexture) && !Texture._supportRenderBufferDepthFormat(depth, rhi, false)) {\n      throw new Error(`RenderBufferDepthFormat is not supported:${RenderBufferDepthFormat[depth]}`);\n    }\n    if (renderTexture?.length > 1 && !rhi.canIUse(GLCapabilityType.drawBuffers)) {\n      throw new Error(\"MRT is not supported\");\n    }\n    if (renderTexture) {\n      this._colorTextures = renderTexture instanceof Array ? renderTexture.slice() : [renderTexture];\n    } else {\n      this._colorTextures = [];\n    }\n    if (this._colorTextures.some((v) => v.width !== width || v.height !== height)) {\n      throw new Error(\"RenderColorTexture's size must as same as RenderTarget\");\n    }\n    if (depth instanceof RenderDepthTexture && (depth.width !== width || depth.height !== height)) {\n      throw new Error(\"RenderDepthTexture's size must as same as RenderTarget\");\n    }\n    if (this._colorTextures.length > 1 && this._colorTextures.some((v) => v._isCube)) {\n      throw new Error(\"MRT+Cube+[,MSAA] is not supported\");\n    }\n    const maxAntiAliasing = rhi.capability.maxAntiAliasing;\n    if (antiAliasing > maxAntiAliasing) {\n      Logger.warn(`MSAA antiAliasing exceeds the limit and is automatically downgraded to:${maxAntiAliasing}`);\n      antiAliasing = maxAntiAliasing;\n    }\n    this._rhi = rhi;\n    this._width = width;\n    this._height = height;\n    this._frameBuffer = gl.createFramebuffer();\n    this._antiAliasing = antiAliasing;\n    if (depth instanceof RenderDepthTexture) {\n      this._depthTexture = depth;\n    }\n    this._bindMainFBO(depth);\n    if (antiAliasing > 1) {\n      this._MSAAFrameBuffer = gl.createFramebuffer();\n      this._bindMSAAFBO(depth);\n    }\n  }\n  get width() {\n    return this._width;\n  }\n  get height() {\n    return this._height;\n  }\n  get colorTextureCount() {\n    return this._colorTextures.length;\n  }\n  get depthTexture() {\n    return this._depthTexture;\n  }\n  get antiAliasing() {\n    return this._antiAliasing;\n  }\n  getColorTexture(index = 0) {\n    return this._colorTextures[index];\n  }\n  destroy() {\n    const gl = this._rhi.gl;\n    gl.deleteFramebuffer(this._frameBuffer);\n    this._depthRenderBuffer && gl.deleteRenderbuffer(this._depthRenderBuffer);\n    this._MSAAFrameBuffer && gl.deleteFramebuffer(this._MSAAFrameBuffer);\n    this._MSAADepthRenderBuffer && gl.deleteRenderbuffer(this._MSAADepthRenderBuffer);\n    for (let i = 0; i < this._colorTextures.length; i++) {\n      this._colorTextures[i].destroy();\n    }\n    for (let i = 0; i < this._MSAAColorRenderBuffers.length; i++) {\n      gl.deleteRenderbuffer(this._MSAAColorRenderBuffers[i]);\n    }\n    this._depthTexture && this._depthTexture.destroy();\n    this._frameBuffer = null;\n    this._colorTextures.length = 0;\n    this._depthTexture = null;\n    this._depthRenderBuffer = null;\n    this._MSAAFrameBuffer = null;\n    this._MSAAColorRenderBuffers.length = 0;\n    this._MSAADepthRenderBuffer = null;\n  }\n  _activeRenderTarget() {\n    const gl = this._rhi.gl;\n    if (this._MSAAFrameBuffer) {\n      gl.bindFramebuffer(gl.FRAMEBUFFER, this._MSAAFrameBuffer);\n    } else {\n      gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);\n    }\n  }\n  _setRenderTargetFace(faceIndex) {\n    const gl = this._rhi.gl;\n    const colorTexture = this._colorTextures[0];\n    const depthTexture = this._depthTexture;\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);\n    if (colorTexture?._isCube) {\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, colorTexture._glTexture, 0);\n    }\n    if (depthTexture?._isCube) {\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, depthTexture._formatDetail.attachment, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, depthTexture._glTexture, 0);\n    }\n    this._activeRenderTarget();\n  }\n  _blitRenderTarget() {\n    const gl = this._rhi.gl;\n    const mask = gl.COLOR_BUFFER_BIT | (this._depthTexture ? gl.DEPTH_BUFFER_BIT : 0);\n    const colorTextureLength = this._colorTextures.length;\n    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this._MSAAFrameBuffer);\n    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this._frameBuffer);\n    for (let textureIndex = 0; textureIndex < colorTextureLength; textureIndex++) {\n      const attachment = gl.COLOR_ATTACHMENT0 + textureIndex;\n      this._blitDrawBuffers[textureIndex] = attachment;\n      gl.readBuffer(attachment);\n      gl.drawBuffers(this._blitDrawBuffers);\n      gl.blitFramebuffer(0, 0, this._width, this._height, 0, 0, this._width, this._height, mask, gl.NEAREST);\n      this._blitDrawBuffers[textureIndex] = gl.NONE;\n    }\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n  }\n  _bindMainFBO(renderDepth) {\n    const gl = this._rhi.gl;\n    const isWebGL2 = this._rhi.isWebGL2;\n    const colorTextureLength = this._colorTextures.length;\n    const drawBuffers = new Array(colorTextureLength);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);\n    for (let i = 0; i < colorTextureLength; i++) {\n      const colorTexture = this._colorTextures[i];\n      const attachment = gl.COLOR_ATTACHMENT0 + i;\n      drawBuffers[i] = attachment;\n      if (!colorTexture._isCube) {\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, colorTexture._glTexture, 0);\n      }\n    }\n    if (colorTextureLength > 1) {\n      gl.drawBuffers(drawBuffers);\n    }\n    this._oriDrawBuffers = drawBuffers;\n    if (renderDepth !== null) {\n      if (renderDepth instanceof RenderDepthTexture) {\n        if (!renderDepth._isCube) {\n          gl.framebufferTexture2D(gl.FRAMEBUFFER, renderDepth._formatDetail.attachment, gl.TEXTURE_2D, renderDepth._glTexture, 0);\n        }\n      } else if (this._antiAliasing <= 1) {\n        const {internalFormat, attachment} = Texture._getRenderBufferDepthFormatDetail(renderDepth, gl, isWebGL2);\n        const depthRenderBuffer = gl.createRenderbuffer();\n        this._depthRenderBuffer = depthRenderBuffer;\n        gl.bindRenderbuffer(gl.RENDERBUFFER, depthRenderBuffer);\n        gl.renderbufferStorage(gl.RENDERBUFFER, internalFormat, this._width, this._height);\n        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, depthRenderBuffer);\n      }\n    }\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.bindRenderbuffer(gl.RENDERBUFFER, null);\n  }\n  _bindMSAAFBO(renderDepth) {\n    const gl = this._rhi.gl;\n    const isWebGL2 = this._rhi.isWebGL2;\n    const MSAADepthRenderBuffer = gl.createRenderbuffer();\n    const colorTextureLength = this._colorTextures.length;\n    this._blitDrawBuffers = new Array(colorTextureLength);\n    this._MSAADepthRenderBuffer = MSAADepthRenderBuffer;\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this._MSAAFrameBuffer);\n    for (let i = 0; i < colorTextureLength; i++) {\n      const MSAAColorRenderBuffer = gl.createRenderbuffer();\n      this._MSAAColorRenderBuffers[i] = MSAAColorRenderBuffer;\n      this._blitDrawBuffers[i] = gl.NONE;\n      gl.bindRenderbuffer(gl.RENDERBUFFER, MSAAColorRenderBuffer);\n      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, this._antiAliasing, this._colorTextures[i]._formatDetail.internalFormat, this._width, this._height);\n      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, MSAAColorRenderBuffer);\n    }\n    gl.drawBuffers(this._oriDrawBuffers);\n    if (renderDepth !== null) {\n      const {internalFormat, attachment} = renderDepth instanceof RenderDepthTexture ? renderDepth._formatDetail : Texture._getRenderBufferDepthFormatDetail(renderDepth, gl, isWebGL2);\n      gl.bindRenderbuffer(gl.RENDERBUFFER, MSAADepthRenderBuffer);\n      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, this._antiAliasing, internalFormat, this._width, this._height);\n      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, MSAADepthRenderBuffer);\n    }\n    this._checkFrameBuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.bindRenderbuffer(gl.RENDERBUFFER, null);\n  }\n  _checkFrameBuffer() {\n    const gl = this._rhi.gl;\n    const isWebGL2 = this._rhi.isWebGL2;\n    const e = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n    switch (e) {\n      case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:\n        throw new Error(\"The attachment types are mismatched or not all framebuffer attachment points are framebuffer attachment complete\");\n      case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\n        throw new Error(\"There is no attachment\");\n      case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:\n        throw new Error(\" Height and width of the attachment are not the same.\");\n      case gl.FRAMEBUFFER_UNSUPPORTED:\n        throw new Error(\"The format of the attachment is not supported or if depth and stencil attachments are not the same renderbuffer\");\n    }\n    if (isWebGL2 && e === gl.FRAMEBUFFER_INCOMPLETE_MULTISAMPLE) {\n      throw new Error(\"The values of gl.RENDERBUFFER_SAMPLES are different among attached renderbuffers, or are non-zero if the attached images are a mix of renderbuffers and textures.\");\n    }\n  }\n}\n\nclass RenderColorTexture extends Texture {\n  constructor(engine, width, height, format = RenderBufferColorFormat.R8G8B8A8, mipmap = false, isCube = false) {\n    super(engine);\n    this._isCube = false;\n    this._autoMipmap = false;\n    const rhi = engine._hardwareRenderer;\n    const gl = rhi.gl;\n    const isWebGL2 = rhi.isWebGL2;\n    if (!Texture._supportRenderBufferColorFormat(format, rhi)) {\n      throw new Error(`RenderBufferColorFormat is not supported:${RenderBufferColorFormat[format]}`);\n    }\n    if (isCube && width !== height) {\n      throw new Error(\"The cube texture must have the same width and height\");\n    }\n    if (mipmap && !isWebGL2 && (!Texture._isPowerOf2(width) || !Texture._isPowerOf2(height))) {\n      Logger.warn(\"non-power-2 texture is not supported for mipmap in WebGL1,and has automatically downgraded to non-mipmap\");\n      mipmap = false;\n    }\n    this._glTexture = gl.createTexture();\n    this._formatDetail = Texture._getRenderBufferColorFormatDetail(format, gl, isWebGL2);\n    this._isCube = isCube;\n    this._rhi = rhi;\n    this._target = isCube ? gl.TEXTURE_CUBE_MAP : gl.TEXTURE_2D;\n    this._mipmap = mipmap;\n    this._width = width;\n    this._height = height;\n    this._format = format;\n    this._mipmapCount = this._getMipmapCount();\n    this._initMipmap(isCube);\n    this.filterMode = TextureFilterMode.Bilinear;\n    this.wrapModeU = this.wrapModeV = TextureWrapMode.Clamp;\n  }\n  get format() {\n    return this._format;\n  }\n  get autoGenerateMipmaps() {\n    return this._autoMipmap;\n  }\n  set autoGenerateMipmaps(value) {\n    this._autoMipmap = value;\n  }\n  getPixelBuffer(face, x, y, width, height, out) {\n    super._getPixelBuffer(face, x, y, width, height, out);\n  }\n}\n\nclass SpriteRenderer extends RenderableComponent {\n  constructor(entity) {\n    super(entity);\n    this._worldSize = [];\n    this._rotationAngle = 0;\n    this.renderMode = \"2D\";\n    this.tintColor = new Vector4(1, 1, 1, 1);\n    this._worldSizeFactor = 100;\n    this.setTexture(void 0);\n    this.setRect(void 0);\n    this.setAnchor(void 0);\n    this.setUvRect();\n    this.setWorldSize();\n    this._positionQuad = {\n      leftTop: new Vector3(),\n      leftBottom: new Vector3(),\n      rightTop: new Vector3(),\n      rightBottom: new Vector3()\n    };\n  }\n  set texture(v) {\n    this.setTexture(v);\n    this.setRect();\n    this.setUvRect();\n    this.setWorldSize();\n  }\n  get texture() {\n    return this._texture;\n  }\n  set anchor(v) {\n    this._anchor = v || [0.5, 0.5];\n  }\n  get anchor() {\n    return this._anchor;\n  }\n  set rect(v) {\n    this.setRect(v);\n    this.setUvRect();\n    this.setWorldSize();\n  }\n  get rect() {\n    return this._rect;\n  }\n  setTexture(texture) {\n    if (texture && texture.asset) {\n      texture = texture.asset;\n    }\n    this._texture = texture;\n  }\n  get rotationAngle() {\n    return this._rotationAngle;\n  }\n  set rotationAngle(v) {\n    this._rotationAngle = v;\n  }\n  setRect(rect) {\n    let rectObject;\n    try {\n      if (rect) {\n        rectObject = JSON.parse(rect);\n      }\n    } catch (error) {\n      Logger.warn(\"Rect is not valid JSON format\");\n    }\n    this._rect = rect || {\n      x: 0,\n      y: 0,\n      width: this._texture?.width ?? 0,\n      height: this._texture?.height ?? 0\n    };\n  }\n  setAnchor(anchor) {\n    this._anchor = anchor || [0.5, 0.5];\n  }\n  setWorldSize() {\n    const {_worldSizeFactor} = this;\n    this._worldSize = [this._rect.width / _worldSizeFactor, this._rect.height / _worldSizeFactor];\n  }\n  setUvRect() {\n    let w, h;\n    if (this._texture) {\n      w = this._texture.width;\n      h = this._texture.height;\n    } else {\n      w = this._rect.width;\n      h = this._rect.height;\n    }\n    this._uvRect = {\n      u: this._rect.x / w,\n      v: this._rect.y / h,\n      width: this._rect.width / w,\n      height: this._rect.height / h\n    };\n  }\n  render(camera) {\n    this._updatePositionQuad(camera);\n    this._transformByMatrix();\n    camera._renderPipeline.pushSprite(this, this._positionQuad, this._uvRect, this.tintColor, this.texture, this.renderMode, camera);\n  }\n  _transformByMatrix() {\n    if (!this.transformMatrix)\n      return;\n    const matrix = this.transformMatrix;\n    let temp = this._positionQuad.leftTop;\n    const leftTop = SpriteRenderer._tempVec40;\n    leftTop.setValue(temp.x, temp.y, temp.z, 1);\n    temp = this._positionQuad.leftBottom;\n    const leftBottom = SpriteRenderer._tempVec41;\n    leftBottom.setValue(temp.x, temp.y, temp.z, 1);\n    temp = this._positionQuad.rightTop;\n    const rightTop = SpriteRenderer._tempVec42;\n    rightTop.setValue(temp.x, temp.y, temp.z, 1);\n    temp = this._positionQuad.rightBottom;\n    const rightBottom = SpriteRenderer._tempVec43;\n    rightBottom.setValue(temp.x, temp.y, temp.z, 1);\n    Vector4.transform(leftTop, matrix, leftTop);\n    Vector4.transform(leftBottom, matrix, leftBottom);\n    Vector4.transform(rightTop, matrix, rightTop);\n    Vector4.transform(rightBottom, matrix, rightBottom);\n    this._positionQuad.leftTop.setValue(leftTop.x, leftTop.y, leftTop.z);\n    this._positionQuad.leftBottom.setValue(leftBottom.x, leftBottom.y, leftBottom.z);\n    this._positionQuad.rightTop.setValue(rightTop.x, rightTop.y, rightTop.z);\n    this._positionQuad.rightBottom.setValue(rightBottom.x, rightBottom.y, rightBottom.z);\n  }\n  _updatePositionQuad(camera) {\n    if (this.renderMode === \"2D\") {\n      const m = camera.viewMatrix.elements;\n      const vx = new Vector3(m[0], m[4], m[8]);\n      const vy = new Vector3(m[1], m[5], m[9]);\n      const c = this.entity.worldPosition.clone();\n      const s = this._worldSize;\n      const ns = this.entity.scale;\n      vx.scale(s[0] * ns.x);\n      vy.scale(s[1] * ns.y);\n      if (this._rotationAngle !== 0) {\n        const vz = new Vector3(m[2], m[6], m[10]);\n        const rotation = new Quaternion();\n        Quaternion.rotationAxisAngle(vz, this._rotationAngle, rotation);\n        Vector3.transformByQuat(vx, rotation, vx);\n        Vector3.transformByQuat(vy, rotation, vy);\n      }\n      const cx = new Vector3();\n      const cy = new Vector3();\n      Vector3.scale(vx, (this.anchor[0] - 0.5) * 2, cx);\n      Vector3.scale(vy, (this.anchor[1] - 0.5) * 2, cy);\n      c.subtract(cx).add(cy);\n      const leftTop = this._positionQuad.leftTop;\n      Vector3.subtract(c, vx, leftTop);\n      leftTop.add(vy);\n      const leftBottom = this._positionQuad.leftBottom;\n      Vector3.subtract(c, vx, leftBottom);\n      leftBottom.subtract(vy);\n      const rightBottom = this._positionQuad.rightBottom;\n      Vector3.add(c, vx, rightBottom);\n      rightBottom.subtract(vy);\n      const rightTop = this._positionQuad.rightTop;\n      Vector3.add(c, vx, rightTop);\n      rightTop.add(vy);\n    }\n  }\n}\nSpriteRenderer._tempVec40 = new Vector4();\nSpriteRenderer._tempVec41 = new Vector4();\nSpriteRenderer._tempVec42 = new Vector4();\nSpriteRenderer._tempVec43 = new Vector4();\n\nvar WrapMode;\n(function(WrapMode2) {\n  WrapMode2[WrapMode2[\"ONCE\"] = 0] = \"ONCE\";\n  WrapMode2[WrapMode2[\"LOOP\"] = 1] = \"LOOP\";\n})(WrapMode || (WrapMode = {}));\nvar AnimationEventType;\n(function(AnimationEventType2) {\n  AnimationEventType2[AnimationEventType2[\"FINISHED\"] = 0] = \"FINISHED\";\n  AnimationEventType2[AnimationEventType2[\"LOOP_END\"] = 1] = \"LOOP_END\";\n  AnimationEventType2[AnimationEventType2[\"FRAME_EVENT\"] = 2] = \"FRAME_EVENT\";\n})(AnimationEventType || (AnimationEventType = {}));\nvar InterpolationType;\n(function(InterpolationType2) {\n  InterpolationType2[InterpolationType2[\"LINEAR\"] = 0] = \"LINEAR\";\n  InterpolationType2[InterpolationType2[\"CUBICSPLINE\"] = 1] = \"CUBICSPLINE\";\n  InterpolationType2[InterpolationType2[\"STEP\"] = 2] = \"STEP\";\n})(InterpolationType || (InterpolationType = {}));\n\nvar TagetType;\n(function(TagetType2) {\n  TagetType2[TagetType2[\"position\"] = 0] = \"position\";\n  TagetType2[TagetType2[\"rotation\"] = 1] = \"rotation\";\n  TagetType2[TagetType2[\"scale\"] = 2] = \"scale\";\n  TagetType2[TagetType2[\"other\"] = 3] = \"other\";\n})(TagetType || (TagetType = {}));\nclass AnimationClip extends AssetObject {\n  constructor(name) {\n    super(null);\n    this.name = name;\n    this.samplers = [];\n    this.channels = [];\n  }\n  addSampler(_input, _output, _outputSize, _interpolation = InterpolationType.LINEAR) {\n    if (_interpolation === InterpolationType.CUBICSPLINE) {\n      if (_outputSize <= 4) {\n        _interpolation = InterpolationType.LINEAR;\n      } else {\n        _outputSize /= 3;\n      }\n    }\n    const sampler = {\n      input: _input,\n      output: _output,\n      outputSize: _outputSize,\n      interpolation: _interpolation\n    };\n    this.samplers.push(sampler);\n  }\n  addChannel(samplerIndex, targetID, targetPath) {\n    const bindSampler = this.samplers[samplerIndex];\n    let tagetType = AnimationClip._tagetTypeMap[targetPath];\n    const channel = {\n      sampler: bindSampler,\n      target: {\n        id: targetID,\n        path: targetPath,\n        pathType: tagetType ?? 3\n      }\n    };\n    this.channels.push(channel);\n  }\n  getChannelCount() {\n    return this.channels.length;\n  }\n  getChannelObject(channelIndex) {\n    return this.channels[channelIndex];\n  }\n  getFrameCount(channelIndex) {\n    const sampler = this.channels[channelIndex].sampler;\n    return sampler.input.length;\n  }\n  getFrameTime(channelIndex, frameIndex) {\n    const sampler = this.channels[channelIndex].sampler;\n    return sampler.input[frameIndex];\n  }\n  getChannelTimeLength(channelIndex) {\n    const sampler = this.channels[channelIndex].sampler;\n    const frameCount = sampler.input.length;\n    return sampler.input[frameCount - 1];\n  }\n  createChannelValue(channelIndex) {\n    const sampler = this.channels[channelIndex].sampler;\n    return new Float32Array(sampler.outputSize);\n  }\n  evaluate(outValue, channelIndex, frameIndex, nextFrameIndex, alpha) {\n    const channel = this.channels[channelIndex];\n    const output = channel.sampler.output;\n    const outputSize = channel.sampler.outputSize;\n    switch (channel.sampler.interpolation) {\n      case InterpolationType.CUBICSPLINE:\n        this.evaluateCubicSpline(outValue, output, outputSize, frameIndex, nextFrameIndex, alpha);\n        break;\n      case InterpolationType.LINEAR:\n        this.evaluateLinear(outValue, output, outputSize, frameIndex, nextFrameIndex, alpha);\n        break;\n    }\n    return outValue;\n  }\n  evaluateCubicSpline(outValue, output, outputSize, frameIndex, nextFrameIndex, alpha) {\n    const squared = alpha * alpha;\n    const cubed = alpha * squared;\n    const part1 = 2 * cubed - 3 * squared + 1;\n    const part2 = -2 * cubed + 3 * squared;\n    const part3 = cubed - 2 * squared + alpha;\n    const part4 = cubed - squared;\n    for (let i = outputSize; i >= 0; i--) {\n      const t1 = output[frameIndex * outputSize * 3 + i];\n      const v1 = output[frameIndex * outputSize * 3 + outputSize + i];\n      const t2 = output[frameIndex * outputSize * 3 + outputSize * 2 + i];\n      const v2 = output[nextFrameIndex * outputSize * 3 + outputSize + i];\n      outValue[i] = v1 * part1 + v2 * part2 + t1 * part3 + t2 * part4;\n    }\n  }\n  evaluateLinear(outValue, output, outputSize, frameIndex, nextFrameIndex, alpha) {\n    switch (outputSize) {\n      case 1:\n        outValue[0] = output[frameIndex] * (1 - alpha) + output[nextFrameIndex] * alpha;\n        break;\n      case 4:\n        this._quaSlerp(outValue, output, frameIndex * outputSize, output, nextFrameIndex * outputSize, alpha);\n        break;\n      default:\n        for (let i = outputSize; i >= 0; i--) {\n          outValue[i] = output[frameIndex * outputSize + i] * (1 - alpha) + output[nextFrameIndex * outputSize + i] * alpha;\n        }\n        break;\n    }\n  }\n  _quaSlerp(out, a, aIndex, b, bIndex, t) {\n    let ax = a[0 + aIndex], ay = a[1 + aIndex], az = a[2 + aIndex], aw = a[3 + aIndex];\n    let bx = b[0 + bIndex], by = b[1 + bIndex], bz = b[2 + bIndex], bw = b[3 + bIndex];\n    let omega, cosom, sinom, scale0, scale1;\n    cosom = ax * bx + ay * by + az * bz + aw * bw;\n    if (cosom < 0) {\n      cosom = -cosom;\n      bx = -bx;\n      by = -by;\n      bz = -bz;\n      bw = -bw;\n    }\n    if (1 - cosom > 1e-6) {\n      omega = Math.acos(cosom);\n      sinom = Math.sin(omega);\n      scale0 = Math.sin((1 - t) * omega) / sinom;\n      scale1 = Math.sin(t * omega) / sinom;\n    } else {\n      scale0 = 1 - t;\n      scale1 = t;\n    }\n    out[0] = scale0 * ax + scale1 * bx;\n    out[1] = scale0 * ay + scale1 * by;\n    out[2] = scale0 * az + scale1 * bz;\n    out[3] = scale0 * aw + scale1 * bw;\n    return out;\n  }\n}\nAnimationClip._tagetTypeMap = {\n  position: 0,\n  rotation: 1,\n  scale: 2\n};\n\nclass AnimationLayer extends EventDispatcher {\n  get isPlaying() {\n    return this._animClip && this._isPlaying;\n  }\n  constructor() {\n    super(null);\n    this.layerWeight = 1;\n    this._activedEvents = [];\n  }\n  canMix(nextAnimClip, rootEntity) {\n    if (!this._animClip || !this._isPlaying || this.isMixLayer || this.isFading) {\n      return false;\n    }\n    if (this._animClip.getChannelCount() !== nextAnimClip.getChannelCount()) {\n      return false;\n    }\n    const count = this._animClip.getChannelCount();\n    for (let i = count - 1; i >= 0; i--) {\n      const curChannel = this._animClip.getChannelObject(i);\n      const curTargetObject = this._findChannelTarget(rootEntity, curChannel.target);\n      const nextChannel = nextAnimClip.getChannelObject(i);\n      const nextTargetObject = this._findChannelTarget(rootEntity, nextChannel.target);\n      if (curTargetObject !== nextTargetObject) {\n        return false;\n      }\n    }\n    return true;\n  }\n  mix(animClip, targetLayer, rootEntity, mixEntity, options = {}) {\n    this._isPlaying = targetLayer.isPlaying;\n    this._animClip = animClip;\n    this._wrapMode = typeof options.wrapMode !== \"undefined\" ? options.wrapMode : targetLayer._wrapMode;\n    this._addEvents(options);\n    this._channelStates = [];\n    this._animClipLength = 0;\n    if (this._isPlaying) {\n      const targetChannelStates = targetLayer._channelStates;\n      const count = this._animClip.getChannelCount();\n      for (let i = count - 1; i >= 0; i--) {\n        const channel = this._animClip.getChannelObject(i);\n        const targetObject = this._findChannelTarget(mixEntity, channel.target);\n        this._channelStates[i] = {\n          frameTime: 0,\n          currentFrame: 0,\n          currentValue: this._animClip.createChannelValue(i),\n          mixWeight: targetObject ? 1 : 0\n        };\n        targetChannelStates[i].mixWeight = targetChannelStates[i].mixWeight === void 0 ? 1 : targetChannelStates[i].mixWeight;\n        if (targetChannelStates[i].mixWeight === 1) {\n          targetChannelStates[i].mixWeight = targetObject ? 0 : 1;\n        }\n        const channelTimeLength = this._animClip.getChannelTimeLength(i);\n        this._animClipLength = this._animClipLength > channelTimeLength ? this._animClipLength : channelTimeLength;\n      }\n      return true;\n    }\n    return false;\n  }\n  removeMixWeight() {\n    const count = this._channelStates.length;\n    for (let i = count - 1; i >= 0; i--) {\n      if (this._channelStates[i].mixWeight === 1) {\n        this.mixTagetLayer._channelStates[i].mixWeight = 1;\n      }\n    }\n  }\n  play(animClip, rootEntity, options = {wrapMode: WrapMode.LOOP}) {\n    this._isPlaying = !!animClip;\n    this._animClip = animClip;\n    this._wrapMode = typeof options.wrapMode !== \"undefined\" ? options.wrapMode : WrapMode.LOOP;\n    this._addEvents(options);\n    this._channelStates = [];\n    this._animClipLength = 0;\n    if (this._isPlaying) {\n      const count = this._animClip.getChannelCount();\n      const channelTargets = [];\n      for (let i = count - 1; i >= 0; i--) {\n        const channel = this._animClip.getChannelObject(i);\n        const targetObject = this._findChannelTarget(rootEntity, channel.target);\n        if (!targetObject) {\n          Logger.warn(\"Can not find channel target:\" + channel.target.id);\n        }\n        this._channelStates[i] = {\n          frameTime: 0,\n          currentFrame: 0,\n          currentValue: this._animClip.createChannelValue(i)\n        };\n        channelTargets[i] = {\n          targetObject,\n          path: channel.target.path,\n          pathType: channel.target.pathType,\n          outputSize: channel.sampler.outputSize\n        };\n        const channelTimeLength = this._animClip.getChannelTimeLength(i);\n        this._animClipLength = this._animClipLength > channelTimeLength ? this._animClipLength : channelTimeLength;\n      }\n      return channelTargets;\n    }\n    return false;\n  }\n  stop(rightnow) {\n    if (!this._animClip || !this._isPlaying) {\n      return;\n    }\n    if (rightnow) {\n      this._isPlaying = false;\n    } else {\n      this._wrapMode = WrapMode.ONCE;\n    }\n  }\n  updateState(deltaTime) {\n    if (!this._animClip || !this._isPlaying) {\n      return;\n    }\n    if (this.isFading) {\n      this.fadeDeltaTime += deltaTime;\n      this.layerWeight = 1 - this.fadeDeltaTime / this.fadeDuration;\n      if (this.layerWeight <= 0) {\n        this._isPlaying = false;\n      }\n    } else if (this.crossFadeDuration) {\n      this.crossFadeDeltaTime += deltaTime;\n      this.layerWeight = this.crossFadeDeltaTime / this.crossFadeDuration;\n      if (this.layerWeight >= 1) {\n        this.layerWeight = 1;\n        delete this.crossFadeDuration;\n      }\n    }\n    deltaTime = deltaTime / 1e3;\n    this._activeEvents(deltaTime);\n    const count = this._animClip.getChannelCount();\n    let playingCount = 0;\n    for (let i = count - 1; i >= 0; i--) {\n      if (this._updateChannelState(deltaTime, i)) {\n        playingCount++;\n      }\n    }\n    if (playingCount === 0) {\n      this._isPlaying = false;\n      if (this.isMixLayer) {\n        this.removeMixWeight();\n      }\n    }\n  }\n  getChannelLayerWeight(channelIndex) {\n    if ((this.hasMixLayer || this.isMixLayer) && channelIndex < this._channelStates.length) {\n      const mixWeight = this._channelStates[channelIndex].mixWeight;\n      const layerWeight = this.isMixLayer ? this.mixTagetLayer.layerWeight : this.layerWeight;\n      return mixWeight * layerWeight;\n    }\n    return this.layerWeight;\n  }\n  getChannelValue(channelIndex) {\n    return this._channelStates[channelIndex].currentValue;\n  }\n  triggerEvents() {\n    this._activedEvents && this._activedEvents.forEach((event) => {\n      this.trigger(event);\n    });\n    this._activedEvents.length = 0;\n  }\n  jumpToFrame(frameTime) {\n    const count = this._animClip.getChannelCount();\n    for (let i = count - 1; i >= 0; i--) {\n      const channelState = this._channelStates[i];\n      channelState.frameTime = 0;\n      this._updateChannelState(frameTime, i);\n    }\n  }\n  _updateChannelState(deltaTime, channelIndex) {\n    const animClip = this._animClip;\n    const channelState = this._channelStates[channelIndex];\n    const animClipLength = animClip.getChannelTimeLength(channelIndex);\n    channelState.frameTime += deltaTime;\n    if (channelState.frameTime > animClipLength) {\n      switch (this._wrapMode) {\n        case WrapMode.ONCE:\n          channelState.frameTime = animClipLength;\n          break;\n        case WrapMode.LOOP:\n          channelState.frameTime = channelState.frameTime % this._animClipLength;\n          break;\n        default:\n          Logger.error(\"Unknown Anim wrap Mode: \" + this._wrapMode);\n      }\n    }\n    if (channelState.mixWeight && channelState.mixWeight === 0) {\n      return true;\n    }\n    const frameTime = Math.min(channelState.frameTime, animClipLength);\n    const lerpState = this._getKeyAndAlpha(animClip.getChannelObject(channelIndex), frameTime);\n    channelState.currentValue = animClip.evaluate(channelState.currentValue, channelIndex, lerpState.currentKey, lerpState.nextKey, lerpState.alpha);\n    if (this._wrapMode === WrapMode.ONCE && channelState.frameTime >= animClipLength) {\n      return false;\n    }\n    return true;\n  }\n  _addEvents(options) {\n    this.removeAllEventListeners();\n    this._frameEvents = [];\n    if (options.events) {\n      let frameEventIndex = 0;\n      for (let i = options.events.length - 1; i >= 0; i--) {\n        const event = options.events[i];\n        let eventType = event.type;\n        if (event.type === AnimationEventType.FRAME_EVENT) {\n          eventType = \"frameEvent\" + frameEventIndex;\n          frameEventIndex++;\n          this._frameEvents.push({\n            eventType,\n            triggerTime: event.triggerTime,\n            triggered: false\n          });\n        }\n        this.addEventListener(eventType, (e) => {\n          event.callback();\n        });\n      }\n    }\n  }\n  _activeEvents(deltaTime) {\n    const index = this._animClip.durationIndex;\n    if (this._frameEvents.length > 0 && this._channelStates.length > 0) {\n      const curFrameTime = this._channelStates[index].frameTime + deltaTime;\n      for (let i = this._frameEvents.length - 1; i >= 0; i--) {\n        const frameEvent = this._frameEvents[i];\n        if (!frameEvent.triggered && curFrameTime > frameEvent.triggerTime) {\n          this._activedEvents.push(new Event(frameEvent.eventType, this));\n          frameEvent.triggered = true;\n        }\n      }\n    }\n    if (this._channelStates.length > 0 && this._channelStates[index].frameTime + deltaTime >= this._animClip.duration) {\n      if (this._wrapMode === WrapMode.LOOP) {\n        if (this._frameEvents.length > 0) {\n          for (let i = this._frameEvents.length - 1; i >= 0; i--) {\n            this._frameEvents[i].triggered = false;\n          }\n        }\n        if (this.hasEvent(AnimationEventType.LOOP_END)) {\n          this._activedEvents.push(new Event(AnimationEventType.LOOP_END, this));\n        }\n      } else if (this.hasEvent(AnimationEventType.FINISHED)) {\n        this._activedEvents.push(new Event(AnimationEventType.FINISHED, this));\n      }\n    }\n  }\n  _findChannelTarget(rootNode, target) {\n    const targetID = target.id;\n    let targetSceneObject = null;\n    if (rootNode.name === targetID) {\n      targetSceneObject = rootNode;\n    } else {\n      targetSceneObject = rootNode.findByName(targetID);\n    }\n    if (target.path === \"weights\") {\n      return targetSceneObject.getComponent(SkinnedMeshRenderer);\n    } else {\n      return targetSceneObject;\n    }\n  }\n  _getKeyAndAlpha(channel, time) {\n    let keyTime = 0;\n    let currentKey = 0;\n    let nextKey = 0;\n    const timeKeys = channel.sampler.input;\n    const numKeys = timeKeys.length;\n    for (let i = numKeys - 1; i >= 0; i--) {\n      if (time > timeKeys[i]) {\n        keyTime = time - timeKeys[i];\n        currentKey = i;\n        break;\n      }\n    }\n    nextKey = currentKey + 1;\n    if (nextKey >= numKeys) {\n      switch (this._wrapMode) {\n        case WrapMode.ONCE:\n          nextKey = numKeys - 1;\n          break;\n        case WrapMode.LOOP:\n          nextKey = 0;\n          break;\n      }\n    }\n    const keyLength = timeKeys[nextKey] - timeKeys[currentKey];\n    const alpha = nextKey === currentKey || keyLength < 1e-5 ? 1 : keyTime / keyLength;\n    return {\n      currentKey,\n      nextKey,\n      alpha\n    };\n  }\n}\n\nvar __defProp$9 = Object.defineProperty;\nvar __getOwnPropDesc$9 = Object.getOwnPropertyDescriptor;\nvar __decorate$9 = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$9(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result)\n    __defProp$9(target, key, result);\n  return result;\n};\nclass Animation extends Component {\n  constructor(entity) {\n    super(entity);\n    this._onUpdateIndex = -1;\n    this._animSet = {};\n    this._animLayers = [new AnimationLayer()];\n    this._timeScale = 1;\n  }\n  get timeScale() {\n    return this._timeScale;\n  }\n  set timeScale(val) {\n    if (val > 0) {\n      this._timeScale = val;\n    }\n  }\n  static lerp(outValue, startValue, endValue, alpha, outputSize) {\n    switch (outputSize) {\n      case 1:\n        outValue = startValue * (1 - alpha) + endValue * alpha;\n        break;\n      case 4:\n        const start = new Quaternion(...startValue);\n        const end = new Quaternion(...endValue);\n        const quat = new Quaternion();\n        Quaternion.slerp(start, end, alpha, quat);\n        outValue[0] = quat.x;\n        outValue[1] = quat.y;\n        outValue[2] = quat.z;\n        outValue[3] = quat.w;\n        break;\n      default:\n        for (let i = outputSize; i >= 0; i--) {\n          outValue[i] = startValue[i] * (1 - alpha) + endValue[i] * alpha;\n        }\n        break;\n    }\n    return outValue;\n  }\n  update(deltaTime) {\n    if (!this.isPlaying()) {\n      return;\n    }\n    deltaTime = deltaTime * this._timeScale;\n    for (let i = this._animLayers.length - 1; i >= 0; i--) {\n      const animLayer = this._animLayers[i];\n      animLayer.updateState(deltaTime);\n    }\n    this._updateValues();\n    for (let i = this._animLayers.length - 1; i >= 0; i--) {\n      const animLayer = this._animLayers[i];\n      animLayer.triggerEvents();\n      if (!animLayer.isPlaying && (animLayer.isFading || animLayer.isMixLayer)) {\n        this._animLayers.splice(i, 1);\n        this._removeRefMixLayers(animLayer);\n      }\n    }\n  }\n  addAnimationClip(animClip, name) {\n    this._animSet[name] = animClip;\n  }\n  removeAnimationClip(name) {\n    const animClip = this._animSet[name];\n    if (animClip) {\n      delete this._animSet[name];\n    }\n  }\n  getAnimationClipLength(name) {\n    const animClip = this._animSet[name];\n    if (animClip) {\n      return animClip.getChannelTimeLength(0);\n    } else {\n      return 0;\n    }\n  }\n  getAnimationClip(name) {\n    return this._animSet[name] || null;\n  }\n  isPlaying() {\n    for (let i = this._animLayers.length - 1; i >= 0; i--) {\n      if (this._animLayers[i].isPlaying) {\n        return true;\n      }\n    }\n    return false;\n  }\n  playAnimationClip(name, options) {\n    const animClip = this._animSet[name];\n    if (!animClip) {\n      Logger.error(\"can not find anim clip: \" + name);\n      return;\n    }\n    let animLayer = null;\n    for (let i = this._animLayers.length - 1; i >= 0; i--) {\n      if (!this._animLayers[i].isFading && !this._animLayers[i].isMixLayer) {\n        animLayer = this._animLayers[i];\n        break;\n      }\n    }\n    if (!animLayer) {\n      animLayer = new AnimationLayer();\n      this._animLayers.push(animLayer);\n    }\n    this._removeRefMixLayers(animLayer);\n    this._channelTargets = animLayer.play(animClip, this.entity, options);\n  }\n  crossFade(name, crossFadeDuration, options) {\n    const animClip = this._animSet[name];\n    if (!animClip) {\n      Logger.error(\"can not find anim clip: \" + name);\n      return;\n    }\n    if (!crossFadeDuration || crossFadeDuration < 0) {\n      Logger.error(\"crossFadeDuration can not less than 0!\");\n      return;\n    }\n    let targetAnimLayer = null;\n    for (let i = this._animLayers.length - 1; i >= 0; i--) {\n      if (this._animLayers[i].canMix(animClip, this.entity)) {\n        targetAnimLayer = this._animLayers[i];\n        break;\n      }\n    }\n    if (targetAnimLayer) {\n      for (let i = this._animLayers.length - 1; i >= 0; i--) {\n        if (this._animLayers[i].isFading) {\n          this._animLayers.splice(i, 1);\n        }\n      }\n      targetAnimLayer.isFading = true;\n      targetAnimLayer.fadeDuration = crossFadeDuration;\n      targetAnimLayer.fadeDeltaTime = 0;\n      const animLayer = new AnimationLayer();\n      animLayer.crossFadeDuration = crossFadeDuration;\n      animLayer.crossFadeDeltaTime = 0;\n      animLayer.play(animClip, this.entity, options);\n      this._animLayers.push(animLayer);\n    } else {\n      this.playAnimationClip(name, options);\n    }\n  }\n  mix(name, mixBoneName, options) {\n    const animClip = this._animSet[name];\n    if (!animClip) {\n      Logger.error(\"can not find anim clip: \" + name);\n      return;\n    }\n    const mixNode = this.entity.findByName(mixBoneName);\n    if (!mixNode) {\n      Logger.error(\"can not find mix bone!\");\n      return;\n    }\n    let targetAnimLayer = null;\n    for (let i = this._animLayers.length - 1; i >= 0; i--) {\n      if (this._animLayers[i].canMix(animClip, this.entity)) {\n        targetAnimLayer = this._animLayers[i];\n        break;\n      }\n    }\n    if (targetAnimLayer) {\n      this._removeRefMixLayers(null, mixNode);\n      targetAnimLayer.hasMixLayer = true;\n      const animLayer = new AnimationLayer();\n      animLayer.isMixLayer = true;\n      animLayer.mixTagetLayer = targetAnimLayer;\n      animLayer.mixEntity = mixNode;\n      animLayer.mix(animClip, targetAnimLayer, this.entity, mixNode, options);\n      this._animLayers.push(animLayer);\n    }\n  }\n  stop(rightnow) {\n    for (let i = this._animLayers.length - 1; i >= 0; i--) {\n      if (this._animLayers[i].isFading) {\n        this._animLayers.splice(i, 1);\n      } else {\n        this._animLayers[i].stop(rightnow);\n      }\n    }\n  }\n  jumpToFrame(frameTime) {\n    frameTime = frameTime / 1e3;\n    for (let i = this._animLayers.length - 1; i >= 0; i--) {\n      this._animLayers[i].jumpToFrame(frameTime);\n    }\n    this._updateValues();\n  }\n  _removeRefMixLayers(targetLayer, mixNode) {\n    if (targetLayer && targetLayer.hasMixLayer) {\n      for (let i = this._animLayers.length - 1; i >= 0; i--) {\n        const animLayer = this._animLayers[i];\n        if (animLayer.isMixLayer && animLayer.mixTagetLayer === targetLayer) {\n          animLayer.removeMixWeight();\n          this._animLayers.splice(i, 1);\n        }\n      }\n    }\n    if (mixNode) {\n      for (let i = this._animLayers.length - 1; i >= 0; i--) {\n        const animLayer = this._animLayers[i];\n        if (animLayer.isMixLayer && (animLayer.mixEntity === mixNode || animLayer.mixEntity.findByName(mixNode) || mixNode.findByName(animLayer.mixEntity))) {\n          animLayer.removeMixWeight();\n          this._animLayers.splice(i, 1);\n        }\n      }\n    }\n  }\n  _updateValues() {\n    if (this._animLayers.length === 0 || !this._channelTargets) {\n      return;\n    }\n    for (let i = this._channelTargets.length - 1; i >= 0; i--) {\n      const channelTarget = this._channelTargets[i];\n      const val = this._getChannelValue(i, channelTarget.outputSize);\n      const targetObject = channelTarget.targetObject;\n      const path = channelTarget.path;\n      if (path === \"weights\") {\n        targetObject.setWeights(val);\n      } else {\n        const v = val;\n        const transform = targetObject.transform;\n        switch (channelTarget.pathType) {\n          case TagetType.position:\n            const position = transform.position;\n            position.setValue(v[0], v[1], v[2]);\n            transform.position = position;\n            break;\n          case TagetType.rotation:\n            const rotation = transform.rotationQuaternion;\n            rotation.setValue(v[0], v[1], v[2], v[3]);\n            transform.rotationQuaternion = rotation;\n            break;\n          case TagetType.scale:\n            const scale = transform.scale;\n            scale.setValue(v[0], v[1], v[2]);\n            transform.scale = scale;\n            break;\n          default:\n            targetObject[path] = val;\n        }\n      }\n    }\n  }\n  _getChannelValue(channelIndex, outputSize) {\n    const weights = [];\n    const values = [];\n    for (let i = this._animLayers.length - 1; i >= 0; i--) {\n      const weight = this._animLayers[i].getChannelLayerWeight(channelIndex);\n      if (weight > 0) {\n        weights.push(weight);\n        values.push(this._animLayers[i].getChannelValue(channelIndex));\n      }\n    }\n    if (values.length === 1) {\n      return values[0];\n    } else if (values.length === 2) {\n      return Animation.lerp(values[0], values[0], values[1], weights[1], outputSize);\n    }\n    Logger.error(\"Can not get channel value!\");\n    return false;\n  }\n  _onEnable() {\n    this.engine._componentsManager.addOnUpdateAnimations(this);\n  }\n  _onDisable() {\n    this.engine._componentsManager.removeOnUpdateAnimations(this);\n  }\n}\n__decorate$9([\n  ignoreClone\n], Animation.prototype, \"_onUpdateIndex\", 2);\n__decorate$9([\n  shallowClone\n], Animation.prototype, \"_animSet\", 2);\n__decorate$9([\n  ignoreClone\n], Animation.prototype, \"_animLayers\", 2);\n__decorate$9([\n  ignoreClone\n], Animation.prototype, \"_timeScale\", 2);\n__decorate$9([\n  ignoreClone\n], Animation.prototype, \"_channelTargets\", 2);\n\nvar VertexShader = \"#include <common>\\n#include <common_vert>\\n#include <uv_share>\\n#include <normal_share>\\n#include <worldpos_share>\\n#include <shadow_share>\\n#include <morph_target_vert>\\n\\n#include <fog_share>\\n\\nvoid main() {\\n\\n    #include <begin_position_vert>\\n    #include <begin_normal_vert>\\n\\n    #include <morph_vert>\\n    #include <skinning_vert>\\n    #include <uv_vert>\\n    #include <normal_vert>\\n    #include <worldpos_vert>\\n    #include <shadow_vert>\\n    #include <position_vert>\\n\\n    #include <fog_vert>\\n\\n}\\n\";\n\nclass CommonMaterial extends Material {\n  constructor(engine, name) {\n    super(engine, name);\n    this.renderStates = {\n      enable: [],\n      disable: [],\n      functions: {}\n    };\n    this.emission = new Vector4(0, 0, 0, 1);\n    this.ambient = new Vector4(0, 0, 0, 1);\n    this.renderStates = {};\n  }\n  get emission() {\n    return this.getValue(\"u_emission\");\n  }\n  set emission(val) {\n    this.setValue(\"u_emission\", val);\n  }\n  get ambient() {\n    return this.getValue(\"u_ambient\");\n  }\n  set ambient(val) {\n    this.setValue(\"u_ambient\", val);\n  }\n  prepareDrawing(context, component, primitive) {\n    const camera = context.camera;\n    const lightMgr = camera.scene.findFeature(LightFeature);\n    lightMgr.bindMaterialValues(this);\n    const {ambientLightCount} = lightMgr.lightSortAmount;\n    if (!this._technique || this._ambientLightCount !== ambientLightCount) {\n      this._ambientLightCount = ambientLightCount;\n      this._generateTechnique();\n      this.bindLightUniformDefine(camera);\n    }\n    super.prepareDrawing(context, component, primitive);\n  }\n  bindLightUniformDefine(camera) {\n    const lightMgr = camera.scene.findFeature(LightFeature);\n    this._technique.uniforms = {\n      ...lightMgr.getUniformDefine(),\n      ...this._technique.uniforms\n    };\n  }\n  _internalGenerate(name, fragmentShader) {\n    const customMacros = this._generateMacros();\n    const uniforms = this._generateFragmentUniform();\n    const tech = new RenderTechnique(name);\n    tech.isValid = true;\n    tech.uniforms = uniforms;\n    tech.attributes = {};\n    tech.states = this.renderStates;\n    tech.customMacros = customMacros;\n    tech.vertexShader = VertexShader;\n    tech.fragmentShader = fragmentShader;\n    this._technique = tech;\n  }\n  _generateMacros() {\n    const macros = [];\n    if (this.emission instanceof Texture2D)\n      macros.push(\"O3_EMISSION_TEXTURE\");\n    if (this.ambient instanceof Texture2D)\n      macros.push(\"O3_AMBIENT_TEXTURE\");\n    if (this._ambientLightCount) {\n      macros.push(\"O3_HAS_AMBIENT_LIGHT\");\n    }\n    return macros;\n  }\n  _generateFragmentUniform() {\n    const fragmentUniform = {\n      u_emission: {\n        name: \"u_emission\",\n        type: DataType.FLOAT_VEC4\n      },\n      u_ambient: {\n        name: \"u_ambient\",\n        type: DataType.FLOAT_VEC4\n      }\n    };\n    if (this.emission instanceof Texture2D) {\n      fragmentUniform.u_emission.type = DataType.SAMPLER_2D;\n    }\n    if (this.ambient instanceof Texture2D) {\n      fragmentUniform.u_ambient.type = DataType.SAMPLER_2D;\n    }\n    return fragmentUniform;\n  }\n}\n\nvar ConstantShader = \"#include <common>\\n#include <common_frag>\\n#include <uv_share>\\n#include <mobile_material_frag>\\n\\n#include <fog_share>\\n#include <ambient_light_frag>\\n\\nvoid main() {\\n\\n    #include <begin_mobile_frag>\\n\\n    gl_FragColor = emission + ambient;\\n\\n    #include <fog_frag>\\n\\n}\\n\";\n\nclass ConstantMaterial extends CommonMaterial {\n  _generateTechnique() {\n    this._internalGenerate(\"ConstantMaterial\", ConstantShader);\n  }\n}\n\nvar LambertShader = \"#include <common>\\n#include <common_frag>\\n#include <uv_share>\\n#include <normal_share>\\n\\n#include <ambient_light_frag>\\n#include <direct_light_frag>\\n#include <mobile_material_frag>\\n\\n#include <fog_share>\\n\\nvoid main() {\\n\\n    #include <begin_mobile_frag>\\n    #include <begin_normal_frag>\\n    #include <mobile_lambert_frag>\\n\\n    gl_FragColor = emission + ambient + diffuse;\\n\\n    #include <fog_frag>\\n\\n}\\n\";\n\nclass LambertMaterial extends CommonMaterial {\n  constructor(engine, name) {\n    super(engine, name);\n    this._directLightCount = 0;\n    this.diffuse = new Vector4(1, 1, 1, 1);\n  }\n  get diffuse() {\n    return this.getValue(\"u_diffuse\");\n  }\n  set diffuse(val) {\n    this.setValue(\"u_diffuse\", val);\n  }\n  _generateTechnique() {\n    this._internalGenerate(\"LambertMaterial\", LambertShader);\n  }\n  prepareDrawing(context, component, primitive) {\n    const camera = context.camera;\n    const scene = camera.scene;\n    const lightMgr = scene.findFeature(LightFeature);\n    const {directLightCount} = lightMgr.lightSortAmount;\n    if (this._technique === null || this._directLightCount != directLightCount) {\n      this._directLightCount = directLightCount;\n      this._generateTechnique();\n      this.bindLightUniformDefine(camera);\n    }\n    super.prepareDrawing(context, component, primitive);\n  }\n  _generateFragmentUniform() {\n    let uniforms = {};\n    if (this.diffuse instanceof Texture2D) {\n      uniforms.u_diffuse = {\n        name: \"u_diffuse\",\n        type: DataType.SAMPLER_2D\n      };\n    } else {\n      uniforms.u_diffuse = {\n        name: \"u_diffuse\",\n        type: DataType.FLOAT_VEC4\n      };\n    }\n    const baseUniforms = super._generateFragmentUniform();\n    return Object.assign(baseUniforms, uniforms);\n  }\n  _generateMacros() {\n    const macros = super._generateMacros();\n    macros.push(\"O3_NEED_WORLDPOS\");\n    if (this._directLightCount > 0)\n      macros.push(`O3_DIRECT_LIGHT_COUNT ${this._directLightCount}`);\n    if (this.diffuse instanceof Texture2D)\n      macros.push(\"O3_DIFFUSE_TEXTURE\");\n    return macros;\n  }\n}\n\nvar BlinnPhongShader = \"#include <common>\\n#include <common_frag>\\n\\n#include <uv_share>\\n#include <normal_share>\\n#include <worldpos_share>\\n\\n#include <ambient_light_frag>\\n#include <direct_light_frag>\\n#include <point_light_frag>\\n#include <spot_light_frag>\\n#include <mobile_material_frag>\\n\\n#include <fog_share>\\n\\nvoid main() {\\n\\n    #include <begin_mobile_frag>\\n    #include <begin_normal_frag>\\n    #include <begin_viewdir_frag>\\n    #include <mobile_blinnphong_frag>\\n\\n    gl_FragColor = emission + ambient + diffuse + specular;\\n\\n    #include <fog_frag>\\n\\n}\\n\";\n\nclass BlinnPhongMaterial extends CommonMaterial {\n  constructor(engine, name) {\n    super(engine, name);\n    this._directLightCount = 0;\n    this._pointLightCount = 0;\n    this._spotLightCount = 0;\n    this.diffuse = new Vector4(1, 1, 1, 1);\n    this.specular = new Vector4(1, 1, 1, 1);\n    this.shininess = 16;\n  }\n  get diffuse() {\n    return this.getValue(\"u_diffuse\");\n  }\n  set diffuse(val) {\n    this.setValue(\"u_diffuse\", val);\n  }\n  get specular() {\n    return this.getValue(\"u_specular\");\n  }\n  set specular(val) {\n    this.setValue(\"u_specular\", val);\n  }\n  get shininess() {\n    return this.getValue(\"u_shininess\");\n  }\n  set shininess(val) {\n    this.setValue(\"u_shininess\", val);\n  }\n  _generateTechnique() {\n    this._internalGenerate(\"BlinnPhongMaterial\", BlinnPhongShader);\n  }\n  _generateMacros() {\n    const macros = super._generateMacros();\n    macros.push(\"O3_NEED_WORLDPOS\");\n    if (this.diffuse instanceof Texture2D)\n      macros.push(\"O3_DIFFUSE_TEXTURE\");\n    if (this.specular instanceof Texture2D)\n      macros.push(\"O3_SPECULAR_TEXTURE\");\n    if (this._directLightCount > 0)\n      macros.push(`O3_DIRECT_LIGHT_COUNT ${this._directLightCount}`);\n    if (this._pointLightCount > 0)\n      macros.push(`O3_POINT_LIGHT_COUNT ${this._pointLightCount}`);\n    if (this._spotLightCount > 0)\n      macros.push(`O3_SPOT_LIGHT_COUNT ${this._spotLightCount}`);\n    return macros;\n  }\n  prepareDrawing(context, component, primitive) {\n    const camera = context.camera;\n    const scene = camera.scene;\n    const lightMgr = scene.findFeature(LightFeature);\n    const {directLightCount, pointLightCount, spotLightCount} = lightMgr.lightSortAmount;\n    if (this._technique === null || this._directLightCount != directLightCount || this._pointLightCount != pointLightCount || this._spotLightCount != spotLightCount) {\n      this._directLightCount = directLightCount;\n      this._pointLightCount = pointLightCount;\n      this._spotLightCount = spotLightCount;\n      this._generateTechnique();\n      this.bindLightUniformDefine(camera);\n    }\n    super.prepareDrawing(context, component, primitive);\n  }\n  _generateFragmentUniform() {\n    let uniforms = {};\n    if (this.diffuse instanceof Texture2D) {\n      uniforms.u_diffuse = {\n        name: \"u_diffuse\",\n        type: DataType.SAMPLER_2D\n      };\n    } else {\n      uniforms.u_diffuse = {\n        name: \"u_diffuse\",\n        type: DataType.FLOAT_VEC4\n      };\n    }\n    if (this.specular instanceof Texture2D) {\n      uniforms.u_specular = {\n        name: \"u_specular\",\n        type: DataType.SAMPLER_2D\n      };\n    } else {\n      uniforms.u_specular = {\n        name: \"u_specular\",\n        type: DataType.FLOAT_VEC4\n      };\n    }\n    uniforms.u_shininess = {\n      name: \"u_shininess\",\n      type: DataType.FLOAT\n    };\n    const baseUniforms = super._generateFragmentUniform();\n    return Object.assign(baseUniforms, uniforms);\n  }\n}\n\nvar FRAG_SHADER = \"#include <common>\\n#include <common_frag>\\n\\nuniform sampler2D u_diffuse;\\nvarying vec3 v_pos;\\nuniform vec4 u_tintColor;\\nuniform float u_opacity;\\n\\nvoid main()\\n{\\n  #ifdef O3_DIFFUSE_TEXTURE\\n    gl_FragColor = texture2D(u_diffuse, v_uv);\\n  #else\\n    gl_FragColor = vec4(1);\\n  #endif\\n}\\n\";\n\nclass TextureMaterial extends CommonMaterial {\n  constructor(engine, name) {\n    super(engine, name || \"TextureMaterial\");\n  }\n  _generateTechnique() {\n    this._internalGenerate(\"Texture\", FRAG_SHADER);\n  }\n  setValue(name, value) {\n    if (name === \"doubleSided\") {\n      this._setDoubleSidedDisplay(value);\n    }\n    super.setValue(name, value);\n  }\n  set texture(v) {\n    this.setValue(\"u_diffuse\", v);\n  }\n  get texture() {\n    return this.getValue(\"u_diffuse\");\n  }\n  set doubleSided(v) {\n    this.setValue(\"doubleSided\", v);\n  }\n  get doubleSided() {\n    return this.getValue(\"doubleSided\");\n  }\n  _generateFragmentUniform() {\n    const uniforms = {};\n    if (this.texture instanceof Texture2D) {\n      uniforms.u_diffuse = {\n        name: \"u_diffuse\",\n        paramName: \"_MainTex\",\n        type: DataType.SAMPLER_2D\n      };\n    }\n    return {\n      ...super._generateFragmentUniform(),\n      ...uniforms\n    };\n  }\n  _generateMacros() {\n    const macros = super._generateMacros();\n    if (this.texture instanceof Texture2D)\n      macros.push(\"O3_DIFFUSE_TEXTURE\");\n    return macros;\n  }\n  _setDoubleSidedDisplay(value) {\n    this._technique.states.disable = [];\n    if (value) {\n      this._technique.states.disable.push(RenderState.CULL_FACE);\n    }\n  }\n}\nTextureMaterial.TECH_NAME = \"Texture\";\n\nclass TransparentMaterial extends CommonMaterial {\n  constructor(engine, name) {\n    super(engine, name || \"TransparentMaterial\");\n  }\n  _generateTechnique() {\n    this.renderStates = {\n      enable: [RenderState.BLEND],\n      disable: [RenderState.CULL_FACE],\n      functions: {\n        blendFunc: [BlendFunc.SRC_ALPHA, BlendFunc.ONE_MINUS_SRC_ALPHA],\n        depthMask: [false]\n      }\n    };\n    this.renderType = MaterialType.TRANSPARENT;\n    this._internalGenerate(\"Transparent\", FRAG_SHADER);\n  }\n  set texture(v) {\n    this.setValue(\"u_diffuse\", v);\n  }\n  get texture() {\n    return this.getValue(\"u_diffuse\");\n  }\n  _generateFragmentUniform() {\n    const uniforms = {};\n    if (this.texture instanceof Texture2D) {\n      uniforms.u_diffuse = {\n        name: \"u_diffuse\",\n        paramName: \"_MainTex\",\n        type: DataType.SAMPLER_2D\n      };\n    }\n    return {\n      ...super._generateFragmentUniform(),\n      ...uniforms\n    };\n  }\n  _generateMacros() {\n    const macros = super._generateMacros();\n    if (this.texture instanceof Texture2D)\n      macros.push(\"O3_DIFFUSE_TEXTURE\");\n    return macros;\n  }\n}\nTransparentMaterial.TECH_NAME = \"Transparent\";\n\nclass ShaderMaterial extends Material {\n  constructor(engine, name) {\n    super(engine, name);\n    this.vertexShader = \"\";\n    this.fragmentShader = \"\";\n    this.isValid = true;\n    this.attributes = {};\n    this._uniforms = ShaderMaterial.commonUniforms;\n    this._renderStates = {\n      enable: [],\n      disable: [],\n      functions: {}\n    };\n    this._enableConfig = [];\n    this._disableConfig = [];\n    this._functionsConfig = {\n      blendFunc: [BlendFunc.SRC_ALPHA, BlendFunc.ONE_MINUS_SRC_ALPHA]\n    };\n  }\n  prepareDrawing(context, component, primitive) {\n    const camera = context.camera;\n    if (!this._technique) {\n      const tech = this._generateTechnique(camera, component, primitive);\n      this._technique = tech;\n    }\n    super.prepareDrawing(context, component, primitive);\n  }\n  updateTechnique() {\n    this._technique = null;\n  }\n  _generateTechnique(camera, component, primitive) {\n    const tech = new RenderTechnique(\"ShaderMaterial\");\n    tech.isValid = this.isValid;\n    tech.uniforms = this.uniforms;\n    tech.attributes = this.attributes;\n    tech.states = this.renderStates;\n    tech.vertexShader = this.vertexShader;\n    tech.fragmentShader = this.fragmentShader;\n    return tech;\n  }\n  addState(key, state) {\n    this.renderStates[key] = union(this.renderStates[key], state);\n  }\n  removeState(key, state) {\n    this.renderStates[key] = this.renderStates[key].filter((value) => value !== state);\n  }\n  get renderStates() {\n    return this._renderStates;\n  }\n  set renderStates(value) {\n    const {enable = [], disable = [], functions = {}} = value;\n    const enableState = enable.filter((value2) => ShaderMaterial.commonEnable.indexOf(value2) < 0);\n    const disableState = disable.filter((value2) => ShaderMaterial.commonDisable.indexOf(value2) < 0);\n    this._renderStates.enable = union(enableState, this._enableConfig);\n    this._renderStates.disable = union(disableState, this._disableConfig);\n    this._renderStates.functions = Object.assign({}, functions, this._functionsConfig);\n  }\n  get uniforms() {\n    return this._uniforms;\n  }\n  set uniforms(value) {\n    this._uniforms = Object.assign({}, ShaderMaterial.commonUniforms, value);\n  }\n  set blend(value) {\n    if (value) {\n      this._enableConfig = union(this._enableConfig, [RenderState.BLEND]);\n    } else {\n      this._enableConfig = this._enableConfig.filter((state) => state !== RenderState.BLEND);\n      this.removeState(\"enable\", RenderState.BLEND);\n    }\n    this.renderStates = this._renderStates;\n  }\n  set blendSrcFactor(value) {\n    this._functionsConfig.blendFunc[0] = value;\n    this.renderStates = this._renderStates;\n  }\n  set blendDstFactor(value) {\n    this._functionsConfig.blendFunc[1] = value;\n    this.renderStates = this._renderStates;\n  }\n  set doubleSide(value) {\n    if (value) {\n      this._disableConfig = union(this._disableConfig, [RenderState.CULL_FACE]);\n    } else {\n      this._disableConfig = this._disableConfig.filter((state) => state !== RenderState.CULL_FACE);\n      this.removeState(\"disable\", RenderState.CULL_FACE);\n    }\n    this.renderStates = this._renderStates;\n  }\n  set depthTest(value) {\n    if (!value) {\n      this._disableConfig = union(this._disableConfig, [RenderState.DEPTH_TEST]);\n    } else {\n      this._disableConfig = this._disableConfig.filter((state) => state !== RenderState.DEPTH_TEST);\n      this.removeState(\"disable\", RenderState.DEPTH_TEST);\n    }\n    this.renderStates = this._renderStates;\n  }\n}\nShaderMaterial.commonUniforms = {\n  matModelViewProjection: {\n    name: \"matModelViewProjection\",\n    semantic: UniformSemantic.MODELVIEWPROJECTION,\n    type: DataType.FLOAT_MAT4\n  },\n  matModelView: {\n    name: \"matModelView\",\n    semantic: UniformSemantic.MODELVIEW,\n    type: DataType.FLOAT_MAT4\n  }\n};\nShaderMaterial.commonEnable = [RenderState.BLEND];\nShaderMaterial.commonDisable = [RenderState.CULL_FACE, RenderState.DEPTH_TEST];\nfunction union(arr1, arr2) {\n  return arr1.concat(arr2.filter((v) => !(arr1.indexOf(v) > -1)));\n}\n\nclass BufferGeometry extends EngineObject {\n  constructor(engine, name) {\n    super(engine);\n    this._subGeometries = [];\n    this._primitive = new Primitive(engine);\n    this.name = name;\n  }\n  get vertexBufferBindings() {\n    return this._primitive.vertexBufferBindings;\n  }\n  get indexBufferBinding() {\n    return this._primitive.indexBufferBinding;\n  }\n  get vertexElements() {\n    return this._primitive.vertexElements;\n  }\n  get subGeometry() {\n    return this._subGeometries[0] || null;\n  }\n  get subGeometries() {\n    return this._subGeometries;\n  }\n  get instanceCount() {\n    return this._primitive.instanceCount;\n  }\n  set instanceCount(count) {\n    this._primitive.instanceCount = count;\n  }\n  get bounds() {\n    return this._bounds;\n  }\n  set bounds(value) {\n    this._bounds = value;\n  }\n  setVertexBufferBinding(bufferOrBinding, stride = 0, firstIndex = 0) {\n    this._primitive.setVertexBufferBinding(bufferOrBinding, stride, firstIndex);\n  }\n  setVertexBufferBindings(vertexBufferBindings, firstIndex = 0) {\n    this._primitive.setVertexBufferBindings(vertexBufferBindings, firstIndex);\n  }\n  setIndexBufferBinding(bufferOrBinding, format) {\n    this._primitive.setIndexBufferBinding(bufferOrBinding, format);\n  }\n  setVertexElements(elements) {\n    this._primitive.setVertexElements(elements);\n  }\n  addSubGeometry(start, count, topology = PrimitiveTopology.Triangles) {\n    const subGeometry = new SubPrimitive(start, count, topology);\n    this._subGeometries.push(subGeometry);\n    return subGeometry;\n  }\n  removeSubGeometry(subGeometry) {\n    const subGeometries = this._subGeometries;\n    const index = subGeometries.indexOf(subGeometry);\n    if (index !== -1) {\n      subGeometries.splice(index, 1);\n    }\n  }\n  clearSubGeometry() {\n    this._subGeometries.length = 0;\n  }\n  destroy() {\n    if (this._primitive) {\n      this._primitive.destroy();\n      this._primitive = null;\n    }\n  }\n}\n\nclass GeometryRenderer extends RenderableComponent {\n  set geometry(value) {\n    if (this._geometry) {\n      this._geometry._primitive._addRefCount(-1);\n    }\n    value._primitive._addRefCount(1);\n    this._geometry = value;\n  }\n  get geometry() {\n    return this._geometry;\n  }\n  set material(value) {\n    if (this._material) {\n      this._material._addRefCount(-1);\n    }\n    value._addRefCount(1);\n    this._material = value;\n  }\n  get material() {\n    return this._material;\n  }\n  render(camera) {\n    const geometry = this.geometry;\n    if (geometry) {\n      const subGeometries = geometry.subGeometries;\n      const renderPipeline = camera._renderPipeline;\n      const material = this._material;\n      for (let i = 0, n = subGeometries.length; i < n; i++) {\n        if (material) {\n          const element = RenderElement.getFromPool();\n          element.setValue(this, geometry._primitive, subGeometries[i], material);\n          renderPipeline.pushPrimitive(element);\n        }\n      }\n    } else {\n      Logger.error(\"geometry is null.\");\n    }\n  }\n  _updateBounds(worldBounds) {\n    const localBounds = this._geometry.bounds;\n    if (localBounds) {\n      const worldMatrix = this._entity.transform.worldMatrix;\n      Vector3.transformCoordinate(localBounds.min, worldMatrix, worldBounds.min);\n      Vector3.transformCoordinate(localBounds.max, worldMatrix, worldBounds.max);\n    } else {\n      worldBounds.min.setValue(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);\n      worldBounds.max.setValue(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);\n    }\n  }\n}\n\nclass ShapeGeometry extends BufferGeometry {\n  _initialize(engine, vertices, indices) {\n    const vertexStride = 32;\n    const vertexElements = [\n      new VertexElement(\"POSITION\", 0, VertexElementFormat.Vector3, 0),\n      new VertexElement(\"NORMAL\", 12, VertexElementFormat.Vector3, 0),\n      new VertexElement(\"TEXCOORD_0\", 24, VertexElementFormat.Vector2, 0)\n    ];\n    this._initBuffer(engine, vertices, indices, vertexStride, vertexElements);\n  }\n  _initBuffer(engine, vertices, indices, vertexStride, vertexElements) {\n    const positionElement = vertexElements[0];\n    const vertexBuffer = new Buffer(engine, BufferBindFlag.VertexBuffer, vertices, BufferUsage.Static);\n    const indexBuffer = new Buffer(engine, BufferBindFlag.IndexBuffer, indices, BufferUsage.Static);\n    this.setVertexBufferBinding(vertexBuffer, vertexStride);\n    this.setIndexBufferBinding(indexBuffer, IndexFormat.UInt16);\n    this.setVertexElements(vertexElements);\n    this.addSubGeometry(0, indices.length);\n    this._computeBounds(positionElement, vertices);\n  }\n  _computeBounds(positionElement, vertices) {\n    const vertexElement = positionElement;\n    const bufferIndex = vertexElement.bindingIndex;\n    const vertexBufferBinding = this._primitive.vertexBufferBindings[bufferIndex];\n    const stride = vertexBufferBinding.stride;\n    const offset = vertexElement.offset;\n    const vertexCount = vertexBufferBinding.buffer.byteLength / stride;\n    let arrayBuffer = vertices;\n    if (!(arrayBuffer instanceof ArrayBuffer)) {\n      arrayBuffer = arrayBuffer.buffer;\n    }\n    const dataView = new DataView(arrayBuffer, offset);\n    let min = new Vector3(Infinity, Infinity, Infinity);\n    let max = new Vector3(-Infinity, -Infinity, -Infinity);\n    for (let i = 0; i < vertexCount; i++) {\n      const base = offset + stride * i;\n      const position = new Vector3(dataView.getFloat32(base, true), dataView.getFloat32(base + 4, true), dataView.getFloat32(base + 8, true));\n      Vector3.min(min, position, min);\n      Vector3.max(max, position, max);\n    }\n    let bounds = this.bounds;\n    if (bounds) {\n      min.cloneTo(bounds.min);\n      max.cloneTo(bounds.max);\n    } else {\n      bounds = {min, max};\n      this.bounds = bounds;\n    }\n  }\n}\n\nclass CuboidGeometry extends ShapeGeometry {\n  constructor(engine, width = 1, height = 1, depth = 1) {\n    super(engine);\n    const halfWidth = width / 2;\n    const halfHeight = height / 2;\n    const halfDepth = depth / 2;\n    const vertices = new Float32Array([\n      -halfWidth,\n      halfHeight,\n      -halfDepth,\n      0,\n      1,\n      0,\n      0,\n      0,\n      halfWidth,\n      halfHeight,\n      -halfDepth,\n      0,\n      1,\n      0,\n      1,\n      0,\n      halfWidth,\n      halfHeight,\n      halfDepth,\n      0,\n      1,\n      0,\n      1,\n      1,\n      -halfWidth,\n      halfHeight,\n      halfDepth,\n      0,\n      1,\n      0,\n      0,\n      1,\n      -halfWidth,\n      -halfHeight,\n      -halfDepth,\n      0,\n      -1,\n      0,\n      0,\n      1,\n      halfWidth,\n      -halfHeight,\n      -halfDepth,\n      0,\n      -1,\n      0,\n      1,\n      1,\n      halfWidth,\n      -halfHeight,\n      halfDepth,\n      0,\n      -1,\n      0,\n      1,\n      0,\n      -halfWidth,\n      -halfHeight,\n      halfDepth,\n      0,\n      -1,\n      0,\n      0,\n      0,\n      -halfWidth,\n      halfHeight,\n      -halfDepth,\n      -1,\n      0,\n      0,\n      0,\n      0,\n      -halfWidth,\n      halfHeight,\n      halfDepth,\n      -1,\n      0,\n      0,\n      1,\n      0,\n      -halfWidth,\n      -halfHeight,\n      halfDepth,\n      -1,\n      0,\n      0,\n      1,\n      1,\n      -halfWidth,\n      -halfHeight,\n      -halfDepth,\n      -1,\n      0,\n      0,\n      0,\n      1,\n      halfWidth,\n      halfHeight,\n      -halfDepth,\n      1,\n      0,\n      0,\n      1,\n      0,\n      halfWidth,\n      halfHeight,\n      halfDepth,\n      1,\n      0,\n      0,\n      0,\n      0,\n      halfWidth,\n      -halfHeight,\n      halfDepth,\n      1,\n      0,\n      0,\n      0,\n      1,\n      halfWidth,\n      -halfHeight,\n      -halfDepth,\n      1,\n      0,\n      0,\n      1,\n      1,\n      -halfWidth,\n      halfHeight,\n      halfDepth,\n      0,\n      0,\n      1,\n      0,\n      0,\n      halfWidth,\n      halfHeight,\n      halfDepth,\n      0,\n      0,\n      1,\n      1,\n      0,\n      halfWidth,\n      -halfHeight,\n      halfDepth,\n      0,\n      0,\n      1,\n      1,\n      1,\n      -halfWidth,\n      -halfHeight,\n      halfDepth,\n      0,\n      0,\n      1,\n      0,\n      1,\n      -halfWidth,\n      halfHeight,\n      -halfDepth,\n      0,\n      0,\n      -1,\n      1,\n      0,\n      halfWidth,\n      halfHeight,\n      -halfDepth,\n      0,\n      0,\n      -1,\n      0,\n      0,\n      halfWidth,\n      -halfHeight,\n      -halfDepth,\n      0,\n      0,\n      -1,\n      0,\n      1,\n      -halfWidth,\n      -halfHeight,\n      -halfDepth,\n      0,\n      0,\n      -1,\n      1,\n      1\n    ]);\n    const indices = new Uint16Array([\n      0,\n      2,\n      1,\n      2,\n      0,\n      3,\n      4,\n      6,\n      7,\n      6,\n      4,\n      5,\n      8,\n      10,\n      9,\n      10,\n      8,\n      11,\n      12,\n      14,\n      15,\n      14,\n      12,\n      13,\n      16,\n      18,\n      17,\n      18,\n      16,\n      19,\n      20,\n      22,\n      23,\n      22,\n      20,\n      21\n    ]);\n    this._initialize(engine, vertices, indices);\n  }\n}\n\nclass SphereGeometry extends ShapeGeometry {\n  constructor(engine, radius = 1, horizontalSegments = 8, verticalSegments = 6, alphaStart = 0, alphaRange = Math.PI * 2, thetaStart = 0, thetaRange = Math.PI) {\n    super(engine);\n    this._parameters = {\n      radius: radius || 1,\n      horizontalSegments: Math.max(3, Math.floor(horizontalSegments)),\n      verticalSegments: Math.max(2, Math.floor(verticalSegments)),\n      alphaStart,\n      alphaRange,\n      thetaStart,\n      thetaRange\n    };\n    this._thetaEnd = this._parameters.thetaStart + this._parameters.thetaRange;\n    this.initialize(engine);\n  }\n  initialize(engine) {\n    const {verticalSegments, horizontalSegments} = this._parameters;\n    let index = 0;\n    const grid = [];\n    const vertices = new Float32Array((verticalSegments + 1) * (horizontalSegments + 1) * 8);\n    const indices = [];\n    for (let iy = 0; iy <= verticalSegments; iy++) {\n      const verticesRow = [];\n      const v = iy / verticalSegments;\n      for (let ix = 0; ix <= horizontalSegments; ix++) {\n        const u = ix / horizontalSegments;\n        let posX = -this._parameters.radius * Math.cos(this._parameters.alphaStart + u * this._parameters.alphaRange) * Math.sin(this._parameters.thetaStart + v * this._parameters.thetaRange);\n        let posY = this._parameters.radius * Math.cos(this._parameters.thetaStart + v * this._parameters.thetaRange);\n        let posZ = this._parameters.radius * Math.sin(this._parameters.alphaStart + u * this._parameters.alphaRange) * Math.sin(this._parameters.thetaStart + v * this._parameters.thetaRange);\n        posX = Math.abs(posX) < 1e-6 ? 0 : posX;\n        posY = Math.abs(posY) < 1e-6 ? 0 : posY;\n        posZ = Math.abs(posZ) < 1e-6 ? 0 : posZ;\n        const offset = index * 8;\n        vertices[offset] = posX;\n        vertices[offset + 1] = posY;\n        vertices[offset + 2] = posZ;\n        vertices[offset + 3] = posX;\n        vertices[offset + 4] = posY;\n        vertices[offset + 5] = posZ;\n        vertices[offset + 6] = u;\n        vertices[offset + 7] = 1 - v;\n        verticesRow.push(index++);\n      }\n      grid.push(verticesRow);\n    }\n    for (let iy = 0; iy < verticalSegments; iy++) {\n      for (let ix = 0; ix < horizontalSegments; ix++) {\n        const a = grid[iy][ix + 1];\n        const b = grid[iy][ix];\n        const c = grid[iy + 1][ix];\n        const d = grid[iy + 1][ix + 1];\n        if (iy !== 0 || this._parameters.thetaStart > 0)\n          indices.push(a, b, d);\n        if (iy !== verticalSegments - 1 || this._thetaEnd < Math.PI)\n          indices.push(b, c, d);\n      }\n    }\n    this._initialize(engine, vertices, Uint16Array.from(indices));\n  }\n}\n\nclass PlaneGeometry extends ShapeGeometry {\n  constructor(engine, width = 1, height = 1, horizontalSegments = 1, verticalSegments = 1) {\n    super(engine);\n    this._parameters = {\n      width,\n      height,\n      horizontalSegments: Math.floor(horizontalSegments),\n      verticalSegments: Math.floor(verticalSegments)\n    };\n    this.halfWidth = this._parameters.width / 2;\n    this.halfHeight = this._parameters.height / 2;\n    this.initialize(engine);\n  }\n  initialize(engine) {\n    const {verticalSegments, horizontalSegments} = this._parameters;\n    let index = 0;\n    let offset = 0;\n    const grid = [];\n    const vertices = new Float32Array((verticalSegments + 1) * (horizontalSegments + 1) * 8);\n    const indices = new Uint16Array(verticalSegments * horizontalSegments * 6);\n    for (let iy = 0; iy <= verticalSegments; iy++) {\n      const verticesRow = [];\n      const v = iy / verticalSegments;\n      for (let ix = 0; ix <= horizontalSegments; ix++) {\n        const u = ix / horizontalSegments;\n        const posX = u * this._parameters.width - this.halfWidth;\n        const posY = v * this._parameters.height - this.halfHeight;\n        vertices[offset++] = posX;\n        vertices[offset++] = posY;\n        vertices[offset++] = 0;\n        vertices[offset++] = 0;\n        vertices[offset++] = 0;\n        vertices[offset++] = 1;\n        vertices[offset++] = u;\n        vertices[offset++] = 1 - v;\n        verticesRow.push(index++);\n      }\n      grid.push(verticesRow);\n    }\n    index = 0;\n    for (let iy = 0; iy < verticalSegments; iy++) {\n      for (let ix = 0; ix < horizontalSegments; ix++) {\n        const a = grid[iy][ix + 1];\n        const b = grid[iy][ix];\n        const c = grid[iy + 1][ix];\n        const d = grid[iy + 1][ix + 1];\n        indices[index++] = a;\n        indices[index++] = c;\n        indices[index++] = b;\n        indices[index++] = a;\n        indices[index++] = d;\n        indices[index++] = c;\n      }\n    }\n    this._initialize(engine, vertices, indices);\n  }\n}\n\nclass CylinderGeometry extends ShapeGeometry {\n  constructor(engine, radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = 2 * Math.PI, frontFace = FrontFace.CCW) {\n    super(engine);\n    this.FrontFace = frontFace;\n    this._parameters = {\n      radiusTop,\n      radiusBottom,\n      height,\n      radialSegments,\n      heightSegments,\n      openEnded,\n      thetaStart,\n      thetaLength\n    };\n    this._vertices = [];\n    this._indices = [];\n    this.index = 0;\n    this.indexArray = [];\n    this.halfHeight = this._parameters.height / 2;\n    this.generateTorso();\n    if (this._parameters.openEnded === false) {\n      if (this._parameters.radiusTop > 0)\n        this.generateCap(true);\n      if (this._parameters.radiusBottom > 0)\n        this.generateCap(false);\n    }\n    this._initialize(engine, Float32Array.from(this._vertices), Uint16Array.from(this._indices));\n  }\n  generateTorso() {\n    const {radialSegments, heightSegments, radiusBottom, radiusTop, height} = this._parameters;\n    let x, y;\n    const normal = new Vector3();\n    const slope = (radiusBottom - radiusTop) / height;\n    for (y = 0; y <= heightSegments; y++) {\n      const indexRow = [];\n      const v = y / heightSegments;\n      const radius = v * (radiusBottom - radiusTop) + radiusTop;\n      for (x = 0; x <= radialSegments; x++) {\n        const u = x / radialSegments;\n        const theta = u * this._parameters.thetaLength + this._parameters.thetaStart;\n        const sinTheta = Math.sin(theta);\n        const cosTheta = Math.cos(theta);\n        const vertX = radius * sinTheta;\n        const vertY = -v * height + this.halfHeight;\n        const vertZ = radius * cosTheta;\n        this._vertices.push(vertX, vertY, vertZ);\n        normal.setValue(sinTheta, slope, cosTheta);\n        normal.normalize();\n        this._vertices.push(normal.x, normal.y, normal.z);\n        if (this.FrontFace === FrontFace.CCW) {\n          this._vertices.push(u, v);\n        } else {\n          this._vertices.push(1 - u, v);\n        }\n        indexRow.push(this.index++);\n      }\n      this.indexArray.push(indexRow);\n    }\n    for (x = 0; x < radialSegments; x++) {\n      for (y = 0; y < heightSegments; y++) {\n        var a = this.indexArray[y][x];\n        var b = this.indexArray[y + 1][x];\n        var c = this.indexArray[y + 1][x + 1];\n        var d = this.indexArray[y][x + 1];\n        this._indices.push(a, b, d);\n        this._indices.push(b, c, d);\n      }\n    }\n  }\n  generateCap(isTop) {\n    const {radialSegments} = this._parameters;\n    let x;\n    const radius = isTop === true ? this._parameters.radiusTop : this._parameters.radiusBottom;\n    const sign = isTop === true ? 1 : -1;\n    const centerIndexStart = this.index;\n    for (x = 1; x <= radialSegments; x++) {\n      this._vertices.push(0, this.halfHeight * sign, 0);\n      this._vertices.push(0, sign, 0);\n      this._vertices.push(0.5, 0.5);\n      this.index++;\n    }\n    const centerIndexEnd = this.index;\n    for (x = 0; x <= radialSegments; x++) {\n      const u = x / radialSegments;\n      const theta = u * this._parameters.thetaLength + this._parameters.thetaStart;\n      const cosTheta = Math.cos(theta);\n      const sinTheta = Math.sin(theta);\n      const vertexX = radius * sinTheta;\n      const vertexY = this.halfHeight * sign;\n      const vertexZ = radius * cosTheta;\n      this._vertices.push(vertexX, vertexY, vertexZ);\n      this._vertices.push(0, sign, 0);\n      const uvX = cosTheta * 0.5 + 0.5;\n      const uvY = sinTheta * 0.5 * sign + 0.5;\n      this._vertices.push(uvX, uvY);\n      this.index++;\n    }\n    for (x = 0; x < radialSegments; x++) {\n      var c = centerIndexStart + x;\n      var i = centerIndexEnd + x;\n      if (isTop === true) {\n        this._indices.push(i, i + 1, c);\n      } else {\n        this._indices.push(i + 1, i, c);\n      }\n    }\n  }\n}\n\nclass CircleGeometry extends ShapeGeometry {\n  constructor(engine, options = {}) {\n    super(engine);\n    this.radius = 1;\n    this.segments = 16;\n    this.thetaStart = 0;\n    this.thetaLength = Math.PI * 2;\n    this.radius = options.radius || this.radius;\n    this.segments = options.segments || this.segments;\n    this.thetaStart = options.thetaStart || this.thetaStart;\n    this.thetaLength = options.thetaLength || this.thetaLength;\n    const {segments, radius} = this;\n    const vertices = new Float32Array((segments + 2) * 8);\n    vertices.set([0, 0, 0, 0, 0, 1, 0.5, 0.5]);\n    let index = 8;\n    for (let s = 0; s <= segments; s++) {\n      let segment = this.thetaStart + s / segments * this.thetaLength;\n      const x = radius * Math.cos(segment);\n      const y = radius * Math.sin(segment);\n      vertices[index++] = x;\n      vertices[index++] = y;\n      vertices[index++] = 0;\n      vertices[index++] = 0;\n      vertices[index++] = 0;\n      vertices[index++] = 1;\n      vertices[index++] = (x / radius + 1) * 0.5;\n      vertices[index++] = (y / radius + 1) * 0.5;\n    }\n    const indices = new Uint16Array(segments * 3);\n    index = 0;\n    for (let i = 1; i <= segments; i++) {\n      indices[index++] = i;\n      indices[index++] = i + 1;\n      indices[index++] = 0;\n    }\n    this._initialize(engine, vertices, indices);\n  }\n}\n\nclass ScreenQuadGeometry extends ShapeGeometry {\n  constructor(engine) {\n    super(engine);\n    const vertices = new Float32Array([-1, -1, 0, 0, 0, 1, -1, 0, 1, 0, 1, 1, 0, 1, 1, -1, 1, 0, 0, 1]);\n    const indices = new Uint16Array([0, 1, 2, 3]);\n    this._initialize(engine, vertices, indices);\n    this.subGeometry.topology = PrimitiveTopology.TriangleFan;\n  }\n  _initialize(engine, vertices, indices) {\n    const vertexStride = 20;\n    const vertexElements = [\n      new VertexElement(\"POSITION\", 0, VertexElementFormat.Vector3, 0),\n      new VertexElement(\"TEXCOORD_0\", 12, VertexElementFormat.Vector2, 0)\n    ];\n    this._initBuffer(engine, vertices, indices, vertexStride, vertexElements);\n  }\n}\n\nclass TorusGeometry extends ShapeGeometry {\n  constructor(parameters = {}, engine) {\n    super(engine);\n    this.parameters = parameters;\n    const radius = this.parameters.radius || 1;\n    const tube = this.parameters.tube || 0.4;\n    const radialSegments = Math.floor(this.parameters.radialSegments) || 8;\n    const tubularSegments = Math.floor(this.parameters.tubularSegments) || 6;\n    const arc = this.parameters.arc || Math.PI * 2;\n    const vertices = new Float32Array((radialSegments + 1) * (tubularSegments + 1) * 3);\n    const indices = new Uint16Array(radialSegments * tubularSegments * 6);\n    let index = 0;\n    for (let j = 0; j <= radialSegments; j++) {\n      for (let i = 0; i <= tubularSegments; i++) {\n        const u = i / tubularSegments * arc;\n        const v = j / radialSegments * Math.PI * 2;\n        vertices[index++] = (radius + tube * Math.cos(v)) * Math.cos(u);\n        vertices[index++] = (radius + tube * Math.cos(v)) * Math.sin(u);\n        vertices[index++] = tube * Math.sin(v);\n      }\n    }\n    index = 0;\n    for (let j = 1; j <= radialSegments; j++) {\n      for (let i = 1; i <= tubularSegments; i++) {\n        const a = (tubularSegments + 1) * j + i - 1;\n        const b = (tubularSegments + 1) * (j - 1) + i - 1;\n        const c = (tubularSegments + 1) * (j - 1) + i;\n        const d = (tubularSegments + 1) * j + i;\n        indices[index++] = a;\n        indices[index++] = b;\n        indices[index++] = d;\n        indices[index++] = b;\n        indices[index++] = c;\n        indices[index++] = d;\n      }\n    }\n    this._initialize(engine, vertices, indices);\n  }\n  _initialize(engine, vertices, indices) {\n    const vertexStride = 12;\n    const vertexElements = [new VertexElement(\"POSITION\", 0, VertexElementFormat.Vector3, 0)];\n    this._initBuffer(engine, vertices, indices, vertexStride, vertexElements);\n  }\n}\n\nclass Model extends GeometryRenderer {\n  set geometryType(value) {\n    switch (value) {\n      case \"Sphere\":\n        const {\n          sphereRadius,\n          sphereHorizontalSegments,\n          sphereVerticalSegments,\n          sphereAlphaStart,\n          sphereAlphaRange,\n          sphereThetaStart,\n          sphereThetaRange\n        } = this._props;\n        this.geometry = new SphereGeometry(this.engine, sphereRadius, sphereHorizontalSegments, sphereVerticalSegments, sphereAlphaStart, sphereAlphaRange, sphereThetaStart, sphereThetaRange);\n        break;\n      case \"Cylinder\":\n        const {\n          cylinderRadiusTop,\n          cylinderRadiusBottom,\n          cylinderHeight,\n          cylinderRadialSegments,\n          cylinderHeightSegments,\n          cylinderOpenEnded\n        } = this._props;\n        this.geometry = new CylinderGeometry(this.engine, cylinderRadiusTop, cylinderRadiusBottom, cylinderHeight, cylinderRadialSegments, cylinderHeightSegments, cylinderOpenEnded, void 0, void 0, void 0);\n        break;\n      case \"Plane\":\n        const {planeWidth, planeHeight, planeHorizontalSegments, planeVerticalSegments} = this._props;\n        this.geometry = new PlaneGeometry(this.engine, planeWidth, planeHeight, planeHorizontalSegments, planeVerticalSegments);\n        break;\n      case \"Box\":\n        var {boxWidth, boxHeight, boxDepth} = this._props;\n        this.geometry = new CuboidGeometry(this.engine, boxWidth, boxHeight, boxDepth);\n        break;\n    }\n    this._geometryType = value;\n  }\n  get geometryType() {\n    return this._geometryType;\n  }\n  constructor(entity) {\n    super(entity);\n  }\n  get material() {\n    return this._material;\n  }\n  set material(mtl) {\n    if (!mtl) {\n      this._material = new BlinnPhongMaterial(this.engine, \"mtl\");\n    } else {\n      this._material = mtl;\n    }\n  }\n  init(props) {\n    this._props = props;\n    const {geometryType = GeometryType.Box} = props;\n    this.material = props.material;\n    this.geometryType = geometryType;\n  }\n  setProp(key, value) {\n    this._props[key] = value;\n    if (key === \"material\") {\n      this.material = value;\n    } else {\n      this.geometryType = this._props.geometryType;\n    }\n  }\n}\nvar GeometryType;\n(function(GeometryType2) {\n  GeometryType2[\"Box\"] = \"Box\";\n  GeometryType2[\"Cylinder\"] = \"Cylinder\";\n  GeometryType2[\"Plane\"] = \"Plane\";\n  GeometryType2[\"Sphere\"] = \"Sphere\";\n})(GeometryType || (GeometryType = {}));\n\nvar fs = \"uniform samplerCube u_cube;\\n\\nvarying vec3 v_cubeUV;\\n\\nvoid main() {\\n\\n    gl_FragColor = textureCube( u_cube, v_cubeUV );\\n\\n}\\n\";\n\nvar vs = \"#include <common_vert>\\n\\nuniform mat4 u_mvpNoscale;\\n\\nvarying vec3 v_cubeUV;\\n\\nvoid main() {\\n\\n    v_cubeUV = a_position.xyz;\\n    gl_Position = u_mvpNoscale * vec4( a_position, 1.0 );\\n    gl_Position.z = gl_Position.w;\\n\\n}\\n\";\n\nclass SkyBoxMaterial extends Material {\n  constructor(engine, name = SkyBoxMaterial.defaultName) {\n    super(engine, name);\n  }\n  setModel(modelMatrix) {\n    this.modelMatrix = modelMatrix;\n  }\n  prepareDrawing(context, component) {\n    if (this._technique === null) {\n      this._generateTechnique();\n    }\n    if (!this._cacheMat1) {\n      this._cacheMat1 = new Matrix();\n      this._cacheMat2 = new Matrix();\n    }\n    const view = context.viewMatrix;\n    const proj = context.projectionMatrix;\n    Matrix.multiply(view, this.modelMatrix, this._cacheMat1);\n    const e = this._cacheMat1.elements;\n    e[12] = e[13] = e[14] = 0;\n    Matrix.multiply(proj, this._cacheMat1, this._cacheMat2);\n    this.setValue(\"u_mvpNoscale\", this._cacheMat2);\n    super.prepareDrawing(context, component, void 0);\n  }\n  _generateTechnique() {\n    const tech = new RenderTechnique(SkyBoxMaterial.techniqueName);\n    tech.isValid = true;\n    tech.uniforms = SkyBoxMaterial.techniqueConfig.uniforms;\n    tech.attributes = SkyBoxMaterial.techniqueConfig.attributes;\n    tech.states = SkyBoxMaterial.techniqueConfig.states;\n    tech.vertexShader = SkyBoxMaterial.vertexShader;\n    tech.fragmentShader = SkyBoxMaterial.fragmentShader;\n    this._technique = tech;\n  }\n}\nSkyBoxMaterial.defaultName = \"SKY_BOX_MATERIAL\";\nSkyBoxMaterial.techniqueName = \"SKY_BOX_TECHNIQUE\";\nSkyBoxMaterial.vertexShader = vs;\nSkyBoxMaterial.fragmentShader = fs;\nSkyBoxMaterial.techniqueConfig = {\n  attributes: {},\n  uniforms: {\n    u_mvpNoscale: {\n      name: \"u_mvpNoscale\",\n      type: DataType.FLOAT_MAT4\n    },\n    u_cube: {\n      name: \"u_cube\",\n      type: DataType.SAMPLER_CUBE\n    }\n  },\n  states: {\n    disable: [RenderState.CULL_FACE],\n    functions: {\n      depthFunc: CompFunc.LEQUAL\n    }\n  }\n};\n\nclass SkyBox extends GeometryRenderer {\n  constructor(entity) {\n    super(entity);\n    this.geometry = new CuboidGeometry(this.engine, 2, 2, 2);\n    this.material = new SkyBoxMaterial(this.engine);\n  }\n  update() {\n    this.material.setModel(this.entity.transform.worldMatrix);\n  }\n  render(camera) {\n    if (!this._skyBoxMap)\n      return;\n    super.render(camera);\n  }\n  get skyBoxMap() {\n    return this._skyBoxMap;\n  }\n  set skyBoxMap(v) {\n    this._skyBoxMap = v;\n    this.material.setValue(\"u_cube\", v);\n  }\n}\n\nvar fs$1 = \"#include <common>\\n#include <common_frag>\\n#include <pbr_common_frag_define>\\n#include <pbr_util_frag_define>\\n\\n#include <fog_share>\\n\\n#include <uv_share>\\n#include <normal_share>\\n#include <color_share>\\n#include <worldpos_share>\\n#include <refraction_share>\\n#include <perturbation_share>\\n#include <clipPlane_frag_define>\\n\\n// light\\n#include <ambient_light_frag>\\n#include <direct_light_frag>\\n#include <point_light_frag>\\n#include <spot_light_frag>\\n#include <pbr_envmap_light_frag_define>\\n\\n// prop & texture\\n#include <pbr_base_frag_define>\\n#include <pbr_texture_frag_define>\\n\\n// runtime context\\n#include <pbr_runtime_frag_define>\\n\\n// todo: generalize\\n#include <pbr_normal_frag_define>\\n\\n\\n// todo: BxDF\\n#include <pbr_brdf_cook_torrance_frag_define>\\n\\n\\n// direct + indirect\\n#include <pbr_direct_irradiance_frag_define>\\n#include <pbr_ibl_diffuse_frag_define>\\n#include <pbr_ibl_specular_frag_define>\\n\\n#include <oit_frag_define>\\n\\n\\nvoid main() {\\n    #include <clipPlane_frag>\\n\\n    #include <pbr_begin_frag>\\n    #include <pbr_direct_irradiance_frag>\\n    #include <pbr_ibl_diffuse_frag>\\n    #include <pbr_ibl_specular_frag>\\n    // todo: generalize texture logic\\n    #include <pbr_end_frag>\\n    #include <gamma_frag>\\n    #include <refraction_frag>\\n    #include <perturbation_frag>\\n    #include <fog_frag>\\n\\n    #include <oit_frag>\\n\\n    // gl_FragColor = texture2D( u_baseColorSampler, v_uv );\\n}\\n\";\n\nvar vs$1 = \"#include <common>\\n#include <common_vert>\\n#include <uv_share>\\n#include <color_share>\\n#include <normal_share>\\n#include <worldpos_share>\\n#include <clipPlane_vert_define>\\n#include <morph_target_vert>\\n\\n#include <fog_share>\\n\\nvoid main() {\\n\\n    #include <begin_position_vert>\\n    #include <begin_normal_vert>\\n\\n    #include <morph_vert>\\n    #include <skinning_vert>\\n    #include <uv_vert>\\n    #include <color_vert>\\n    #include <normal_vert>\\n    #include <worldpos_vert>\\n    #include <clipPlane_vert>\\n    #include <position_vert>\\n\\n    #include <fog_vert>\\n}\\n\";\n\nclass PBRMaterial extends Material {\n  constructor(engine, name = PBRMaterial.MATERIAL_NAME, props = {}) {\n    super(engine, name);\n    this.createDefaulteValues();\n    this.setUniforms(props);\n    this.setStates(props);\n  }\n  createDefaulteValues() {\n    this._uniformObj = {\n      baseColorFactor: new Vector4(1, 1, 1, 1),\n      metallicFactor: 1,\n      roughnessFactor: 1,\n      metallicRoughness: new Vector2(1, 1),\n      normalScale: 1,\n      emissiveFactor: new Vector3(0, 0, 0),\n      occlusionStrength: 1,\n      alphaCutoff: 0.5,\n      specularFactor: new Vector3(1, 1, 1),\n      glossinessFactor: 0,\n      envMapIntensity: 1,\n      refractionRatio: 1 / 1.33,\n      refractionDepth: 1,\n      perturbationUOffset: 0,\n      perturbationVOffset: 0\n    };\n    this._stateObj = {\n      alphaMode: \"OPAQUE\",\n      doubleSided: false,\n      side: Side.FRONT,\n      unlit: false,\n      srgb: false,\n      srgbFast: false,\n      gamma: false,\n      blendFunc: [],\n      blendFuncSeparate: [BlendFunc.SRC_ALPHA, BlendFunc.ONE_MINUS_SRC_ALPHA, BlendFunc.ONE, BlendFunc.ONE],\n      depthMask: [false],\n      getOpacityFromRGB: false,\n      isMetallicWorkflow: true,\n      envMapModeRefract: false\n    };\n    Object.keys(this._uniformObj).forEach((k) => this.setValueByParamName(k, this._uniformObj[k]));\n  }\n  setUniforms(obj) {\n    Object.keys(obj).forEach((key) => {\n      switch (key) {\n        case \"baseColorFactor\":\n          this.baseColorFactor = obj[key];\n          break;\n        case \"opacity\":\n          this.opacity = obj[key];\n          break;\n        case \"opacityTexture\":\n          this.opacityTexture = obj[key];\n          break;\n        case \"baseColorTexture\":\n          this.baseColorTexture = obj[key];\n          break;\n        case \"metallicFactor\":\n          this.metallicFactor = obj[key];\n          break;\n        case \"roughnessFactor\":\n          this.roughnessFactor = obj[key];\n          break;\n        case \"metallicTexture\":\n          this.metallicTexture = obj[key];\n          break;\n        case \"roughnessTexture\":\n          this.roughnessTexture = obj[key];\n          break;\n        case \"metallicRoughnessTexture\":\n          this.metallicRoughnessTexture = obj[key];\n          break;\n        case \"normalTexture\":\n          this.normalTexture = obj[key];\n          break;\n        case \"normalScale\":\n          this.normalScale = obj[key];\n          break;\n        case \"emissiveTexture\":\n          this.emissiveTexture = obj[key];\n          break;\n        case \"emissiveFactor\":\n          this.emissiveFactor = obj[key];\n          break;\n        case \"occlusionTexture\":\n          this.occlusionTexture = obj[key];\n          break;\n        case \"occlusionStrength\":\n          this.occlusionStrength = obj[key];\n          break;\n        case \"alphaCutoff\":\n          this.alphaCutoff = obj[key];\n          break;\n        case \"specularFactor\":\n          this.specularFactor = obj[key];\n          break;\n        case \"glossinessFactor\":\n          this.glossinessFactor = obj[key];\n          break;\n        case \"specularGlossinessTexture\":\n          this.specularGlossinessTexture = obj[key];\n          break;\n        case \"reflectionTexture\":\n          this.reflectionTexture = obj[key];\n          break;\n        case \"envMapIntensity\":\n          this.envMapIntensity = obj[key];\n          break;\n        case \"refractionRatio\":\n          this.refractionRatio = obj[key];\n          break;\n        case \"refractionDepth\":\n          this.refractionDepth = obj[key];\n          break;\n        case \"refractionTexture\":\n          this.refractionTexture = obj[key];\n          break;\n        case \"perturbationTexture\":\n          this.perturbationTexture = obj[key];\n          break;\n        case \"perturbationUOffset\":\n          this.perturbationUOffset = obj[key];\n          break;\n        case \"perturbationVOffset\":\n          this.perturbationVOffset = obj[key];\n          break;\n      }\n    });\n  }\n  setStates(obj) {\n    Object.keys(obj).forEach((key) => {\n      switch (key) {\n        case \"doubleSided\":\n          this.doubleSided = obj[key];\n          break;\n        case \"side\":\n          this.side = obj[key];\n          break;\n        case \"alphaMode\":\n          this.alphaMode = obj[key];\n          break;\n        case \"unlit\":\n          this.unlit = obj[key];\n          break;\n        case \"srgb\":\n          this.srgb = obj[key];\n          break;\n        case \"srgbFast\":\n          this.srgbFast = obj[key];\n          break;\n        case \"gamma\":\n          this.gamma = obj[key];\n          break;\n        case \"blendFunc\":\n          this.blendFunc = obj[key];\n          break;\n        case \"blendFuncSeparate\":\n          this.blendFuncSeparate = obj[key];\n          break;\n        case \"depthMask\":\n          this.depthMask = obj[key];\n          break;\n        case \"getOpacityFromRGB\":\n          this.getOpacityFromRGB = obj[key];\n          break;\n        case \"isMetallicWorkflow\":\n          this.isMetallicWorkflow = obj[key];\n          break;\n        case \"envMapModeRefract\":\n          this.envMapModeRefract = obj[key];\n          break;\n      }\n    });\n  }\n  setValueByParamName(paramName, value) {\n    const uniforms = PBRMaterial.TECH_CONFIG.uniforms;\n    const uniformName = Object.keys(uniforms).find((key) => uniforms[key].paramName === paramName);\n    if (uniformName) {\n      this.setValue(uniformName, value);\n    }\n  }\n  updateTechnique(stateName, v) {\n    if (this[stateName] === v)\n      return;\n    this._stateObj[stateName] = v;\n    const states = this.technique?.states;\n    if (!states)\n      return;\n    switch (stateName) {\n      case \"doubleSided\":\n      case \"side\":\n        if (this.doubleSided) {\n          states.disable.push(RenderState.CULL_FACE);\n        } else {\n          const index = states.disable.indexOf(RenderState.CULL_FACE);\n          if (index > -1) {\n            states.disable.splice(index, 1);\n          }\n          switch (this.side) {\n            case Side.FRONT:\n              states.functions.cullFace = [CullFace.BACK];\n              break;\n            case Side.BACK:\n              states.functions.cullFace = [CullFace.FRONT];\n              break;\n            case Side.NONE:\n              states.functions.cullFace = [CullFace.FRONT_AND_BACK];\n              break;\n            default:\n              delete states.functions.cullFace;\n          }\n        }\n        break;\n      case \"blendFunc\":\n      case \"blendFuncSeparate\":\n        if (this.blendFunc.length) {\n          states.functions.blendFunc = this.blendFunc;\n        } else {\n          states.functions.blendFuncSeparate = this.blendFuncSeparate;\n        }\n        break;\n      case \"depthMask\":\n        states.functions.depthMask = v;\n        break;\n      default:\n        this._technique = null;\n    }\n  }\n  get baseColorFactor() {\n    return this._uniformObj.baseColorFactor;\n  }\n  set baseColorFactor(v) {\n    this._uniformObj.baseColorFactor = v;\n    this.setValueByParamName(\"baseColorFactor\", v);\n  }\n  get opacity() {\n    return this.baseColorFactor.w;\n  }\n  set opacity(val) {\n    this.baseColorFactor.w = val;\n  }\n  get baseColorTexture() {\n    return this._uniformObj.baseColorTexture;\n  }\n  set baseColorTexture(v) {\n    this.setValueByParamName(\"baseColorTexture\", v);\n    this._uniformObj.baseColorTexture = v;\n  }\n  get opacityTexture() {\n    return this._uniformObj.opacityTexture;\n  }\n  set opacityTexture(v) {\n    this.setValueByParamName(\"opacityTexture\", v);\n    this._uniformObj.opacityTexture = v;\n  }\n  get metallicFactor() {\n    return this._uniformObj.metallicFactor;\n  }\n  set metallicFactor(v) {\n    this._uniformObj.metallicFactor = v;\n    this._uniformObj.metallicRoughness.x = v;\n    this.setValueByParamName(\"metallicRoughness\", this._uniformObj.metallicRoughness);\n  }\n  get roughnessFactor() {\n    return this._uniformObj.roughnessFactor;\n  }\n  set roughnessFactor(v) {\n    this._uniformObj.roughnessFactor = v;\n    this._uniformObj.metallicRoughness.y = v;\n    this.setValueByParamName(\"metallicRoughness\", this._uniformObj.metallicRoughness);\n  }\n  get metallicTexture() {\n    return this._uniformObj.metallicTexture;\n  }\n  set metallicTexture(v) {\n    this.setValueByParamName(\"metallicTexture\", v);\n    this._uniformObj.metallicTexture = v;\n  }\n  get roughnessTexture() {\n    return this._uniformObj.roughnessTexture;\n  }\n  set roughnessTexture(v) {\n    this.setValueByParamName(\"roughnessTexture\", v);\n    this._uniformObj.roughnessTexture = v;\n  }\n  get metallicRoughnessTexture() {\n    return this._uniformObj.metallicRoughnessTexture;\n  }\n  set metallicRoughnessTexture(v) {\n    this.setValueByParamName(\"metallicRoughnessTexture\", v);\n    this._uniformObj.metallicRoughnessTexture = v;\n  }\n  get normalTexture() {\n    return this._uniformObj.normalTexture;\n  }\n  set normalTexture(v) {\n    this.setValueByParamName(\"normalTexture\", v);\n    this._uniformObj.normalTexture = v;\n  }\n  get normalScale() {\n    return this._uniformObj.normalScale;\n  }\n  set normalScale(v) {\n    this._uniformObj.normalScale = v;\n    this.setValueByParamName(\"normalScale\", v);\n  }\n  get emissiveTexture() {\n    return this._uniformObj.emissiveTexture;\n  }\n  set emissiveTexture(v) {\n    this.setValueByParamName(\"emissiveTexture\", v);\n    this._uniformObj.emissiveTexture = v;\n  }\n  get emissiveFactor() {\n    return this._uniformObj.emissiveFactor;\n  }\n  set emissiveFactor(v) {\n    this._uniformObj.emissiveFactor = v;\n    this.setValueByParamName(\"emissiveFactor\", v);\n  }\n  get occlusionTexture() {\n    return this._uniformObj.occlusionTexture;\n  }\n  set occlusionTexture(v) {\n    this.setValueByParamName(\"occlusionTexture\", v);\n    this._uniformObj.occlusionTexture = v;\n  }\n  get occlusionStrength() {\n    return this._uniformObj.occlusionStrength;\n  }\n  set occlusionStrength(v) {\n    this._uniformObj.occlusionStrength = v;\n    this.setValueByParamName(\"occlusionStrength\", v);\n  }\n  get alphaCutoff() {\n    return this._uniformObj.alphaCutoff;\n  }\n  set alphaCutoff(v) {\n    this._uniformObj.alphaCutoff = v;\n    this.setValueByParamName(\"alphaCutoff\", v);\n  }\n  get specularFactor() {\n    return this._uniformObj.specularFactor;\n  }\n  set specularFactor(v) {\n    this.setValueByParamName(\"specularFactor\", v);\n    this._uniformObj.specularFactor = v;\n  }\n  get glossinessFactor() {\n    return this._uniformObj.glossinessFactor;\n  }\n  set glossinessFactor(v) {\n    this.setValueByParamName(\"glossinessFactor\", v);\n    this._uniformObj.glossinessFactor = v;\n  }\n  get specularGlossinessTexture() {\n    return this._uniformObj.specularGlossinessTexture;\n  }\n  set specularGlossinessTexture(v) {\n    this.setValueByParamName(\"specularGlossinessTexture\", v);\n    this._uniformObj.specularGlossinessTexture = v;\n  }\n  get reflectionTexture() {\n    return this._uniformObj.reflectionTexture;\n  }\n  set reflectionTexture(v) {\n    this.setValueByParamName(\"reflectionTexture\", v);\n    this._uniformObj.reflectionTexture = v;\n  }\n  get envMapIntensity() {\n    return this._uniformObj.envMapIntensity;\n  }\n  set envMapIntensity(v) {\n    this.setValueByParamName(\"envMapIntensity\", v);\n    this._uniformObj.envMapIntensity = v;\n  }\n  get refractionRatio() {\n    return this._uniformObj.refractionRatio;\n  }\n  set refractionRatio(v) {\n    this.setValueByParamName(\"refractionRatio\", v);\n    this._uniformObj.refractionRatio = v;\n  }\n  get refractionDepth() {\n    return this._uniformObj.refractionDepth;\n  }\n  set refractionDepth(v) {\n    this.setValueByParamName(\"refractionDepth\", v);\n    this._uniformObj.refractionDepth = v;\n  }\n  get refractionTexture() {\n    return this._uniformObj.refractionTexture;\n  }\n  set refractionTexture(v) {\n    this.setValueByParamName(\"refractionTexture\", v);\n    this._uniformObj.refractionTexture = v;\n  }\n  get perturbationTexture() {\n    return this._uniformObj.perturbationTexture;\n  }\n  set perturbationTexture(v) {\n    this.setValueByParamName(\"perturbationTexture\", v);\n    this._uniformObj.perturbationTexture = v;\n  }\n  get perturbationUOffset() {\n    return this._uniformObj.perturbationUOffset;\n  }\n  set perturbationUOffset(v) {\n    this.setValueByParamName(\"perturbationUOffset\", v);\n    this._uniformObj.perturbationUOffset = v;\n  }\n  get perturbationVOffset() {\n    return this._uniformObj.perturbationVOffset;\n  }\n  set perturbationVOffset(v) {\n    this.setValueByParamName(\"perturbationVOffset\", v);\n    this._uniformObj.perturbationVOffset = v;\n  }\n  get alphaMode() {\n    return this._stateObj.alphaMode;\n  }\n  set alphaMode(v) {\n    this.updateTechnique(\"alphaMode\", v);\n  }\n  get doubleSided() {\n    return this._stateObj.doubleSided;\n  }\n  set doubleSided(v) {\n    if (v) {\n      this._stateObj.side = Side.DOUBLE;\n    } else if (this._stateObj.side === Side.DOUBLE) {\n      this._stateObj.side = Side.FRONT;\n    }\n    this.updateTechnique(\"doubleSided\", v);\n  }\n  get side() {\n    return this._stateObj.side;\n  }\n  set side(v) {\n    if (v === Side.DOUBLE) {\n      this._stateObj.doubleSided = true;\n    } else {\n      this._stateObj.doubleSided = false;\n    }\n    this.updateTechnique(\"side\", v);\n  }\n  get unlit() {\n    return this._stateObj.unlit;\n  }\n  set unlit(v) {\n    this.updateTechnique(\"unlit\", v);\n  }\n  get srgb() {\n    return this._stateObj.srgb;\n  }\n  set srgb(v) {\n    this.updateTechnique(\"srgb\", v);\n  }\n  get srgbFast() {\n    return this._stateObj.srgbFast;\n  }\n  set srgbFast(v) {\n    this.updateTechnique(\"srgbFast\", v);\n  }\n  get gamma() {\n    return this._stateObj.gamma;\n  }\n  set gamma(v) {\n    this.updateTechnique(\"gamma\", v);\n  }\n  get blendFunc() {\n    return this._stateObj.blendFunc;\n  }\n  set blendFunc(v) {\n    this.updateTechnique(\"blendFunc\", v);\n  }\n  get blendFuncSeparate() {\n    return this._stateObj.blendFuncSeparate;\n  }\n  set blendFuncSeparate(v) {\n    this.updateTechnique(\"blendFuncSeparate\", v);\n  }\n  get depthMask() {\n    return this._stateObj.depthMask;\n  }\n  set depthMask(v) {\n    this.updateTechnique(\"depthMask\", v);\n  }\n  get getOpacityFromRGB() {\n    return this._stateObj.getOpacityFromRGB;\n  }\n  set getOpacityFromRGB(v) {\n    this.updateTechnique(\"getOpacityFromRGB\", v);\n  }\n  get isMetallicWorkflow() {\n    return this._stateObj.isMetallicWorkflow;\n  }\n  set isMetallicWorkflow(v) {\n    this.updateTechnique(\"isMetallicWorkflow\", v);\n  }\n  get envMapModeRefract() {\n    return this._stateObj.envMapModeRefract;\n  }\n  set envMapModeRefract(v) {\n    this.updateTechnique(\"envMapModeRefract\", v);\n  }\n  prepareDrawing(context, component, primitive) {\n    const camera = context.camera;\n    const scene = camera.scene;\n    const canvas = scene.engine.canvas;\n    const lightMgr = scene.findFeature(LightFeature);\n    const canOIT = camera._renderPipeline.canOIT;\n    lightMgr.bindMaterialValues(this);\n    this.setValue(\"u_resolution\", new Vector2(canvas.width, canvas.height));\n    for (let i = 0; i < this._clipPlaneCount; i++) {\n      this.setValue(`u_clipPlanes[${i}]`, scene.clipPlanes[i]);\n    }\n    if (canOIT) {\n      this.setValue(\"u_depthSampler\", camera._renderPipeline.depthTexture);\n    }\n    const {\n      ambientLightCount,\n      directLightCount,\n      pointLightCount,\n      spotLightCount,\n      envMapLightCount,\n      useDiffuseEnv,\n      useSpecularEnv\n    } = lightMgr.lightSortAmount;\n    if (!this._technique || this._ambientLightCount !== ambientLightCount || this._envMapLightCount !== envMapLightCount || this._useDiffuseEnv !== useDiffuseEnv || this._useSpecularEnv !== useSpecularEnv || this._directLightCount !== directLightCount || this._pointLightCount !== pointLightCount || this._spotLightCount !== spotLightCount || this._clipPlaneCount !== scene.clipPlanes?.length || this._useOIT !== canOIT) {\n      this._ambientLightCount = ambientLightCount;\n      this._envMapLightCount = envMapLightCount;\n      this._useDiffuseEnv = useDiffuseEnv;\n      this._useSpecularEnv = useSpecularEnv;\n      this._directLightCount = directLightCount;\n      this._pointLightCount = pointLightCount;\n      this._spotLightCount = spotLightCount;\n      this._clipPlaneCount = scene.clipPlanes?.length;\n      this._useOIT = canOIT;\n      this._generateTechnique(camera, component, primitive);\n    }\n    super.prepareDrawing(context, component, primitive);\n  }\n  _generateTechnique(camera, component, primitive) {\n    const customMacros = this._generateShaderMacros(camera, component, primitive);\n    const techName = PBRMaterial.TECHNIQUE_NAME;\n    const vertex = PBRMaterial.STATIC_VERTEX_SHADER;\n    const frag = PBRMaterial.STATIC_FRAGMENT_SHADER;\n    const config = this._generateConfig();\n    const lightMgr = camera.scene.findFeature(LightFeature);\n    const tech = new RenderTechnique(techName);\n    tech.isValid = true;\n    tech.uniforms = {...lightMgr.getUniformDefine(), ...config.uniforms};\n    tech.attributes = config.attributes;\n    tech.fragmentPrecision = \"highp\";\n    tech.customMacros = customMacros;\n    tech.states = config.states;\n    tech.vertexShader = vertex;\n    tech.fragmentShader = frag;\n    this._technique = tech;\n    return tech;\n  }\n  _generateShaderMacros(camera, component, primitive) {\n    const rhi = camera.scene.engine._hardwareRenderer;\n    const _macros = [\"O3_NEED_WORLDPOS\"];\n    if (!primitive._vertexElementMap.NORMAL || !primitive._vertexElementMap.TANGENT) {\n      if (rhi.canIUse(GLCapabilityType.standardDerivatives))\n        _macros.push(\"HAS_DERIVATIVES\");\n    }\n    const uniforms = Object.keys(this._values);\n    if (uniforms.indexOf(\"u_baseColorSampler\") > -1)\n      _macros.push(\"HAS_BASECOLORMAP\");\n    if (uniforms.indexOf(\"u_normalSampler\") > -1)\n      _macros.push(\"O3_HAS_NORMALMAP\");\n    if (uniforms.indexOf(\"u_metallicSampler\") > -1)\n      _macros.push(\"HAS_METALMAP\");\n    if (uniforms.indexOf(\"u_roughnessSampler\") > -1)\n      _macros.push(\"HAS_ROUGHNESSMAP\");\n    if (uniforms.indexOf(\"u_metallicRoughnessSampler\") > -1)\n      _macros.push(\"HAS_METALROUGHNESSMAP\");\n    if (uniforms.indexOf(\"u_emissiveSampler\") > -1)\n      _macros.push(\"HAS_EMISSIVEMAP\");\n    if (uniforms.indexOf(\"u_occlusionSampler\") > -1)\n      _macros.push(\"HAS_OCCLUSIONMAP\");\n    if (uniforms.indexOf(\"u_specularGlossinessSampler\") > -1)\n      _macros.push(\"HAS_SPECULARGLOSSINESSMAP\");\n    if (uniforms.indexOf(\"u_perturbationSampler\") > -1)\n      _macros.push(\"HAS_PERTURBATIONMAP\");\n    if (uniforms.indexOf(\"u_reflectionSampler\") > -1)\n      _macros.push(\"HAS_REFLECTIONMAP\");\n    if (uniforms.indexOf(\"u_refractionSampler\") > -1) {\n      this.setValueByParamName(\"PTMMatrix\", new Matrix(0.5, 0, 0, 0, 0, 0.5, 0, 0, 0, 0, 0.5, 0, 0.5, 0.5, 0.5, 1));\n      _macros.push(\"HAS_REFRACTIONMAP\");\n    }\n    if (this.alphaMode === \"MASK\") {\n      _macros.push(\"ALPHA_MASK\");\n    } else if (this.alphaMode === \"BLEND\" && !this.refractionTexture) {\n      _macros.push(\"ALPHA_BLEND\");\n      if (uniforms.indexOf(\"u_opacitySampler\") > -1) {\n        _macros.push(\"HAS_OPACITYMAP\");\n        if (this.getOpacityFromRGB) {\n          _macros.push(\"GETOPACITYFROMRGB\");\n        }\n      }\n    }\n    if (this._envMapLightCount) {\n      _macros.push(\"O3_HAS_ENVMAP_LIGHT\");\n      if (this._useDiffuseEnv)\n        _macros.push(\"O3_USE_DIFFUSE_ENV\");\n      if (this._useSpecularEnv)\n        _macros.push(\"O3_USE_SPECULAR_ENV\");\n      if (rhi.canIUse(GLCapabilityType.shaderTextureLod))\n        _macros.push(\"HAS_TEX_LOD\");\n    }\n    if (this._ambientLightCount) {\n      _macros.push(\"O3_HAS_AMBIENT_LIGHT\");\n    }\n    if (this._directLightCount)\n      _macros.push(`O3_DIRECT_LIGHT_COUNT ${this._directLightCount}`);\n    if (this._pointLightCount)\n      _macros.push(`O3_POINT_LIGHT_COUNT ${this._pointLightCount}`);\n    if (this._spotLightCount)\n      _macros.push(`O3_SPOT_LIGHT_COUNT ${this._spotLightCount}`);\n    if (this._clipPlaneCount)\n      _macros.push(`O3_CLIPPLANE_NUM ${this._clipPlaneCount}`);\n    if (this._stateObj.unlit)\n      _macros.push(\"UNLIT\");\n    if (this._stateObj.srgb)\n      _macros.push(\"MANUAL_SRGB\");\n    if (this._stateObj.srgbFast)\n      _macros.push(\"SRGB_FAST_APPROXIMATION\");\n    if (this._stateObj.gamma)\n      _macros.push(\"GAMMA\");\n    if (this._stateObj.isMetallicWorkflow)\n      _macros.push(\"IS_METALLIC_WORKFLOW\");\n    if (this._stateObj.envMapModeRefract)\n      _macros.push(\"ENVMAPMODE_REFRACT\");\n    if (camera._renderPipeline.canOIT) {\n      _macros.push(\"OIT_ENABLE\");\n    }\n    return _macros;\n  }\n  _generateConfig() {\n    const defaultState = PBRMaterial.TECH_CONFIG.states;\n    const states = {\n      disable: defaultState.disable.slice(),\n      enable: defaultState.enable.slice(),\n      functions: Object.assign({}, defaultState.functions)\n    };\n    if (this.doubleSided) {\n      states.disable.push(RenderState.CULL_FACE);\n    } else {\n      switch (this.side) {\n        case Side.FRONT:\n          states.functions.cullFace = [CullFace.BACK];\n          break;\n        case Side.BACK:\n          states.functions.cullFace = [CullFace.FRONT];\n          break;\n        case Side.NONE:\n          states.functions.cullFace = [CullFace.FRONT_AND_BACK];\n          break;\n        default:\n          delete states.functions.cullFace;\n      }\n    }\n    if (this.alphaMode === \"BLEND\" && !this.refractionTexture) {\n      states.enable.push(RenderState.BLEND);\n      if (this.blendFunc.length) {\n        states.functions.blendFunc = this._stateObj.blendFunc;\n      } else {\n        states.functions.blendFuncSeparate = this._stateObj.blendFuncSeparate;\n      }\n      states.functions.depthMask = this._stateObj.depthMask;\n      this.renderType = MaterialType.TRANSPARENT;\n    } else {\n      this.renderType = MaterialType.OPAQUE;\n    }\n    const clipPlaneUniforms = {};\n    for (let i = 0; i < this._clipPlaneCount; i++) {\n      clipPlaneUniforms[`u_clipPlanes[${i}]`] = {\n        name: `u_clipPlanes[${i}]`,\n        type: DataType.FLOAT_VEC4\n      };\n    }\n    PBRMaterial.TECH_CONFIG.uniforms = Object.assign({}, PBRMaterial.TECH_CONFIG.uniforms, clipPlaneUniforms);\n    return Object.assign({}, PBRMaterial.TECH_CONFIG, {states});\n  }\n  clone(name) {\n    const newMtl = new PBRMaterial(this._engine, name || this.name);\n    newMtl.renderType = this.renderType;\n    newMtl.useFog = this.useFog;\n    for (const name2 in this._uniformObj) {\n      const value = this._uniformObj[name2];\n      if (value instanceof Texture) {\n        newMtl[name2] = value;\n      } else {\n        newMtl[name2] = Util.clone(value);\n      }\n    }\n    if (this._stateObj) {\n      newMtl._stateObj = Util.clone(this._stateObj);\n    }\n    return newMtl;\n  }\n}\nPBRMaterial.MATERIAL_NAME = \"PBR_MATERIAL\";\nPBRMaterial.TECHNIQUE_NAME = \"PBR_TECHNIQUE\";\nPBRMaterial.STATIC_VERTEX_SHADER = vs$1;\nPBRMaterial.STATIC_FRAGMENT_SHADER = fs$1;\nPBRMaterial.attribUniformVec4 = 12;\nPBRMaterial.TECH_CONFIG = {\n  attributes: {},\n  uniforms: Object.assign({\n    u_baseColorSampler: {\n      name: \"u_baseColorSampler\",\n      paramName: \"baseColorTexture\",\n      type: DataType.SAMPLER_2D\n    },\n    u_baseColorFactor: {\n      name: \"u_baseColorFactor\",\n      paramName: \"baseColorFactor\",\n      type: DataType.FLOAT_VEC4\n    },\n    u_normalSampler: {\n      name: \"u_normalSampler\",\n      paramName: \"normalTexture\",\n      type: DataType.SAMPLER_2D\n    },\n    u_normalScale: {\n      name: \"u_normalScale\",\n      paramName: \"normalScale\",\n      type: DataType.FLOAT\n    },\n    u_lightDirection: {\n      name: \"u_lightDirection\",\n      type: DataType.FLOAT_VEC3\n    },\n    u_lightColor: {\n      name: \"u_lightColor\",\n      type: DataType.FLOAT_VEC3\n    },\n    u_metallicRoughnessValue: {\n      name: \"u_metallicRoughnessValue\",\n      paramName: \"metallicRoughness\",\n      type: DataType.FLOAT_VEC2\n    },\n    u_metallicSampler: {\n      name: \"u_metallicSampler\",\n      paramName: \"metallicTexture\",\n      type: DataType.SAMPLER_2D\n    },\n    u_roughnessSampler: {\n      name: \"u_roughnessSampler\",\n      paramName: \"roughnessTexture\",\n      type: DataType.SAMPLER_2D\n    },\n    u_metallicRoughnessSampler: {\n      name: \"u_metallicRoughnessSampler\",\n      paramName: \"metallicRoughnessTexture\",\n      type: DataType.SAMPLER_2D\n    },\n    u_emissiveFactor: {\n      name: \"u_emissiveFactor\",\n      paramName: \"emissiveFactor\",\n      type: DataType.FLOAT_VEC3\n    },\n    u_emissiveSampler: {\n      name: \"u_emissiveSampler\",\n      paramName: \"emissiveTexture\",\n      type: DataType.SAMPLER_2D\n    },\n    u_occlusionSampler: {\n      name: \"u_occlusionSampler\",\n      paramName: \"occlusionTexture\",\n      type: DataType.SAMPLER_2D\n    },\n    u_occlusionStrength: {\n      name: \"u_occlusionStrength\",\n      paramName: \"occlusionStrength\",\n      type: DataType.FLOAT\n    },\n    u_alphaCutoff: {\n      name: \"u_alphaCutoff\",\n      paramName: \"alphaCutoff\",\n      type: DataType.FLOAT\n    },\n    u_opacitySampler: {\n      name: \"u_opacitySampler\",\n      paramName: \"opacityTexture\",\n      type: DataType.SAMPLER_2D\n    },\n    u_specularFactor: {\n      name: \"u_specularFactor\",\n      paramName: \"specularFactor\",\n      type: DataType.FLOAT_VEC3\n    },\n    u_glossinessFactor: {\n      name: \"u_glossinessFactor\",\n      paramName: \"glossinessFactor\",\n      type: DataType.FLOAT\n    },\n    u_specularGlossinessSampler: {\n      name: \"u_specularGlossinessSampler\",\n      paramName: \"specularGlossinessTexture\",\n      type: DataType.SAMPLER_2D\n    },\n    u_reflectionSampler: {\n      name: \"u_reflectionSampler\",\n      paramName: \"reflectionTexture\",\n      type: DataType.SAMPLER_CUBE\n    },\n    u_PTMMatrix: {\n      name: \"u_PTMMatrix\",\n      paramName: \"PTMMatrix\",\n      type: DataType.FLOAT_MAT4\n    },\n    u_envMapIntensity: {\n      name: \"u_envMapIntensity\",\n      paramName: \"envMapIntensity\",\n      type: DataType.FLOAT\n    },\n    u_refractionRatio: {\n      name: \"u_refractionRatio\",\n      paramName: \"refractionRatio\",\n      type: DataType.FLOAT\n    },\n    u_refractionDepth: {\n      name: \"u_refractionDepth\",\n      paramName: \"refractionDepth\",\n      type: DataType.FLOAT\n    },\n    u_refractionSampler: {\n      name: \"u_refractionSampler\",\n      paramName: \"refractionTexture\",\n      type: DataType.SAMPLER_2D\n    },\n    u_resolution: {\n      name: \"u_resolution\",\n      paramName: \"resolution\",\n      type: DataType.FLOAT_VEC2\n    },\n    u_perturbationSampler: {\n      name: \"u_perturbationSampler\",\n      paramName: \"perturbationTexture\",\n      type: DataType.SAMPLER_2D\n    },\n    u_perturbationUOffset: {\n      name: \"u_perturbationUOffset\",\n      paramName: \"perturbationUOffset\",\n      type: DataType.FLOAT\n    },\n    u_perturbationVOffset: {\n      name: \"u_perturbationVOffset\",\n      paramName: \"perturbationVOffset\",\n      type: DataType.FLOAT\n    },\n    u_depthSampler: {\n      name: \"u_depthSampler\",\n      type: DataType.SAMPLER_2D\n    }\n  }),\n  states: {\n    disable: [],\n    enable: [],\n    functions: {}\n  }\n};\n\nclass GPUParticleSystem extends GeometryRenderer {\n  constructor(entity) {\n    super(entity);\n    this._time = 0;\n    this._isInit = false;\n    this._isStart = false;\n  }\n  initialize(props) {\n    this.maxCount = props.maxCount !== void 0 ? props.maxCount : 1e3;\n    this.once = props.once || false;\n    this.options = props.options || {};\n    this.getOptions = props.getOptions;\n    this.rotateToVelocity = props.rotateToVelocity || false;\n    if (props.blendFuncSeparate) {\n      this.blendFuncSeparate = props.blendFuncSeparate;\n    }\n    this.blendFunc = props.blendFunc || [BlendFunc.SRC_ALPHA, BlendFunc.ONE_MINUS_SRC_ALPHA];\n    this.useOriginColor = props.useOriginColor !== void 0 ? props.useOriginColor : true;\n    this.fragmentShader = props.fragmentShader || null;\n    this.vertexShader = props.vertexShader || null;\n    this.particleTex = props.texture || null;\n    this.fadeIn = props.fadeIn || false;\n    this.fadeOut = props.fadeOut === void 0 ? true : props.fadeOut;\n    this.particleMaskTex = props.maskTexture || null;\n    this.isScaleByLifetime = props.isScaleByLifetime || false;\n    this.scaleFactor = props.scaleFactor || 1;\n    this.spriteSheet = props.spriteSheet || null;\n    this.is2d = props.is2d === void 0 ? true : props.is2d;\n    this.interleaved = props.spriteSheet || true;\n    this.setMaterial();\n    this.geometry = this._createGeometry();\n    this._isInit = true;\n    const options = this.getOptions ? this.getOptions(this._time) : this.options;\n    for (let x = 0; x < this.maxCount; x++) {\n      this._spawnParticle(options, x);\n    }\n    this._vertexBuffer.setData(this._vertices);\n    return this;\n  }\n  update(deltaTime) {\n    if (!this._isInit || !this._isStart) {\n      return;\n    }\n    this._time += deltaTime / 1e3;\n    this.material.setValue(\"uTime\", this._time);\n  }\n  setOptions(options) {\n    if (options !== void 0) {\n      this.options = {...this.options, ...options};\n    }\n    return this;\n  }\n  start() {\n    this._isStart = true;\n    this._time = 0;\n    this.material.setValue(\"uActive\", 1);\n  }\n  stop() {\n    this.material.setValue(\"uActive\", 0);\n  }\n  destroy() {\n    super.destroy();\n    this.options = null;\n    if (this.particleTex) {\n      this.particleTex = null;\n    }\n    if (this.particleMaskTex) {\n      this.particleMaskTex = null;\n    }\n  }\n  setMaterial() {\n    const technique = this._createTechnique();\n    const material = new Material(this.engine, \"particleMaterial\");\n    material.technique = technique;\n    material.renderType = MaterialType.TRANSPARENT;\n    material.setValue(\"uOnce\", this.once ? 1 : 0);\n    material.setValue(\"uTime\", this._time);\n    if (this.particleTex) {\n      this.particleTex.wrapModeU = this.particleTex.wrapModeV = TextureWrapMode.Clamp;\n      material.setValue(\"particleTex\", this.particleTex);\n    }\n    if (this.particleMaskTex) {\n      this.particleMaskTex.wrapModeU = this.particleTex.wrapModeV = TextureWrapMode.Clamp;\n      material.setValue(\"particleMaskTex\", this.particleMaskTex);\n    }\n    this.material = material;\n  }\n  _createTechnique() {\n    const cfg = {\n      attributes: {\n        positionStart: {\n          name: \"positionStart\",\n          semantic: \"POSITIONSTART\",\n          type: DataType.FLOAT_VEC3\n        },\n        color: {\n          name: \"color\",\n          semantic: \"COLOR\",\n          type: DataType.FLOAT_VEC3\n        },\n        alpha: {\n          name: \"alpha\",\n          semantic: \"ALPHA\",\n          type: DataType.FLOAT\n        },\n        acceleration: {\n          name: \"acceleration\",\n          semantic: \"ACCELERATION\",\n          type: DataType.FLOAT_VEC3\n        },\n        velocity: {\n          name: \"velocity\",\n          semantic: \"VELOCITY\",\n          type: DataType.FLOAT_VEC3\n        },\n        startAngle: {\n          name: \"startAngle\",\n          semantic: \"STARTANGLE\",\n          type: DataType.FLOAT\n        },\n        lifeTime: {\n          name: \"lifeTime\",\n          semantic: \"LIFETIME\",\n          type: DataType.FLOAT\n        },\n        startTime: {\n          name: \"startTime\",\n          semantic: \"STARTTIME\",\n          type: DataType.FLOAT\n        },\n        size: {\n          name: \"size\",\n          semantic: \"SIZE\",\n          type: DataType.FLOAT\n        },\n        rotateRate: {\n          name: \"rotateRate\",\n          semantic: \"ROTATERATE\",\n          type: DataType.FLOAT\n        },\n        scaleFactor: {\n          name: \"scaleFactor\",\n          semantic: \"SCALEFACTOR\",\n          type: DataType.FLOAT\n        },\n        uv: {\n          name: \"uv\",\n          semantic: \"UV\",\n          type: DataType.FLOAT_VEC3\n        },\n        normalizedUv: {\n          name: \"normalizedUv\",\n          semantic: \"NORMALIZED_UV\",\n          type: DataType.FLOAT_VEC2\n        }\n      },\n      uniforms: {\n        uOnce: {\n          name: \"uOnce\",\n          type: DataType.FLOAT\n        },\n        uActive: {\n          name: \"uActive\",\n          type: DataType.FLOAT\n        },\n        uTime: {\n          name: \"uTime\",\n          type: DataType.FLOAT\n        },\n        matModelViewProjection: {\n          name: \"matModelViewProjection\",\n          semantic: UniformSemantic.MODELVIEWPROJECTION,\n          type: DataType.FLOAT_MAT4\n        },\n        matModelView: {\n          name: \"matModelView\",\n          semantic: UniformSemantic.MODELVIEW,\n          type: DataType.FLOAT_MAT4\n        }\n      },\n      states: {\n        enable: [RenderState.BLEND],\n        functions: {\n          depthMask: [false]\n        }\n      }\n    };\n    if (this.is2d) {\n      cfg.uniforms.matViewInverse = {\n        name: \"matViewInverse\",\n        semantic: UniformSemantic.VIEWINVERSE,\n        type: DataType.FLOAT_MAT4\n      };\n      cfg.uniforms.matProjection = {\n        name: \"matProjection\",\n        semantic: UniformSemantic.PROJECTION,\n        type: DataType.FLOAT_MAT4\n      };\n      cfg.uniforms.matView = {\n        name: \"matView\",\n        semantic: UniformSemantic.VIEW,\n        type: DataType.FLOAT_MAT4\n      };\n      cfg.uniforms.matWorld = {\n        name: \"matWorld\",\n        semantic: UniformSemantic.MODEL,\n        type: DataType.FLOAT_MAT4\n      };\n    } else {\n      cfg.states.disable = [RenderState.CULL_FACE];\n    }\n    if (this.blendFuncSeparate) {\n      cfg.states.functions.blendFuncSeparate = this.blendFuncSeparate;\n    } else {\n      cfg.states.functions.blendFunc = this.blendFunc;\n    }\n    if (this.particleTex) {\n      cfg.uniforms.particleTex = {\n        name: \"particleTex\",\n        type: DataType.SAMPLER_2D\n      };\n    }\n    if (this.particleMaskTex) {\n      cfg.uniforms.particleMaskTex = {\n        name: \"particleMaskTex\",\n        type: DataType.SAMPLER_2D\n      };\n    }\n    const tech = new RenderTechnique(\"particleTech\");\n    tech.isValid = true;\n    tech.uniforms = cfg.uniforms;\n    tech.attributes = cfg.attributes;\n    tech.states = cfg.states;\n    tech.vertexShader = this._createVertexShader();\n    tech.fragmentShader = this._createFragmentShader();\n    return tech;\n  }\n  _createGeometry() {\n    const geometry2 = new BufferGeometry(this._entity.engine, \"particleGeometry\");\n    const vertexStride = 96;\n    const vertexFloatCount = this.maxCount * 4 * vertexStride;\n    const vertices = new Float32Array(vertexFloatCount);\n    const indices = new Uint16Array(6 * this.maxCount);\n    for (let i = 0, idx = 0; i < this.maxCount; ++i) {\n      let startIndex = i * 4;\n      indices[idx++] = startIndex + 0;\n      indices[idx++] = startIndex + 1;\n      indices[idx++] = startIndex + 2;\n      indices[idx++] = startIndex + 0;\n      indices[idx++] = startIndex + 2;\n      indices[idx++] = startIndex + 3;\n    }\n    const vertexElements = [\n      new VertexElement(\"POSITIONSTART\", 0, VertexElementFormat.Vector3, 0),\n      new VertexElement(\"VELOCITY\", 12, VertexElementFormat.Vector3, 0),\n      new VertexElement(\"ACCELERATION\", 24, VertexElementFormat.Vector3, 0),\n      new VertexElement(\"COLOR\", 36, VertexElementFormat.Vector3, 0),\n      new VertexElement(\"ALPHA\", 48, VertexElementFormat.Float, 0),\n      new VertexElement(\"SIZE\", 52, VertexElementFormat.Float, 0),\n      new VertexElement(\"ROTATERATE\", 56, VertexElementFormat.Float, 0),\n      new VertexElement(\"STARTTIME\", 60, VertexElementFormat.Float, 0),\n      new VertexElement(\"LIFETIME\", 64, VertexElementFormat.Float, 0),\n      new VertexElement(\"STARTANGLE\", 68, VertexElementFormat.Float, 0),\n      new VertexElement(\"SCALEFACTOR\", 72, VertexElementFormat.Float, 0),\n      new VertexElement(\"UV\", 76, VertexElementFormat.Vector3, 0),\n      new VertexElement(\"NORMALIZED_UV\", 88, VertexElementFormat.Vector2, 0)\n    ];\n    const vertexBuffer = new Buffer(this.engine, BufferBindFlag.VertexBuffer, vertexFloatCount * 4, BufferUsage.Dynamic);\n    const indexBuffer = new Buffer(this.engine, BufferBindFlag.IndexBuffer, indices, BufferUsage.Dynamic);\n    geometry2.setVertexBufferBinding(vertexBuffer, vertexStride);\n    geometry2.setIndexBufferBinding(indexBuffer, IndexFormat.UInt16);\n    geometry2.setVertexElements(vertexElements);\n    geometry2.addSubGeometry(0, indices.length);\n    this._vertexBuffer = vertexBuffer;\n    this._vertexStride = vertexStride;\n    this._vertices = vertices;\n    return geometry2;\n  }\n  _spawnParticle(options, i) {\n    const position = options.position !== void 0 ? options.position.clone() : new Vector3();\n    const positionRandomness = options.positionRandomness !== void 0 ? options.positionRandomness.clone() : new Vector3();\n    const positionArray = options.positionArray;\n    const velocity = options.velocity !== void 0 ? options.velocity.clone() : new Vector3();\n    const velocityRandomness = options.velocityRandomness !== void 0 ? options.velocityRandomness.clone() : new Vector3();\n    const color = options.color !== void 0 ? options.color.clone() : new Vector3(1, 1, 1);\n    const colorRandomness = options.colorRandomness !== void 0 ? options.colorRandomness : 1;\n    const alpha = options.alpha !== void 0 ? options.alpha : 1;\n    const alphaRandomness = options.alphaRandomness !== void 0 ? options.alphaRandomness : 0;\n    const lifetime = options.lifetime !== void 0 ? options.lifetime : 5;\n    let size = options.size !== void 0 ? options.size : 1;\n    const sizeRandomness = options.sizeRandomness !== void 0 ? options.sizeRandomness : 0;\n    const smoothPosition = options.smoothPosition !== void 0 ? options.smoothPosition : false;\n    const startTimeRandomness = options.startTimeRandomness !== void 0 ? options.startTimeRandomness : 0;\n    const acceleration = options.acceleration !== void 0 ? options.acceleration.clone() : new Vector3();\n    const accelerationRandomness = options.accelerationRandomness !== void 0 ? options.accelerationRandomness.clone() : new Vector3();\n    const startAngle = options.startAngle !== void 0 ? options.startAngle : 0;\n    const startAngleRandomness = options.startAngleRandomness !== void 0 ? options.startAngleRandomness : 0;\n    const rotateRate = options.rotateRate !== void 0 ? options.rotateRate : 0;\n    const rotateRateRandomness = options.rotateRateRandomness !== void 0 ? options.rotateRateRandomness : 0;\n    const scaleFactor = options.scaleFactor !== void 0 ? options.scaleFactor : 1;\n    let x = position.x;\n    let y = position.y;\n    let z = position.z;\n    if (positionArray) {\n      if (positionArray.length !== this.maxCount) {\n        throw Error(\"The length of positionArray must be equal to maxCount.\");\n      }\n      x += positionArray[i].x;\n      y += positionArray[i].y;\n      z += positionArray[i].z;\n    } else {\n      x += this._getRandom() * positionRandomness.x;\n      y += this._getRandom() * positionRandomness.y;\n      z += this._getRandom() * positionRandomness.z;\n    }\n    if (smoothPosition === true) {\n      x += -(velocity.x * this._getRandom());\n      y += -(velocity.y * this._getRandom());\n      z += -(velocity.z * this._getRandom());\n    }\n    const velX = velocity.x + this._getRandom() * velocityRandomness.x;\n    const velY = velocity.y + this._getRandom() * velocityRandomness.y;\n    const velZ = velocity.z + this._getRandom() * velocityRandomness.z;\n    const accX = acceleration.x + this._getRandom() * accelerationRandomness.x;\n    const accY = acceleration.y + this._getRandom() * accelerationRandomness.y;\n    const accZ = acceleration.z + this._getRandom() * accelerationRandomness.z;\n    color.x = MathUtil.clamp(color.x + this._getRandom() * colorRandomness, 0, 1);\n    color.y = MathUtil.clamp(color.y + this._getRandom() * colorRandomness, 0, 1);\n    color.z = MathUtil.clamp(color.z + this._getRandom() * colorRandomness, 0, 1);\n    size = Math.max(size + this._getRandom() * sizeRandomness * size * 2, 0);\n    const lifeTime = lifetime + this._getRandom() * lifetime;\n    const sa = startAngle + this._getRandom() * Math.PI * startAngleRandomness * 2;\n    const rr = rotateRate + this._getRandom() * rotateRateRandomness;\n    const particleAlpha = MathUtil.clamp(alpha + this._getRandom() * alphaRandomness, 0, 1);\n    const startTime = Math.random() * startTimeRandomness;\n    const vertices = this._vertices;\n    for (let j = 0; j < 4; j++) {\n      const k = (i * 4 + j) * this._vertexStride / 4;\n      vertices[k] = x;\n      vertices[k + 1] = y;\n      vertices[k + 2] = z;\n      vertices[k + 3] = velX;\n      vertices[k + 4] = velY;\n      vertices[k + 5] = velZ;\n      vertices[k + 6] = accX;\n      vertices[k + 7] = accY;\n      vertices[k + 8] = accZ;\n      vertices[k + 9] = color[0];\n      vertices[k + 10] = color[1];\n      vertices[k + 11] = color[2];\n      vertices[k + 12] = particleAlpha;\n      vertices[k + 13] = size;\n      vertices[k + 14] = rr;\n      vertices[k + 15] = startTime;\n      vertices[k + 16] = lifeTime;\n      vertices[k + 17] = sa;\n      vertices[k + 18] = scaleFactor;\n      this._setUvs(i, j, k);\n    }\n  }\n  _setUvs(i, j, k) {\n    const {spriteSheet} = this;\n    const {particleTex} = this;\n    let rects;\n    const normalizedRects = [\n      [-0.5, -0.5],\n      [0.5, -0.5],\n      [0.5, 0.5],\n      [-0.5, 0.5]\n    ];\n    if (particleTex) {\n      const width = particleTex.image ? particleTex.image.width : particleTex.width;\n      const height = particleTex.image ? particleTex.image.height : particleTex.height;\n      if (spriteSheet) {\n        const {x, y, w, h} = spriteSheet[i % spriteSheet.length];\n        const u = x / width;\n        const v = y / height;\n        const p = u + w / width;\n        const q = v + h / height;\n        rects = [\n          [u, q, h / w],\n          [p, q, h / w],\n          [p, v, h / w],\n          [u, v, h / w]\n        ];\n      } else {\n        rects = [\n          [0, 0, height / width],\n          [1, 0, height / width],\n          [1, 1, height / width],\n          [0, 1, height / width]\n        ];\n      }\n    } else {\n      rects = [\n        [0, 0, 1],\n        [1, 0, 1],\n        [1, 1, 1],\n        [0, 1, 1]\n      ];\n    }\n    const vertices = this._vertices;\n    const uv = rects[j];\n    vertices[k + 19] = uv[0];\n    vertices[k + 20] = uv[1];\n    vertices[k + 21] = uv[2];\n    const nuv = normalizedRects[j];\n    vertices[k + 22] = nuv[0];\n    vertices[k + 23] = nuv[1];\n  }\n  _getRandom() {\n    return Math.random() - 0.5;\n  }\n  _getShader() {\n    return {\n      vertexShader: `\n        precision highp float;\n        precision highp int;\n\n        attribute float lifeTime;\n        attribute float startTime;\n        attribute float size;\n        attribute float rotateRate;\n        attribute vec3 velocity;\n        attribute vec3 acceleration;\n        attribute vec3 positionStart;\n        attribute vec3 color;\n        attribute float alpha;\n        attribute float startAngle;\n        attribute float scaleFactor;\n        attribute vec3 uv;\n        attribute vec2 normalizedUv;\n        \n        uniform float uTime;\n        uniform float uOnce;\n        uniform float uActive;\n        uniform mat4 matModelViewProjection;\n        uniform mat4 matModelView;\n        uniform mat4 matViewInverse;\n        uniform mat4 matView;\n        uniform mat4 matProjection;\n        uniform mat4 matWorld;\n\n        varying vec3 v_color;\n        varying float v_alpha;\n        varying float lifeLeft;\n        varying mat2 vTextureMat;\n        varying vec2 v_uv;\n\n        mat2 rotation2d(float angle) {\n          float s = sin(angle);\n          float c = cos(angle);\n        \n          return mat2(\n            c, -s,\n            s, c\n          );\n        }\n\n        void main()\n        {\n          v_color = color;\n          v_uv = uv.xy;\n          v_alpha = alpha;\n          \n          // float deltaTime = max(mod(uTime, lifeTime), 0.0);\n          // \\u771F\\u5B9E\\u7684\\u751F\\u547D\\u5468\\u671F\n          float life = lifeTime + startTime;\n          // \\u5F53\\u524D\\u5DF2\\u8FC7\\u53BB\\u7684\\u65F6\\u95F4\n          float deltaTime = max(mod(uTime, life) - startTime, 0.0);\n\n          bool isDying = false;\n\n          if (uOnce == 1.0 || uActive == 0.0) {\n            isDying = true;\n          }\n\n          if ((isDying && uTime > life)) {\n            deltaTime = life;\n          }\n\n          // \\u6CA1\\u51FA\\u751F\\u5C31\\u4EE3\\u8868\\u6B7B\\u4EA1\\uFF0C\\u5426\\u5219\\u6CA1\\u51FA\\u751F\\u5C31\\u663E\\u793A\\u4E86\n          if (deltaTime == 0.0) {\n            deltaTime = life;\n          }\n\n          lifeLeft = 1.0 - deltaTime / lifeTime;\n          float scale = size;\n          vec3 position = positionStart + (velocity + acceleration * deltaTime * 0.5) * deltaTime;\n      `,\n      postionShader: `\n        gl_Position = matModelViewProjection * vec4(position, 1.0 );\n      `,\n      sizeVertexShader: `\n          scale *= pow(scaleFactor, deltaTime);\n      `,\n      isScaleByLifetimeVertexShader: `\n          scale *= lifeLeft;\n      `,\n      rotateToVelocityVertexShader: `\n        vec3 v = velocity + acceleration * deltaTime;\n        float angle = atan(v.z, v.x) * 2.0;\n        float s = sin(angle);\n        float c = cos(angle);\n      `,\n      rotationVertexShader: `\n        float deltaAngle = deltaTime * rotateRate;\n        float angle = startAngle + deltaAngle;\n        float s = sin(angle);\n        float c = cos(angle);\n\n      `,\n      rotation2dShader: `\n        vec2 rotatedPoint = rotation2d(angle) * vec2(normalizedUv.x, normalizedUv.y * uv.z);\n\n        vec3 basisX = matViewInverse[0].xyz;\n        vec3 basisZ = matViewInverse[1].xyz;\n\n        vec3 localPosition = vec3(basisX * rotatedPoint.x + \n                    basisZ * rotatedPoint.y) * scale + position;\n\n        gl_Position = matProjection * matView * vec4(localPosition + matWorld[3].xyz, 1.);\n      `,\n      rotation3dShader: `\n        vec4 rotatedPoint = vec4((normalizedUv.x * c + normalizedUv.y * uv.z * s) * scale , 0., \n                                 (normalizedUv.x * s - normalizedUv.y * uv.z * c) * scale, 1.);\n      \n        vec4 orientation = vec4(0, 0, 0, 1);\n        vec4 q2 = orientation + orientation;\n        vec4 qx = orientation.xxxw * q2.xyzx;\n        vec4 qy = orientation.xyyw * q2.xyzy;\n        vec4 qz = orientation.xxzw * q2.xxzz;\n      \n        mat4 localMatrix = mat4(\n            (1.0 - qy.y) - qz.z, \n            qx.y + qz.w, \n            qx.z - qy.w,\n            0,\n      \n            qx.y - qz.w, \n            (1.0 - qx.x) - qz.z, \n            qy.z + qx.w,\n            0,\n      \n            qx.z + qy.w, \n            qy.z - qx.w, \n            (1.0 - qx.x) - qy.y,\n            0,\n      \n            position.x, position.y, position.z, 1);\n\n        rotatedPoint = localMatrix * rotatedPoint;\n\n        gl_Position = matModelViewProjection * rotatedPoint;\n      `,\n      fragmentShader: `\n        precision mediump float;\n        precision mediump int;\n\n        varying vec3 v_color;\n        varying float v_alpha;\n        varying float lifeLeft;\n        varying vec2 v_uv;\n        uniform sampler2D particleTex;\n        uniform sampler2D particleMaskTex;\n\n        void main()\n        {\n          float alphaFactor = 1.0;\n      `,\n      fadeInFragmentShader: `\n        float fadeInFactor = step(0.5, lifeLeft);\n        alphaFactor = 2.0 * fadeInFactor * (1.0 - lifeLeft) + (1.0 - fadeInFactor);\n      `,\n      fadeOutFragmentShader: `\n        float fadeOutFactor = step(0.5, lifeLeft);\n        alphaFactor = alphaFactor * 2.0 * (1.0 - fadeOutFactor) * lifeLeft + alphaFactor * fadeOutFactor;\n      `,\n      noImgFragmentShader: ` \n        gl_FragColor = vec4( v_color, alphaFactor * v_alpha);\n      `,\n      imgFragmentShader: `\n        vec4 tex = texture2D(particleTex, v_uv);\n      `,\n      originColorFragmentShader: `\n        gl_FragColor = vec4(tex.rgb, alphaFactor * tex.a * v_alpha);\n      `,\n      createColorFragmentShader: `\n        gl_FragColor = vec4(v_color * tex.rgb, alphaFactor * tex.a * v_alpha);\n      `,\n      createColorWithMaskFragmentShader: `\n        vec4 maskTex = texture2D( particleMaskTex, v_uv);\n        gl_FragColor = vec4(v_color * tex.rgb + maskTex.a, alphaFactor * tex.a * v_alpha);\n      `\n    };\n  }\n  _createVertexShader() {\n    const shader = this._getShader();\n    let vertexShader = \"\";\n    if (this.vertexShader) {\n      vertexShader = this.vertexShader;\n    } else {\n      vertexShader = shader.vertexShader;\n      if (this.isScaleByLifetime) {\n        vertexShader += shader.isScaleByLifetimeVertexShader;\n      } else {\n        vertexShader += shader.sizeVertexShader;\n      }\n      if (this.rotateToVelocity) {\n        vertexShader += shader.rotateToVelocityVertexShader;\n      } else {\n        vertexShader += shader.rotationVertexShader;\n      }\n      if (this.is2d) {\n        vertexShader += shader.rotation2dShader;\n      } else {\n        vertexShader += shader.rotation3dShader;\n      }\n      vertexShader += \"}\";\n    }\n    return vertexShader;\n  }\n  _createFragmentShader() {\n    const shader = this._getShader();\n    let fragmentShader = \"\";\n    if (this.fragmentShader) {\n      fragmentShader = this.fragmentShader;\n    } else {\n      fragmentShader = shader.fragmentShader;\n      if (this.fadeIn) {\n        fragmentShader += shader.fadeInFragmentShader;\n      }\n      if (this.fadeOut) {\n        fragmentShader += shader.fadeOutFragmentShader;\n      }\n      if (!this.particleTex) {\n        fragmentShader += shader.noImgFragmentShader;\n      } else {\n        fragmentShader += shader.imgFragmentShader;\n        if (this.useOriginColor) {\n          fragmentShader += shader.originColorFragmentShader;\n        } else {\n          if (this.particleMaskTex) {\n            fragmentShader += shader.createColorWithMaskFragmentShader;\n          } else {\n            fragmentShader += shader.createColorFragmentShader;\n          }\n        }\n      }\n      fragmentShader += \"}\";\n    }\n    return fragmentShader;\n  }\n}\n\nclass Particle extends GPUParticleSystem {\n  constructor(entity) {\n    super(entity);\n  }\n  init(props) {\n    this._options = {\n      position: props.__position,\n      positionRandomness: props.__positionRandomness,\n      velocity: props.__velocity,\n      velocityRandomness: props.__velocityRandomness,\n      acceleration: props.__acceleration,\n      accelerationRandomness: props.__accelerationRandomness,\n      color: props.__color,\n      colorRandomness: props.__colorRandomness,\n      lifetime: props.__lifetime,\n      size: props.__size,\n      sizeRandomness: props.__sizeRandomness,\n      startAngle: props.__startAngle,\n      startAngleRandomness: props.__startAngleRandomness,\n      rotateRate: props.__rotateRate,\n      rotateRateRandomness: props.__rotateRateRandomness,\n      scaleFactor: props.__scaleFactor,\n      alpha: props.__alpha,\n      alphaRandomness: props.__alphaRandomness,\n      startTimeRandomness: props.__startTimeRandomness\n    };\n    this._config = {\n      maxCount: props.__maxCount,\n      once: props.__once,\n      rotateToVelocity: props.__rotateToVelocity,\n      isScaleByLifetime: props.__isScaleByLifetime,\n      fadeIn: props.__fadeIn,\n      fadeOut: props.__fadeOut,\n      texture: props.__texture ? props.__texture : null,\n      maskTexture: props.__maskTexture ? props.__maskTexture : null,\n      useOriginColor: props.__useOriginColor,\n      is2d: props.__is2d,\n      options: this._options\n    };\n    if (props.__spriteSheet) {\n      if (typeof props.__spriteSheet === \"object\" && props.__spriteSheet.length) {\n        this._config.spriteSheet = props.__spriteSheet;\n      } else if (typeof props.__spriteSheet === \"string\") {\n        try {\n          const spriteSheet = JSON.parse(props.__spriteSheet);\n          if (spriteSheet.length) {\n            this._config.spriteSheet = spriteSheet;\n          }\n        } catch (e) {\n        }\n      }\n    }\n    if (props.__positionArray) {\n      if (typeof props.__positionArray === \"object\" && props.__positionArray.length) {\n        this._options.positionArray = props.__positionArray;\n      } else if (typeof props.__positionArray === \"string\") {\n        try {\n          const positionArray = JSON.parse(props.__positionArray);\n          if (positionArray.length) {\n            this._options.positionArray = positionArray;\n          }\n        } catch (e) {\n        }\n      }\n    }\n    if (props.__separate) {\n      this._config.blendFuncSeparate = [\n        BlendFunc[props.__srcRGB || \"SRC_ALPHA\"],\n        BlendFunc[props.__dstRGB || \"ONE_MINUS_SRC_ALPHA\"],\n        BlendFunc[props.__srcAlpha || \"SRC_ALPHA\"],\n        BlendFunc[props.__dstAlpha || \"ONE_MINUS_SRC_ALPHA\"]\n      ];\n    } else if (props.__src && props.__dst) {\n      this._config.blendFunc = [BlendFunc[props.__src], BlendFunc[props.__dst]];\n    }\n    this.initialize(this._config);\n    if (props.__defaultStart === true || props.__defaultStart === void 0) {\n      this.start();\n    }\n  }\n  updateOption(key, value) {\n    this._options = {\n      ...this._options,\n      [key]: value\n    };\n    this._config = {\n      ...this._config,\n      options: {\n        ...this._options\n      }\n    };\n    this.initialize(this._config);\n    this.start();\n  }\n  updateConfig(key, value) {\n    this._config = {\n      ...this._config,\n      [key]: value\n    };\n    this.initialize(this._config);\n    this.start();\n  }\n  set __position(value) {\n    this.updateOption(\"position\", value);\n  }\n  set __positionRandomness(value) {\n    this.updateOption(\"positionRandomness\", value);\n  }\n  set __velocity(value) {\n    this.updateOption(\"velocity\", value);\n  }\n  set __velocityRandomness(value) {\n    this.updateOption(\"velocityRandomness\", value);\n  }\n  set __acceleration(value) {\n    this.updateOption(\"acceleration\", value);\n  }\n  set __accelerationRandomness(value) {\n    this.updateOption(\"accelerationRandomness\", value);\n  }\n  set __color(value) {\n    this.updateOption(\"color\", value);\n  }\n  set __colorRandomness(value) {\n    this.updateOption(\"colorRandomness\", value);\n  }\n  set __lifetime(value) {\n    this.updateOption(\"lifetime\", value);\n  }\n  set __size(value) {\n    this.updateOption(\"size\", value);\n  }\n  set __sizeRandomness(value) {\n    this.updateOption(\"sizeRandomness\", value);\n  }\n  set __startAngle(value) {\n    this.updateOption(\"startAngle\", value);\n  }\n  set __startAngleRandomness(value) {\n    this.updateOption(\"startAngleRandomness\", value);\n  }\n  set __rotateRate(value) {\n    this.updateOption(\"rotateRate\", value);\n  }\n  set __rotateRateRandomness(value) {\n    this.updateOption(\"rotateRateRandomness\", value);\n  }\n  set __scaleFactor(value) {\n    this.updateOption(\"scaleFactor\", value);\n  }\n  set __alpha(value) {\n    this.updateOption(\"alpha\", value);\n  }\n  set __alphaRandomness(value) {\n    this.updateOption(\"alphaRandomness\", value);\n  }\n  set __startTimeRandomness(value) {\n    this.updateOption(\"startTimeRandomness\", value);\n  }\n  set __positionArray(value) {\n    if (typeof value === \"object\" && value.length) {\n      this.updateOption(\"positionArray\", value);\n    } else if (typeof value === \"string\") {\n      try {\n        const positionArray = JSON.parse(value);\n        if (positionArray.length) {\n          this.updateOption(\"positionArray\", positionArray);\n        } else {\n          this.updateOption(\"positionArray\", null);\n        }\n      } catch (e) {\n        this.updateOption(\"positionArray\", null);\n      }\n    } else {\n      this.updateOption(\"positionArray\", null);\n    }\n  }\n  set __maxCount(value) {\n    this.updateConfig(\"maxCount\", value);\n  }\n  set __useOriginColor(value) {\n    this.updateConfig(\"useOriginColor\", value);\n  }\n  set __once(value) {\n    this.updateConfig(\"once\", value);\n  }\n  set __rotateToVelocity(value) {\n    this.updateConfig(\"rotateToVelocity\", value);\n  }\n  set __isScaleByLifetime(value) {\n    this.updateConfig(\"isScaleByLifetime\", value);\n  }\n  set __fadeIn(value) {\n    this.updateConfig(\"fadeIn\", value);\n  }\n  set __fadeOut(value) {\n    this.updateConfig(\"fadeOut\", value);\n  }\n  set __texture(value) {\n    this.updateConfig(\"texture\", value);\n  }\n  set __maskTexture(value) {\n    this.updateConfig(\"maskTexture\", value);\n  }\n  set __spriteSheet(value) {\n    if (typeof value === \"object\" && value.length) {\n      this.updateConfig(\"spriteSheet\", value);\n    } else if (typeof value === \"string\") {\n      try {\n        const spriteSheet = JSON.parse(value);\n        if (spriteSheet.length) {\n          this.updateConfig(\"spriteSheet\", spriteSheet);\n        } else {\n          this.updateConfig(\"spriteSheet\", null);\n        }\n      } catch (e) {\n        this.updateConfig(\"spriteSheet\", null);\n      }\n    } else {\n      this.updateConfig(\"spriteSheet\", null);\n    }\n  }\n  set __is2d(value) {\n    this.updateConfig(\"is2d\", value);\n  }\n}\n\nvar FRAG_SHADER$1 = \"varying vec2 v_uv;\\n\\nuniform sampler2D u_texture;\\n\\nvoid main(void) {\\n\\n  gl_FragColor = texture2D(u_texture, v_uv);\\n\\n}\\n\";\n\nvar VERT_SHADER = \"attribute vec3 a_position;\\nattribute vec2 a_uv;\\n\\nvarying vec2 v_uv;\\n\\nuniform mat4 u_projMat;\\nuniform mat4 u_viewMat;\\n\\nvoid main() {\\n\\n  gl_Position = u_projMat * u_viewMat * vec4( a_position, 1.0 );\\n  v_uv = a_uv;\\n\\n}\\n\";\n\nclass TrailMaterial extends Material {\n  _generateTechnique() {\n    const tech = new RenderTechnique(\"trail_tech\");\n    tech.isValid = true;\n    tech.uniforms = {\n      u_texture: {\n        name: \"u_texture\",\n        type: DataType.SAMPLER_2D\n      }\n    };\n    tech.attributes = {};\n    tech.states = {\n      enable: [RenderState.BLEND],\n      functions: {\n        blendFunc: [BlendFunc.SRC_ALPHA, BlendFunc.ONE],\n        depthMask: [false]\n      }\n    };\n    tech.customMacros = [];\n    tech.vertexShader = VERT_SHADER;\n    tech.fragmentShader = FRAG_SHADER$1;\n    this._technique = tech;\n    this.renderType = MaterialType.TRANSPARENT;\n  }\n  prepareDrawing(context, component, primitive) {\n    if (this._technique === null) {\n      this._generateTechnique();\n    }\n    super.prepareDrawing(context, component, primitive);\n  }\n}\n\nconst _tempVector3 = new Vector3();\nclass TrailRenderer extends GeometryRenderer {\n  constructor(entity, props) {\n    super(entity);\n    this._stroke = props.stroke || 0.2;\n    this._minSeg = props.minSeg || 0.02;\n    this._lifetime = props.lifetime || 1e3;\n    this._maxPointNum = this._lifetime / 1e3 * entity.engine.targetFrameRate;\n    this._points = [];\n    this._pointStates = [];\n    this._strapPoints = [];\n    for (let i = 0; i < this._maxPointNum; i++) {\n      this._points.push(new Vector3());\n      this._pointStates.push(this._lifetime);\n      this._strapPoints.push(new Vector3());\n      this._strapPoints.push(new Vector3());\n    }\n    this._curPointNum = 0;\n    const mtl = props.material || new TrailMaterial(this.engine, \"trial_mtl\");\n    this.material = mtl;\n    this.setTexture(props.texture);\n    this._initGeometry();\n  }\n  update(deltaTime) {\n    let mov = 0, newIdx = 0;\n    for (let i = 0; i < this._curPointNum; i++) {\n      this._pointStates[i] -= deltaTime;\n      if (this._pointStates[i] < 0) {\n        mov++;\n      } else if (mov > 0) {\n        newIdx = i - mov;\n        this._pointStates[newIdx] = this._pointStates[i];\n        this._points[i].cloneTo(this._points[newIdx]);\n      }\n    }\n    this._curPointNum -= mov;\n    let appendNewPoint = true;\n    if (this._curPointNum === this._maxPointNum) {\n      appendNewPoint = false;\n    } else if (this._curPointNum > 0) {\n      const lastPoint = this._points[this._points.length - 1];\n      if (Vector3.distance(this.entity.worldPosition, lastPoint) < this._minSeg) {\n        appendNewPoint = false;\n      }\n    }\n    if (appendNewPoint) {\n      this._pointStates[this._curPointNum] = this._lifetime;\n      this.entity.worldPosition.cloneTo(this._points[this._curPointNum]);\n      this._curPointNum++;\n    }\n  }\n  render(camera) {\n    this._updateStrapVertices(camera, this._points);\n    this._updateStrapCoords();\n    this._vertexBuffer.setData(this._vertices);\n    super.render(camera);\n  }\n  setTexture(texture) {\n    if (texture) {\n      this.material.setValue(\"u_texture\", texture);\n    }\n  }\n  _initGeometry() {\n    const geometry2 = new BufferGeometry(this._entity.engine);\n    const vertexStride = 20;\n    const vertexCount = this._maxPointNum * 2;\n    const vertexFloatCount = vertexCount * vertexStride;\n    const vertices = new Float32Array(vertexFloatCount);\n    const vertexElements = [\n      new VertexElement(\"POSITION\", 0, VertexElementFormat.Vector3, 0),\n      new VertexElement(\"TEXCOORD_0\", 12, VertexElementFormat.Vector2, 0)\n    ];\n    const vertexBuffer = new Buffer(this.engine, vertexFloatCount * 4, BufferUsage.Dynamic);\n    geometry2.setVertexBufferBinding(vertexBuffer, vertexStride);\n    geometry2.setVertexElements(vertexElements);\n    geometry2.addSubGeometry(0, vertexCount, PrimitiveTopology.TriangleStrip);\n    this._vertexBuffer = vertexBuffer;\n    this._vertexStride = vertexStride;\n    this._vertices = vertices;\n    this.geometry = geometry2;\n  }\n  _updateStrapVertices(camera, points) {\n    const m = camera.viewMatrix;\n    const e = m.elements;\n    const vx = new Vector3(e[0], e[4], e[8]);\n    const vy = new Vector3(e[1], e[5], e[9]);\n    const vz = new Vector3(e[2], e[6], e[10]);\n    const s = this._stroke;\n    vy.scale(s);\n    const up = new Vector3();\n    const down = new Vector3();\n    const rotation = new Quaternion();\n    Vector3.transformByQuat(vx, rotation, vx);\n    Vector3.transformByQuat(vy, rotation, vy);\n    const dy = new Vector3();\n    const cross = new Vector3();\n    const perpVector = new Vector3();\n    vx.normalize();\n    const vertieces = this._vertices;\n    for (let i = 0; i < this._maxPointNum; i++) {\n      if (i < this._curPointNum) {\n        const p = points[i];\n        if (i === this._curPointNum - 1 && i !== 0) {\n          Vector3.subtract(p, points[i - 1], perpVector);\n        } else {\n          Vector3.subtract(points[i + 1], p, perpVector);\n        }\n        this._projectOnPlane(perpVector, vz, perpVector);\n        perpVector.normalize();\n        let angle = Math.acos(Vector3.dot(vx, perpVector));\n        Vector3.cross(vx, perpVector, cross);\n        if (Vector3.dot(cross, vz) <= 0) {\n          angle = Math.PI * 2 - angle;\n        }\n        Quaternion.rotationAxisAngle(vz, angle, rotation);\n        Vector3.transformByQuat(vy, rotation, dy);\n        Vector3.add(p, dy, up);\n        Vector3.subtract(p, dy, down);\n      }\n      const p0 = i * 2 * this._vertexStride / 4;\n      const p1 = (i * 2 + 1) * this._vertexStride / 4;\n      vertieces[p0] = up.x;\n      vertieces[p0 + 1] = up.y;\n      vertieces[p0 + 2] = up.z;\n      vertieces[p1] = down.x;\n      vertieces[p1 + 1] = down.y;\n      vertieces[p1 + 2] = down.z;\n    }\n  }\n  _updateStrapCoords() {\n    if (this._prePointsNum === this._curPointNum) {\n      return;\n    }\n    this._prePointsNum = this._curPointNum;\n    const count = this._curPointNum;\n    const texDelta = 1 / count;\n    const vertieces = this._vertices;\n    for (let i = 0; i < count; i++) {\n      const d = 1 - i * texDelta;\n      const p0 = i * 2 * this._vertexStride / 4;\n      const p1 = (i * 2 + 1) * this._vertexStride / 4;\n      vertieces[p0] = 0;\n      vertieces[p0 + 1] = d;\n      vertieces[p1] = 1;\n      vertieces[p1 + 1] = d;\n    }\n  }\n  _projectOnVector(a, p, out) {\n    const n_p = p.clone();\n    Vector3.normalize(n_p, n_p);\n    const cosine = Vector3.dot(a, n_p);\n    out.x = n_p.x * cosine;\n    out.y = n_p.y * cosine;\n    out.z = n_p.z * cosine;\n  }\n  _projectOnPlane(a, n, out) {\n    this._projectOnVector(a, n, _tempVector3);\n    Vector3.subtract(a, _tempVector3, out);\n  }\n}\n\nclass BoxCollider extends ABoxCollider {\n  constructor(entity) {\n    super(entity);\n    this._center = new Vector3();\n    this._size = new Vector3();\n    this.isShowCollider = true;\n    this.center = this.center;\n    this.size = this.size;\n    this.isShowCollider = this.isShowCollider;\n  }\n  get center() {\n    return this._center;\n  }\n  set center(value) {\n    this._center = value;\n    this.setBoxCenterSize(this._center, this._size);\n  }\n  get size() {\n    return this._size;\n  }\n  set size(value) {\n    this._size = value;\n    this.setBoxCenterSize(this._center, this._size);\n  }\n}\n\nclass SphereCollider extends ASphereCollider {\n  constructor(entity) {\n    super(entity);\n    this.__center = new Vector3();\n    this.__radius = 1;\n    this.isShowCollider = true;\n    this._center = this._center;\n    this._radius = this._radius;\n    this.isShowCollider = this.isShowCollider;\n  }\n  get _center() {\n    return this.__center;\n  }\n  set _center(value) {\n    this.__center = value;\n    this.setSphere(this.__center, this.__radius);\n  }\n  get _radius() {\n    return this.__radius;\n  }\n  set _radius(value) {\n    this.__radius = value;\n    this.setSphere(this.__center, this.__radius);\n  }\n}\n\nScene.registerFeature(ColliderFeature);\n\nfunction intersectBox2Box(boxA, boxB) {\n  return boxA.min.x <= boxB.max.x && boxA.max.x >= boxB.min.x && boxA.min.y <= boxB.max.y && boxA.max.y >= boxB.min.y && boxA.min.z <= boxB.max.z && boxA.max.z >= boxB.min.z;\n}\nfunction intersectSphere2Sphere(sphereA, sphereB) {\n  const distance = Vector3.distance(sphereA.center, sphereB.center);\n  return distance < sphereA.radius + sphereA.radius;\n}\nfunction intersectSphere2Box(sphere, box) {\n  const center = sphere.center;\n  const closestPoint = new Vector3(Math.max(box.min.x, Math.min(center.x, box.max.x)), Math.max(box.min.y, Math.min(center.y, box.max.y)), Math.max(box.min.z, Math.min(center.z, box.max.z)));\n  const distance = Vector3.distance(center, closestPoint);\n  return distance < sphere.radius;\n}\n\nclass CollisionDetection extends Script {\n  constructor(entity) {\n    super(entity);\n    this._colliderManager = null;\n    this._myCollider = null;\n    this._overlopCollider = null;\n  }\n  get overlopCollider() {\n    return this._overlopCollider;\n  }\n  onUpdate(deltaTime) {\n    super.onUpdate(deltaTime);\n    let overlopCollider = null;\n    if (this._colliderManager && this._myCollider) {\n      const colliders = this._colliderManager.colliders;\n      if (this._myCollider instanceof ABoxCollider) {\n        this._box = this._getWorldBox(this._myCollider);\n        for (let i = 0, len = colliders.length; i < len; i++) {\n          const collider2 = colliders[i];\n          if (collider2 != this._myCollider && this._boxCollision(collider2)) {\n            overlopCollider = collider2;\n            this.trigger(new Event(\"collision\", this, {collider: collider2}));\n          }\n        }\n      } else if (this._myCollider instanceof ASphereCollider) {\n        this._sphere = this._getWorldSphere(this._myCollider);\n        for (let i = 0, len = colliders.length; i < len; i++) {\n          const collider2 = colliders[i];\n          if (collider2 != this._myCollider && this._sphereCollision(collider2)) {\n            overlopCollider = collider2;\n            this.trigger(new Event(\"collision\", this, {collider: collider2}));\n          }\n        }\n      }\n    }\n    if (overlopCollider != null && this._overlopCollider != overlopCollider) {\n      this.trigger(new Event(\"begin_overlop\", this, {collider: overlopCollider}));\n    }\n    if (this._overlopCollider != null && this._overlopCollider != overlopCollider) {\n      const e = this._overlopCollider;\n      this.trigger(new Event(\"end_overlop\", this, {collider: e}));\n    }\n    this._overlopCollider = overlopCollider;\n  }\n  _getWorldBox(boxCollider) {\n    const mat = boxCollider.entity.transform.worldMatrix;\n    const max = new Vector3();\n    const min = new Vector3();\n    Vector3.transformCoordinate(boxCollider.boxMax, mat, max);\n    Vector3.transformCoordinate(boxCollider.boxMin, mat, min);\n    const temp = CollisionDetection._tempVec3;\n    const corners = boxCollider.getCorners();\n    for (let i = 0; i < 8; i++) {\n      Vector3.transformCoordinate(corners[i], mat, temp);\n      if (temp.x > max.x)\n        max.x = temp.x;\n      if (temp.y > max.y)\n        max.y = temp.y;\n      if (temp.z > max.z)\n        max.z = temp.z;\n      if (temp.x < min.x)\n        min.x = temp.x;\n      if (temp.y < min.y)\n        min.y = temp.y;\n      if (temp.z < min.z)\n        min.z = temp.z;\n    }\n    return {\n      min,\n      max\n    };\n  }\n  _getWorldSphere(sphereCollider) {\n    const center = new Vector3();\n    Vector3.transformCoordinate(sphereCollider.center, sphereCollider.entity.transform.worldMatrix, center);\n    return {\n      radius: sphereCollider.radius,\n      center\n    };\n  }\n  _boxCollision(other) {\n    if (other instanceof ABoxCollider) {\n      const box = this._getWorldBox(other);\n      return intersectBox2Box(box, this._box);\n    } else if (other instanceof ASphereCollider) {\n      const sphere = this._getWorldSphere(other);\n      return intersectSphere2Box(sphere, this._box);\n    }\n    return false;\n  }\n  _sphereCollision(other) {\n    if (other instanceof ABoxCollider) {\n      const box = this._getWorldBox(other);\n      return intersectSphere2Box(this._sphere, box);\n    } else if (other instanceof ASphereCollider) {\n      const sphere = this._getWorldSphere(other);\n      return intersectSphere2Sphere(sphere, this._sphere);\n    }\n    return false;\n  }\n  onAwake() {\n    this._colliderManager = this.scene.findFeature(ColliderFeature);\n    this._myCollider = this.entity.getComponent(Collider);\n  }\n}\nCollisionDetection._tempVec3 = new Vector3();\n\nclass Fog extends Component {\n  constructor(node) {\n    super(node);\n    this.color = new Vector3(1, 0, 0);\n  }\n  _onEnable() {\n    this.scene.findFeature(FogFeature).fog = this;\n  }\n  _onDisable() {\n    this.scene.findFeature(FogFeature).fog = null;\n  }\n  bindMaterialValues(mtl) {\n  }\n}\n\nclass EXP2Fog extends Fog {\n  constructor() {\n    super(...arguments);\n    this.density = 25e-4;\n  }\n  bindMaterialValues(mtl) {\n    mtl.setValue(\"u_fogColor\", this.color);\n    mtl.setValue(\"u_fogDensity\", this.density);\n  }\n}\n\nfunction hasFogFeature() {\n  return true;\n}\nfunction getFogMacro() {\n  return this.findFeature(FogFeature).macro;\n}\nfunction bindFogToMaterial(mtl) {\n  this.findFeature(FogFeature).bindFogToMaterial(mtl);\n}\nclass FogFeature extends SceneFeature {\n  constructor() {\n    super();\n    this._fog = null;\n    this._macros = [];\n  }\n  get fog() {\n    return this._fog;\n  }\n  set fog(v) {\n    if (v !== this._fog) {\n      this._fog = v;\n      const macro = [];\n      if (v instanceof Fog) {\n        macro.push(\"O3_HAS_FOG\");\n        if (v instanceof EXP2Fog) {\n          macro.push(\"O3_FOG_EXP2\");\n        }\n      }\n      if (this._macros.length !== macro.length) {\n        this._macros = macro;\n      }\n    }\n  }\n  get macro() {\n    return this._macros;\n  }\n  bindFogToMaterial(mtl) {\n    if (this.fog && mtl.useFog) {\n      this.fog.bindMaterialValues(mtl);\n    }\n    return this;\n  }\n}\n\nclass LinearFog extends Fog {\n  constructor() {\n    super(...arguments);\n    this.near = 1;\n    this.far = 1e3;\n  }\n  bindMaterialValues(mtl) {\n    mtl.setValue(\"u_fogColor\", this.color);\n    mtl.setValue(\"u_fogNear\", this.near);\n    mtl.setValue(\"u_fogFar\", this.far);\n  }\n}\n\nScene.registerFeature(FogFeature);\nScene.prototype.hasFogFeature = hasFogFeature;\nScene.prototype.getFogMacro = getFogMacro;\nScene.prototype.bindFogToMaterial = bindFogToMaterial;\n\nlet cacheId = 0;\nclass Probe extends Component {\n  set camera(camera) {\n    if (camera === this._camera)\n      return;\n    this._camera && this.renderPipeline.removeRenderPass(this.renderPass);\n    this._camera = camera;\n    camera && this.renderPipeline.addRenderPass(this.renderPass);\n  }\n  get camera() {\n    return this._camera;\n  }\n  get texture() {\n    return this.renderPass.renderTarget?.getColorTexture();\n  }\n  get depthTexture() {\n    return this.renderPass.renderTarget?.depthTexture;\n  }\n  get cubeTexture() {\n    return this.renderPass.renderTarget?.getColorTexture();\n  }\n  get renderPipeline() {\n    return this.camera._renderPipeline;\n  }\n  get rhi() {\n    return this.camera.scene.engine._hardwareRenderer;\n  }\n  get renderItems() {\n    const opaqueQueue = this.renderPipeline.opaqueQueue;\n    const transparentQueue = this.renderPipeline.transparentQueue;\n    return opaqueQueue.items.concat(transparentQueue.items).filter((item) => {\n      if (!item.primitive)\n        return false;\n      if (this.excludeRenderList.includes(item.material))\n        return false;\n      if (this.renderAll)\n        return true;\n      if (this.renderList.includes(item.material))\n        return true;\n    });\n  }\n  get samples() {\n    return this.renderTarget.antiAliasing;\n  }\n  constructor(entity) {\n    super(entity);\n    this.cacheId = cacheId++;\n    this.renderPass = new RenderPass(\"_renderPass\" + this.cacheId, -10);\n    this.renderPass.renderOverride = true;\n    this.renderPass.preRender = this.preRender.bind(this);\n    this.renderPass.render = this.render.bind(this);\n    this.renderPass.postRender = this.postRender.bind(this);\n    this.addEventListener(\"enabled\", () => {\n      this.renderPass.enabled = true;\n    });\n    this.addEventListener(\"disabled\", () => {\n      this.renderPass.enabled = false;\n    });\n  }\n  init(config = {}) {\n    this.isCube = !!config.isCube;\n    this.camera = config.camera || this.scene._activeCameras[0];\n    this.excludeRenderList = config.excludeRenderList || [];\n    this.renderAll = !!config.renderAll;\n    this.renderList = config.renderList || [];\n    this.clipPlanes = config.clipPlanes || [];\n    const width = config.width || 1024;\n    const height = config.height || 1024;\n    const samples = config.samples || 1;\n    this.renderTarget = new RenderTarget(this.engine, width, height, new RenderColorTexture(this.engine, width, height, void 0, false, this.isCube), RenderBufferDepthFormat.Depth, samples);\n    this.renderTargetSwap = new RenderTarget(this.engine, width, height, new RenderColorTexture(this.engine, width, height, void 0, false, this.isCube), RenderBufferDepthFormat.Depth, samples);\n    this.renderPass.renderTarget = this.renderTarget;\n  }\n  preRender() {\n    this.oriClipPlane = this.scene.clipPlanes;\n    this.scene.clipPlanes = this.clipPlanes;\n  }\n  render() {\n    const context = RenderContext._getRenderContext(this.camera);\n    this.renderItems.forEach((item) => {\n      const {component, primitive, subPrimitive, material} = item;\n      if (!(component.renderPassFlag & this.renderPassFlag))\n        return;\n      material.prepareDrawing(context, component, primitive);\n      this.rhi.drawPrimitive(primitive, subPrimitive, material);\n    });\n  }\n  postRender() {\n    this.scene.clipPlanes = this.oriClipPlane;\n    if (this.renderPass.enabled) {\n      if (this.onTextureChange) {\n        if (this.isCube) {\n          this.onTextureChange(this.cubeTexture);\n        } else {\n          this.onTextureChange(this.texture, this.depthTexture);\n        }\n      }\n      if (this.renderPass.renderTarget === this.renderTarget) {\n        this.renderPass.renderTarget = this.renderTargetSwap;\n      } else {\n        this.renderPass.renderTarget = this.renderTarget;\n      }\n    }\n  }\n  destroy() {\n    this.enabled = false;\n    this.renderPipeline.removeRenderPass(this.renderPass);\n    super.destroy();\n    this.renderTarget.destroy();\n    this.renderTargetSwap.destroy();\n  }\n  onTextureChange(texture, depthTexture) {\n  }\n}\n\nclass PlaneProbe extends Probe {\n  constructor(node) {\n    super(node);\n  }\n  init(config = {}) {\n    super.init(config);\n  }\n  storeMaterial() {\n    this.renderItems.forEach((item) => {\n      const material = item.material;\n      item.initialSide = material.side;\n      material.side = Side.BACK;\n    });\n  }\n  restoreMaterial() {\n    this.renderItems.forEach((item) => {\n      const material = item.material;\n      material.side = item.initialSide;\n      delete item.initialSide;\n    });\n  }\n  preRender() {\n    super.preRender();\n    this.storeMaterial();\n  }\n  postRender() {\n    super.postRender();\n    this.restoreMaterial();\n  }\n}\n\nconst cacheTarget = new Vector3();\nconst cacheUp = new Vector3();\nconst cacheDir = new Vector3();\nconst fovRadian = 90 * Math.PI / 180;\nclass CubeProbe extends Probe {\n  constructor(node) {\n    super(node);\n    this.oriViewMatrix = new Matrix();\n    this.oriInverseViewMatrix = new Matrix();\n    this.oriProjectionMatrix = new Matrix();\n    this.oriInverseProjectionMatrix = new Matrix();\n  }\n  init(config = {}) {\n    super.init({\n      ...config,\n      isCube: true\n    });\n    this.position = config.position || new Vector3();\n  }\n  storeCamera() {\n    this.camera.viewMatrix.cloneTo(this.oriViewMatrix);\n    this.camera.inverseViewMatrix.cloneTo(this.oriInverseViewMatrix);\n    this.camera.projectionMatrix.cloneTo(this.oriProjectionMatrix);\n    this.camera.inverseProjectionMatrix.cloneTo(this.oriInverseProjectionMatrix);\n  }\n  restoreCamera() {\n    this.oriViewMatrix.cloneTo(this.camera.viewMatrix);\n    this.oriInverseViewMatrix.cloneTo(this.camera.inverseViewMatrix);\n    this.oriProjectionMatrix.cloneTo(this.camera.projectionMatrix);\n    this.oriInverseProjectionMatrix.cloneTo(this.camera.inverseProjectionMatrix);\n  }\n  preRender() {\n    super.preRender();\n    this.storeCamera();\n  }\n  render() {\n    for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\n      this.rhi.setRenderTargetFace(this.renderPass.renderTarget, faceIndex);\n      this.rhi.clearRenderTarget(this.renderPass.clearMode, this.renderPass.clearParam);\n      this.setCamera(faceIndex);\n      super.render();\n      if (faceIndex < 5) {\n        this.rhi.blitRenderTarget(this.renderPass.renderTarget);\n      }\n    }\n  }\n  postRender() {\n    super.postRender();\n    this.restoreCamera();\n  }\n  setCamera(faceIndex) {\n    switch (faceIndex) {\n      case 0:\n        cacheUp.setValue(0, -1, 0);\n        cacheDir.setValue(1, 0, 0);\n        break;\n      case 1:\n        cacheUp.setValue(0, -1, 0);\n        cacheDir.setValue(-1, 0, 0);\n        break;\n      case 2:\n        cacheUp.setValue(0, 0, 1);\n        cacheDir.setValue(0, 1, 0);\n        break;\n      case 3:\n        cacheUp.setValue(0, 0, -1);\n        cacheDir.setValue(0, -1, 0);\n        break;\n      case 4:\n        cacheUp.setValue(0, -1, 0);\n        cacheDir.setValue(0, 0, 1);\n        break;\n      case 5:\n        cacheUp.setValue(0, -1, 0);\n        cacheDir.setValue(0, 0, -1);\n        break;\n    }\n    Vector3.add(this.position, cacheDir, cacheTarget);\n    Matrix.lookAt(this.position, cacheTarget, cacheUp, this.camera.viewMatrix);\n    Matrix.invert(this.camera.viewMatrix, this.camera.inverseViewMatrix);\n    Matrix.perspective(fovRadian, 1, this.camera.nearClipPlane, this.camera.farClipPlane, this.camera.projectionMatrix);\n    Matrix.invert(this.camera.projectionMatrix, this.camera.inverseProjectionMatrix);\n  }\n}\n\nclass LightShadow {\n  constructor(props = {engine: null, width: 512, height: 512}) {\n    this._mapSize = new Vector2(props.width, props.height);\n    this._renderTarget = new RenderTarget(props.engine, props.width, props.height, new RenderColorTexture(props.engine, props.width, props.height));\n    this.bias = 5e-3;\n    this.intensity = 0.2;\n    this.radius = 1;\n    this.projectionMatrix = new Matrix();\n  }\n  get renderTarget() {\n    return this._renderTarget;\n  }\n  get map() {\n    return this._renderTarget.getColorTexture();\n  }\n  get mapSize() {\n    return this._mapSize;\n  }\n  initShadowProjectionMatrix(light) {\n    if (light instanceof DirectLight) {\n      Matrix.ortho(-5, 5, -5, 5, 0.1, 50, this.projectionMatrix);\n    }\n    if (light instanceof PointLight) {\n      Matrix.perspective(MathUtil.degreeToRadian(50), 1, 0.5, 50, this.projectionMatrix);\n    }\n    if (light instanceof SpotLight) {\n      const fov = Math.min(Math.PI / 2, light.angle * 2 * Math.sqrt(2));\n      Matrix.perspective(fov, 1, 0.1, light.distance + 5, this.projectionMatrix);\n    }\n  }\n  bindShadowValues(mtl, index, light) {\n    mtl.setValue(`u_viewMatFromLight[${index}]`, light.viewMatrix);\n    mtl.setValue(`u_projMatFromLight[${index}]`, this.projectionMatrix);\n    const uniformName = `u_shadows[${index}]`;\n    mtl.setValue(uniformName + \".bias\", this.bias);\n    mtl.setValue(uniformName + \".intensity\", this.intensity);\n    mtl.setValue(uniformName + \".radius\", this.radius);\n    mtl.setValue(uniformName + \".mapSize\", this._mapSize);\n    mtl.setValue(`u_shadowMaps[${index}]`, this.map);\n  }\n  static getUniformDefine(index) {\n    const uniforms = {};\n    uniforms[`u_viewMatFromLight[${index}]`] = {\n      name: `u_viewMatFromLight[${index}]`,\n      type: DataType.FLOAT_MAT4\n    };\n    uniforms[`u_projMatFromLight[${index}]`] = {\n      name: `u_projMatFromLight[${index}]`,\n      type: DataType.FLOAT_MAT4\n    };\n    const uniformName = `u_shadows[${index}]`;\n    uniforms[uniformName + \".bias\"] = {\n      name: uniformName + \".bias\",\n      type: DataType.FLOAT\n    };\n    uniforms[uniformName + \".intensity\"] = {\n      name: uniformName + \".intensity\",\n      type: DataType.FLOAT\n    };\n    uniforms[uniformName + \".radius\"] = {\n      name: uniformName + \".radius\",\n      type: DataType.FLOAT\n    };\n    uniforms[uniformName + \".mapSize\"] = {\n      name: uniformName + \".mapSize\",\n      type: DataType.FLOAT_VEC2\n    };\n    uniforms[`u_shadowMaps[${index}]`] = {\n      name: `u_shadowMaps[${index}]`,\n      type: DataType.SAMPLER_2D\n    };\n    return uniforms;\n  }\n}\n\nObject.defineProperty(Light.prototype, \"enableShadow\", {\n  get: function() {\n    return this._enableShadow;\n  },\n  set: function(enabled) {\n    this._enableShadow = enabled;\n    if (this._enableShadow) {\n      if (this instanceof AmbientLight) {\n        Logger.warn(\"Has no shadow!\");\n        return;\n      }\n      this.shadow = this.shadow || new LightShadow({engine: this.engine, width: 512, height: 512});\n      this.shadow.initShadowProjectionMatrix(this);\n    }\n  }\n});\nObject.defineProperty(Component.prototype, \"recieveShadow\", {\n  get: function() {\n    return this._recieveShadow;\n  },\n  set: function(enabled) {\n    this._recieveShadow = enabled;\n  }\n});\nObject.defineProperty(Component.prototype, \"castShadow\", {\n  get: function() {\n    return this._castShadow;\n  },\n  set: function(enabled) {\n    this._castShadow = enabled;\n  }\n});\n\nvar fs$2 = \"precision mediump float;\\n\\n/**\\n * \\n*/\\nvec4 pack (float depth) {\\n\\n  // rgba 432z,11/256\\n  const vec4 bitShift = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);\\n  const vec4 bitMask = vec4(1.0/256.0, 1.0/256.0, 1.0/256.0, 0.0);\\n\\n  vec4 rgbaDepth = fract(depth * bitShift); //z\\n\\n  // Cut off the value which do not fit in 8 bits\\n  rgbaDepth -= rgbaDepth.gbaa * bitMask;\\n\\n  return rgbaDepth;\\n}\\n\\nvoid main() {\\n\\n  // zrgba,z\\n  gl_FragColor = pack(gl_FragCoord.z);\\n\\n}\";\n\nvar vs$2 = \"#include <common_vert>\\n#include <normal_share>\\n#include <shadow_share>\\n\\nvoid main() {\\n\\n    #include <begin_position_vert>\\n    #include <begin_normal_vert>\\n    #include <skinning_vert>\\n    #include <shadow_vert>\\n    #include <position_vert>\\n\\n}\\n\";\n\nclass ShadowMapMaterial extends ComplexMaterial {\n  _generateTechnique(camera, component) {\n    const customMacros = this._generateMacros();\n    const uniforms = this._generateFragmentUniform();\n    const tech = new RenderTechnique(this.name);\n    tech.isValid = true;\n    tech.uniforms = uniforms;\n    tech.attributes = {};\n    tech.states = {};\n    tech.customMacros = customMacros;\n    tech.vertexShader = vs$2;\n    tech.fragmentShader = fs$2;\n    return tech;\n  }\n  _generateFragmentUniform() {\n    const uniforms = {\n      u_viewMatFromLight: {\n        name: \"u_viewMatFromLight\",\n        type: DataType.FLOAT_MAT4\n      },\n      u_projMatFromLight: {\n        name: \"u_projMatFromLight\",\n        type: DataType.FLOAT_MAT4\n      }\n    };\n    return uniforms;\n  }\n  _generateMacros() {\n    const macros = [];\n    macros.push(\"O3_GENERATE_SHADOW_MAP\");\n    return macros;\n  }\n}\n\nclass ShadowMapPass extends RenderPass {\n  constructor(name, priority, renderTarget, replaceMaterial, mask, light) {\n    super(name, priority, renderTarget, replaceMaterial, mask);\n    this.light = light;\n  }\n  preRender(camera, opaqueQueue, transparentQueue) {\n    this.replaceMaterial.setValue(\"u_viewMatFromLight\", this.light.viewMatrix);\n    this.replaceMaterial.setValue(\"u_projMatFromLight\", this.light.shadow.projectionMatrix);\n  }\n}\n\nvar fs$3 = \"varying vec2 v_uv;\\n\\nuniform vec4 u_ambientLight;\\n\\n#ifdef O3_SHADOW_MAP_COUNT\\n\\nstruct Shadow {\\n  float     bias;\\n  float     intensity;\\n  vec2      mapSize;\\n  float     radius;\\n};\\n\\nuniform Shadow u_shadows[O3_SHADOW_MAP_COUNT];\\n\\nuniform sampler2D u_shadowMaps[O3_SHADOW_MAP_COUNT];\\n\\nvarying vec4 v_PositionFromLight[O3_SHADOW_MAP_COUNT];\\n\\nconst vec4 bitShift = vec4(1.0, 1.0/256.0, 1.0/(256.0*256.0), 1.0/(256.0*256.0*256.0));\\n\\n/**\\n* \\n*/\\nfloat unpack(const in vec4 rgbaDepth) {\\n  return dot(rgbaDepth, bitShift);\\n}\\n\\n/**\\n* \\n*/\\nfloat getVisibility(vec4 positionFromLight, const in sampler2D shadowMap, vec2 mapSize, float intensity, float bias, float radius) {\\n\\n    vec3 shadowCoord = (positionFromLight.xyz/positionFromLight.w)/2.0 + 0.5;\\n    float filterX = step(0.0, shadowCoord.x) * (1.0 - step(1.0, shadowCoord.x));\\n    float filterY = step(0.0, shadowCoord.y) * (1.0 - step(1.0, shadowCoord.y));\\n\\n    shadowCoord.z -= bias;\\n    vec2 texelSize = vec2( 1.0 ) / mapSize;\\n\\n    float visibility = 0.0;\\n    for (float y = -1.0 ; y <=1.0 ; y+=1.0) {\\n      for (float x = -1.0 ; x <=1.0 ; x+=1.0) {\\n        vec2 uv = shadowCoord.xy + texelSize * vec2(x, y) * radius;\\n        vec4 rgbaDepth = texture2D(shadowMap, uv);\\n        float depth = unpack(rgbaDepth);\\n        visibility += step(depth, shadowCoord.z) * intensity;\\n      }\\n    }\\n\\n    visibility *= ( 1.0 / 9.0 );\\n    return visibility * filterX * filterY;\\n\\n}\\n\\n#endif\\n\\nvoid main() {\\n\\n  vec4 shadowColor = vec4(1.0, 1.0, 1.0, 1.0);\\n\\n#ifdef O3_SHADOW_MAP_COUNT\\n\\n  float visibility = 1.0;\\n\\n  for(int i = 0; i < O3_SHADOW_MAP_COUNT; i++) {\\n\\n   visibility -= getVisibility(v_PositionFromLight[i], u_shadowMaps[i], u_shadows[i].mapSize, u_shadows[i].intensity, u_shadows[i].bias, u_shadows[i].radius);\\n\\n  }\\n\\n  visibility = clamp(visibility, 0.0, 1.0);\\n  shadowColor = vec4(visibility, visibility, visibility, 1.0);\\n\\n#endif\\n\\n  gl_FragColor = shadowColor;\\n}\";\n\nclass ShadowMaterial extends ComplexMaterial {\n  _generateTechnique(camera, component) {\n    const customMacros = this._generateMacros();\n    const uniforms = this._generateFragmentUniform();\n    const tech = new RenderTechnique(this.name);\n    tech.autoConvert = false;\n    tech.isValid = true;\n    tech.uniforms = uniforms;\n    tech.attributes = {};\n    tech.states = {};\n    tech.customMacros = customMacros;\n    tech.vertexShader = vs$2;\n    tech.fragmentShader = fs$3;\n    tech.states = {\n      enable: [RenderState.BLEND],\n      functions: {\n        depthFunc: [CompFunc.LEQUAL],\n        blendFunc: [BlendFunc.DST_COLOR, BlendFunc.ZERO]\n      }\n    };\n    return tech;\n  }\n  _generateFragmentUniform() {\n    let uniforms = {};\n    for (let i = 0; i < this.shadowMapCount; i++) {\n      const lgtUniforms = LightShadow.getUniformDefine(i);\n      uniforms = {...uniforms, ...lgtUniforms};\n    }\n    return uniforms;\n  }\n  _generateMacros() {\n    const macros = [];\n    if (this.shadowMapCount > 0) {\n      macros.push(`O3_SHADOW_MAP_COUNT ${this.shadowMapCount}`);\n    }\n    return macros;\n  }\n}\n\nclass ShadowPass extends RenderPass {\n  constructor(...args) {\n    super(...args);\n    this.clearMode = ClearMode.DONT_CLEAR;\n  }\n  preRender(camera, opaqueQueue, transparentQueue) {\n    this.enabled = false;\n    const lightMgr = camera.scene.findFeature(LightFeature);\n    if (lightMgr) {\n      const pass = camera._renderPipeline.defaultRenderPass;\n      this.renderTarget = pass.renderTarget;\n      const lights = lightMgr.visibleLights;\n      let shadowMapCount = 0;\n      for (let i = 0, len = lights.length; i < len; i++) {\n        const lgt = lights[i];\n        if (lgt.enableShadow) {\n          lgt.shadow.bindShadowValues(this.replaceMaterial, shadowMapCount, lgt);\n          shadowMapCount++;\n        }\n      }\n      if (shadowMapCount !== this.replaceMaterial.shadowMapCount) {\n        this.replaceMaterial.shadowMapCount = shadowMapCount;\n        this.replaceMaterial.clearTechniques();\n      }\n      if (shadowMapCount)\n        this.enabled = true;\n    }\n  }\n}\n\nclass ShadowFeature extends SceneFeature {\n  preRender(scene, camera) {\n    const lightMgr = camera.scene.findFeature(LightFeature);\n    if (lightMgr && lightMgr.visibleLights.length > 0) {\n      if (!this._shadowPass) {\n        this.addShadowPass(camera);\n      }\n      const lights = lightMgr.visibleLights;\n      for (let i = 0, len = lights.length; i < len; i++) {\n        const lgt = lights[i];\n        if (lgt.enableShadow && !lgt.shadowMapPass) {\n          lgt.shadowMapPass = this.addShadowMapPass(camera, lgt);\n        } else if (!lgt.enableShadow && lgt.shadowMapPass) {\n          const renderer = camera._renderPipeline;\n          renderer.removeRenderPass(lgt.shadowMapPass);\n          lgt.shadowMapPass = null;\n        }\n      }\n      this.updatePassRenderFlag(camera._renderPipeline.opaqueQueue);\n      this.updatePassRenderFlag(camera._renderPipeline.transparentQueue);\n    }\n  }\n  addShadowPass(camera) {\n    const shadowMaterial = new ShadowMaterial(camera.engine, \"shadowMaterial\");\n    this._shadowPass = new ShadowPass(\"ShadowPass\", 1, null, shadowMaterial, MaskList.SHADOW);\n    const renderer = camera._renderPipeline;\n    renderer.addRenderPass(this._shadowPass);\n  }\n  addShadowMapPass(camera, light) {\n    this._shadowMapMaterial = this._shadowMapMaterial || new ShadowMapMaterial(camera.engine, \"shadowMapMaterial\");\n    const shadowMapPass = new ShadowMapPass(\"ShadowMapPass\", -1, light.shadow.renderTarget, this._shadowMapMaterial, MaskList.SHADOW_MAP, light);\n    const renderer = camera._renderPipeline;\n    renderer.addRenderPass(shadowMapPass);\n    return shadowMapPass;\n  }\n  updatePassRenderFlag(renderQueue) {\n    const items = renderQueue.items;\n    for (let i = 0, len = items.length; i < len; i++) {\n      const item = items[i];\n      const ability = item.component;\n      const recieveShadow = ability.recieveShadow;\n      const castShadow = ability.castShadow;\n      if (recieveShadow === true) {\n        ability.addPassMasks(MaskList.SHADOW);\n      } else if (recieveShadow === false) {\n        ability.removePassMasks(MaskList.SHADOW);\n      }\n      if (castShadow === true) {\n        ability.addPassMasks(MaskList.SHADOW_MAP);\n      } else if (castShadow === false) {\n        ability.removePassMasks(MaskList.SHADOW_MAP);\n      }\n    }\n  }\n}\n\nScene.registerFeature(ShadowFeature);\n\nScene.registerFeature(LightFeature);\nScene.prototype.hasLight = hasLight;\n\nexport { ABoxCollider, Collider as ACollider, ASphereCollider, AmbientLight, Animation, AnimationClip, AnimationEventType as AnimationEvent, AssetObject, AssetPromise, AssetPromiseStatus, AssetType, BasicRenderPipeline, BlendFunc, BlinnPhongMaterial, BoundingType, BoxCollider, Buffer, BufferBindFlag, BufferGeometry, BufferUsage, BufferUtil, Camera, CircleGeometry, ClearMode, ColliderFeature, CollisionDetection, CommonMaterial, CompFunc, ComplexMaterial, Component, ConstantMaterial, CubeProbe, CuboidGeometry, CullFace, CylinderGeometry, DataType, DirectLight, EXP2Fog, Engine, EngineFeature, EngineObject, Entity, EnvironmentMapLight, Event, EventDispatcher, FogFeature, FrontFace, GLCapabilityType, GLCompressedTextureInternalFormat, GPUParticleSystem, GeometryRenderer, IndexBufferBinding, IndexFormat, InternalAssetType, InterpolationType, LODGroup, LambertMaterial, Layer, Light, LightFeature, LinearFog, Loader, Logger, MaskList, Material, MaterialType, Mesh, MeshRenderer, Model, OITMode, ObjectValues, PBRMaterial, Particle, PlaneCollider, PlaneGeometry, PlaneProbe, PointLight, Primitive, PrimitiveTopology, Probe, RefObject, RefreshRate, RenderBufferColorFormat, RenderBufferDepthFormat, RenderColorTexture, RenderContext, RenderDepthTexture, RenderPass, RenderQueue, RenderState, RenderTarget, RenderTechnique, RenderableComponent, ResourceManager, Scene, SceneFeature, SceneVisitor, ScreenQuadGeometry, Script, SetDataOptions, ShaderFactory, ShaderMaterial, ShapeGeometry, Side, Skin, SkinnedMeshRenderer, SkyBox, SphereCollider, SphereGeometry, SpotLight, SpriteRenderer, SubPrimitive, SystemInfo, Texture, Texture2D, TextureCubeFace, TextureCubeMap, TextureFilter, TextureFilterMode, TextureFormat, TextureMaterial, TextureWrapMode, Time, TorusGeometry, TrailMaterial, TrailRenderer, Transform, TransparentMaterial, UniformSemantic, UpdateFlag, Util, VertexBufferBinding, VertexElement, VertexElementFormat, WrapMode, bindFogToMaterial, dependencies, getFogMacro, hasFogFeature, request, resourceLoader };\n//# sourceMappingURL=module.js.map\n","import { Logger, request } from '@oasis-engine/core';\n\nclass DRACOWorker {\n  constructor(workerSourceURL, decoderWASMBinary) {\n    this._costs = {};\n    this._currentLoad = 0;\n    this._callbacks = {};\n    this._worker = new Worker(workerSourceURL);\n    this._worker.onmessage = (e) => {\n      const message = e.data;\n      switch (message.type) {\n        case \"decode\":\n          this._callbacks[message.id].resolve(message.geometry);\n          break;\n        case \"error\":\n          this._callbacks[message.id].reject(message);\n          break;\n        default:\n          Logger.error('DRACOWorker: Unexpected message, \"' + message.type + '\"');\n      }\n    };\n    if (decoderWASMBinary) {\n      this._worker.postMessage({type: \"init\", decoderConfig: {wasmBinary: decoderWASMBinary}});\n    } else {\n      this._worker.postMessage({type: \"init\", decoderConfig: {}});\n    }\n  }\n  get currentLoad() {\n    return this._currentLoad;\n  }\n  setCosts(taskId, cost) {\n    this._costs[taskId] = cost;\n  }\n  addCurrentLoad(cost) {\n    this._currentLoad += cost;\n  }\n  setCallback(taskId, resolve, reject) {\n    this._callbacks[taskId] = {resolve, reject};\n  }\n  decode(taskId, taskConfig, buffer) {\n    this._worker.postMessage({type: \"decode\", id: taskId, taskConfig, buffer}, [buffer]);\n  }\n  releaseTask(taskId) {\n    this._currentLoad -= this._costs[taskId];\n    delete this._callbacks[taskId];\n    delete this._costs[taskId];\n  }\n}\n\nvar workerString = 'let decoderPending;\\nlet decoderConfig;\\n\\nonmessage = function(e) {\\n  const message = e.data;\\n\\n  switch (message.type) {\\n    case \"init\":\\n      decoderConfig = message.decoderConfig;\\n      decoderPending = new Promise(function(resolve /*, reject*/) {\\n        decoderConfig.onModuleLoaded = function(draco) {\\n          // Module is Promise-like. Wrap before resolving to avoid loop.\\n          resolve({ draco: draco });\\n        };\\n        DracoDecoderModule(decoderConfig);\\n      });\\n      break;\\n\\n    case \"decode\":\\n      const buffer = message.buffer;\\n      const taskConfig = message.taskConfig;\\n      decoderPending.then(module => {\\n        const draco = module.draco;\\n        const decoder = new draco.Decoder();\\n        const decoderBuffer = new draco.DecoderBuffer();\\n        decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\\n        try {\\n          const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\\n          const buffers = geometry.attributes.map(attr => attr.array.buffer);\\n          if (geometry.index) buffers.push(geometry.index.array.buffer);\\n          self.postMessage({ type: \"decode\", id: message.id, geometry }, buffers);\\n        } catch (error) {\\n          console.error(error);\\n          self.postMessage({ type: \"error\", id: message.id, error: error.message });\\n        } finally {\\n          draco.destroy(decoderBuffer);\\n          draco.destroy(decoder);\\n        }\\n      });\\n      break;\\n  }\\n};\\n\\nfunction decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\\n  const attributeIDs = taskConfig.attributeIDs;\\n  const attributeTypes = taskConfig.attributeTypes;\\n\\n  let dracoGeometry;\\n  let decodingStatus;\\n\\n  const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\\n  if (geometryType === draco.TRIANGULAR_MESH) {\\n    dracoGeometry = new draco.Mesh();\\n    decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\\n  } else {\\n    throw new Error(\"DRACODecoder worker: Unexpected geometry type.\");\\n  }\\n\\n  if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\\n    throw new Error(\"DRACODecoder worker: Decoding failed: \" + decodingStatus.error_msg());\\n  }\\n\\n  const geometry = { index: null, attributes: [] };\\n\\n  // Gather all vertex attributes.\\n  for (let attributeName in attributeIDs) {\\n    const attributeType = self[attributeTypes[attributeName]];\\n\\n    let attribute;\\n    let attributeID;\\n\\n    // A Draco file may be created with default vertex attributes, whose attribute IDs\\n    // are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\\n    // a Draco file may contain a custom set of attributes, identified by known unique\\n    // IDs. glTF files always do the latter, and `.drc` files typically do the former.\\n    if (taskConfig.useUniqueIDs) {\\n      attributeID = attributeIDs[attributeName];\\n      attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\\n    } else {\\n      attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\\n      if (attributeID === -1) continue;\\n      attribute = decoder.GetAttribute(dracoGeometry, attributeID);\\n    }\\n    geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\\n  }\\n  // Add index.\\n  if (geometryType === draco.TRIANGULAR_MESH) {\\n    // Generate mesh faces.\\n    const numFaces = dracoGeometry.num_faces();\\n    const numIndices = numFaces * 3;\\n    let dataSize;\\n    let ptr;\\n    let index;\\n    const indexType = self[taskConfig.indexType];\\n\\n    switch (indexType) {\\n      case Uint16Array:\\n        dataSize = numIndices * 2;\\n        ptr = draco._malloc(dataSize);\\n        decoder.GetTrianglesUInt16Array(dracoGeometry, dataSize, ptr);\\n        index = new Uint16Array(draco.HEAPU16.buffer, ptr, numIndices).slice();\\n        draco._free(ptr);\\n        break;\\n      case Uint32Array:\\n        dataSize = numIndices * 4;\\n        ptr = draco._malloc(dataSize);\\n        decoder.GetTrianglesUInt32Array(dracoGeometry, dataSize, ptr);\\n        index = new Uint32Array(draco.HEAPU32.buffer, ptr, numIndices).slice();\\n        draco._free(ptr);\\n      default:\\n        throw new Error(\"DRACODecoder: Unexpected index type.\");\\n    }\\n    geometry.index = { array: index, itemSize: 1 };\\n  }\\n  draco.destroy(dracoGeometry);\\n  return geometry;\\n}\\n\\nfunction decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\\n  const numComponents = attribute.num_components();\\n  const numPoints = dracoGeometry.num_points();\\n  const numValues = numPoints * numComponents;\\n  let ptr;\\n  let array;\\n  let dataSize;\\n  switch (attributeType) {\\n    case Float32Array:\\n      dataSize = numValues * 4;\\n      ptr = draco._malloc(dataSize);\\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_FLOAT32, dataSize, ptr);\\n      array = new Float32Array(draco.HEAPF32.buffer, ptr, numValues).slice();\\n      draco._free(ptr);\\n      break;\\n\\n    case Int8Array:\\n      ptr = draco._malloc(numValues);\\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_INT8, numValues, ptr);\\n      array = new Int8Array(draco.HEAP8.buffer, ptr, numValues).slice();\\n      draco._free(ptr);\\n      break;\\n\\n    case Int16Array:\\n      dataSize = numValues * 2;\\n      ptr = draco._malloc(dataSize);\\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_INT16, dataSize, ptr);\\n      array = new Int16Array(draco.HEAP16.buffer, ptr, numValues).slice();\\n      draco._free(ptr);\\n      break;\\n\\n    case Int32Array:\\n      dataSize = numValues * 4;\\n      ptr = draco._malloc(dataSize);\\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_INT32, dataSize, ptr);\\n      array = new Int32Array(draco.HEAP32.buffer, ptr, numValues).slice();\\n      draco._free(ptr);\\n      break;\\n\\n    case Uint8Array:\\n      ptr = draco._malloc(numValues);\\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_UINT8, numValues, ptr);\\n      array = new Uint8Array(draco.HEAPU8.buffer, ptr, numValues).slice();\\n      draco._free(ptr);\\n      break;\\n\\n    case Uint16Array:\\n      dataSize = numValues * 2;\\n      ptr = draco._malloc(dataSize);\\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_UINT16, dataSize, ptr);\\n      array = new Uint16Array(draco.HEAPU16.buffer, ptr, numValues).slice();\\n      draco._free(ptr);\\n      break;\\n\\n    case Uint32Array:\\n      dataSize = numValues * 4;\\n      ptr = draco._malloc(dataSize);\\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_UINT32, dataSize, ptr);\\n      array = new Uint32Array(draco.HEAPU32.buffer, ptr, numValues).slice();\\n      draco._free(ptr);\\n      break;\\n\\n    default:\\n      throw new Error(\"DRACODecoder: Unexpected attribute type.\");\\n  }\\n\\n  return {\\n    name: attributeName,\\n    array: array,\\n    itemSize: numComponents\\n  };\\n}\\n';\n\nconst LIB_PATH = \"https://gw.alipayobjects.com/os/lib/alipay/draco-javascript/1.3.6/lib/\";\nconst JS_FILE = \"draco_decoder_gltf.js\";\nconst WASM_FILE = \"draco_decoder_gltf.r3bin\";\nconst WASM_WRAPPER_FILE = \"draco_wasm_wrapper_gltf.js\";\nclass DRACODecoder {\n  constructor(config = {type: \"wasm\", workerLimit: 4}) {\n    this.pool = [];\n    this.workerLimit = Math.min(navigator.hardwareConcurrency || 4, 4);\n    this.currentTaskId = 1;\n    this.taskCache = new WeakMap();\n    if (config.workerLimit > this.workerLimit) {\n      Logger.warn(\"DRACOWorkerPool: Can not initialize worker pool with limit:\" + config.workerLimit);\n    } else {\n      this.workerLimit = config.workerLimit ?? 4;\n    }\n    this.useJS = typeof WebAssembly !== \"object\" || config.type === \"js\";\n    this.loadLibPromise = this.preloadLib();\n  }\n  preloadLib() {\n    if (this.loadLibPromise) {\n      return this.loadLibPromise;\n    }\n    return new Promise((resolve, reject) => {\n      if (this.useJS) {\n        request(`${LIB_PATH}${JS_FILE}`, {type: \"text\"}).then((jsSource) => {\n          const body = [jsSource, workerString].join(\"\\n\");\n          const workerSourceURL = URL.createObjectURL(new Blob([body]));\n          resolve({workerSourceURL, decoderWASMBinary: null});\n        }).catch((reason) => {\n          reject(reason);\n        });\n      } else {\n        Promise.all([\n          request(`${LIB_PATH}${WASM_WRAPPER_FILE}`, {type: \"text\"}),\n          request(`${LIB_PATH}${WASM_FILE}`, {type: \"arraybuffer\"})\n        ]).then((resources) => {\n          const [wrapperSource, decoderWASMBinary] = resources;\n          const body = [wrapperSource, workerString].join(\"\\n\");\n          const workerSourceURL = URL.createObjectURL(new Blob([body]));\n          resolve({workerSourceURL, decoderWASMBinary});\n        }).catch((reason) => {\n          reject(reason);\n        });\n      }\n    });\n  }\n  getWorker() {\n    return this.preloadLib().then((worderResources) => {\n      if (this.pool.length < this.workerLimit) {\n        const dracoWorker = new DRACOWorker(worderResources.workerSourceURL, worderResources.decoderWASMBinary);\n        this.pool.push(dracoWorker);\n      } else {\n        this.pool.sort(function(a, b) {\n          return a.currentLoad > b.currentLoad ? -1 : 1;\n        });\n      }\n      return this.pool[this.pool.length - 1];\n    });\n  }\n  decode(buffer, taskConfig) {\n    const taskKey = JSON.stringify(taskConfig);\n    if (this.taskCache.has(buffer)) {\n      const cachedTask = this.taskCache.get(buffer);\n      if (cachedTask.key === taskKey) {\n        return cachedTask.promise;\n      } else if (buffer.byteLength === 0) {\n        throw new Error(\"DRACODecoder: Unable to re-decode a buffer with different settings. Buffer has already been transferred.\");\n      }\n    }\n    const taskId = this.currentTaskId++;\n    const cost = buffer.byteLength;\n    let taskWorker;\n    const task = new Promise((resolve, reject) => {\n      this.getWorker().then((worker2) => {\n        taskWorker = worker2;\n        worker2.setCosts(taskId, cost);\n        worker2.addCurrentLoad(cost);\n        worker2.setCallback(taskId, resolve, reject);\n        worker2.decode(taskId, taskConfig, buffer);\n      }).catch((e) => {\n        reject(e);\n      });\n    });\n    task.finally(() => {\n      if (taskWorker && taskId) {\n        taskWorker.releaseTask(taskId);\n      }\n    });\n    this.taskCache.set(buffer, {\n      key: taskKey,\n      promise: task\n    });\n    return task;\n  }\n}\n\nexport { DRACODecoder };\n//# sourceMappingURL=module.js.map\n","import { resourceLoader, AssetType, Loader, AssetPromise, VertexElement, DataType, IndexFormat, VertexElementFormat, Material, Logger, SkinnedMeshRenderer, MeshRenderer, Entity, Animation, ConstantMaterial, PBRMaterial, EngineObject, Skin, Mesh, Primitive, SubPrimitive, PrimitiveTopology, AnimationClip, InterpolationType, Camera, Buffer, BufferBindFlag, BufferUsage, IndexBufferBinding, GLCapabilityType, Texture2D, GLCompressedTextureInternalFormat, TextureFormat, TextureCubeMap, TextureCubeFace, Component, Texture, ShaderMaterial, BlinnPhongMaterial, ObjectValues, EventDispatcher } from '@oasis-engine/core';\nimport { Vector4, Vector3, Matrix, Quaternion, Vector2 } from '@oasis-engine/math';\nimport { DRACODecoder } from '@oasis-engine/draco';\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __decorate = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result)\n    __defProp(target, key, result);\n  return result;\n};\nfunction isBase64(url) {\n  return /^data:(.+?);base64,/.test(url);\n}\nlet BufferLoader = class extends Loader {\n  load(item) {\n    const url = item.url;\n    if (isBase64(url)) {\n      return new AssetPromise((resolve) => {\n        const base64Str = url.slice(13 + RegExp.$1.length);\n        const result = Uint8Array.from(atob(base64Str), (c) => c.charCodeAt(0));\n        resolve(result.buffer);\n      });\n    }\n    return this.request(url, {\n      ...item,\n      type: \"arraybuffer\"\n    });\n  }\n};\nBufferLoader = __decorate([\n  resourceLoader(AssetType.Buffer, [\"bin\", \"r3bin\"], false)\n], BufferLoader);\n\nconst WEBGL_COMPONENT_TYPES = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\nfunction decodeText(array) {\n  if (typeof TextDecoder !== \"undefined\") {\n    return new TextDecoder().decode(array);\n  }\n  let s = \"\";\n  for (let i = 0, il = array.length; i < il; i++) {\n    s += String.fromCharCode(array[i]);\n  }\n  return decodeURIComponent(encodeURIComponent(s));\n}\nfunction getAccessorTypeSize(accessorType) {\n  const ACCESSOR_TYPE_SIZE = {\n    SCALAR: 1,\n    VEC2: 2,\n    VEC3: 3,\n    VEC4: 4,\n    MAT2: 4,\n    MAT3: 9,\n    MAT4: 16\n  };\n  return ACCESSOR_TYPE_SIZE[accessorType];\n}\nfunction getComponentType(componentType) {\n  return WEBGL_COMPONENT_TYPES[componentType];\n}\nfunction getAccessorData(gltf, accessor, buffers) {\n  const bufferView = gltf.bufferViews[accessor.bufferView];\n  const arrayBuffer = buffers[bufferView.buffer];\n  const accessorByteOffset = accessor.hasOwnProperty(\"byteOffset\") ? accessor.byteOffset : 0;\n  const bufferViewByteOffset = bufferView.hasOwnProperty(\"byteOffset\") ? bufferView.byteOffset : 0;\n  const byteOffset = accessorByteOffset + bufferViewByteOffset;\n  const accessorTypeSize = getAccessorTypeSize(accessor.type);\n  const length = accessorTypeSize * accessor.count;\n  const byteStride = bufferView.byteStride ?? 0;\n  const arrayType = getComponentType(accessor.componentType);\n  let uint8Array;\n  if (byteStride) {\n    uint8Array = new Uint8Array(length * arrayType.BYTES_PER_ELEMENT);\n    const originalBufferView = new Uint8Array(arrayBuffer, bufferViewByteOffset, bufferView.byteLength);\n    let viewAccessor = 0;\n    const accessorByteSize = accessorTypeSize * arrayType.BYTES_PER_ELEMENT;\n    for (let i = 0; i < accessor.count; i++) {\n      viewAccessor = i * byteStride + accessorByteOffset;\n      for (let j = 0; j < accessorByteSize; j++) {\n        uint8Array[i * accessorByteSize + j] = originalBufferView[viewAccessor + j];\n      }\n    }\n  } else {\n    uint8Array = new Uint8Array(arrayBuffer, byteOffset, length * arrayType.BYTES_PER_ELEMENT);\n    uint8Array = new Uint8Array(uint8Array);\n  }\n  return new arrayType(uint8Array.buffer);\n}\nfunction getBufferData(bufferView, buffers) {\n  const arrayBuffer = buffers[bufferView.buffer];\n  const byteOffset = bufferView.byteOffset || 0;\n  return arrayBuffer.slice(byteOffset, byteOffset + bufferView.byteLength);\n}\nfunction getVertexStride(accessor) {\n  const size = getAccessorTypeSize(accessor.type);\n  const componentType = getComponentType(accessor.componentType);\n  return size * componentType.BYTES_PER_ELEMENT;\n}\nfunction createVertexElement(gltf, semantic, accessor, index) {\n  const size = getAccessorTypeSize(accessor.type);\n  return new VertexElement(semantic, 0, getElementFormat(accessor.componentType, size), index);\n}\nfunction getIndexFormat(type) {\n  switch (type) {\n    case DataType.UNSIGNED_BYTE:\n      return IndexFormat.UInt8;\n    case DataType.UNSIGNED_SHORT:\n      return IndexFormat.UInt16;\n    case DataType.UNSIGNED_INT:\n      return IndexFormat.UInt32;\n  }\n}\nfunction getElementFormat(type, size) {\n  if (type == DataType.FLOAT) {\n    switch (size) {\n      case 1:\n        return VertexElementFormat.Float;\n      case 2:\n        return VertexElementFormat.Vector2;\n      case 3:\n        return VertexElementFormat.Vector3;\n      case 4:\n        return VertexElementFormat.Vector4;\n    }\n  }\n  if (type == DataType.UNSIGNED_SHORT) {\n    switch (size) {\n      case 2:\n        return VertexElementFormat.UShort2;\n      case 4:\n        return VertexElementFormat.UShort4;\n    }\n  }\n}\nfunction loadImageBuffer(imageBuffer, type) {\n  return new Promise((resolve, reject) => {\n    const blob = new window.Blob([imageBuffer], {type});\n    const img = new Image();\n    img.src = URL.createObjectURL(blob);\n    img.crossOrigin = \"anonymous\";\n    img.onerror = function() {\n      reject(new Error(\"Failed to load image buffer\"));\n    };\n    img.onload = function() {\n      resolve(img);\n    };\n  });\n}\nfunction isAbsoluteUrl(url) {\n  return /^(?:http|blob|data:|\\/)/.test(url);\n}\nfunction parseRelativeUrl(baseUrl, relativeUrl) {\n  if (isAbsoluteUrl(relativeUrl)) {\n    return relativeUrl;\n  }\n  return baseUrl.substring(0, baseUrl.lastIndexOf(\"/\") + 1) + relativeUrl;\n}\n\nlet decoder;\nconst glTFDracoMeshCompression = {\n  init() {\n    if (!decoder) {\n      decoder = new DRACODecoder();\n    }\n  },\n  parse(extension, gltfPrimitive, gltf, buffers) {\n    const {bufferViews, accessors} = gltf;\n    const bufferViewIndex = extension.bufferView;\n    const gltfAttributeMap = extension.attributes;\n    const attributeMap = {};\n    const attributeTypeMap = {};\n    for (let attributeName in gltfAttributeMap) {\n      attributeMap[attributeName] = gltfAttributeMap[attributeName];\n    }\n    for (let attributeName in gltfPrimitive.attributes) {\n      if (gltfAttributeMap[attributeName] !== void 0) {\n        const accessorDef = accessors[gltfPrimitive.attributes[attributeName]];\n        attributeTypeMap[attributeName] = getComponentType(accessorDef.componentType).name;\n      }\n    }\n    const indexAccessor = accessors[gltfPrimitive.indices];\n    const indexType = getComponentType(indexAccessor.componentType).name;\n    const taskConfig = {\n      attributeIDs: attributeMap,\n      attributeTypes: attributeTypeMap,\n      useUniqueIDs: true,\n      indexType\n    };\n    const buffer = getBufferData(bufferViews[bufferViewIndex], buffers);\n    return decoder.decode(buffer, taskConfig).then((parsedGeometry) => parsedGeometry);\n  }\n};\n\nconst TARGET_PATH_MAP = {\n  translation: \"position\",\n  rotation: \"rotation\",\n  scale: \"scale\",\n  weights: \"weights\"\n};\nlet nodeCount = 0;\nconst RegistedObjs = {};\nconst RegistedCustomMaterials = {};\nconst getDefaultMaterial = function() {\n  return (engine) => {\n    let defaultMateril = new ConstantMaterial(engine, \"default\");\n    defaultMateril.emission = new Vector4(0.749, 0.749, 0.749, 1);\n    return defaultMateril;\n  };\n}();\nconst HandledExtensions = {\n  PBRMaterial: \"PBRMaterial\",\n  KHR_lights: \"KHR_lights\",\n  KHR_materials_unlit: \"KHR_materials_unlit\",\n  KHR_materials_pbrSpecularGlossiness: \"KHR_materials_pbrSpecularGlossiness\",\n  KHR_techniques_webgl: \"KHR_techniques_webgl\",\n  KHR_draco_mesh_compression: \"KHR_draco_mesh_compression\"\n};\nlet KHR_lights = null;\nconst extensionParsers = {\n  KHR_lights,\n  KHR_materials_unlit: PBRMaterial,\n  KHR_materials_pbrSpecularGlossiness: PBRMaterial,\n  KHR_techniques_webgl: Material,\n  KHR_draco_mesh_compression: glTFDracoMeshCompression\n};\nfunction RegistExtension(extobj) {\n  Object.keys(extobj).forEach((name) => {\n    if (RegistedObjs[name] === void 0) {\n      RegistedObjs[name] = extobj[name];\n      switch (name) {\n        case HandledExtensions.PBRMaterial:\n          extensionParsers.KHR_materials_unlit = PBRMaterial;\n          break;\n        case HandledExtensions.KHR_lights:\n          KHR_lights = extobj[name];\n          extensionParsers.KHR_lights = KHR_lights;\n          break;\n        default:\n          if (Material.isPrototypeOf(extobj[name]) && extobj[name].TECH_NAME)\n            RegistedCustomMaterials[extobj[name].TECH_NAME] = extobj[name];\n          break;\n      }\n    }\n  });\n}\nclass GLTFResource extends EngineObject {\n}\nfunction parseGLTF(data, engine) {\n  const resources = {\n    engine,\n    gltf: data.gltf,\n    buffers: data.buffers,\n    asset: new GLTFResource(engine)\n  };\n  resources.asset.textures = data.textures;\n  resources.asset.meta = data.gltf;\n  if (resources.gltf.asset && resources.gltf.asset.version) {\n    resources.gltf.version = Number(resources.gltf.asset.version);\n    resources.gltf.isGltf2 = resources.gltf.version >= 2 && resources.gltf.version <= 3;\n  }\n  parseExtensions(resources);\n  return parseResources(resources, \"materials\", parseMaterial).then(() => parseResources(resources, \"meshes\", parseMesh)).then(() => parseResources(resources, \"nodes\", parseNode)).then(() => parseResources(resources, \"scenes\", parseScene)).then(() => parseResources(resources, \"skins\", parseSkin)).then(() => parseResources(resources, \"animations\", parseAnimation)).then(() => buildSceneGraph(resources));\n}\nfunction parseExtensions(resources) {\n  const {gltf, asset} = resources;\n  const {extensions, extensionsUsed, extensionsRequired} = gltf;\n  if (extensionsUsed) {\n    Logger.info(\"extensionsUsed: \", extensionsUsed);\n    for (let i = 0; i < extensionsUsed.length; i++) {\n      if (Object.keys(extensionParsers).indexOf(extensionsUsed[i]) > -1) {\n        if (!extensionParsers[extensionsUsed[i]]) {\n          Logger.warn(\"extension \" + extensionsUsed[i] + \" is used, you can add this extension into gltf\");\n        }\n      } else {\n        Logger.warn(\"extensionsUsed has unsupported extension \" + extensionsUsed[i]);\n      }\n    }\n  }\n  if (extensionsRequired) {\n    Logger.info(`extensionsRequired: ${extensionsRequired}`);\n    for (let i = 0; i < extensionsRequired.length; i++) {\n      if (Object.keys(extensionParsers).indexOf(extensionsRequired[i]) < 0 || !extensionParsers[extensionsRequired[i]]) {\n        Logger.error(`model has not supported required extension ${extensionsRequired[i]}`);\n      }\n      if (extensionsRequired[i] === HandledExtensions.KHR_draco_mesh_compression) {\n        extensionParsers.KHR_draco_mesh_compression.init();\n      }\n    }\n  }\n  if (extensions) {\n    if (KHR_lights && extensions.KHR_lights) {\n      asset.lights = KHR_lights.parseLights(extensions.KHR_lights.lights);\n    }\n  }\n}\nfunction parseResources(resources, name, handler) {\n  const {gltf, asset} = resources;\n  if (!asset[name]) {\n    asset[name] = [];\n  }\n  if (gltf.hasOwnProperty(name)) {\n    const entities = gltf[name] || [];\n    Logger.debug(name + \":\", entities);\n    const promises = [];\n    for (let i = entities.length - 1; i >= 0; i--) {\n      promises.push(handler(entities[i], resources));\n    }\n    return Promise.all(promises).then((results) => {\n      for (let i = 0; i < results.length; i++) {\n        asset[name].push(results[i]);\n      }\n    });\n  }\n  return Promise.resolve();\n}\nfunction parseMaterial(gltfMaterial, resources) {\n  const {gltf, asset} = resources;\n  let material;\n  if (gltf.isGltf2 && typeof gltfMaterial.technique === \"undefined\") {\n    const uniformObj = {};\n    const stateObj = {};\n    const {\n      pbrMetallicRoughness,\n      normalTexture,\n      emissiveTexture,\n      emissiveFactor,\n      occlusionTexture,\n      alphaMode,\n      alphaCutoff,\n      doubleSided,\n      extensions\n    } = gltfMaterial;\n    if (pbrMetallicRoughness) {\n      const {\n        baseColorFactor,\n        baseColorTexture,\n        metallicFactor,\n        roughnessFactor,\n        metallicRoughnessTexture\n      } = pbrMetallicRoughness;\n      if (baseColorTexture) {\n        uniformObj.baseColorTexture = getItemByIdx(\"textures\", baseColorTexture.index || 0, resources, false);\n      }\n      if (baseColorFactor) {\n        uniformObj.baseColorFactor = new Vector4(...baseColorFactor);\n      }\n      uniformObj.metallicFactor = metallicFactor !== void 0 ? metallicFactor : 1;\n      uniformObj.roughnessFactor = roughnessFactor !== void 0 ? roughnessFactor : 1;\n      if (metallicRoughnessTexture) {\n        uniformObj.metallicRoughnessTexture = getItemByIdx(\"textures\", metallicRoughnessTexture.index || 0, resources, false);\n      }\n    }\n    if (normalTexture) {\n      const {index, texCoord, scale} = normalTexture;\n      uniformObj.normalTexture = getItemByIdx(\"textures\", index || 0, resources, false);\n      if (typeof scale !== void 0) {\n        uniformObj.normalScale = scale;\n      }\n    }\n    if (emissiveTexture) {\n      uniformObj.emissiveTexture = getItemByIdx(\"textures\", emissiveTexture.index || 0, resources, false);\n    }\n    if (occlusionTexture) {\n      uniformObj.occlusionTexture = getItemByIdx(\"textures\", occlusionTexture.index || 0, resources, false);\n      if (occlusionTexture.strength !== void 0) {\n        uniformObj.occlusionStrength = occlusionTexture.strength;\n      }\n    }\n    stateObj.doubleSided = !!doubleSided;\n    stateObj.alphaMode = alphaMode || \"OPAQUE\";\n    if (alphaMode === \"MASK\") {\n      uniformObj.alphaCutoff = alphaCutoff === void 0 ? 0.5 : alphaCutoff;\n    }\n    if (extensions) {\n      if (extensions.KHR_materials_unlit) {\n        stateObj.unlit = true;\n      }\n      if (extensions.KHR_materials_pbrSpecularGlossiness) {\n        const {\n          diffuseFactor,\n          diffuseTexture,\n          specularFactor,\n          glossinessFactor,\n          specularGlossinessTexture\n        } = extensions.KHR_materials_pbrSpecularGlossiness;\n        stateObj.isMetallicWorkflow = false;\n        if (diffuseFactor) {\n          uniformObj.baseColorFactor = new Vector4(...diffuseFactor);\n        }\n        if (diffuseTexture) {\n          uniformObj.baseColorTexture = getItemByIdx(\"textures\", diffuseTexture.index || 0, resources, false);\n        }\n        if (specularFactor) {\n          uniformObj.specularFactor = new Vector3(...specularFactor);\n        }\n        if (glossinessFactor !== void 0) {\n          uniformObj.glossinessFactor = glossinessFactor;\n        }\n        if (specularGlossinessTexture) {\n          uniformObj.specularGlossinessTexture = getItemByIdx(\"textures\", specularGlossinessTexture.index || 0, resources, false);\n        }\n      }\n    }\n    const {unlit, srgb, gamma, blendFunc, depthMask} = gltfMaterial;\n    if (unlit)\n      stateObj.unlit = true;\n    if (srgb)\n      stateObj.srgb = true;\n    if (gamma)\n      stateObj.gamma = true;\n    if (blendFunc)\n      stateObj.blendFunc = blendFunc;\n    if (depthMask !== void 0)\n      stateObj.depthMask = depthMask;\n    material = new PBRMaterial(resources.engine, gltfMaterial.name || PBRMaterial.MATERIAL_NAME, Object.assign({}, uniformObj, stateObj));\n  } else {\n    const techniqueName = gltfMaterial.technique;\n    Logger.warn(\"Deprecated: Please use a model that meets the glTF 2.0 specification\");\n    if (techniqueName === \"Texture\") {\n      material = new PBRMaterial(resources.engine, gltfMaterial.name || PBRMaterial.MATERIAL_NAME);\n      material.unlit = true;\n      const index = gltfMaterial.values._MainTex[0];\n      material.baseColorTexture = getItemByIdx(\"textures\", index || 0, resources, false);\n    }\n  }\n  return Promise.resolve(material);\n}\nfunction parseSkin(gltfSkin, resources) {\n  const {gltf, buffers} = resources;\n  const jointCount = gltfSkin.joints.length;\n  const skin = new Skin(gltfSkin.name);\n  const accessor = gltf.accessors[gltfSkin.inverseBindMatrices];\n  const buffer = getAccessorData(gltf, accessor, buffers);\n  const MAT4_LENGTH = 16;\n  for (let i = 0; i < jointCount; i++) {\n    const startIdx = MAT4_LENGTH * i;\n    const endIdx = startIdx + MAT4_LENGTH;\n    skin.inverseBindMatrices[i] = new Matrix(...buffer.subarray(startIdx, endIdx));\n  }\n  for (let i = 0; i < jointCount; i++) {\n    const node2 = getItemByIdx(\"nodes\", gltfSkin.joints[i], resources);\n    skin.joints[i] = node2.name;\n  }\n  const node = getItemByIdx(\"nodes\", gltfSkin.skeleton == null ? gltfSkin.joints[0] : gltfSkin.skeleton, resources);\n  skin.skeleton = node.name;\n  return Promise.resolve(skin);\n}\nfunction parsePrimitiveVertex(mesh, primitive, primitiveGroup, gltfPrimitive, gltf, getVertexBufferData, getIndexBufferData, engine) {\n  let i = 0;\n  const vertexElements = [];\n  for (const attributeSemantic in gltfPrimitive.attributes) {\n    const accessorIdx = gltfPrimitive.attributes[attributeSemantic];\n    const accessor = gltf.accessors[accessorIdx];\n    const stride = getVertexStride(accessor);\n    const vertexELement = createVertexElement(gltf, attributeSemantic, accessor, i);\n    vertexElements.push(vertexELement);\n    const bufferData = getVertexBufferData(attributeSemantic);\n    const vertexBuffer = new Buffer(engine, BufferBindFlag.VertexBuffer, bufferData.byteLength, BufferUsage.Static);\n    vertexBuffer.setData(bufferData);\n    primitive.setVertexBufferBinding(vertexBuffer, stride, i++);\n    if (vertexELement.semantic == \"POSITION\") {\n      const position = new Vector3();\n      const vertexCount = bufferData.length / 3;\n      const {min, max} = mesh.bounds;\n      for (let i2 = 0; i2 < vertexCount; i2++) {\n        const offset = i2 * 3;\n        position.setValue(bufferData[offset], bufferData[offset + 1], bufferData[offset + 2]);\n        Vector3.min(min, position, min);\n        Vector3.max(max, position, max);\n      }\n    }\n  }\n  primitive.setVertexElements(vertexElements);\n  const indexAccessor = gltf.accessors[gltfPrimitive.indices];\n  const indexData = getIndexBufferData();\n  const indexCount = indexAccessor.count;\n  const indexFormat = getIndexFormat(indexAccessor.componentType);\n  const indexByteSize = indexFormat == IndexFormat.UInt32 ? 4 : indexFormat == IndexFormat.UInt16 ? 2 : 1;\n  const indexBuffer = new Buffer(engine, BufferBindFlag.IndexBuffer, indexCount * indexByteSize, BufferUsage.Static);\n  indexBuffer.setData(indexData);\n  primitive.setIndexBufferBinding(new IndexBufferBinding(indexBuffer, indexFormat));\n  primitiveGroup.start = 0;\n  primitiveGroup.count = indexCount;\n  return Promise.resolve(primitive);\n}\nfunction parseMesh(gltfMesh, resources) {\n  const {gltf, buffers, engine} = resources;\n  const mesh = new Mesh(gltfMesh.name);\n  const primitivePromises = [];\n  const groups = [];\n  for (let i = 0; i < gltfMesh.primitives.length; i++) {\n    primitivePromises.push(new Promise((resolve, reject) => {\n      const gltfPrimitive = gltfMesh.primitives[i];\n      const primitive = new Primitive(engine, gltfPrimitive.name || gltfMesh.name || i);\n      const subPrimitive = new SubPrimitive();\n      groups.push(subPrimitive);\n      subPrimitive.topology = gltfPrimitive.mode == null ? PrimitiveTopology.Triangles : gltfPrimitive.mode;\n      if (gltfPrimitive.hasOwnProperty(\"targets\")) {\n        primitive.targets = [];\n        mesh.weights = gltfMesh.weights || new Array(gltfPrimitive.targets.length).fill(0);\n      }\n      let vertexPromise;\n      if (gltfPrimitive.extensions && gltfPrimitive.extensions[HandledExtensions.KHR_draco_mesh_compression]) {\n        const extensionParser = extensionParsers.KHR_draco_mesh_compression;\n        const extension = gltfPrimitive.extensions[HandledExtensions.KHR_draco_mesh_compression];\n        vertexPromise = extensionParser.parse(extension, gltfPrimitive, gltf, buffers).then((decodedGeometry) => {\n          return parsePrimitiveVertex(mesh, primitive, subPrimitive, gltfPrimitive, gltf, (attributeSemantic) => {\n            for (let i2 = 0; i2 < decodedGeometry.attributes.length; i2++) {\n              if (decodedGeometry.attributes[i2].name === attributeSemantic) {\n                return decodedGeometry.attributes[i2].array;\n              }\n            }\n            return null;\n          }, () => {\n            return decodedGeometry.index.array;\n          }, resources.engine);\n        });\n      } else {\n        vertexPromise = parsePrimitiveVertex(mesh, primitive, subPrimitive, gltfPrimitive, gltf, (attributeSemantic) => {\n          const accessorIdx = gltfPrimitive.attributes[attributeSemantic];\n          const accessor = gltf.accessors[accessorIdx];\n          return getAccessorData(gltf, accessor, buffers);\n        }, () => {\n          const indexAccessor = gltf.accessors[gltfPrimitive.indices];\n          return getAccessorData(gltf, indexAccessor, buffers);\n        }, resources.engine);\n      }\n      vertexPromise.then((processedPrimitive) => {\n        resolve(processedPrimitive);\n      }).catch((e) => {\n        reject(e);\n      });\n    }));\n  }\n  return Promise.all(primitivePromises).then((primitives) => {\n    for (let i = 0; i < primitives.length; i++) {\n      mesh.primitives.push(primitives[i]);\n      mesh.groups.push(groups[i]);\n    }\n    return mesh;\n  });\n}\nfunction parseAnimation(gltfAnimation, resources) {\n  const {gltf, buffers} = resources;\n  const gltfSamplers = gltfAnimation.samplers || [];\n  const gltfChannels = gltfAnimation.channels || [];\n  const animationIdx = gltf.animations.indexOf(gltfAnimation);\n  const animationClip = new AnimationClip(gltfAnimation.name || `Animation${animationIdx}`);\n  let duration = -1;\n  let durationIndex = -1;\n  for (let i = 0; i < gltfSamplers.length; i++) {\n    const gltfSampler = gltfSamplers[i];\n    const inputAccessor = gltf.accessors[gltfSampler.input];\n    const outputAccessor = gltf.accessors[gltfSampler.output];\n    const input = getAccessorData(gltf, inputAccessor, buffers);\n    const output = getAccessorData(gltf, outputAccessor, buffers);\n    let outputAccessorSize = getAccessorTypeSize(outputAccessor.type);\n    if (outputAccessorSize * input.length !== output.length)\n      outputAccessorSize = output.length / input.length;\n    let samplerInterpolation = InterpolationType.LINEAR;\n    switch (gltfSampler.interpolation) {\n      case \"CUBICSPLINE\":\n        samplerInterpolation = InterpolationType.CUBICSPLINE;\n        break;\n      case \"STEP\":\n        samplerInterpolation = InterpolationType.STEP;\n        break;\n    }\n    const maxTime = input[input.length - 1];\n    if (maxTime > duration) {\n      duration = maxTime;\n      durationIndex = i;\n    }\n    animationClip.addSampler(input, output, outputAccessorSize, samplerInterpolation);\n  }\n  animationClip.durationIndex = durationIndex;\n  animationClip.duration = duration;\n  for (let i = 0; i < gltfChannels.length; i++) {\n    const gltfChannel = gltfChannels[i];\n    const target = gltfChannel.target;\n    const samplerIndex = gltfChannel.sampler;\n    const targetNode = getItemByIdx(\"nodes\", target.node, resources);\n    const targetPath = TARGET_PATH_MAP[target.path];\n    animationClip.addChannel(samplerIndex, targetNode.name, targetPath);\n  }\n  return Promise.resolve(animationClip);\n}\nfunction parseNode(gltfNode, resources) {\n  const entity = new Entity(resources.engine, gltfNode.name || `GLTF_NODE_${nodeCount++}`);\n  if (gltfNode.hasOwnProperty(\"matrix\")) {\n    const m = gltfNode.matrix;\n    const mat = new Matrix();\n    mat.setValueByArray(m);\n    const pos = new Vector3();\n    const scale = new Vector3(1, 1, 1);\n    const rot = new Quaternion();\n    mat.decompose(pos, rot, scale);\n    entity.transform.position = pos;\n    entity.transform.rotationQuaternion = rot;\n    entity.transform.scale = scale;\n  } else {\n    for (const key in TARGET_PATH_MAP) {\n      if (gltfNode.hasOwnProperty(key)) {\n        const mapKey = TARGET_PATH_MAP[key];\n        if (mapKey === \"weights\") {\n          entity[mapKey] = gltfNode[key];\n        } else {\n          const arr = gltfNode[key];\n          const len = arr.length;\n          const obj = entity[mapKey];\n          if (len === 2) {\n            obj.setValue(arr[0], arr[1]);\n          } else if (len === 3) {\n            obj.setValue(arr[0], arr[1], arr[2]);\n          } else if (len === 4) {\n            obj.setValue(arr[0], arr[1], arr[2], arr[3]);\n          }\n          entity[mapKey] = obj;\n        }\n      }\n    }\n  }\n  if (gltfNode.camera !== void 0) {\n    const cameraOptions = resources.gltf.cameras[gltfNode.camera];\n    const camera = entity.addComponent(Camera);\n    if (cameraOptions.type === \"orthographic\") {\n      camera.isOrthographic = true;\n      let {ymag, xmag, zfar, znear} = cameraOptions.orthographic;\n      if (znear !== void 0) {\n        camera.nearClipPlane = znear;\n      }\n      if (zfar !== void 0) {\n        camera.farClipPlane = zfar;\n      }\n      if (ymag && xmag) {\n        camera.orthographicSize = Math.max(ymag, xmag) / 2;\n      }\n      if (ymag !== void 0 && xmag) {\n        camera.orthographicSize = xmag / 2;\n      }\n      if (xmag !== void 0 && ymag) {\n        camera.orthographicSize = ymag / 2;\n      }\n    } else {\n      const {aspectRatio, yfov, zfar, znear} = cameraOptions.perspective;\n      if (yfov !== void 0) {\n        camera.fieldOfView = yfov;\n      }\n      if (zfar !== void 0) {\n        camera.farClipPlane = zfar;\n      }\n      if (znear !== void 0) {\n        camera.nearClipPlane = znear;\n      }\n    }\n  }\n  if (gltfNode.extensions) {\n    if (KHR_lights && gltfNode.extensions.KHR_lights) {\n      const lightIdx = gltfNode.extensions.KHR_lights.light;\n      if (lightIdx !== void 0) {\n        const light = getItemByIdx(\"lights\", lightIdx, resources);\n        if (light) {\n          const lightCon = entity.addComponent(light.ability);\n          Object.assign(lightCon, light.props);\n        }\n      }\n    }\n  }\n  return Promise.resolve(entity);\n}\nfunction parseScene(gltfScene, resources) {\n  const sceneNodes = [];\n  for (let i = 0; i < gltfScene.nodes.length; i++) {\n    const node = getItemByIdx(\"nodes\", gltfScene.nodes[i], resources);\n    sceneNodes.push(node);\n  }\n  if (gltfScene.extensions) {\n    if (KHR_lights && gltfScene.extensions.KHR_lights) {\n      const lightIdx = gltfScene.extensions.KHR_lights.light;\n      if (lightIdx !== void 0) {\n        const light = getItemByIdx(\"lights\", lightIdx, resources);\n        if (light)\n          sceneNodes[0].addComponent(light.ability, light.props);\n      }\n    }\n  }\n  return Promise.resolve({\n    nodes: sceneNodes\n  });\n}\nfunction getItemByIdx(name, idx, resources, inverse = true) {\n  const {asset} = resources;\n  const itemIdx = inverse ? asset[name].length - idx - 1 : idx;\n  return asset[name][itemIdx];\n}\nfunction buildSceneGraph(resources) {\n  const {asset, gltf} = resources;\n  const gltfNodes = gltf.nodes || [];\n  const gltfMeshes = gltf.meshes;\n  asset.defaultScene = getItemByIdx(\"scenes\", gltf.scene ?? 0, resources);\n  for (let i = gltfNodes.length - 1; i >= 0; i--) {\n    const gltfNode = gltfNodes[i];\n    const node = getItemByIdx(\"nodes\", i, resources);\n    if (gltfNode.hasOwnProperty(\"children\")) {\n      const children = gltfNode.children || [];\n      for (let j = children.length - 1; j >= 0; j--) {\n        const childNode = getItemByIdx(\"nodes\", children[j], resources);\n        node.addChild(childNode);\n      }\n    }\n    if (gltfNode.hasOwnProperty(\"mesh\")) {\n      const meshIndex = gltfNode.mesh;\n      node.meshIndex = meshIndex;\n      const gltfMeshPrimitives = gltfMeshes[meshIndex].primitives;\n      const mesh = getItemByIdx(\"meshes\", meshIndex, resources);\n      let renderer;\n      if (gltfNode.hasOwnProperty(\"skin\") || mesh.hasOwnProperty(\"weights\")) {\n        const skin = getItemByIdx(\"skins\", gltfNode.skin, resources);\n        const weights = mesh.weights;\n        const skinRenderer = node.addComponent(SkinnedMeshRenderer);\n        skinRenderer.mesh = mesh;\n        skinRenderer.skin = skin;\n        skinRenderer.setWeights(weights);\n        renderer = skinRenderer;\n      } else {\n        renderer = node.addComponent(MeshRenderer);\n        renderer.mesh = mesh;\n      }\n      for (let j = 0, m = gltfMeshPrimitives.length; j < m; j++) {\n        const materialIndex = gltfMeshPrimitives[j].material;\n        mesh.primitives[j].materialIndex = materialIndex;\n        const material = materialIndex !== void 0 ? getItemByIdx(\"materials\", materialIndex, resources) : getDefaultMaterial(node.engine);\n        renderer.setSharedMaterial(j, material);\n      }\n    }\n  }\n  const nodes = asset.defaultScene.nodes;\n  if (nodes.length === 1) {\n    asset.defaultSceneRoot = nodes[0];\n  } else {\n    const rootNode = new Entity(resources.engine);\n    for (let i = 0; i < nodes.length; i++) {\n      rootNode.addChild(nodes[i]);\n    }\n    asset.defaultSceneRoot = rootNode;\n  }\n  const animator = asset.defaultSceneRoot.addComponent(Animation);\n  const animations = asset.animations;\n  if (animations) {\n    animations.forEach((clip) => {\n      animator.addAnimationClip(clip, clip.name);\n    });\n  }\n  return resources.asset;\n}\n\nfunction parseGLB(glb) {\n  const UINT32_LENGTH = 4;\n  const GLB_HEADER_MAGIC = 1179937895;\n  const GLB_HEADER_LENGTH = 12;\n  const GLB_CHUNK_TYPES = {JSON: 1313821514, BIN: 5130562};\n  const dataView = new DataView(glb);\n  const header = {\n    magic: dataView.getUint32(0, true),\n    version: dataView.getUint32(UINT32_LENGTH, true),\n    length: dataView.getUint32(2 * UINT32_LENGTH, true)\n  };\n  if (header.magic !== GLB_HEADER_MAGIC) {\n    console.error(\"Invalid glb magic number. Expected 0x46546C67, found 0x\" + header.magic.toString(16));\n    return null;\n  }\n  let chunkLength = dataView.getUint32(GLB_HEADER_LENGTH, true);\n  let chunkType = dataView.getUint32(GLB_HEADER_LENGTH + UINT32_LENGTH, true);\n  if (chunkType !== GLB_CHUNK_TYPES.JSON) {\n    console.error(\"Invalid glb chunk type. Expected 0x004E4942, found 0x\" + chunkType.toString(16));\n    return null;\n  }\n  const glTFData = new Uint8Array(glb, GLB_HEADER_LENGTH + 2 * UINT32_LENGTH, chunkLength);\n  const gltf = JSON.parse(decodeText(glTFData));\n  const buffers = [];\n  let byteOffset = GLB_HEADER_LENGTH + 2 * UINT32_LENGTH + chunkLength;\n  while (byteOffset < header.length) {\n    chunkLength = dataView.getUint32(byteOffset, true);\n    chunkType = dataView.getUint32(byteOffset + UINT32_LENGTH, true);\n    if (chunkType !== GLB_CHUNK_TYPES.BIN) {\n      console.error(\"Invalid glb chunk type. Expected 0x004E4942, found 0x\" + chunkType.toString(16));\n      return null;\n    }\n    const currentOffset = byteOffset + 2 * UINT32_LENGTH;\n    const buffer = glb.slice(currentOffset, currentOffset + chunkLength);\n    buffers.push(buffer);\n    byteOffset += chunkLength + 2 * UINT32_LENGTH;\n  }\n  return {\n    gltf,\n    buffers\n  };\n}\n\nvar __defProp$1 = Object.defineProperty;\nvar __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor;\nvar __decorate$1 = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$1(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result)\n    __defProp$1(target, key, result);\n  return result;\n};\nlet GLTFLoader = class extends Loader {\n  constructor() {\n    super(...arguments);\n    this.requestGLTF = (item, resourceManager) => {\n      return this.request(item.url, {\n        ...item,\n        type: \"json\"\n      }).then((res) => this._loadGLTFResources(item, res, resourceManager));\n    };\n    this.requestGLB = (item, resourceManager) => {\n      return this.request(item.url, {\n        ...item,\n        type: \"arraybuffer\"\n      }).then(parseGLB).then((res) => {\n        return {...res, baseUrl: item.url, resourceManager};\n      }).then(this._loadImages);\n    };\n    this._loadImages = ({\n      gltf,\n      buffers,\n      baseUrl,\n      resourceManager\n    }) => {\n      if (!gltf.images) {\n        return Promise.resolve({gltf, buffers});\n      }\n      let texturePromises = void 0;\n      const rhi = resourceManager.engine._hardwareRenderer;\n      if (gltf.astc && rhi.canIUse(GLCapabilityType.pvrtc)) {\n        texturePromises = this._loadCompressedTexture(resourceManager, gltf.pvrtc, baseUrl);\n      } else if (gltf.pvrtc && rhi.canIUse(GLCapabilityType.astc)) {\n        texturePromises = this._loadCompressedTexture(resourceManager, gltf.astc, baseUrl);\n      } else if (gltf.etc && rhi.canIUse(GLCapabilityType.etc)) {\n        texturePromises = this._loadCompressedTexture(resourceManager, gltf.etc, baseUrl);\n      } else {\n        texturePromises = this._loadBasicImages(resourceManager, gltf.images, baseUrl, buffers, gltf);\n      }\n      return texturePromises.then((textures) => {\n        return {gltf, buffers, textures};\n      });\n    };\n    this._loadBasicImages = (resourceManager, images, baseUrl, buffers, gltf) => {\n      return Promise.all(images.map(({uri, bufferView: bufferViewIndex, mimeType}) => {\n        if (uri) {\n          return resourceManager.load({url: parseRelativeUrl(baseUrl, uri), type: AssetType.Texture2D});\n        } else {\n          const bufferView = gltf.bufferViews[bufferViewIndex];\n          const bufferData = getBufferData(bufferView, buffers);\n          return loadImageBuffer(bufferData, mimeType).then((image) => {\n            const tex = new Texture2D(resourceManager.engine, image.width, image.height);\n            tex.setImageSource(image);\n            tex.generateMipmaps();\n            return tex;\n          });\n        }\n      }));\n    };\n    this._loadCompressedTexture = (resourceManager, images, baseUrl) => {\n      const promises = images.map((item) => {\n        return resourceManager.load({url: parseRelativeUrl(baseUrl, item.uri), type: AssetType.KTX});\n      });\n      return Promise.all(promises);\n    };\n  }\n  load(item, resourceManager) {\n    return new AssetPromise((resolve, reject) => {\n      const requestGLTFResource = this.isGLB(item.url) ? this.requestGLB : this.requestGLTF;\n      requestGLTFResource(item, resourceManager).then((res) => {\n        parseGLTF(res, resourceManager.engine).then((gltf) => {\n          resolve(gltf);\n        });\n      }).catch((e) => {\n        console.error(e);\n        reject(\"Error loading glTF JSON from \" + item.url);\n      });\n    });\n  }\n  isGLB(url) {\n    return url.substring(url.lastIndexOf(\".\") + 1) === \"glb\";\n  }\n  _loadGLTFResources(item, gltf, resourceManager) {\n    return this._loadBuffers(item.url, gltf, resourceManager).then(this._loadImages);\n  }\n  _loadBuffers(baseUrl, gltf, resourceManager) {\n    if (gltf.buffers) {\n      return Promise.all(gltf.buffers.map((item) => {\n        if (item instanceof ArrayBuffer) {\n          return Promise.resolve(item);\n        }\n        return resourceManager.load({\n          url: parseRelativeUrl(baseUrl, item.uri),\n          type: AssetType.Buffer\n        });\n      })).then((buffers) => {\n        return {buffers, gltf, baseUrl, resourceManager};\n      });\n    }\n    return Promise.resolve({baseUrl, gltf, resourceManager});\n  }\n};\nGLTFLoader = __decorate$1([\n  resourceLoader(AssetType.Perfab, [\"gltf\", \"glb\"])\n], GLTFLoader);\n\nvar __defProp$2 = Object.defineProperty;\nvar __getOwnPropDesc$2 = Object.getOwnPropertyDescriptor;\nvar __decorate$2 = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$2(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result)\n    __defProp$2(target, key, result);\n  return result;\n};\nlet JSONLoader = class extends Loader {\n  load(item) {\n    return this.request(item.url, {\n      ...item,\n      type: \"json\"\n    });\n  }\n};\nJSONLoader = __decorate$2([\n  resourceLoader(AssetType.JSON, [\"json\"], false)\n], JSONLoader);\n\nconst HEADER_LEN = 12 + 13 * 4;\nconst COMPRESSED_2D = 0;\nfunction getMipmaps(ktxContainer, loadMipmaps) {\n  const mipmaps = [];\n  var dataOffset = HEADER_LEN + ktxContainer.bytesOfKeyValueData;\n  var width = ktxContainer.pixelWidth;\n  var height = ktxContainer.pixelHeight;\n  var mipmapCount = loadMipmaps ? ktxContainer.numberOfMipmapLevels : 1;\n  for (var level = 0; level < mipmapCount; level++) {\n    var imageSize = new Int32Array(ktxContainer.buffer, dataOffset, 1)[0];\n    dataOffset += 4;\n    for (var face = 0; face < ktxContainer.numberOfFaces; face++) {\n      var byteArray = new Uint8Array(ktxContainer.buffer, dataOffset, imageSize);\n      mipmaps.push({data: byteArray, width, height});\n      dataOffset += imageSize;\n      dataOffset += 3 - (imageSize + 3) % 4;\n    }\n    width = Math.max(1, width * 0.5);\n    height = Math.max(1, height * 0.5);\n  }\n  return mipmaps;\n}\nfunction isValid(data) {\n  if (data.byteLength >= 12) {\n    const identifier = new Uint8Array(data, 0, 12);\n    if (identifier[0] === 171 && identifier[1] === 75 && identifier[2] === 84 && identifier[3] === 88 && identifier[4] === 32 && identifier[5] === 49 && identifier[6] === 49 && identifier[7] === 187 && identifier[8] === 13 && identifier[9] === 10 && identifier[10] === 26 && identifier[11] === 10) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction getEngineFormat(internalFormat) {\n  switch (internalFormat) {\n    case GLCompressedTextureInternalFormat.RGB_S3TC_DXT1_EXT:\n      return TextureFormat.DXT1;\n    case GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT:\n      return TextureFormat.DXT5;\n    case GLCompressedTextureInternalFormat.RGB_ETC1_WEBGL:\n      return TextureFormat.ETC1_RGB;\n    case GLCompressedTextureInternalFormat.RGB8_ETC2:\n      return TextureFormat.ETC2_RGB;\n    case GLCompressedTextureInternalFormat.RGB8_PUNCHTHROUGH_ALPHA1_ETC2:\n      return TextureFormat.ETC2_RGBA5;\n    case GLCompressedTextureInternalFormat.RGBA8_ETC2_EAC:\n      return TextureFormat.ETC2_RGBA8;\n    case GLCompressedTextureInternalFormat.RGB_PVRTC_2BPPV1_IMG:\n      return TextureFormat.PVRTC_RGB2;\n    case GLCompressedTextureInternalFormat.RGBA_PVRTC_2BPPV1_IMG:\n      return TextureFormat.PVRTC_RGBA2;\n    case GLCompressedTextureInternalFormat.RGB_PVRTC_4BPPV1_IMG:\n      return TextureFormat.PVRTC_RGB4;\n    case GLCompressedTextureInternalFormat.RGBA_PVRTC_4BPPV1_IMG:\n      return TextureFormat.PVRTC_RGBA4;\n    case GLCompressedTextureInternalFormat.RGBA_ASTC_4X4_KHR:\n      return TextureFormat.ASTC_4x4;\n    case GLCompressedTextureInternalFormat.RGBA_ASTC_5X5_KHR:\n      return TextureFormat.ASTC_5x5;\n    case GLCompressedTextureInternalFormat.RGBA_ASTC_6X6_KHR:\n      return TextureFormat.ASTC_6x6;\n    case GLCompressedTextureInternalFormat.RGBA_ASTC_8X8_KHR:\n      return TextureFormat.ASTC_8x8;\n    case GLCompressedTextureInternalFormat.RGBA_ASTC_10X10_KHR:\n      return TextureFormat.ASTC_10x10;\n    case GLCompressedTextureInternalFormat.RGBA_ASTC_12X12_KHR:\n      return TextureFormat.ASTC_12x12;\n    default:\n      const formatName = GLCompressedTextureInternalFormat[internalFormat];\n      throw new Error(`this format is not supported in Oasis Engine: ${formatName}`);\n  }\n}\nconst khronosTextureContainerParser = {\n  parse(buffer, facesExpected, withMipmaps, mapEngineFormat = false) {\n    if (!isValid(buffer)) {\n      throw new Error(\"khronosTextureContainerParser: invalid KTX file, texture missing KTX identifier\");\n    }\n    const dataSize = Uint32Array.BYTES_PER_ELEMENT;\n    const headerDataView = new DataView(buffer, 12, 13 * dataSize);\n    const endianness = headerDataView.getUint32(0, true);\n    const littleEndian = endianness === 67305985;\n    const parsedResult = {\n      buffer,\n      glType: headerDataView.getUint32(1 * dataSize, littleEndian),\n      glTypeSize: headerDataView.getUint32(2 * dataSize, littleEndian),\n      glFormat: headerDataView.getUint32(3 * dataSize, littleEndian),\n      glInternalFormat: headerDataView.getUint32(4 * dataSize, littleEndian),\n      glBaseInternalFormat: headerDataView.getUint32(5 * dataSize, littleEndian),\n      pixelWidth: headerDataView.getUint32(6 * dataSize, littleEndian),\n      pixelHeight: headerDataView.getUint32(7 * dataSize, littleEndian),\n      pixelDepth: headerDataView.getUint32(8 * dataSize, littleEndian),\n      numberOfArrayElements: headerDataView.getUint32(9 * dataSize, littleEndian),\n      numberOfFaces: headerDataView.getUint32(10 * dataSize, littleEndian),\n      numberOfMipmapLevels: headerDataView.getUint32(11 * dataSize, littleEndian),\n      bytesOfKeyValueData: headerDataView.getUint32(12 * dataSize, littleEndian),\n      loadType: COMPRESSED_2D\n    };\n    if (parsedResult.glType !== 0) {\n      throw new Error(\"only compressed formats currently supported\");\n    } else {\n      parsedResult.numberOfMipmapLevels = Math.max(1, parsedResult.numberOfMipmapLevels);\n    }\n    if (parsedResult.pixelHeight === 0 || parsedResult.pixelDepth !== 0) {\n      throw new Error(\"only 2D textures currently supported\");\n    }\n    if (parsedResult.numberOfArrayElements !== 0) {\n      throw new Error(\"texture arrays not currently supported\");\n    }\n    if (parsedResult.numberOfFaces !== facesExpected) {\n      throw new Error(\"number of faces expected\" + facesExpected + \", but found \" + parsedResult.numberOfFaces);\n    }\n    if (withMipmaps) {\n      parsedResult.mipmaps = getMipmaps(parsedResult, true);\n    }\n    if (mapEngineFormat) {\n      parsedResult.engineFormat = getEngineFormat(parsedResult.glInternalFormat);\n    }\n    return parsedResult;\n  }\n};\n\nfunction parseSingleKTX(data) {\n  const ktx = khronosTextureContainerParser.parse(data, 1, true, true);\n  return {\n    mipmaps: ktx.mipmaps,\n    engineFormat: ktx.engineFormat,\n    internalFormat: ktx.glInternalFormat,\n    width: ktx.pixelWidth,\n    height: ktx.pixelHeight\n  };\n}\nfunction parseCubeKTX(dataArray) {\n  const mipmapsFaces = [];\n  let internalFormat;\n  let engineFormat;\n  let width;\n  let height;\n  for (let i = 0; i < dataArray.length; i++) {\n    const ktx = khronosTextureContainerParser.parse(dataArray[i], 1, true, true);\n    mipmapsFaces.push(ktx.mipmaps);\n    if (i === 0) {\n      width = ktx.pixelWidth;\n      height = ktx.pixelHeight;\n      internalFormat = ktx.glInternalFormat;\n      engineFormat = ktx.engineFormat;\n    }\n  }\n  return {\n    mipmapsFaces,\n    engineFormat,\n    internalFormat,\n    width,\n    height\n  };\n}\n\nvar __defProp$3 = Object.defineProperty;\nvar __getOwnPropDesc$3 = Object.getOwnPropertyDescriptor;\nvar __decorate$3 = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$3(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result)\n    __defProp$3(target, key, result);\n  return result;\n};\nlet KTXCubeLoader = class extends Loader {\n  load(item, resourceManager) {\n    return new AssetPromise((resolve, reject) => {\n      Promise.all(item.urls.map((url) => this.request(url, {\n        ...item,\n        type: \"arraybuffer\"\n      }))).then((data) => {\n        const parsedData = parseCubeKTX(data);\n        const {width, mipmapsFaces, engineFormat} = parsedData;\n        const mipmap = mipmapsFaces[0].length > 1;\n        const texture = new TextureCubeMap(resourceManager.engine, width, engineFormat, mipmap);\n        for (let face = 0; face < 6; face++) {\n          const length = mipmapsFaces[face].length;\n          for (let miplevel = 0; miplevel < length; miplevel++) {\n            const {data: data2, width: width2, height} = mipmapsFaces[face][miplevel];\n            texture.setPixelBuffer(TextureCubeFace.PositiveX + face, data2, miplevel, 0, 0, width2, height);\n          }\n        }\n        resolve(texture);\n      }).catch((e) => {\n        reject(e);\n      });\n    });\n  }\n};\nKTXCubeLoader = __decorate$3([\n  resourceLoader(AssetType.KTXCube, [])\n], KTXCubeLoader);\n\nvar __defProp$4 = Object.defineProperty;\nvar __getOwnPropDesc$4 = Object.getOwnPropertyDescriptor;\nvar __decorate$4 = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$4(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result)\n    __defProp$4(target, key, result);\n  return result;\n};\nlet KTXLoader = class extends Loader {\n  load(item, resourceManager) {\n    return new AssetPromise((resolve, reject) => {\n      this.request(item.url, {\n        ...item,\n        type: \"arraybuffer\"\n      }).then((bin) => {\n        const parsedData = parseSingleKTX(bin);\n        const {width, height, mipmaps, engineFormat} = parsedData;\n        const mipmap = mipmaps.length > 1;\n        const texture = new Texture2D(resourceManager.engine, width, height, engineFormat, mipmap);\n        for (let miplevel = 0; miplevel < mipmaps.length; miplevel++) {\n          const {width: width2, height: height2, data} = mipmaps[miplevel];\n          texture.setPixelBuffer(data, miplevel, 0, 0, width2, height2);\n        }\n        resolve(texture);\n      }).catch((e) => {\n        reject(e);\n      });\n    });\n  }\n};\nKTXLoader = __decorate$4([\n  resourceLoader(AssetType.KTX, [\"ktx\"])\n], KTXLoader);\n\nvar __defProp$5 = Object.defineProperty;\nvar __getOwnPropDesc$5 = Object.getOwnPropertyDescriptor;\nvar __decorate$5 = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$5(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result)\n    __defProp$5(target, key, result);\n  return result;\n};\nlet Texture2DLoader = class extends Loader {\n  load(item, resourceManager) {\n    return new AssetPromise((resolve, reject) => {\n      this.request(item.url, {\n        ...item,\n        type: \"image\"\n      }).then((image) => {\n        const texture = new Texture2D(resourceManager.engine, image.width, image.height);\n        if (!texture._glTexture)\n          return;\n        texture.setImageSource(image);\n        texture.generateMipmaps();\n        if (item.url.indexOf(\"data:\") !== 0) {\n          const splitPath = item.url.split(\"/\");\n          texture.name = splitPath[splitPath.length - 1];\n        }\n        resolve(texture);\n      }).catch((e) => {\n        reject(e);\n      });\n    });\n  }\n};\nTexture2DLoader = __decorate$5([\n  resourceLoader(AssetType.Texture2D, [\"png\", \"jpg\", \"webp\", \"jpeg\"])\n], Texture2DLoader);\n\nvar __defProp$6 = Object.defineProperty;\nvar __getOwnPropDesc$6 = Object.getOwnPropertyDescriptor;\nvar __decorate$6 = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$6(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result)\n    __defProp$6(target, key, result);\n  return result;\n};\nlet TextureCubeLoader = class extends Loader {\n  load(item, resourceManager) {\n    return new AssetPromise((resolve, reject) => {\n      Promise.all(item.urls.map((url) => this.request(url, {\n        ...item,\n        type: \"image\"\n      }))).then((images) => {\n        const {width, height} = images[0];\n        if (width !== height) {\n          console.error(\"The cube texture must have the same width and height\");\n          return;\n        }\n        const tex = new TextureCubeMap(resourceManager.engine, width);\n        if (!tex._glTexture)\n          return;\n        for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\n          tex.setImageSource(TextureCubeFace.PositiveX + faceIndex, images[faceIndex], 0);\n        }\n        tex.generateMipmaps();\n        resolve(tex);\n      }).catch((e) => {\n        reject(e);\n      });\n    });\n  }\n};\nTextureCubeLoader = __decorate$6([\n  resourceLoader(AssetType.TextureCube, [\"\"])\n], TextureCubeLoader);\n\nclass GLTFModel extends Component {\n  constructor(entity) {\n    super(entity);\n    this._hasBuiltNode = false;\n  }\n  get asset() {\n    return this._asset;\n  }\n  set asset(value) {\n    if (value && value.defaultSceneRoot === this.GLTFNode) {\n      return;\n    }\n    if (!this._hasBuiltNode) {\n      this.GLTFNode.clearChildren();\n      if (value !== null) {\n        if (this.GLTFNode) {\n          this.GLTFNode.destroy();\n        }\n        this.GLTFNode = value.defaultSceneRoot.clone();\n        this._animator = this.GLTFNode.getComponent(Animation);\n        this.entity.addChild(this.GLTFNode);\n      }\n    }\n    this._asset = value;\n  }\n  get animator() {\n    return this._animator;\n  }\n  get autoPlay() {\n    return this._autoPlay;\n  }\n  set autoPlay(value) {\n    if (this._animator) {\n      if (value) {\n        this._animator.playAnimationClip(value, {\n          wrapMode: this._loop\n        });\n      } else {\n        this._animator.stop(false);\n      }\n    }\n    this._autoPlay = value;\n  }\n  get loop() {\n    return this._loop;\n  }\n  set loop(value) {\n    if (this._animator && this.autoPlay) {\n      this._animator.playAnimationClip(this._autoPlay, {\n        wrapMode: value\n      });\n    }\n    this._loop = value;\n  }\n  init(props) {\n    const {asset = null, autoPlay, loop, isClone} = props;\n    if (isClone) {\n      const rootName = props.gltfRootName;\n      if (rootName) {\n        this.GLTFNode = this.entity.findByName(rootName);\n      }\n    }\n    if (!this.GLTFNode) {\n      const rootName = `GLTF-${Date.now()}`;\n      props.gltfRootName = rootName;\n      this.GLTFNode = this.entity.createChild(rootName);\n      this._hasBuiltNode = false;\n    } else {\n      this._hasBuiltNode = true;\n    }\n    this.asset = asset;\n    this.loop = loop;\n    this.autoPlay = autoPlay;\n    this.addEventListener(\"enabled\", () => {\n      this.GLTFNode.isActive = true;\n    });\n    this.addEventListener(\"disabled\", () => {\n      this.GLTFNode.isActive = false;\n    });\n  }\n}\n\nclass PluginManager {\n  constructor() {\n    this.registeredPlugins = new Set();\n    this.plugins = [];\n  }\n  register(plugin) {\n    this.registeredPlugins.add(plugin);\n  }\n  boot(oasis) {\n    for (let plugin of this.registeredPlugins.values()) {\n      if (typeof plugin === \"function\") {\n        plugin = plugin(oasis);\n      }\n      Object.assign(plugin, {\n        _enabled: true,\n        get enabled() {\n          return this._enabled;\n        },\n        set enabled(v) {\n          if (v === this._enabled) {\n            return;\n          }\n          this._enabled = v;\n          if (v && this.onEnabled) {\n            this.onEnabled();\n          } else if (this.onDisabled) {\n            this.onDisabled();\n          }\n        }\n      });\n      this.plugins.push(plugin);\n    }\n  }\n  reset() {\n    this.registeredPlugins.clear();\n    this.plugins = [];\n  }\n  nodeAdded(entity) {\n    this.delegateMethod(\"nodeAdded\", entity);\n  }\n  delegateMethod(name, ...args) {\n    this.plugins.forEach((plugin) => {\n      if (plugin[name]) {\n        return plugin[name](...args);\n      }\n    });\n  }\n}\nfunction pluginHook(options) {\n  return function(target, propertyName, descriptor) {\n    const method = descriptor.value;\n    descriptor.value = function(...args) {\n      options.before && this.oasis.pluginManager.delegateMethod(options.before, ...args);\n      return Promise.resolve(method.apply(this, arguments)).then((returnObj) => {\n        options.after && this.oasis.pluginManager.delegateMethod(options.after, returnObj);\n        return returnObj;\n      });\n    };\n  };\n}\n\nfunction switchElementsIndex(elements, currentIndex, targetIndex) {\n  if (currentIndex === targetIndex || targetIndex === null || targetIndex === void 0) {\n    return;\n  }\n  [elements[currentIndex], elements[targetIndex]] = [elements[targetIndex], elements[currentIndex]];\n}\nfunction isAsset(config) {\n  return config && config.type === \"asset\";\n}\nfunction getAllGetters(obj) {\n  const result = [];\n  const prototype = Object.getPrototypeOf(obj);\n  const prototype_property_descriptors = Object.getOwnPropertyDescriptors(prototype);\n  for (const [property, descriptor] of Object.entries(prototype_property_descriptors)) {\n    if (typeof descriptor.get === \"function\") {\n      result.push(property);\n    }\n  }\n  return result;\n}\n\nclass SchemaResource {\n  constructor(resourceManager, _resource) {\n    this.resourceManager = resourceManager;\n    this._resource = _resource;\n    this._meta = {};\n    this._attachedResources = [];\n    this.setMeta();\n  }\n  get resource() {\n    return this._resource;\n  }\n  get meta() {\n    return this._meta;\n  }\n  get attachedResources() {\n    return this._attachedResources;\n  }\n  setMeta() {\n  }\n  loadWithAttachedResources(resourceLoader, assetConfig, oasis) {\n    return new Promise((resolve, reject) => {\n      this.load(resourceLoader, assetConfig, oasis).then(() => {\n        resolve({\n          resources: [this],\n          structure: {\n            index: 0,\n            props: {}\n          }\n        });\n      }).catch((e) => {\n        reject(e);\n      });\n    });\n  }\n  getProps() {\n    return {};\n  }\n  bind() {\n  }\n  attach() {\n  }\n  update(key, value) {\n    if (isAsset(value)) {\n      const resource = this.resourceManager.get(value.id);\n      if (resource) {\n        this._resource[key] = resource.resource;\n      } else {\n        Logger.warn(`SchemaResource: ${this.meta.name} can't find asset, which id is: ${value.id}`);\n      }\n    } else {\n      this._resource[key] = value;\n    }\n  }\n  updateMeta(key, value) {\n    this._meta[key] = value;\n  }\n  onDestroy() {\n  }\n}\n\nclass TextureResource extends SchemaResource {\n  load(resourceManager, assetConfig, oasis) {\n    return new Promise((resolve, reject) => {\n      let url;\n      let assetType = AssetType.Texture2D;\n      if (this.resourceManager.useCompressedTexture && assetConfig?.props?.compression?.compressions.length) {\n        const rhi = oasis.engine._hardwareRenderer;\n        const compressions = assetConfig.props.compression.compressions;\n        for (let i = 0; i < compressions.length; i++) {\n          const compression = compressions[i];\n          if (compression.container === \"ktx\" && rhi.canIUse(GLCapabilityType[compression.type])) {\n            url = compression.url;\n            assetType = AssetType.KTX;\n            break;\n          }\n        }\n      }\n      url = url ?? assetConfig.url;\n      resourceManager.load({url, type: assetType}).then((res) => {\n        this._resource = res;\n        resolve(this);\n      }).catch((e) => {\n        reject(e);\n      });\n    });\n  }\n  setMeta() {\n    if (this.resource) {\n      this._meta.name = this.resource.name;\n      if (this.resource.image) {\n        this._meta.url = this.resource.image.src;\n      }\n    }\n  }\n}\n\nclass PBRMaterialResource extends SchemaResource {\n  load(resourceManager, assetConfig) {\n    return new Promise((resolve) => {\n      const assetObj = new PBRMaterial(resourceManager.engine, assetConfig.name);\n      this.configProps = assetConfig.props;\n      for (let k in this.configProps) {\n        if (!isAsset(this.configProps[k])) {\n          assetObj[k] = this.configProps[k];\n        }\n      }\n      this._resource = assetObj;\n      this.setMeta();\n      resolve(this);\n    });\n  }\n  loadWithAttachedResources(resourceManager, assetConfig) {\n    return new Promise((resolve, reject) => {\n      let loadPromise;\n      if (assetConfig.resource instanceof PBRMaterial) {\n        loadPromise = new Promise((resolve2) => {\n          this._resource = assetConfig.resource;\n          this.setMeta();\n          resolve2(this);\n        });\n      } else if (assetConfig.props) {\n        loadPromise = this.load(resourceManager, assetConfig);\n      } else {\n        reject(\"Load PBRMaterial Error\");\n      }\n      if (loadPromise) {\n        loadPromise.then(() => {\n          const result = {\n            resources: [this],\n            structure: {\n              index: 0,\n              props: {}\n            }\n          };\n          const material = this._resource;\n          getAllGetters(this._resource).forEach((attr) => {\n            if (!(material[attr] instanceof Texture))\n              return;\n            const textureResource = new TextureResource(this.resourceManager, material[attr]);\n            this.attachedResources.push(textureResource);\n            result.resources.push(textureResource);\n            result.structure.props[attr] = {\n              index: result.resources.length - 1\n            };\n          });\n          resolve(result);\n        });\n      }\n    });\n  }\n  setMeta() {\n    if (this.resource) {\n      this.meta.name = this.resource.name;\n    }\n  }\n  getProps() {\n    const result = {};\n    const props = getAllGetters(this.resource);\n    props.forEach((prop) => result[prop] = this.resource[prop]);\n    return result;\n  }\n  bind() {\n    const resource = this._resource;\n    Object.keys(this.configProps).forEach((attr) => {\n      const value = this.configProps[attr];\n      if (isAsset(value)) {\n        const textureResource = this.resourceManager.get(value.id);\n        if (textureResource && textureResource instanceof TextureResource) {\n          resource[attr] = textureResource.resource;\n          this._attachedResources.push(textureResource);\n        } else {\n          resource[attr] = null;\n          Logger.warn(`PBRMaterialResource: ${this.meta.name} can't find asset \"${attr}\", which id is: ${value.id}`);\n        }\n      } else {\n        if (attr === \"side\") {\n          return;\n        }\n        resource[attr] = value;\n      }\n    });\n  }\n}\n\nclass GLTFResource$1 extends SchemaResource {\n  load(resourceManager, assetConfig, oasis) {\n    if (!!assetConfig.props?.compression) {\n      glTFDracoMeshCompression.init();\n    }\n    return resourceManager.load({url: assetConfig.url, type: AssetType.Perfab}).then((res) => {\n      const gltf = res;\n      if (assetConfig.props) {\n        gltf.newMaterial = assetConfig.props.newMaterial;\n      }\n      this._resource = gltf;\n    });\n  }\n  loadWithAttachedResources(resourceManager, assetConfig, oasis) {\n    return new Promise((resolve) => {\n      this.load(resourceManager, assetConfig, oasis).then(() => {\n        const gltf = this.resource;\n        const {materials} = gltf;\n        const loadPromises = [];\n        const result = {\n          resources: [this],\n          structure: {\n            index: 0,\n            props: {\n              newMaterial: []\n            }\n          }\n        };\n        for (let i = 0; i < materials.length; i++) {\n          const material = materials[i];\n          const materialResource = new PBRMaterialResource(this.resourceManager);\n          this._attachedResources.push(materialResource);\n          loadPromises.push(materialResource.loadWithAttachedResources(resourceManager, {\n            type: \"PBRMaterial\",\n            name: material.name,\n            resource: material\n          }));\n        }\n        Promise.all(loadPromises).then((res) => {\n          const newMaterial = result.structure.props.newMaterial;\n          res.forEach((mat) => {\n            const matStructure = mat.structure;\n            const matResource = mat.resources[matStructure.index];\n            result.resources.push(matResource);\n            matStructure.index = result.resources.length - 1;\n            for (const key in matStructure.props) {\n              if (matStructure.props.hasOwnProperty(key)) {\n                const textureStructure = matStructure.props[key];\n                const textureResource = mat.resources[textureStructure.index];\n                result.resources.push(textureResource);\n                textureStructure.index = result.resources.length - 1;\n              }\n            }\n            newMaterial.push(matStructure);\n          });\n          resolve(result);\n        });\n      });\n    });\n  }\n  setMeta(assetConfig) {\n    if (assetConfig) {\n      this.meta.name = assetConfig.name;\n    }\n  }\n  bind() {\n    const resource = this._resource;\n    this.bindMaterials(resource.newMaterial);\n  }\n  update(key, value) {\n    if (key === \"newMaterial\") {\n      this.bindMaterials(value);\n    } else {\n      this._resource[key] = value;\n    }\n  }\n  bindMaterials(materials) {\n    if (!materials || !materials.length) {\n      return;\n    }\n    const gltf = this._resource;\n    const meshes = gltf.meshes;\n    for (let i = 0; i < materials.length; i++) {\n      const mtlResource = this.resourceManager.get(materials[i].id);\n      if (mtlResource) {\n        this._attachedResources.push(mtlResource);\n        gltf.materials[i] = mtlResource.resource;\n      } else {\n        Logger.warn(`GLTFResource: ${this.meta.name} can't find asset \"material\", which id is: ${materials[i].id}`);\n      }\n    }\n    for (let j = 0; j < meshes.length; j++) {\n      const node = this.getNodeByMeshIndex(gltf.nodes, meshes.length - 1 - j);\n      if (node) {\n        for (let k = 0; k < meshes[j].primitives.length; k++) {\n          const primitive = meshes[j].primitives[k];\n          const meshRenderer = node.getComponent(MeshRenderer);\n          const material = gltf.materials[gltf.materials.length - 1 - primitive.materialIndex];\n          if (meshRenderer && material && material instanceof Material) {\n            meshRenderer.setSharedMaterial(k, material);\n          }\n        }\n      }\n    }\n  }\n  getNodeByMeshIndex(nodes, index) {\n    for (let i = 0; i <= nodes.length; i++) {\n      const node = nodes[i];\n      if (node.meshIndex === index) {\n        return node;\n      }\n    }\n    return null;\n  }\n}\n\nclass ShaderMaterialResource extends SchemaResource {\n  loadShaderDefine(oasis) {\n    return new Promise((resolve) => {\n      const name = this.scripts[0].name;\n      if (this.resourceManager.isLocal) {\n        resolve(oasis.options?.scripts[name] ?? {});\n      } else {\n        const oldScriptDom = document.getElementById(name);\n        if (oldScriptDom) {\n          document.body.removeChild(oldScriptDom);\n        }\n        const scriptDom = document.createElement(\"script\");\n        scriptDom.crossOrigin = \"anonymous\";\n        scriptDom.onload = () => {\n          const scripts = window.o3Scripts;\n          resolve((scripts && scripts[name]) ?? {});\n        };\n        scriptDom.id = name;\n        scriptDom.src = this._meta.url;\n        document.body.appendChild(scriptDom);\n      }\n    }).then((shaderMaterialDefine) => {\n      const {\n        vertexShader = \"\",\n        fragmentShader = \"\",\n        states = {},\n        uniforms = {},\n        attributes = {}\n      } = shaderMaterialDefine;\n      this._resource.uniforms = uniforms;\n      this._resource.attributes = attributes;\n      this._resource.vertexShader = vertexShader;\n      this._resource.fragmentShader = fragmentShader;\n      this._resource.renderStates = states;\n    });\n  }\n  createMaterial(engine) {\n    const material = new ShaderMaterial(engine, this.meta.name || \"shader_mtl\");\n    this._resource = material;\n  }\n  load(resourceLoader, assetConfig, oasis) {\n    this.setMeta(assetConfig);\n    this.scripts = assetConfig.props.scripts;\n    this.createMaterial(oasis.engine);\n    return this.loadShaderDefine(oasis).then(() => new Promise((resolve, reject) => {\n      try {\n        for (let k in assetConfig.props) {\n          this._resource[k] = assetConfig.props[k];\n        }\n        this._resource.updateTechnique();\n        resolve(this);\n      } catch {\n        reject(\"[shader material] createTechnique error\");\n      }\n    }));\n  }\n  setMeta(assetConfig) {\n    if (assetConfig) {\n      this._meta.name = assetConfig.name;\n      this._meta.url = assetConfig.url;\n      this._meta.source = assetConfig.source;\n    }\n  }\n  updateMeta(key, value) {\n    super.updateMeta(key, value);\n    if (key === \"url\") {\n      this.loadShaderDefine().then(() => {\n        try {\n          this._resource.updateTechnique();\n        } catch {\n          console.error(\"[shader material] createTechnique error\");\n        }\n      });\n    }\n  }\n  update(key, value) {\n    this._resource[key] = value;\n    this._resource.updateTechnique();\n  }\n}\n\nconst scriptAbility = {};\nfunction script(name) {\n  return (target) => {\n    scriptAbility[name] = target;\n  };\n}\nclass ScriptResource extends SchemaResource {\n  constructor() {\n    super(...arguments);\n    this.isInit = false;\n  }\n  initScriptContext() {\n    if (this.isInit) {\n      return;\n    }\n    this.isInit = true;\n    window.__o3_script_context__ = {\n      o3: Parser._components[\"o3\"],\n      script: (name) => {\n        return (target) => {\n          scriptAbility[name] = target;\n        };\n      }\n    };\n  }\n  load(resourceLoader, assetConfig, oasis) {\n    this.initScriptContext();\n    return new Promise((resolve) => {\n      const config = assetConfig;\n      const scripts = config.props.scripts;\n      if (!this.resourceManager.isLocal) {\n        const scriptDom = document.createElement(\"script\");\n        scriptDom.crossOrigin = \"anonymous\";\n        this.setMeta(assetConfig);\n        scriptDom.onload = () => {\n          const o3Scripts = window.o3Scripts;\n          for (let i = 0; i < scripts.length; i++) {\n            const name = scripts[i].name;\n            this._resource = o3Scripts && o3Scripts[name];\n            scriptAbility[name] = this._resource;\n          }\n          resolve(this);\n        };\n        scriptDom.src = assetConfig.url;\n        document.body.appendChild(scriptDom);\n      } else {\n        for (let i = 0; i < scripts.length; i++) {\n          const name = scripts[i].name;\n          scriptAbility[name] = oasis.options?.scripts[name];\n        }\n        resolve(this);\n      }\n    });\n  }\n  setMeta(assetConfig) {\n    if (assetConfig) {\n      this._meta.name = assetConfig.name;\n      this._meta.url = assetConfig.url;\n      this._meta.source = assetConfig.source;\n    }\n  }\n}\n\nclass BlinnPhongMaterialResource extends SchemaResource {\n  load(resourceManager, assetConfig) {\n    return new Promise((resolve) => {\n      const assetObj = new BlinnPhongMaterial(resourceManager.engine, assetConfig.name);\n      for (let k in assetConfig.props) {\n        assetObj[k] = assetConfig.props[k];\n      }\n      this._resource = assetObj;\n      this.setMeta();\n      resolve(this);\n    });\n  }\n  setMeta() {\n    if (this.resource) {\n      this.meta.name = this.resource.name;\n    }\n  }\n}\n\nconst imageOrderMap = {\n  px: 0,\n  nx: 1,\n  py: 2,\n  ny: 3,\n  pz: 4,\n  nz: 5\n};\nclass TextureCubeMapResource extends SchemaResource {\n  load(resourceManager, assetConfig, oasis) {\n    return new Promise((resolve, reject) => {\n      const imageUrls = [];\n      let type = AssetType.TextureCube;\n      if (this.resourceManager.useCompressedTexture && assetConfig?.props?.compression?.compressions.length) {\n        const rhi = oasis.engine._hardwareRenderer;\n        const compressions = assetConfig.props.compression.compressions;\n        for (let i = 0; i < compressions.length; i++) {\n          const compression = compressions[i];\n          if (compression.container === \"ktx\" && rhi.canIUse(GLCapabilityType[compression.type])) {\n            for (const key in compression.files) {\n              if (compression.files.hasOwnProperty(key)) {\n                const image = compression.files[key];\n                imageUrls[imageOrderMap[key]] = image.url;\n              }\n            }\n            console.warn(compression.type);\n            type = AssetType.KTXCube;\n            break;\n          }\n        }\n      }\n      if (type === AssetType.TextureCube) {\n        for (const key in assetConfig.props.images) {\n          if (assetConfig.props.images.hasOwnProperty(key)) {\n            const image = assetConfig.props.images[key];\n            imageUrls[imageOrderMap[key]] = image.url;\n          }\n        }\n      }\n      resourceManager.load({\n        urls: imageUrls,\n        type\n      }).then((res) => {\n        this._resource = res;\n        resolve(this);\n      }).catch((e) => {\n        reject(e);\n      });\n    });\n  }\n  setMeta() {\n    if (this.resource) {\n      this.meta.name = this.resource.name;\n    }\n  }\n}\n\nclass BaseResource extends SchemaResource {\n  load(resourceLoader, assetConfig) {\n    return new Promise((resolve) => {\n      this._resource = assetConfig;\n      this.setMetaData(\"name\", this.resource.name);\n      this.setMetaData(\"url\", this.resource.url);\n      resolve(this);\n    });\n  }\n  setMetaData(key, value) {\n    this._meta[key] = value;\n  }\n}\n\nvar __defProp$7 = Object.defineProperty;\nvar __getOwnPropDesc$7 = Object.getOwnPropertyDescriptor;\nvar __decorate$7 = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$7(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result)\n    __defProp$7(target, key, result);\n  return result;\n};\nclass AbilityManager {\n  constructor(oasis) {\n    this.oasis = oasis;\n    this.abilityMap = {};\n  }\n  add(abilityConfig) {\n    const {type, node: nodeId, props, id, index} = abilityConfig;\n    const node = this.oasis.nodeManager.get(nodeId);\n    const AbilityConstructor = this.getCompConstructor(type);\n    if (!AbilityConstructor) {\n      Logger.error(`${type} abiltiy is not defined`);\n      return;\n    }\n    const abilityProps = this.mixPropsToExplicitProps(props);\n    const ability = node.addComponent(AbilityConstructor);\n    const {enabled} = abilityProps;\n    if (enabled !== void 0) {\n      ability.enabled = enabled;\n    }\n    if (type === \"Model\" || type === \"GLTFModel\" || type === \"Particle\") {\n      ability.init(abilityProps);\n    } else {\n      for (let k in abilityProps) {\n        if (abilityProps[k] !== null) {\n          ability[k] = abilityProps[k];\n        }\n      }\n    }\n    const abilityArray = node._components;\n    const currentIndex = abilityArray.length - 1;\n    switchElementsIndex(abilityArray, currentIndex, index);\n    ability.id = id;\n    this.abilityMap[id] = ability;\n    return ability;\n  }\n  update(id, key, value) {\n    if (this.get(id).constructor.name === \"Model\") {\n      if (value && this.checkIsAsset(value)) {\n        this.get(id).setProp(key, this.oasis.resourceManager.get(value.id).resource);\n      } else {\n        this.get(id).setProp(key, value);\n      }\n    } else {\n      if (value && this.checkIsAsset(value)) {\n        this.get(id)[key] = this.oasis.resourceManager.get(value.id).resource;\n      } else {\n        this.get(id)[key] = value;\n      }\n    }\n    return {id, key, value};\n  }\n  get(id) {\n    return this.abilityMap[id];\n  }\n  delete(id) {\n    const ability = this.abilityMap[id];\n    ability.destroy();\n    delete this.abilityMap[id];\n    return id;\n  }\n  getCompConstructor(type) {\n    const splits = type.split(\".\");\n    if (splits[0] === \"script\") {\n      return scriptAbility[splits[1]];\n    }\n    const constructor = Parser._components[\"o3\"][type];\n    if (!constructor) {\n      throw new Error(`${type} is not defined`);\n    }\n    return constructor;\n  }\n  mixPropsToExplicitProps(props) {\n    const explicitProps = {...props};\n    for (let k in props) {\n      const prop = props[k];\n      if (prop && this.checkIsAsset(prop)) {\n        const res = this.oasis.resourceManager.get(prop.id);\n        if (res) {\n          explicitProps[k] = res.resource;\n        } else {\n          explicitProps[k] = null;\n          Logger.warn(`AbilityManager: can't get asset \"${k}\", which id is ${prop.id}`);\n        }\n      }\n    }\n    return explicitProps;\n  }\n  checkIsAsset(prop) {\n    return prop.type === \"asset\";\n  }\n}\n__decorate$7([\n  pluginHook({after: \"abilityAdded\", before: \"beforeAbilityAdded\"})\n], AbilityManager.prototype, \"add\", 1);\n__decorate$7([\n  pluginHook({before: \"beforeAbilityUpdated\", after: \"abilityUpdated\"})\n], AbilityManager.prototype, \"update\", 1);\n__decorate$7([\n  pluginHook({after: \"abilityDeleted\", before: \"beforeAbilityDeleted\"})\n], AbilityManager.prototype, \"delete\", 1);\n\nvar __defProp$8 = Object.defineProperty;\nvar __getOwnPropDesc$8 = Object.getOwnPropertyDescriptor;\nvar __decorate$8 = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$8(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result)\n    __defProp$8(target, key, result);\n  return result;\n};\nclass NodeManager {\n  constructor(oasis) {\n    this.oasis = oasis;\n    this.nodeMap = {};\n    this.root = new Entity(this.oasis.engine, \"root\");\n  }\n  addRootEntity() {\n    this.oasis.engine.sceneManager.activeScene.addRootEntity(this.root);\n  }\n  add(nodeConfig) {\n    this.create(nodeConfig);\n    this.append(nodeConfig.id, nodeConfig.parent, nodeConfig.index);\n    return this.get(nodeConfig.id);\n  }\n  update(id, key, value) {\n    this.get(id)[key] = value;\n    return {id, key, value};\n  }\n  get(id) {\n    return this.nodeMap[id];\n  }\n  reset() {\n    this.nodeMap = {};\n  }\n  delete(id) {\n    this.nodeMap[id].destroy();\n    delete this.nodeMap[id];\n  }\n  create(nodeConfig) {\n    const {isActive, position, rotation, scale, id, name} = nodeConfig;\n    const entity = new Entity(this.oasis.engine, name);\n    entity.isActive = isActive;\n    entity.transform.position = new Vector3(position[0], position[1], position[2]);\n    entity.transform.rotation = new Vector3(rotation[0], rotation[1], rotation[2]);\n    entity.transform.scale = new Vector3(scale[0], scale[1], scale[2]);\n    entity.id = id;\n    this.nodeMap[id] = entity;\n    return entity;\n  }\n  append(childId, parentId, index) {\n    const child = this.nodeMap[childId];\n    const parent = this.nodeMap[parentId] || this.root;\n    parent.addChild(child);\n    const children = parent._children;\n    const currentIndex = children.length - 1;\n    switchElementsIndex(children, currentIndex, index);\n  }\n}\n__decorate$8([\n  pluginHook({after: \"nodeAdded\"})\n], NodeManager.prototype, \"add\", 1);\n__decorate$8([\n  pluginHook({before: \"beforeNodeUpdated\", after: \"nodeUpdated\"})\n], NodeManager.prototype, \"update\", 1);\n__decorate$8([\n  pluginHook({before: \"beforeNodeDeleted\"})\n], NodeManager.prototype, \"delete\", 1);\n\nvar __defProp$9 = Object.defineProperty;\nvar __getOwnPropDesc$9 = Object.getOwnPropertyDescriptor;\nvar __decorate$9 = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$9(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result)\n    __defProp$9(target, key, result);\n  return result;\n};\nconst RESOURCE_CLASS = {\n  script: ScriptResource,\n  gltf: GLTFResource$1,\n  texture: TextureResource,\n  cubeTexture: TextureCubeMapResource,\n  PBRMaterial: PBRMaterialResource,\n  PBRSpecularMaterial: PBRMaterialResource,\n  unlitMaterial: PBRMaterialResource,\n  ShaderMaterial: ShaderMaterialResource,\n  BlinnPhongMaterial: BlinnPhongMaterialResource,\n  base: BaseResource\n};\nconst RESOURCE_TYPE = new Map();\nfor (const key in RESOURCE_CLASS) {\n  if (RESOURCE_CLASS.hasOwnProperty(key)) {\n    const element = RESOURCE_CLASS[key];\n    if (element === PBRMaterialResource) {\n      RESOURCE_TYPE.set(element, \"PBRMaterial\");\n    } else {\n      RESOURCE_TYPE.set(element, key);\n    }\n  }\n}\nconst resourceFactory = {\n  createResource(resourceManager, type) {\n    return new RESOURCE_CLASS[type](resourceManager);\n  }\n};\nfunction registerResource(type, resource) {\n  if (!RESOURCE_CLASS.hasOwnProperty(type)) {\n    RESOURCE_CLASS[type] = resource;\n    RESOURCE_TYPE.set(resource, type);\n  }\n}\nclass SchemaResourceManager {\n  constructor(oasis) {\n    this.oasis = oasis;\n    this.resourceMap = {};\n    this.resourceIdMap = new WeakMap();\n    this.maxId = 0;\n    this.engineResourceManager = this.oasis.engine.resourceManager;\n  }\n  load(asset) {\n    const resource = resourceFactory.createResource(this, asset.type);\n    const loadPromise = resource.load(this.oasis.engine.resourceManager, asset, this.oasis);\n    this.maxId = Math.max(+asset.id, this.maxId);\n    loadPromise.then(() => {\n      this.resourceMap[asset.id] = resource;\n      this.resourceIdMap.set(resource, asset.id);\n    });\n    return loadPromise;\n  }\n  add(asset) {\n    const resource = resourceFactory.createResource(this, asset.type);\n    return new Promise((resolve) => {\n      resource.loadWithAttachedResources(this.oasis.engine.resourceManager, asset, this.oasis).then((result) => {\n        resolve(this.getAddResourceResult(result.resources, result.structure));\n      });\n    });\n  }\n  remove(id) {\n    return new Promise((resolve) => {\n      const resource = this.resourceMap[id];\n      const result = [id];\n      let hasAttachedResource = false;\n      delete this.resourceMap[id];\n      if (resource) {\n        const attached = resource.attachedResources;\n        for (let index = 0; index < attached.length; index++) {\n          const attachedResource = attached[index];\n          const attachedResourceId = this.resourceIdMap.get(attachedResource);\n          if (attachedResourceId) {\n            hasAttachedResource = true;\n            this.remove(attachedResourceId).then((attachedResourceRemoveResult) => {\n              result.push(...attachedResourceRemoveResult);\n              resolve(result);\n            });\n          }\n        }\n      }\n      if (!hasAttachedResource) {\n        resolve(result);\n      }\n    });\n  }\n  update(id, key, value) {\n    const resource = this.get(id);\n    if (resource) {\n      resource.update(key, value);\n    }\n    return {\n      resource,\n      id,\n      key,\n      value\n    };\n  }\n  updateMeta(id, key, value) {\n    const resource = this.get(id);\n    if (resource) {\n      resource.updateMeta(key, value);\n    }\n  }\n  get(id) {\n    return this.resourceMap[id];\n  }\n  getAll() {\n    return ObjectValues(this.resourceMap);\n  }\n  getAddResourceResult(resources2, structure) {\n    const addResourceResult = {};\n    const resource = resources2[structure.index];\n    const id = `${++this.maxId}`;\n    this.resourceMap[id] = resource;\n    this.resourceIdMap.set(resource, id);\n    addResourceResult.id = this.maxId;\n    addResourceResult.type = RESOURCE_TYPE.get(resource.constructor);\n    addResourceResult.meta = resource.meta;\n    addResourceResult.props = {};\n    for (const key in structure.props) {\n      if (structure.props.hasOwnProperty(key)) {\n        const element = structure.props[key];\n        if (element) {\n          if (Array.isArray(element)) {\n            addResourceResult.props[key] = element.map((child) => this.getAddResourceResult(resources2, child));\n          } else {\n            addResourceResult.props[key] = this.getAddResourceResult(resources2, element);\n          }\n        }\n      }\n    }\n    return addResourceResult;\n  }\n  get isLocal() {\n    return this.oasis.options.local;\n  }\n  get useCompressedTexture() {\n    return this.oasis.options.useCompressedTexture ?? true;\n  }\n}\n__decorate$9([\n  pluginHook({before: \"beforeResourceRemove\"})\n], SchemaResourceManager.prototype, \"remove\", 1);\n__decorate$9([\n  pluginHook({after: \"resourceUpdated\", before: \"beforeResourceUpdate\"})\n], SchemaResourceManager.prototype, \"update\", 1);\n\nvar __defProp$a = Object.defineProperty;\nvar __getOwnPropDesc$a = Object.getOwnPropertyDescriptor;\nvar __decorate$a = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$a(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result)\n    __defProp$a(target, key, result);\n  return result;\n};\nclass Oasis extends EventDispatcher {\n  constructor(_options, pluginManager) {\n    super(_options.engine);\n    this._options = _options;\n    this.pluginManager = pluginManager;\n    this.engine = null;\n    this.oasis = this;\n    this.engine = _options.engine;\n    this.resetFeature();\n    this.schema = _options.config;\n    this.timeout = _options.timeout;\n    _options.scripts = _options.scripts ?? {};\n    this.nodeManager = new NodeManager(this);\n    this.abilityManager = new AbilityManager(this);\n    this.nodeManager.add = this.nodeManager.add.bind(this.nodeManager);\n    this.abilityManager.add = this.abilityManager.add.bind(this.abilityManager);\n    this.resourceManager = new SchemaResourceManager(this);\n    if (_options.fps) {\n      this.engine.targetFrameRate = _options.fps;\n      this.engine.vSyncCount = 0;\n    }\n  }\n  get canvas() {\n    return this._options.canvas;\n  }\n  get options() {\n    return this._options;\n  }\n  updateConfig(config) {\n    this.schema = config;\n    this.init();\n  }\n  init() {\n    return this.loadResources().then(() => {\n      this.bindResources();\n      this.parseEntities();\n      this.parseNodeAbilities();\n      this.attach();\n      this.nodeManager.addRootEntity();\n      this.pluginManager.boot(this);\n    });\n  }\n  loadResources() {\n    const {assets = {}} = this.schema;\n    const loadingPromises = ObjectValues(assets).filter((asset) => {\n      if (RESOURCE_CLASS[asset.type]) {\n        return true;\n      }\n      console.warn(`${asset.type} loader is not defined. the ${asset.type} type will be ignored.`);\n      return false;\n    }).map((asset) => this.resourceManager.load(asset));\n    return Promise.all(loadingPromises);\n  }\n  bindResources() {\n    this.resourceManager.getAll().forEach((resource) => {\n      resource.bind();\n    });\n  }\n  parseEntities() {\n    const {nodes} = this.schema;\n    const indices = this.bfsNodes();\n    indices.map((index) => nodes[index]).forEach(this.nodeManager.add);\n  }\n  parseNodeAbilities() {\n    const {abilities} = this.schema;\n    Object.keys(abilities).map((id) => ({id, ...abilities[id]})).forEach(this.abilityManager.add);\n  }\n  bfsNodes() {\n    const {nodes} = this.schema;\n    const roots = ObjectValues(nodes).filter((node) => !nodes[node.parent]).map((node) => node.id);\n    let result = [];\n    const traverseChildren = (roots2) => {\n      result = result.concat(roots2);\n      roots2.forEach((id) => {\n        const children = nodes[id].children;\n        children && traverseChildren(children);\n      });\n    };\n    traverseChildren(roots);\n    return result;\n  }\n  resetFeature() {\n    const scene = this.engine.sceneManager.activeScene;\n    scene.features.splice(2, 1);\n    scene.features.splice(3, 1);\n    scene.hasFogFeature = void 0;\n    scene.getFogMacro = void 0;\n    scene.bindFogToMaterial = void 0;\n  }\n  attach() {\n    this.resourceManager.getAll().forEach((resource) => {\n      resource.attach();\n    });\n  }\n  static create(options, pluginManager) {\n    const oasis = new Oasis(options, pluginManager);\n    return oasis.init().then(() => {\n      options.autoPlay && oasis.engine.run();\n      return oasis;\n    });\n  }\n}\n__decorate$a([\n  pluginHook({after: \"schemaParsed\"})\n], Oasis.prototype, \"init\", 1);\n\nconst _vec3Attribute = [\n  \"color\",\n  \"center\",\n  \"size\",\n  \"__position\",\n  \"__positionRandomness\",\n  \"__color\",\n  \"__velocity\",\n  \"__velocityRandomness\",\n  \"__acceleration\",\n  \"__accelerationRandomness\",\n  \"_center\"\n];\nfunction compatibleToV2(config) {\n  const {abilities = {}, assets = {}} = config;\n  const ids = Object.keys(abilities);\n  const assetKeys = Object.keys(assets);\n  for (let i = 0, l = ids.length; i < l; ++i) {\n    handleProps(abilities[ids[i]].props);\n  }\n  for (let i = 0, l = assetKeys.length; i < l; ++i) {\n    handleAssets(assets[assetKeys[i]].props);\n  }\n  return config;\n}\nfunction handleProps(props) {\n  const keys = Object.keys(props);\n  for (let i = 0, l = keys.length; i < l; ++i) {\n    const k = keys[i];\n    const v = props[k];\n    if (v !== null && typeof v === \"object\" && v.length > 1) {\n      if (k === \"backgroundColor\" || k === \"tintColor\") {\n        props[k] = new Vector4(v[0], v[1], v[2], v[3]);\n      } else if (_vec3Attribute.indexOf(k) !== -1) {\n        props[k] = new Vector3(v[0], v[1], v[2]);\n      }\n    }\n  }\n}\nfunction handleAssets(props = {}) {\n  if (!props) {\n    return;\n  }\n  const keys = Object.keys(props);\n  for (let i = 0, l = keys.length; i < l; i++) {\n    const key = keys[i];\n    const value = props[key];\n    if (key === \"newMaterial\" || key === \"blendFuncSeparate\" || key === \"scripts\") {\n      continue;\n    }\n    switch (value?.length) {\n      case 2:\n        props[key] = new Vector2(value[0], value[1]);\n        break;\n      case 3:\n        props[key] = new Vector3(value[0], value[1], value[2]);\n        break;\n      case 4:\n        props[key] = new Vector4(value[0], value[1], value[2], value[3]);\n        break;\n    }\n  }\n}\n\nconst CURRENT_SCHEMA_VERSION = 3;\nclass Parser {\n  constructor() {\n    this.pluginManager = new PluginManager();\n  }\n  parse(options) {\n    if (options?.config?.version !== CURRENT_SCHEMA_VERSION) {\n      console.warn(`schema-parser: schema version \"${options?.config?.version}\" is out of date, please re-pull the latest version (version ${CURRENT_SCHEMA_VERSION}) of the schema`);\n    }\n    compatibleToV2(options.config);\n    return Oasis.create(options, this.pluginManager);\n  }\n  register(plugin) {\n    this.pluginManager.register(plugin);\n  }\n  resetPlugins() {\n    this.pluginManager.reset();\n  }\n  static create() {\n    const parser2 = new Parser();\n    return parser2;\n  }\n  static registerComponents(namespace, components) {\n    if (!this._components[namespace]) {\n      this._components[namespace] = {};\n    }\n    Object.assign(this._components[namespace], components);\n  }\n}\nParser._components = {};\nconst parser = Parser.create();\n\nexport { GLTFModel, Oasis, Parser, RegistExtension, SchemaResource, parseSingleKTX, parser, registerResource, script };\n//# sourceMappingURL=module.js.map\n","import { Logger, DataType, InternalAssetType, GLCapabilityType, GLCompressedTextureInternalFormat, UniformSemantic, RenderState, BlendFunc, ClearMode, Engine } from '@oasis-engine/core';\nimport { Vector2 } from '@oasis-engine/math';\n\nlet programList = [];\nfunction addLineNum(str) {\n  const lines = str.split(\"\\n\");\n  const limitLength = (lines.length + 1).toString().length + 6;\n  let prefix;\n  return lines.map((line, index) => {\n    prefix = `0:${index + 1}`;\n    if (prefix.length >= limitLength)\n      return prefix.substring(0, limitLength) + line;\n    for (let i = 0; i < limitLength - prefix.length; i++)\n      prefix += \" \";\n    return prefix + line;\n  }).join(\"\\n\");\n}\nclass GLShaderProgram {\n  constructor(gl, _engine) {\n    this._engine = _engine;\n    this._gl = gl;\n    this._vertexShader = null;\n    this._fragmentShader = null;\n    this._vertexShaderSource = null;\n    this._fragmentShaderSource = null;\n    this._program = null;\n    this._attributeCache = {};\n    this._uniformCache = {};\n  }\n  static requireProgram(tech, gl, engine) {\n    let program = null;\n    programList.some((p) => {\n      if (p._gl === gl && p._vertexShaderSource === tech.vertexShader && p._fragmentShaderSource === tech.fragmentShader) {\n        program = p;\n        return true;\n      }\n    });\n    if (!program) {\n      program = new GLShaderProgram(gl, engine);\n      const sucess = program.createFromSource(tech.vertexShader, tech.fragmentShader, tech.attribLocSet);\n      if (!sucess)\n        return null;\n      programList.push(program);\n    }\n    return program;\n  }\n  static releaseProgram(program) {\n    let index = programList.indexOf(program);\n    if (index !== -1) {\n      programList.splice(index, 1);\n    }\n  }\n  get program() {\n    return this._program;\n  }\n  createFromSource(vertexSource, fragmentSource, attribLocSet) {\n    const gl = this._gl;\n    const vertexShader = this._compileShader(gl.VERTEX_SHADER, vertexSource);\n    if (!vertexShader) {\n      return false;\n    }\n    const fragmentShader = this._compileShader(gl.FRAGMENT_SHADER, fragmentSource);\n    if (!fragmentShader) {\n      return false;\n    }\n    const program = gl.createProgram();\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    if (attribLocSet) {\n      for (const attribName in attribLocSet) {\n        gl.bindAttribLocation(program, attribLocSet[attribName], attribName);\n      }\n    }\n    gl.linkProgram(program);\n    gl.validateProgram(program);\n    if (gl.isContextLost()) {\n      Logger.error(\"Contex lost while linking program.\");\n      gl.deleteShader(vertexShader);\n      gl.deleteShader(fragmentShader);\n      return null;\n    }\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS) && !gl.isContextLost()) {\n      const msg = \"Could not link WebGL program. \\n\" + gl.getProgramInfoLog(program);\n      console.error(msg);\n      this._engine.dispatch(\"linkProgramError\", msg);\n      gl.deleteProgram(program);\n      return false;\n    }\n    this._vertexShader = vertexShader;\n    this._fragmentShader = fragmentShader;\n    this._vertexShaderSource = vertexSource;\n    this._fragmentShaderSource = fragmentSource;\n    this._program = program;\n    return true;\n  }\n  _compileShader(shaderType, shaderSource) {\n    const gl = this._gl;\n    const shader = gl.createShader(shaderType);\n    gl.shaderSource(shader, shaderSource);\n    gl.compileShader(shader);\n    if (gl.isContextLost()) {\n      Logger.error(\"Contex lost while compiling shader.\");\n      gl.deleteShader(shader);\n      return null;\n    }\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS) && !gl.isContextLost()) {\n      const msg = `Could not compile WebGL shader.\n${addLineNum(shaderSource)}\n${gl.getShaderInfoLog(shader)}`;\n      console.error(msg);\n      this._engine.dispatch(\"compileShaderError\", msg);\n      gl.deleteShader(shader);\n      return null;\n    }\n    return shader;\n  }\n  getAttribLocation(glProgram, name) {\n    if (this._attributeCache.hasOwnProperty(name)) {\n      return this._attributeCache[name];\n    } else {\n      return this._attributeCache[name] = this._gl.getAttribLocation(glProgram, name);\n    }\n  }\n  getUniformLocation(glProgram, name) {\n    if (this._uniformCache.hasOwnProperty(name)) {\n      return this._uniformCache[name];\n    } else {\n      return this._uniformCache[name] = this._gl.getUniformLocation(glProgram, name);\n    }\n  }\n  finalize() {\n    const gl = this._gl;\n    if (this._vertexShader) {\n      gl.deleteShader(this._vertexShader);\n    }\n    if (this._fragmentShader) {\n      gl.deleteShader(this._fragmentShader);\n    }\n    if (this._program) {\n      gl.deleteProgram(this._program);\n    }\n    this._vertexShader = null;\n    this._fragmentShader = null;\n    this._vertexShaderSource = null;\n    this._fragmentShaderSource = null;\n    this._program = null;\n    this._attributeCache = {};\n    this._uniformCache = {};\n    GLShaderProgram.releaseProgram(this);\n  }\n}\n\nclass GLAsset {\n  constructor(rhi, asset) {\n    this._rhi = rhi;\n    this.asset = asset;\n  }\n  get rhi() {\n    return this._rhi;\n  }\n}\n\nclass GLTechnique extends GLAsset {\n  constructor(rhi, tech) {\n    super(rhi, tech);\n    this.cacheID = ++GLTechnique.cacheCounter;\n    this._tech = tech;\n    this._activeTextureCount = 0;\n    const gl = rhi.gl;\n    this._program = GLShaderProgram.requireProgram(tech, gl, rhi._engine);\n    if (this._program) {\n      this.valid = true;\n      const glProgram = this._program.program;\n      this._attributes = {};\n      const attributes = tech.attributes;\n      for (const name in attributes) {\n        this._attributes[name] = {\n          name,\n          semantic: attributes[name].semantic,\n          location: this._program.getAttribLocation(glProgram, name)\n        };\n      }\n      this._uniforms = {};\n      const uniforms = tech.uniforms;\n      for (const name in uniforms) {\n        const loc = this._program.getUniformLocation(glProgram, name);\n        if (loc !== null) {\n          this._uniforms[name] = {\n            name,\n            location: loc\n          };\n        }\n      }\n    } else {\n      this.valid = false;\n    }\n  }\n  finalize(forceDispose) {\n    if (this._program && forceDispose) {\n      this._program = null;\n    }\n  }\n  get program() {\n    return this._program;\n  }\n  get attributes() {\n    return this._attributes;\n  }\n  get uniforms() {\n    return this._uniforms;\n  }\n  begin(mtl) {\n    const gl = this.rhi.gl;\n    const glProgram = this._program.program;\n    this._activeTextureCount = 0;\n    gl.useProgram(glProgram);\n    const uniforms = this._uniforms;\n    const assetUniforms = this._tech.uniforms;\n    for (const name in assetUniforms) {\n      if (uniforms.hasOwnProperty(name)) {\n        const value = mtl.getValue(name);\n        value != null && this._uploadUniformValue(assetUniforms[name], uniforms[name].location, value);\n      }\n    }\n    const stateManager = this.rhi.renderStates;\n    if (this._tech.states) {\n      stateManager.pushStateBlock(this._tech.name);\n      this._applyStates(stateManager);\n    }\n  }\n  end() {\n    if (this._tech.states) {\n      const stateManager = this.rhi.renderStates;\n      stateManager.popStateBlock();\n    }\n  }\n  _applyStates(stateManager) {\n    const states = this._tech.states;\n    const enable = states.enable;\n    if (enable) {\n      for (let i = 0, len = enable.length; i < len; i++) {\n        stateManager.enable(enable[i]);\n      }\n    }\n    const disable = states.disable;\n    if (disable) {\n      for (let i = 0, len = disable.length; i < len; i++) {\n        stateManager.disable(disable[i]);\n      }\n    }\n    const functions = states.functions;\n    if (functions) {\n      for (const name in functions) {\n        const args = Array.isArray(functions[name]) ? functions[name] : [functions[name]];\n        const func = stateManager[name];\n        func.apply(stateManager, args);\n      }\n    }\n  }\n  _uploadUniformValue(uniform, location, value) {\n    const gl = this.rhi.gl;\n    switch (uniform.type) {\n      case DataType.FLOAT:\n        if (value.length)\n          gl.uniform1fv(location, value);\n        else\n          gl.uniform1f(location, value);\n        break;\n      case DataType.FLOAT_ARRAY:\n        gl.uniform1fv(location, value);\n        break;\n      case DataType.INT:\n        if (value.length)\n          gl.uniform1iv(location, value);\n        else\n          gl.uniform1i(location, value);\n        break;\n      case DataType.INT_ARRAY:\n        gl.uniform1iv(location, value);\n        break;\n      case DataType.FLOAT_VEC2:\n        gl.uniform2f(location, value.x, value.y);\n        break;\n      case DataType.FLOAT_VEC2_ARRAY:\n        gl.uniform2fv(location, value);\n        break;\n      case DataType.FLOAT_VEC3:\n        gl.uniform3f(location, value.x, value.y, value.z);\n        break;\n      case DataType.FLOAT_VEC3_ARRAY:\n        gl.uniform3fv(location, value);\n        break;\n      case DataType.FLOAT_VEC4:\n        gl.uniform4f(location, value.x, value.y, value.z, value.w);\n        break;\n      case DataType.FLOAT_VEC4_ARRAY:\n        gl.uniform4fv(location, value);\n        break;\n      case DataType.INT_VEC2:\n        gl.uniform2i(location, value.x, value.y);\n        break;\n      case DataType.INT_VEC2_ARRAY:\n        gl.uniform2iv(location, value);\n        break;\n      case DataType.INT_VEC3:\n        gl.uniform3i(location, value.x, value.y, value.z);\n        break;\n      case DataType.INT_VEC3_ARRAY:\n        gl.uniform3iv(location, value);\n        break;\n      case DataType.INT_VEC4:\n        gl.uniform4i(location, value.x, value.y, value.z, value.w);\n        break;\n      case DataType.INT_VEC4_ARRAY:\n        gl.uniform4iv(location, value);\n        break;\n      case DataType.FLOAT_MAT2:\n        gl.uniformMatrix2fv(location, false, value.elements);\n        break;\n      case DataType.FLOAT_MAT2_ARRAY:\n        gl.uniformMatrix2fv(location, false, value);\n        break;\n      case DataType.FLOAT_MAT3:\n        gl.uniformMatrix3fv(location, false, value.elements);\n        break;\n      case DataType.FLOAT_MAT3_ARRAY:\n        gl.uniformMatrix3fv(location, false, value);\n        break;\n      case DataType.FLOAT_MAT4:\n        gl.uniformMatrix4fv(location, false, value.elements);\n        break;\n      case DataType.FLOAT_MAT4_ARRAY:\n        gl.uniformMatrix4fv(location, false, value);\n        break;\n      case DataType.SAMPLER_2D: {\n        this._uploadTexture(value, location);\n        break;\n      }\n      case DataType.SAMPLER_2D_ARRAY: {\n        this._uploadTextures(value, location);\n        break;\n      }\n      case DataType.SAMPLER_CUBE: {\n        this._uploadTexture(value, location);\n        break;\n      }\n      case DataType.SAMPLER_CUBE_ARRAY: {\n        this._uploadTextures(value, location);\n        break;\n      }\n      default:\n        Logger.warn(\"UNKNOWN uniform type: \" + uniform.type);\n        break;\n    }\n  }\n  _uploadTexture(texture, location) {\n    if (texture) {\n      const gl = this.rhi.gl;\n      const index = this._activeTextureCount++;\n      gl.activeTexture(gl.TEXTURE0 + index);\n      gl.bindTexture(texture._target, texture._glTexture);\n      gl.uniform1i(location, index);\n    }\n  }\n  _uploadTextures(textures, location) {\n    if (!this._tempSamplerArray || this._tempSamplerArray.length !== textures.length) {\n      this._tempSamplerArray = new Int32Array(textures.length);\n    }\n    const gl = this.rhi.gl;\n    for (let i = 0, length = textures.length; i < length; i++) {\n      const texture = textures[i];\n      if (texture) {\n        const index = this._activeTextureCount++;\n        gl.activeTexture(gl.TEXTURE0 + index);\n        gl.bindTexture(texture._target, texture._glTexture);\n        this._tempSamplerArray[i] = index;\n      } else {\n        this._tempSamplerArray[i] = -1;\n      }\n    }\n    gl.uniform1iv(location, this._tempSamplerArray);\n  }\n}\nGLTechnique.cacheCounter = 0;\n\nclass GLTexture extends GLAsset {\n  constructor(rhi, config, type) {\n    super(rhi, config);\n    this._gl = rhi.gl;\n    this._glTexture = config._glTexture;\n    this._config = config;\n    this._type = type;\n  }\n  get glTexture() {\n    return this._glTexture;\n  }\n  activeBinding(textureIndex) {\n    const gl = this._gl;\n    gl.activeTexture(gl.TEXTURE0 + textureIndex);\n    gl.bindTexture(this._type, this._glTexture);\n  }\n  finalize() {\n  }\n}\n\nclass WebCanvas {\n  constructor(webCanvas) {\n    this._scale = new Vector2();\n    const width = webCanvas.width;\n    const height = webCanvas.height;\n    this._webCanvas = webCanvas;\n    this._width = width;\n    this._height = height;\n  }\n  get width() {\n    return this._width;\n  }\n  set width(value) {\n    if (this._width !== value) {\n      this._webCanvas.width = value;\n      this._width = value;\n    }\n  }\n  get height() {\n    return this._height;\n  }\n  set height(value) {\n    if (this._height !== value) {\n      this._webCanvas.height = value;\n      this._height = value;\n    }\n  }\n  get scale() {\n    const webCanvas = this._webCanvas;\n    if (webCanvas instanceof HTMLCanvasElement) {\n      this._scale.setValue(webCanvas.clientWidth * devicePixelRatio / webCanvas.width, webCanvas.clientHeight * devicePixelRatio / webCanvas.height);\n    }\n    return this._scale;\n  }\n  set scale(value) {\n    const webCanvas = this._webCanvas;\n    if (webCanvas instanceof HTMLCanvasElement) {\n      webCanvas.style.transformOrigin = `left top`;\n      webCanvas.style.transform = `scale(${value.x}, ${value.y})`;\n    }\n  }\n  resizeByClientSize(pixelRatio = window.devicePixelRatio) {\n    const webCanvas = this._webCanvas;\n    if (webCanvas instanceof HTMLCanvasElement) {\n      const width = webCanvas.clientWidth;\n      const height = webCanvas.clientHeight;\n      this.width = width * pixelRatio;\n      this.height = height * pixelRatio;\n    }\n  }\n  setScale(x, y) {\n    this._scale.setValue(x, y);\n    this.scale = this._scale;\n  }\n}\n\nclass GLAssetsCache {\n  constructor(rhi, props = {}) {\n    this._rhi = rhi;\n    this._objectSet = {};\n    this._checkList = [];\n    this._nextID = 1;\n    this._enableCollect = props.enableCollect === void 0 ? true : !!props.enableCollect;\n  }\n  requireObject(asset, ctor) {\n    let cachedObject = null;\n    if (asset.cacheID) {\n      cachedObject = this._objectSet[asset.cacheID];\n    }\n    if (!cachedObject || asset.needRecreate) {\n      const cacheID = this._nextID++;\n      const objectSet = this._objectSet;\n      cachedObject = new ctor(this._rhi, asset);\n      objectSet[cacheID] = cachedObject;\n      cachedObject.cacheID = cacheID;\n      cachedObject.asset = asset;\n      asset.cacheID = cacheID;\n      asset.needRecreate = false;\n      if (this._enableCollect && asset.type === InternalAssetType.Cache) {\n        this._checkList.push(cachedObject);\n      }\n    }\n    cachedObject.activeFrame = this._rhi.frameCount;\n    return cachedObject;\n  }\n  compact() {\n    if (!this._enableCollect)\n      return;\n    const currentFrame = this._rhi.frameCount;\n    const checkList = this._checkList;\n    const objectSet = this._objectSet;\n    for (let i = checkList.length - 1; i >= 0; i--) {\n      const cachedObject = checkList[i];\n      if (cachedObject.activeFrame < currentFrame) {\n        delete objectSet[cachedObject.cacheID];\n        checkList.splice(i, 1);\n        cachedObject.finalize();\n      }\n    }\n  }\n  finalize() {\n    for (const name in this._objectSet) {\n      const obj = this._objectSet[name];\n      obj.finalize(true);\n    }\n    this._objectSet = {};\n    this._checkList = [];\n  }\n}\n\nclass GLCapability {\n  get maxDrawBuffers() {\n    if (!this._maxDrawBuffers) {\n      if (this.canIUse(GLCapabilityType.drawBuffers)) {\n        this._maxDrawBuffers = this._rhi.gl.getParameter(this._rhi.gl.MAX_DRAW_BUFFERS);\n      } else {\n        this._maxDrawBuffers = 1;\n      }\n    }\n    return this._maxDrawBuffers;\n  }\n  get maxAnisoLevel() {\n    if (!this._maxAnisoLevel) {\n      const ext = this._rhi.requireExtension(GLCapabilityType.textureFilterAnisotropic);\n      this._maxAnisoLevel = ext ? this._rhi.gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;\n    }\n    return this._maxAnisoLevel;\n  }\n  get maxAntiAliasing() {\n    if (!this._maxAntiAliasing) {\n      const gl = this._rhi.gl;\n      const canMSAA = this.canIUse(GLCapabilityType.multipleSample);\n      this._maxAntiAliasing = canMSAA ? gl.getParameter(gl.MAX_SAMPLES) : 1;\n    }\n    return this._maxAntiAliasing;\n  }\n  get rhi() {\n    return this._rhi;\n  }\n  constructor(rhi) {\n    this._rhi = rhi;\n    this.capabilityList = new Map();\n    this.init();\n    this.compatibleAllInterface();\n  }\n  canIUse(capabilityType) {\n    return this.capabilityList.get(capabilityType);\n  }\n  canIUseCompressedTextureInternalFormat(internalType) {\n    const {\n      RGBA_ASTC_4X4_KHR,\n      RGBA_ASTC_12X12_KHR,\n      SRGB8_ALPHA8_ASTC_4X4_KHR,\n      SRGB8_ALPHA8_ASTC_12X12_KHR,\n      RGB_ETC1_WEBGL,\n      R11_EAC,\n      SRGB8_ALPHA8_ETC2_EAC,\n      RGB_PVRTC_4BPPV1_IMG,\n      RGBA_PVRTC_2BPPV1_IMG,\n      RGB_S3TC_DXT1_EXT,\n      RGBA_S3TC_DXT5_EXT\n    } = GLCompressedTextureInternalFormat;\n    if (internalType >= RGBA_ASTC_4X4_KHR && RGBA_ASTC_12X12_KHR <= RGBA_ASTC_12X12_KHR || internalType >= SRGB8_ALPHA8_ASTC_4X4_KHR && internalType <= SRGB8_ALPHA8_ASTC_12X12_KHR) {\n      return this.canIUse(GLCapabilityType.astc);\n    } else if (internalType === RGB_ETC1_WEBGL) {\n      return this.canIUse(GLCapabilityType.etc1);\n    } else if (internalType >= R11_EAC && internalType <= SRGB8_ALPHA8_ETC2_EAC) {\n      return this.canIUse(GLCapabilityType.etc);\n    } else if (internalType >= RGB_PVRTC_4BPPV1_IMG && internalType <= RGBA_PVRTC_2BPPV1_IMG) {\n      return this.canIUse(GLCapabilityType.pvrtc);\n    } else if (internalType >= RGB_S3TC_DXT1_EXT && internalType <= RGBA_S3TC_DXT5_EXT) {\n      return this.canIUse(GLCapabilityType.s3tc);\n    }\n    return false;\n  }\n  get canIUseMoreJoints() {\n    return this.canIUse(GLCapabilityType.textureFloat) && this.rhi.renderStates.getParameter(this.rhi.gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) > 0;\n  }\n  init() {\n    const cap = this.capabilityList;\n    const {isWebGL2} = this.rhi;\n    const requireExtension = this.rhi.requireExtension.bind(this.rhi);\n    const {\n      standardDerivatives,\n      shaderTextureLod,\n      elementIndexUint,\n      depthTexture,\n      vertexArrayObject,\n      instancedArrays,\n      multipleSample,\n      drawBuffers,\n      astc,\n      astc_webkit,\n      etc,\n      etc_webkit,\n      etc1,\n      etc1_webkit,\n      pvrtc,\n      pvrtc_webkit,\n      s3tc,\n      s3tc_webkit,\n      textureFloat,\n      textureHalfFloat,\n      textureFloatLinear,\n      textureHalfFloatLinear,\n      WEBGL_colorBufferFloat,\n      colorBufferFloat,\n      colorBufferHalfFloat,\n      textureFilterAnisotropic\n    } = GLCapabilityType;\n    cap.set(standardDerivatives, isWebGL2 || !!requireExtension(standardDerivatives));\n    cap.set(shaderTextureLod, isWebGL2 || !!requireExtension(shaderTextureLod));\n    cap.set(elementIndexUint, isWebGL2 || !!requireExtension(elementIndexUint));\n    cap.set(depthTexture, isWebGL2 || !!requireExtension(depthTexture));\n    cap.set(vertexArrayObject, isWebGL2 || !!requireExtension(vertexArrayObject));\n    cap.set(instancedArrays, isWebGL2 || !!requireExtension(instancedArrays));\n    cap.set(multipleSample, isWebGL2);\n    cap.set(drawBuffers, isWebGL2 || !!requireExtension(drawBuffers));\n    cap.set(textureFloat, isWebGL2 || !!requireExtension(textureFloat));\n    cap.set(textureHalfFloat, isWebGL2 || !!requireExtension(textureHalfFloat));\n    cap.set(textureFloatLinear, !!requireExtension(textureFloatLinear));\n    cap.set(textureHalfFloatLinear, isWebGL2 || !!requireExtension(textureHalfFloatLinear));\n    cap.set(colorBufferFloat, isWebGL2 && !!requireExtension(colorBufferFloat) || !!requireExtension(WEBGL_colorBufferFloat));\n    cap.set(colorBufferHalfFloat, isWebGL2 && !!requireExtension(colorBufferFloat) || !!requireExtension(colorBufferHalfFloat));\n    cap.set(textureFilterAnisotropic, !!requireExtension(textureFilterAnisotropic));\n    cap.set(astc, !!(requireExtension(astc) || requireExtension(astc_webkit)));\n    cap.set(etc, !!(requireExtension(etc) || requireExtension(etc_webkit)));\n    cap.set(etc1, !!(requireExtension(etc1) || requireExtension(etc1_webkit)));\n    cap.set(pvrtc, !!(requireExtension(pvrtc) || requireExtension(pvrtc_webkit)));\n    cap.set(s3tc, !!(requireExtension(s3tc) || requireExtension(s3tc_webkit)));\n  }\n  compatibleInterface(capabilityType, flatItem) {\n    const rhi = this.rhi;\n    const gl = rhi.gl;\n    let ext = null;\n    if (ext = rhi.requireExtension(capabilityType)) {\n      for (let glKey in flatItem) {\n        const extensionKey = flatItem[glKey];\n        const extensionVal = ext[extensionKey];\n        if (extensionVal?.bind) {\n          gl[glKey] = extensionVal.bind(ext);\n        } else {\n          gl[glKey] = extensionVal;\n        }\n      }\n    }\n  }\n  compatibleAllInterface() {\n    const {\n      depthTexture,\n      vertexArrayObject,\n      instancedArrays,\n      drawBuffers,\n      textureFilterAnisotropic,\n      textureHalfFloat,\n      colorBufferHalfFloat,\n      WEBGL_colorBufferFloat\n    } = GLCapabilityType;\n    const {isWebGL2} = this.rhi;\n    if (!isWebGL2) {\n      this.compatibleInterface(depthTexture, {\n        UNSIGNED_INT_24_8: \"UNSIGNED_INT_24_8_WEBGL\"\n      });\n      this.compatibleInterface(vertexArrayObject, {\n        createVertexArray: \"createVertexArrayOES\",\n        deleteVertexArray: \"deleteVertexArrayOES\",\n        isVertexArray: \"isVertexArrayOES\",\n        bindVertexArray: \"bindVertexArrayOES\"\n      });\n      this.compatibleInterface(instancedArrays, {\n        drawArraysInstanced: \"drawArraysInstancedANGLE\",\n        drawElementsInstanced: \"drawElementsInstancedANGLE\",\n        vertexAttribDivisor: \"vertexAttribDivisorANGLE\"\n      });\n      this.compatibleInterface(drawBuffers, {\n        MAX_DRAW_BUFFERS: \"MAX_DRAW_BUFFERS_WEBGL\"\n      });\n      const items = {};\n      if (this.canIUse(GLCapabilityType.drawBuffers)) {\n        const maxDrawBuffers = this.maxDrawBuffers;\n        for (let i = 0; i < maxDrawBuffers; i++) {\n          i != 0 && (items[`COLOR_ATTACHMENT${i}`] = `COLOR_ATTACHMENT${i}_WEBGL`);\n          items[`DRAW_BUFFER${i}`] = `DRAW_BUFFER${i}_WEBGL`;\n        }\n        this.compatibleInterface(drawBuffers, {\n          drawBuffers: \"drawBuffersWEBGL\",\n          ...items\n        });\n      }\n      this.compatibleInterface(textureHalfFloat, {\n        HAFL_FLOAT: \"HALF_FLOAT_OES\"\n      });\n      this.compatibleInterface(colorBufferHalfFloat, {\n        RGBA16F: \"RBGA16F_EXT\"\n      });\n      this.compatibleInterface(WEBGL_colorBufferFloat, {\n        RGBA32F: \"RBGA32F_EXT\"\n      });\n    }\n    this.compatibleInterface(textureFilterAnisotropic, {\n      TEXTURE_MAX_ANISOTROPY_EXT: \"TEXTURE_MAX_ANISOTROPY_EXT\"\n    });\n  }\n}\n\nclass GLExtensions {\n  constructor(rhi) {\n    this.rhi = rhi;\n    this._requireResult = {};\n  }\n  requireExtension(ext) {\n    if (this._requireResult[ext] !== void 0) {\n      return this._requireResult[ext];\n    }\n    this._requireResult[ext] = this.rhi.gl.getExtension(ext);\n    return this._requireResult[ext];\n  }\n}\n\nclass GLPrimitive {\n  constructor(rhi, primitive) {\n    this.vao = new Map();\n    this._primitive = primitive;\n    this.canUseInstancedArrays = rhi.canIUse(GLCapabilityType.instancedArrays);\n    this._useVao = rhi.canIUse(GLCapabilityType.vertexArrayObject);\n    this.gl = rhi.gl;\n  }\n  draw(tech, subPrimitive) {\n    const gl = this.gl;\n    const primitive = this._primitive;\n    if (this._useVao) {\n      if (!this.vao.has(tech.cacheID)) {\n        this.registerVAO(tech);\n      }\n      const vao = this.vao.get(tech.cacheID);\n      gl.bindVertexArray(vao);\n    } else {\n      this.bindBufferAndAttrib(tech);\n    }\n    const {indexBufferBinding, instanceCount, _glIndexType} = primitive;\n    const {topology, start, count} = subPrimitive;\n    if (!instanceCount) {\n      if (indexBufferBinding) {\n        if (this._useVao) {\n          gl.drawElements(topology, count, _glIndexType, start);\n        } else {\n          const {_nativeBuffer} = indexBufferBinding.buffer;\n          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _nativeBuffer);\n          gl.drawElements(topology, count, _glIndexType, start);\n          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        }\n      } else {\n        gl.drawArrays(topology, start, count);\n      }\n    } else {\n      if (this.canUseInstancedArrays) {\n        if (indexBufferBinding) {\n          if (this._useVao) {\n            gl.drawElementsInstanced(topology, count, _glIndexType, start, instanceCount);\n          } else {\n            const {_nativeBuffer} = indexBufferBinding.buffer;\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _nativeBuffer);\n            gl.drawElementsInstanced(topology, count, _glIndexType, start, instanceCount);\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n          }\n        } else {\n          gl.drawArraysInstanced(topology, start, count, instanceCount);\n        }\n      } else {\n        Logger.error(\"ANGLE_instanced_arrays extension is not supported\");\n      }\n    }\n    if (this._useVao) {\n      gl.bindVertexArray(null);\n    } else {\n      this.disableAttrib();\n    }\n  }\n  destroy() {\n    if (this._useVao) {\n      const gl = this.gl;\n      this.vao.forEach((vao) => {\n        gl.deleteVertexArray(vao);\n      });\n    }\n  }\n  bindBufferAndAttrib(tech) {\n    const gl = this.gl;\n    const primitive = this._primitive;\n    const vertexBufferBindings = primitive.vertexBufferBindings;\n    this.attribLocArray = [];\n    const techAttributes = tech.attributes;\n    const attributes = primitive._vertexElementMap;\n    let vbo;\n    let lastBoundVbo;\n    for (const name in techAttributes) {\n      const loc = techAttributes[name].location;\n      if (loc === -1)\n        continue;\n      const semantic = techAttributes[name].semantic;\n      const element = attributes[semantic];\n      if (element) {\n        const {buffer, stride} = vertexBufferBindings[element.bindingIndex];\n        vbo = buffer._nativeBuffer;\n        if (lastBoundVbo !== vbo) {\n          lastBoundVbo = vbo;\n          gl.bindBuffer(gl.ARRAY_BUFFER, vbo);\n        }\n        gl.enableVertexAttribArray(loc);\n        const {size, type: type2} = element._glElementInfo;\n        gl.vertexAttribPointer(loc, size, type2, element.normalized, stride, element.offset);\n        if (this.canUseInstancedArrays) {\n          gl.vertexAttribDivisor(loc, element.instanceDivisor);\n        }\n        this.attribLocArray.push(loc);\n      } else {\n        Logger.warn(\"vertex attribute not found: \" + name);\n      }\n    }\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n  }\n  disableAttrib() {\n    const gl = this.gl;\n    for (let i = 0, l = this.attribLocArray.length; i < l; i++) {\n      gl.disableVertexAttribArray(this.attribLocArray[i]);\n    }\n  }\n  registerVAO(tech) {\n    const gl = this.gl;\n    const vao = gl.createVertexArray();\n    gl.bindVertexArray(vao);\n    const {indexBufferBinding} = this._primitive;\n    if (indexBufferBinding) {\n      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBufferBinding.buffer._nativeBuffer);\n    }\n    this.bindBufferAndAttrib(tech);\n    gl.bindVertexArray(null);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n    this.disableAttrib();\n    this.vao.set(tech.cacheID, vao);\n  }\n}\n\nclass GLRenderStates {\n  constructor(gl) {\n    this._stateStack = [];\n    this._parameters = {};\n    this._gl = gl;\n    this._stateStack = [];\n    this._parameters = {};\n    this._parameters[gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS] = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);\n    this._parameters[gl.MAX_VERTEX_UNIFORM_VECTORS] = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);\n    this._parameters[gl.MAX_VERTEX_ATTRIBS] = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);\n    this._parameters[gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS] = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);\n    this._parameters[gl.BLEND] = false;\n    gl.disable(gl.BLEND);\n    this._parameters[gl.CULL_FACE] = true;\n    gl.enable(gl.CULL_FACE);\n    this._parameters[gl.DEPTH_TEST] = true;\n    gl.enable(gl.DEPTH_TEST);\n    this._parameters[gl.DITHER] = false;\n    gl.disable(gl.DITHER);\n    this._parameters[gl.POLYGON_OFFSET_FILL] = false;\n    gl.disable(gl.POLYGON_OFFSET_FILL);\n    this._parameters[gl.SAMPLE_ALPHA_TO_COVERAGE] = false;\n    gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);\n    this._parameters[gl.SAMPLE_COVERAGE] = false;\n    gl.disable(gl.SAMPLE_COVERAGE);\n    this._parameters[gl.SCISSOR_TEST] = false;\n    gl.disable(gl.SCISSOR_TEST);\n    this._parameters[gl.STENCIL_TEST] = false;\n    gl.disable(gl.STENCIL_TEST);\n    this._parameters[gl.COLOR_WRITEMASK] = [true, true, true, true];\n    gl.colorMask(true, true, true, true);\n    this._parameters[gl.DEPTH_WRITEMASK] = true;\n    gl.depthMask(true);\n    this._parameters[gl.BLEND_SRC_RGB] = gl.ONE;\n    this._parameters[gl.BLEND_SRC_ALPHA] = gl.ONE;\n    this._parameters[gl.BLEND_DST_RGB] = gl.ZERO;\n    this._parameters[gl.BLEND_DST_ALPHA] = gl.ZERO;\n    gl.blendFunc(gl.ONE, gl.ZERO);\n    this._parameters[gl.BLEND_EQUATION_RGB] = gl.FUNC_ADD;\n    this._parameters[gl.BLEND_EQUATION_ALPHA] = gl.FUNC_ADD;\n    this._parameters[gl.CULL_FACE_MODE] = gl.BACK;\n    gl.cullFace(gl.BACK);\n    this._parameters[gl.FRONT_FACE] = gl.CCW;\n    gl.frontFace(gl.CCW);\n    this._parameters[gl.DEPTH_FUNC] = gl.LESS;\n    gl.depthFunc(gl.LESS);\n    this._parameters[gl.DEPTH_RANGE] = [0, 1];\n    gl.depthRange(0, 1);\n    this._parameters[gl.POLYGON_OFFSET_FACTOR] = 0;\n    this._parameters[gl.POLYGON_OFFSET_UNITS] = 0;\n    gl.polygonOffset(0, 0);\n    this._parameters[gl.SCISSOR_BOX] = [0, 0, gl.canvas.width, gl.canvas.height];\n    this._parameters[gl.STENCIL_FUNC] = gl.ALWAYS;\n    this._parameters[gl.STENCIL_VALUE_MASK] = 255;\n    this._parameters[gl.STENCIL_REF] = 0;\n    gl.stencilFunc(gl.ALWAYS, 0, 255);\n    this._parameters[gl.STENCIL_WRITEMASK] = 255;\n    gl.stencilMask(255);\n    this._parameters[gl.STENCIL_FAIL] = gl.KEEP;\n    this._parameters[gl.STENCIL_PASS_DEPTH_FAIL] = gl.KEEP;\n    this._parameters[gl.STENCIL_PASS_DEPTH_PASS] = gl.KEEP;\n  }\n  getParameter(pname) {\n    return this._parameters[pname];\n  }\n  pushStateBlock(_name) {\n    const stateBlock = {\n      name: _name,\n      states: []\n    };\n    this._stateStack.push(stateBlock);\n  }\n  popStateBlock() {\n    const stateBlock = this._stateStack.pop();\n    for (const state of stateBlock.states) {\n      const stateFunc = state.func;\n      const stateArgs = state.args;\n      const parameters = state.parameters;\n      stateFunc.apply(this._gl, stateArgs);\n      for (const param in parameters) {\n        this._parameters[param] = parameters[param];\n      }\n    }\n  }\n  _getStateStackTop() {\n    const count = this._stateStack.length;\n    if (count > 0) {\n      return this._stateStack[count - 1];\n    } else {\n      return null;\n    }\n  }\n  _pushState(_func, _args, _param) {\n    const stateBlock = this._getStateStackTop();\n    if (stateBlock) {\n      stateBlock.states.push({\n        func: _func,\n        args: _args,\n        parameters: _param\n      });\n    }\n  }\n  enable(cap) {\n    const currentState = this._parameters[cap];\n    if (currentState === true)\n      return;\n    this._parameters[cap] = true;\n    this._gl.enable(cap);\n    const pushParam = {};\n    pushParam[cap] = false;\n    this._pushState(this._gl.disable, [cap], pushParam);\n  }\n  disable(cap) {\n    const currentState = this._parameters[cap];\n    if (currentState === false)\n      return;\n    this._parameters[cap] = false;\n    this._gl.disable(cap);\n    const pushParam = {};\n    pushParam[cap] = true;\n    this._pushState(this._gl.enable, [cap], pushParam);\n  }\n  blendFunc(sfactor, dfactor) {\n    const gl = this._gl;\n    const param = this._parameters;\n    if (param[gl.BLEND_SRC_RGB] === sfactor && param[gl.BLEND_SRC_ALPHA] === sfactor && param[gl.BLEND_DST_RGB] === dfactor && param[gl.BLEND_DST_ALPHA] === dfactor)\n      return;\n    const pushArgs = [\n      param[gl.BLEND_SRC_RGB],\n      param[gl.BLEND_DST_RGB],\n      param[gl.BLEND_SRC_ALPHA],\n      param[gl.BLEND_DST_ALPHA]\n    ];\n    const pushParam = {};\n    pushParam[gl.BLEND_SRC_RGB] = param[gl.BLEND_SRC_RGB];\n    pushParam[gl.BLEND_DST_RGB] = param[gl.BLEND_DST_RGB];\n    pushParam[gl.BLEND_SRC_ALPHA] = param[gl.BLEND_SRC_ALPHA];\n    pushParam[gl.BLEND_DST_ALPHA] = param[gl.BLEND_DST_ALPHA];\n    this._pushState(gl.blendFuncSeparate, pushArgs, pushParam);\n    param[gl.BLEND_SRC_RGB] = sfactor;\n    param[gl.BLEND_SRC_ALPHA] = sfactor;\n    param[gl.BLEND_DST_RGB] = dfactor;\n    param[gl.BLEND_DST_ALPHA] = dfactor;\n    gl.blendFunc(sfactor, dfactor);\n  }\n  blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha) {\n    const gl = this._gl;\n    const param = this._parameters;\n    if (param[gl.BLEND_SRC_RGB] === srcRGB && param[gl.BLEND_SRC_ALPHA] === srcAlpha && param[gl.BLEND_DST_RGB] === dstRGB && param[gl.BLEND_DST_ALPHA] === dstAlpha)\n      return;\n    const pushArgs = [\n      param[gl.BLEND_SRC_RGB],\n      param[gl.BLEND_DST_RGB],\n      param[gl.BLEND_SRC_ALPHA],\n      param[gl.BLEND_DST_ALPHA]\n    ];\n    const pushParam = {};\n    pushParam[gl.BLEND_SRC_RGB] = param[gl.BLEND_SRC_RGB];\n    pushParam[gl.BLEND_DST_RGB] = param[gl.BLEND_DST_RGB];\n    pushParam[gl.BLEND_SRC_ALPHA] = param[gl.BLEND_SRC_ALPHA];\n    pushParam[gl.BLEND_DST_ALPHA] = param[gl.BLEND_DST_ALPHA];\n    this._pushState(gl.blendFuncSeparate, pushArgs, pushParam);\n    param[gl.BLEND_SRC_RGB] = srcRGB;\n    param[gl.BLEND_SRC_ALPHA] = srcAlpha;\n    param[gl.BLEND_DST_RGB] = dstRGB;\n    param[gl.BLEND_DST_ALPHA] = dstAlpha;\n    gl.blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);\n  }\n  blendEquationSeparate(modeRGB, modeAlpha) {\n    const gl = this._gl;\n    const param = this._parameters;\n    if (param[gl.BLEND_EQUATION_RGB] === modeRGB && param[gl.BLEND_EQUATION_ALPHA] === modeAlpha)\n      return;\n    const pushArgs = [param[gl.BLEND_EQUATION_RGB], param[gl.BLEND_EQUATION_ALPHA]];\n    const pushParam = {};\n    pushParam[gl.BLEND_EQUATION_RGB] = param[gl.BLEND_EQUATION_RGB];\n    pushParam[gl.BLEND_EQUATION_ALPHA] = param[gl.BLEND_EQUATION_ALPHA];\n    this._pushState(gl.blendEquationSeparate, pushArgs, pushParam);\n    param[gl.BLEND_EQUATION_RGB] = modeRGB;\n    param[gl.BLEND_EQUATION_ALPHA] = modeAlpha;\n    gl.blendEquationSeparate(modeRGB, modeAlpha);\n  }\n  colorMask(red, green, blue, alpha) {\n    const gl = this._gl;\n    const pushParam = {};\n    pushParam[gl.COLOR_WRITEMASK] = this._parameters[gl.COLOR_WRITEMASK];\n    this._pushState(gl.colorMask, this._parameters[gl.COLOR_WRITEMASK], pushParam);\n    this._parameters[gl.COLOR_WRITEMASK] = [red, green, blue, alpha];\n    gl.colorMask(red, green, blue, alpha);\n  }\n  depthMask(flag) {\n    const gl = this._gl;\n    if (this._parameters[gl.DEPTH_WRITEMASK] === flag)\n      return;\n    const pushParam = {};\n    pushParam[gl.DEPTH_WRITEMASK] = this._parameters[gl.DEPTH_WRITEMASK];\n    this._pushState(gl.depthMask, [this._parameters[gl.DEPTH_WRITEMASK]], pushParam);\n    this._parameters[gl.DEPTH_WRITEMASK] = flag;\n    gl.depthMask(flag);\n  }\n  cullFace(mode) {\n    const gl = this._gl;\n    if (this._parameters[gl.CULL_FACE_MODE] === mode)\n      return;\n    const pushParam = {};\n    pushParam[gl.CULL_FACE_MODE] = this._parameters[gl.CULL_FACE_MODE];\n    this._pushState(gl.cullFace, [this._parameters[gl.CULL_FACE_MODE]], pushParam);\n    this._parameters[gl.CULL_FACE_MODE] = mode;\n    gl.cullFace(mode);\n  }\n  frontFace(mode) {\n    const gl = this._gl;\n    if (this._parameters[gl.FRONT_FACE] === mode)\n      return;\n    const pushParam = {};\n    pushParam[gl.FRONT_FACE] = this._parameters[gl.FRONT_FACE];\n    this._pushState(gl.frontFace, [this._parameters[gl.FRONT_FACE]], pushParam);\n    this._parameters[gl.FRONT_FACE] = mode;\n    gl.frontFace(mode);\n  }\n  depthFunc(func) {\n    const gl = this._gl;\n    if (this._parameters[gl.DEPTH_FUNC] === func)\n      return;\n    const pushParam = {};\n    pushParam[gl.DEPTH_FUNC] = this._parameters[gl.DEPTH_FUNC];\n    this._pushState(gl.depthFunc, [this._parameters[gl.DEPTH_FUNC]], pushParam);\n    this._parameters[gl.DEPTH_FUNC] = func;\n    gl.depthFunc(func);\n  }\n  depthRange(zNear, zFar) {\n    const gl = this._gl;\n    const currentValue = this._parameters[gl.DEPTH_RANGE];\n    if (currentValue[0] === zNear && currentValue[1] === zFar)\n      return;\n    const pushParam = {};\n    pushParam[gl.DEPTH_RANGE] = currentValue;\n    this._pushState(gl.depthRange, [this._parameters[gl.DEPTH_RANGE]], pushParam);\n    this._parameters[gl.DEPTH_RANGE] = [zNear, zFar];\n    gl.depthRange(zNear, zFar);\n  }\n  polygonOffset(factor, units) {\n    const gl = this._gl;\n    if (this._parameters[gl.POLYGON_OFFSET_FACTOR] === factor && this._parameters[gl.POLYGON_OFFSET_UNITS] === units)\n      return;\n    const pushParam = {};\n    pushParam[gl.POLYGON_OFFSET_FACTOR] = this._parameters[gl.POLYGON_OFFSET_FACTOR];\n    pushParam[gl.POLYGON_OFFSET_UNITS] = this._parameters[gl.POLYGON_OFFSET_UNITS];\n    this._pushState(gl.polygonOffset, [this._parameters[gl.POLYGON_OFFSET_FACTOR], this._parameters[gl.POLYGON_OFFSET_UNITS]], pushParam);\n    this._parameters[gl.POLYGON_OFFSET_FACTOR] = factor;\n    this._parameters[gl.POLYGON_OFFSET_UNITS] = units;\n    gl.polygonOffset(factor, units);\n  }\n  scissor(x, y, width, height) {\n    const gl = this._gl;\n    const box = this._parameters[gl.SCISSOR_BOX];\n    if (box[0] === x && box[1] === y && box[2] === width && box[3] === height)\n      return;\n    const pushParam = {};\n    pushParam[gl.SCISSOR_BOX] = box;\n    this._pushState(gl.scissor, box, pushParam);\n    this._parameters[gl.SCISSOR_BOX] = [x, y, width, height];\n    gl.scissor(x, y, width, height);\n  }\n  stencilFunc(func, ref, mask) {\n    const gl = this._gl;\n    if (this._parameters[gl.STENCIL_FUNC] === func && this._parameters[gl.STENCIL_REF] === ref && this._parameters[gl.STENCIL_VALUE_MASK] === mask)\n      return;\n    const pushArgs = [\n      this._parameters[gl.STENCIL_FUNC],\n      this._parameters[gl.STENCIL_REF],\n      this._parameters[gl.STENCIL_VALUE_MASK]\n    ];\n    const pushParam = {};\n    pushParam[gl.STENCIL_FUNC] = pushArgs[0];\n    pushParam[gl.STENCIL_REF] = pushArgs[1];\n    pushParam[gl.STENCIL_VALUE_MASK] = pushArgs[2];\n    this._pushState(gl.stencilFunc, pushArgs, pushParam);\n    this._parameters[gl.STENCIL_FUNC] = func;\n    this._parameters[gl.STENCIL_REF] = ref;\n    this._parameters[gl.STENCIL_VALUE_MASK] = mask;\n    gl.stencilFunc(func, ref, mask);\n  }\n  stencilOp(fail, zfail, zpass) {\n    const gl = this._gl;\n    if (this._parameters[gl.STENCIL_FAIL] === fail && this._parameters[gl.STENCIL_PASS_DEPTH_FAIL] === zfail && this._parameters[gl.STENCIL_PASS_DEPTH_PASS] === zpass)\n      return;\n    const pushArgs = [\n      this._parameters[gl.STENCIL_FAIL],\n      this._parameters[gl.STENCIL_PASS_DEPTH_FAIL],\n      this._parameters[gl.STENCIL_PASS_DEPTH_PASS]\n    ];\n    const pushParam = {};\n    pushParam[gl.STENCIL_FAIL] = pushArgs[0];\n    pushParam[gl.STENCIL_PASS_DEPTH_FAIL] = pushArgs[1];\n    pushParam[gl.STENCIL_PASS_DEPTH_PASS] = pushArgs[2];\n    this._pushState(gl.stencilOp, pushArgs, pushParam);\n    this._parameters[gl.STENCIL_FAIL] = fail;\n    this._parameters[gl.STENCIL_BACK_PASS_DEPTH_FAIL] = zfail;\n    this._parameters[gl.STENCIL_PASS_DEPTH_PASS] = zpass;\n    gl.stencilOp(fail, zfail, zpass);\n  }\n  stencilMask(mask) {\n    const gl = this._gl;\n    if (this._parameters[gl.STENCIL_WRITEMASK] === mask)\n      return;\n    const pushParam = {};\n    pushParam[gl.STENCIL_WRITEMASK] = this._parameters[gl.STENCIL_WRITEMASK];\n    this._pushState(gl.stencilMask, [this._parameters[gl.STENCIL_WRITEMASK]], pushParam);\n    this._parameters[gl.STENCIL_WRITEMASK] = mask;\n    gl.stencilMask(mask);\n  }\n}\n\nclass GLSprite {\n  constructor(gl) {\n    this.gl = gl;\n    this._initVertexAttributes(gl);\n    this._vbo = gl.createBuffer();\n    this._maxBatchCount = 0;\n    this._vertBuffer = null;\n    this._vertCursor = 0;\n    this._drawSpriteCount = 0;\n  }\n  setMaxBatchCount(count) {\n    const requireSize = count * 6 * 9;\n    if (this._vertBuffer && this._vertBuffer.length >= requireSize) {\n      return;\n    }\n    this._maxBatchCount = count;\n    this._vertBuffer = new Float32Array(requireSize);\n  }\n  beginDraw(count) {\n    this._vertCursor = 0;\n    this._drawSpriteCount = 0;\n    if (count > this._maxBatchCount) {\n      this.setMaxBatchCount(count);\n    }\n  }\n  drawSprite(positionQuad, uvRect, tintColor) {\n    this._drawSpriteCount++;\n    if (this._drawSpriteCount > this._maxBatchCount) {\n      Logger.warn(\"Sprite: sprite count overflow\");\n      return;\n    }\n    const color = tintColor;\n    const u = uvRect.u;\n    const v = uvRect.v;\n    const p = uvRect.u + uvRect.width;\n    const q = uvRect.v + uvRect.height;\n    this._pushVertex(positionQuad.leftTop, new Vector2(u, v), color);\n    this._pushVertex(positionQuad.leftBottom, new Vector2(u, q), color);\n    this._pushVertex(positionQuad.rightBottom, new Vector2(p, q), color);\n    this._pushVertex(positionQuad.rightBottom, new Vector2(p, q), color);\n    this._pushVertex(positionQuad.rightTop, new Vector2(p, v), color);\n    this._pushVertex(positionQuad.leftTop, new Vector2(u, v), color);\n  }\n  endDraw() {\n    const vertCount = this._vertCursor / 9;\n    if (vertCount <= 0)\n      return;\n    var gl = this.gl;\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n    gl.bindBuffer(gl.ARRAY_BUFFER, this._vbo);\n    gl.bufferData(gl.ARRAY_BUFFER, this._vertBuffer, gl.DYNAMIC_DRAW);\n    for (let i = 0, len = this._vertAttributes.length; i < len; i++) {\n      const attrib = this._vertAttributes[i];\n      gl.vertexAttribPointer(attrib.lastShaderLoc, attrib.size, attrib.type, attrib.normalized, attrib.stride, attrib.offset);\n      gl.enableVertexAttribArray(attrib.lastShaderLoc);\n    }\n    gl.drawArrays(gl.TRIANGLES, 0, vertCount);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    for (let i = 0, len = this._vertAttributes.length; i < len; i++) {\n      gl.disableVertexAttribArray(this._vertAttributes[i].lastShaderLoc);\n    }\n  }\n  _initVertexAttributes(gl) {\n    const vertexStride = (3 + 2 + 4) * 4;\n    const posAtt = {};\n    posAtt.name = \"a_pos\";\n    posAtt.size = 3;\n    posAtt.offset = 0;\n    posAtt.lastShaderLoc = 0;\n    const uvAtt = {};\n    uvAtt.name = \"a_uv\";\n    uvAtt.size = 2;\n    uvAtt.offset = 3 * 4;\n    uvAtt.lastShaderLoc = 1;\n    const colorAtt = {};\n    colorAtt.name = \"a_color\";\n    colorAtt.size = 4;\n    colorAtt.offset = 5 * 4;\n    colorAtt.lastShaderLoc = 2;\n    this._vertAttributes = [posAtt, uvAtt, colorAtt];\n    for (const att of this._vertAttributes) {\n      att.type = gl.FLOAT;\n      att.normalized = false;\n      att.stride = vertexStride;\n    }\n  }\n  _pushVertex(pos, uv, color) {\n    const vb = this._vertBuffer;\n    const id = this._vertCursor;\n    vb[id] = pos.x;\n    vb[id + 1] = pos.y;\n    vb[id + 2] = pos.z;\n    vb[id + 3] = uv.x;\n    vb[id + 4] = uv.y;\n    vb[id + 5] = color.x;\n    vb[id + 6] = color.y;\n    vb[id + 7] = color.z;\n    vb[id + 8] = color.w;\n    this._vertCursor += 9;\n  }\n  finalize() {\n    if (this._vbo) {\n      this.gl.deleteBuffer(this._vbo);\n      this._vbo = null;\n    }\n  }\n}\n\nconst SpriteVertShader = `\nprecision highp float;\n\nuniform mat4 matProjection;\nuniform mat4 matView;\n\nattribute vec3 a_pos;\nattribute vec2 a_uv;\nattribute vec4 a_color;\n\nvarying vec2 v_uv;\nvarying vec4 v_color;\n\nvoid main()\n{\n  gl_Position = matProjection * matView * vec4(a_pos,1.0);\n  v_uv = a_uv;\n  v_color = a_color;\n}\n`;\nconst SpriteFragmentShader = `\nprecision mediump float;\nprecision mediump int;\n\nuniform sampler2D s_diffuse;\nvarying vec2 v_uv;\nvarying vec4 v_color;\n\nvoid main()\n{\n  // \\u53EA\\u4F7F\\u7528\\u8D34\\u56FE\\u7684Alpha\\u505AMask\\uFF0C\\u8FD9\\u6837Tint Color\\u4F9D\\u7136\\u53EF\\u4EE5\\u63A7\\u5236\\u63A7\\u4EF6Fade Out\n  vec4 baseColor = texture2D(s_diffuse, v_uv);\n  gl_FragColor = baseColor * v_color;\n}\n`;\nconst SpriteTechnique = {\n  name: \"spriteTech3D\",\n  vertexShader: SpriteVertShader,\n  fragmentShader: SpriteFragmentShader,\n  attribLocSet: {\n    a_pos: 0,\n    a_uv: 1,\n    a_color: 2\n  },\n  attributes: {\n    a_pos: {\n      name: \"a_pos\",\n      semantic: \"POSITION\",\n      type: DataType.FLOAT_VEC3\n    },\n    a_uv: {\n      name: \"a_uv\",\n      semantic: \"TEXCOORD_0\",\n      type: DataType.FLOAT_VEC2\n    },\n    a_color: {\n      name: \"a_color\",\n      semantic: \"COLOR\",\n      type: DataType.FLOAT_VEC3\n    }\n  },\n  uniforms: {\n    matProjection: {\n      name: \"matProjection\",\n      semantic: UniformSemantic.PROJECTION,\n      type: DataType.FLOAT_MAT4\n    },\n    matView: {\n      name: \"matView\",\n      semantic: UniformSemantic.VIEW,\n      type: DataType.FLOAT_MAT4\n    },\n    s_diffuse: {\n      name: \"s_diffuse\",\n      type: DataType.SAMPLER_2D\n    }\n  },\n  states: {\n    disable: [RenderState.CULL_FACE],\n    enable: [RenderState.BLEND],\n    functions: {\n      blendFunc: [BlendFunc.SRC_ALPHA, BlendFunc.ONE_MINUS_SRC_ALPHA],\n      depthMask: [false]\n    }\n  }\n};\nfunction createSpriteMaterial() {\n  const values = {};\n  return {\n    values,\n    setValue: (key, val) => {\n      values[key] = val;\n    },\n    getValue: (key) => {\n      return values[key];\n    }\n  };\n}\n\nclass GLSpriteBatcher {\n  constructor(rhi) {\n    this._gl = rhi.gl;\n    this._batchedQueue = [];\n    this._targetTexture = null;\n    this._glSprite = new GLSprite(rhi.gl);\n    this._glTech = new GLTechnique(rhi, SpriteTechnique);\n    this._material = createSpriteMaterial();\n    this._camera = null;\n  }\n  flush() {\n    if (this._batchedQueue.length === 0) {\n      return;\n    }\n    if (!this._targetTexture) {\n      Logger.error(\"No texture!\");\n      return;\n    }\n    this._material.setValue(\"s_diffuse\", this._targetTexture);\n    this._material.setValue(\"matView\", this._camera.viewMatrix);\n    this._material.setValue(\"matProjection\", this._camera.projectionMatrix);\n    this._glTech.begin(this._material);\n    this._glSprite.beginDraw(this._batchedQueue.length);\n    for (let i = 0, len = this._batchedQueue.length; i < len; i++) {\n      const positionQuad = this._batchedQueue[i].positionQuad;\n      const uvRect = this._batchedQueue[i].uvRect;\n      const tintColor = this._batchedQueue[i].tintColor;\n      this._glSprite.drawSprite(positionQuad, uvRect, tintColor);\n    }\n    this._glSprite.endDraw();\n    this._glTech.end();\n    this._batchedQueue = [];\n    this._targetTexture = null;\n    this._camera = null;\n  }\n  canBatch(texture, renderMode, camera) {\n    if (this._targetTexture === null) {\n      return true;\n    }\n    return texture === this._targetTexture && camera === this._camera;\n  }\n  drawSprite(positionQuad, uvRect, tintColor, texture, renderMode, camera) {\n    if (!this.canBatch(texture, renderMode, camera)) {\n      this.flush();\n    }\n    this._targetTexture = texture;\n    this._camera = camera;\n    this._batchedQueue.push({positionQuad, uvRect, tintColor});\n  }\n  finalize() {\n    this._glSprite.finalize();\n    this._glTech.finalize();\n  }\n}\n\nvar WebGLMode;\n(function(WebGLMode2) {\n  WebGLMode2[WebGLMode2[\"Auto\"] = 0] = \"Auto\";\n  WebGLMode2[WebGLMode2[\"WebGL2\"] = 1] = \"WebGL2\";\n  WebGLMode2[WebGLMode2[\"WebGL1\"] = 2] = \"WebGL1\";\n})(WebGLMode || (WebGLMode = {}));\nclass WebGLRenderer {\n  get isWebGL2() {\n    return this._isWebGL2;\n  }\n  constructor(options = {}) {\n    this._options = options;\n  }\n  init(canvas, engine) {\n    const option = this._options;\n    this._engine = engine;\n    const webCanvas = canvas._webCanvas;\n    const webGLMode = option.webGLMode || 0;\n    let gl;\n    if (webGLMode == 0 || webGLMode == 1) {\n      gl = webCanvas.getContext(\"webgl2\", option);\n      if (!gl && webCanvas instanceof HTMLCanvasElement) {\n        gl = webCanvas.getContext(\"experimental-webgl2\", option);\n      }\n      this._isWebGL2 = true;\n    }\n    if (!gl) {\n      if (webGLMode == 0 || webGLMode == 2) {\n        gl = webCanvas.getContext(\"webgl\", option);\n        if (!gl && webCanvas instanceof HTMLCanvasElement) {\n          gl = webCanvas.getContext(\"experimental-webgl\", option);\n        }\n        this._isWebGL2 = false;\n      }\n    }\n    if (!gl) {\n      throw new Error(\"Get GL Context FAILED.\");\n    }\n    this._gl = gl;\n    this._renderStates = new GLRenderStates(gl);\n    this._assetsCache = new GLAssetsCache(this, option);\n    this._extensions = new GLExtensions(this);\n    this._capability = new GLCapability(this);\n    this._frameCount = 0;\n    this._options = null;\n  }\n  createPlatformPrimitive(primitive) {\n    return new GLPrimitive(this, primitive);\n  }\n  get gl() {\n    return this._gl;\n  }\n  get assetsCache() {\n    return this._assetsCache;\n  }\n  get renderStates() {\n    return this._renderStates;\n  }\n  get capability() {\n    return this._capability;\n  }\n  get frameCount() {\n    return this._frameCount;\n  }\n  requireExtension(ext) {\n    return this._extensions.requireExtension(ext);\n  }\n  canIUse(capabilityType) {\n    return this.capability.canIUse(capabilityType);\n  }\n  canIUseCompressedTextureInternalFormat(type2) {\n    return this.capability.canIUseCompressedTextureInternalFormat(type2);\n  }\n  get canIUseMoreJoints() {\n    return this.capability.canIUseMoreJoints;\n  }\n  viewport(x, y, width, height) {\n    const gl = this._gl;\n    gl.viewport(x, gl.drawingBufferHeight - y - height, width, height);\n  }\n  colorMask(r, g, b, a) {\n    this._gl.colorMask(r, g, b, a);\n  }\n  beginFrame() {\n    this._frameCount++;\n  }\n  clearRenderTarget(clearMode, clearParam) {\n    const gl = this._gl;\n    switch (clearMode) {\n      case ClearMode.SOLID_COLOR:\n        gl.clearColor(clearParam.x, clearParam.y, clearParam.z, clearParam.w);\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n        break;\n      case ClearMode.DEPTH_ONLY:\n        gl.clear(gl.DEPTH_BUFFER_BIT);\n        break;\n      case ClearMode.COLOR_ONLY:\n        gl.clearColor(clearParam.x, clearParam.y, clearParam.z, clearParam.w);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n        break;\n      case ClearMode.STENCIL_ONLY:\n        gl.clear(gl.STENCIL_BUFFER_BIT);\n        break;\n      case ClearMode.ALL_CLEAR:\n        gl.clearColor(clearParam.x, clearParam.y, clearParam.z, clearParam.w);\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);\n        break;\n      case ClearMode.DONT_CLEAR:\n        break;\n    }\n  }\n  drawPrimitive(primitive, group, mtl) {\n    let glTech = mtl.technique._glTechnique;\n    glTech || (glTech = mtl.technique._glTechnique = new GLTechnique(this, mtl.technique));\n    if (!glTech.valid)\n      return;\n    if (primitive && glTech) {\n      glTech.begin(mtl);\n      primitive.draw(glTech, group);\n      glTech.end();\n    } else {\n      Logger.error(\"draw primitive failed.\");\n    }\n  }\n  drawSprite(positionQuad, uvRect, tintColor, texture, renderMode, camera) {\n    if (!this._spriteBatcher) {\n      this._spriteBatcher = new GLSpriteBatcher(this);\n    }\n    this._spriteBatcher.drawSprite(positionQuad, uvRect, tintColor, texture, renderMode, camera);\n  }\n  flushSprite() {\n    if (this._spriteBatcher) {\n      this._spriteBatcher.flush();\n    }\n  }\n  activeRenderTarget(renderTarget, camera) {\n    const gl = this._gl;\n    if (renderTarget) {\n      renderTarget._activeRenderTarget();\n      const {width, height} = renderTarget;\n      gl.viewport(0, 0, width, height);\n    } else {\n      gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n      const viewport = camera.viewport;\n      const width = gl.drawingBufferWidth;\n      const height = gl.drawingBufferHeight;\n      this.viewport(viewport.x * width, viewport.y * height, viewport.z * width, viewport.w * height);\n    }\n  }\n  blitRenderTarget(renderTarget) {\n    if (renderTarget) {\n      if (renderTarget._MSAAFrameBuffer) {\n        renderTarget._blitRenderTarget();\n        return;\n      }\n    }\n  }\n  setRenderTargetFace(renderTarget, faceIndex) {\n    if (renderTarget) {\n      renderTarget._setRenderTargetFace(faceIndex);\n    }\n  }\n  endFrame() {\n    const CHECK_FREQ = 8;\n    if (this._frameCount % CHECK_FREQ === 0) {\n      this._assetsCache.compact();\n    }\n  }\n  destroy() {\n    this._assetsCache.finalize();\n  }\n}\n\nclass WebGLEngine extends Engine {\n  constructor(canvas, webGLRendererOptions) {\n    const webCanvas = new WebCanvas(typeof canvas === \"string\" ? document.getElementById(canvas) : canvas);\n    const hardwareRenderer = new WebGLRenderer(webGLRendererOptions);\n    super(webCanvas, hardwareRenderer);\n  }\n  get canvas() {\n    return this._canvas;\n  }\n}\n\nexport { GLShaderProgram, GLTechnique, GLTexture, WebCanvas, WebGLEngine, WebGLMode, WebGLRenderer };\n//# sourceMappingURL=module.js.map\n","export * from \"@oasis-engine/core\";\nexport * from \"@oasis-engine/loader\";\nexport * from \"@oasis-engine/math\";\nexport * from \"@oasis-engine/rhi-webgl\";\nimport {\n  BoxCollider,\n  SphereCollider,\n  AmbientLight,\n  Camera,\n  Component,\n  DirectLight,\n  EnvironmentMapLight,\n  GeometryRenderer,\n  Particle,\n  PointLight,\n  SkyBox,\n  SpriteRenderer,\n  PlaneProbe,\n  Model\n} from \"@oasis-engine/core\";\nimport { Parser, GLTFModel } from \"@oasis-engine/loader\";\n\nParser.registerComponents(\"o3\", {\n  GLTFModel,\n  SpriteRenderer,\n  PointLight,\n  AmbientLight,\n  DirectLight,\n  EnvironmentMapLight,\n  Particle,\n  SkyBox,\n  BoxCollider,\n  GeometryRenderer,\n  Camera,\n  Component,\n  SphereCollider,\n  PlaneProbe,\n  Model\n});\n\n//@ts-ignore\nexport const version = `__buildVersion`;\n\nconsole.log(`oasis engine version: ${version}`);\n"],"names":["AssetPromiseStatus","__decorate","AssetType","Parser","registerComponents","GLTFModel","SpriteRenderer","PointLight","AmbientLight","DirectLight","EnvironmentMapLight","Particle","SkyBox","BoxCollider","GeometryRenderer","Camera","Component","SphereCollider","PlaneProbe","Model","version","console","log"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAGY;;EAAL,CAAA,UAAA,cAAA,EAAA;EAEL,EAAA,cAAA,CAAA,cAAA,CAAA,SAAA,CAAA,GAAA,CAAA,CAAA,GAAA,SAAA;EAEA,EAAA,cAAA,CAAA,cAAA,CAAA,WAAA,CAAA,GAAA,CAAA,CAAA,GAAA,WAAA;EAEA,EAAA,cAAA,CAAA,cAAA,CAAA,SAAA,CAAA,GAAA,CAAA,CAAA,GAAA,SAAA;EAAA,CANK,EAAK,aAAA,KAAA,aAAA,GAAA,EAAA,CAAL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ECEA,CAAA,UAAA,mBAAA,EAAA;EAEL,EAAA,mBAAA,CAAA,mBAAA,CAAA,SAAA,CAAA,GAAA,CAAA,CAAA,GAAA,SAAA;EAEA,EAAA,mBAAA,CAAA,mBAAA,CAAA,SAAA,CAAA,GAAA,CAAA,CAAA,GAAA,SAAA;EAEA,EAAA,mBAAA,CAAA,mBAAA,CAAA,QAAA,CAAA,GAAA,CAAA,CAAA,GAAA,QAAA;EAAA,CANK,EAAKA,0BAAA,KAAAA,0BAAA,GAAA,EAAA,CAAL;;;;;;;;;iCA4JL,UAAA;EACE,WAAK,UAAL,CAAgB,GAAhB,CAAoB,QAApB;;EACA,aAAO,IAAP;EAAO;;;+BAOT;EACE,UAAI,KAAK,OAAL,KAAiB,CAArB,EAAqB;EACnB,eAAO,IAAP;EAAO;;EAET,WAAK,OAAL,CAAa,kBAAb;;EACA,aAAO,IAAP;EAAO;;;0BA9BL;EACF,aAAO,KAAK,OAAZ;EAAY;;;0BAMV;EACF,aAAO,KAAK,SAAZ;EAAY;;;0BA3CP,UAAA;EACL,aAAO,IAAI,YAAJ,CAAiB,UAAA,OAAA,EAAA,MAAA,EAAA,WAAA,EAAA;EACtB,YAAI,CAAC,KAAA,CAAM,OAAN,CAAc,QAAd,CAAL,EAAmB;EACjB,iBAAO,OAAA,CAAQ,CAAC,QAAD,CAAR,CAAP;EAAgB;;EAGlB,YAAA,SAAA,GAAgB,CAAhB;EACA,YAAA,KAAA,GAAY,QAAA,CAAS,MAArB;EACA,YAAA,OAAA,GAAc,IAAI,KAAJ,CAAa,KAAb,CAAd;EAEA,QAAA,QAAA,CAAS,OAAT,CAAiB,UAAA,KAAA,EAAA,KAAA,EAAA;EACf,UAAA,OAAA,CAAQ,OAAR,CAAgB,KAAhB,EACG,IADH,CACQ,UAAA,MAAA,EAAA;EACJ,YAAA,OAAA,CAAQ,KAAR,CAAA,GAAiB,MAAjB;EAEA,YAAA,SAAA,IAAa,CAAb;EACA,YAAA,WAAA,CAAY,SAAA,GAAY,KAAxB,CAAA;;EAEA,gBAAI,SAAA,IAAa,KAAjB,EAAiB;EACf,cAAA,OAAA,CAAQ,OAAR,CAAA;EAAQ;EAAA,WARd,WAWS,UAAA,GAAA;EAAA,mBAAS,MAAA,CAAO,GAAP,CAAT;EAAA,WAXT;EAWyB,SAZ3B;EAY2B,OArBtB,CAAP;EAqB6B;;;EAqD/B,wBAAA,QAAA,EAAA;EAAA;;EAAA;;EAOE,QAAA,SAAA;;EAEA,QAAA,WAAA,GAAoB,SAApB,WAAoB,CAAA,QAAA,EAAA;EAClB,UAAI,QAAA,IAAY,MAAK,SAArB,EAAqB;EACnB;EAAA;;EAEF,YAAK,SAAL,GAAiB,QAAjB;;EAJkB,iDAMK,MAAK,UANV;EAAA;;EAAA;EAMlB,4DAA4B;EAAA,cAA5B,QAA4B;EAC1B,UAAA,QAAA,CAAS,QAAT,CAAA;EAAS;EAPO;EAAA;EAAA;EAAA;EAAA;EAOP,KAPb;;EAWA,8BAAM,UAAA,OAAA,EAAA,MAAA,EAAA;EACJ,MAAA,SAAA,GAAY,mBAAA,MAAA,EAAA;EAEV,QAAA,OAAA,CAAQ,OAAR,GAAkB,IAAlB,CAAuB,YAAA;EACrB,gBAAK,OAAL,GAAe,CAAf;EACA,UAAA,MAAA,CAAO,MAAP,CAAA;EAAO,SAFT;EAES,OAJX;;EAOA,MAAA,QAAA,CACE,UAAA,KAAA,EAAA;EAEE,QAAA,OAAA,CAAQ,OAAR,GAAkB,IAAlB,CAAuB,YAAA;EACrB,UAAA,WAAA,CAAY,CAAZ,CAAA;EACA,gBAAK,OAAL,GAAe,CAAf;EACA,UAAA,OAAA,CAAQ,KAAR,CAAA;EAAQ,SAHV;EAGU,OANd,EASE,SATF,EAUE,UAAA,QAAA,EAAA;EAEE,QAAA,OAAA,CAAQ,OAAR,GAAkB,IAAlB,CAAuB,YAAA;EACrB,UAAA,WAAA,CAAY,QAAZ,CAAA;EAAY,SADd;EACc,OAblB,CAAA;EAakB,KArBpB;EA0BA,UAAK,OAAL,GAAe,SAAf;EACA,UAAK,UAAL,GAAkB,IAAI,GAAJ,EAAlB;EACA,UAAK,SAAL,GAAiB,CAAjB;EACA,UAAK,OAAL,GAAe,CAAf;EAjDF;EAiDiB;;;mCA1NkB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ECFnC,uBAAY,eAAZ,EAAY,iBAAZ,EAAY;EAAA;;EAAA;;EARJ,SAAA,MAAA,GAAuC,EAAvC;EAEA,SAAA,YAAA,GAAuB,CAAvB;EACA,SAAA,UAAA,GAAmD,EAAnD;EAMN,SAAK,OAAL,GAAe,IAAI,MAAJ,CAAW,eAAX,CAAf;;EACA,SAAK,OAAL,CAAa,SAAb,GAAyB,UAAA,CAAA,EAAA;EACvB,UAAA,OAAA,GAAgB,CAAA,CAAE,IAAlB;;EACA,cAAQ,OAAA,CAAQ,IAAhB;EAAgB,aACT,QADS;EAEZ,UAAA,KAAA,CAAK,UAAL,CAAgB,OAAA,CAAQ,EAAxB,EAA4B,OAA5B,CAAoC,OAAA,CAAQ,QAA5C;;EACA;;EAAA,aAEG,OAFH;EAGA,UAAA,KAAA,CAAK,UAAL,CAAgB,OAAA,CAAQ,EAAxB,EAA4B,MAA5B,CAAmC,OAAnC;;EACA;;EAAA;EAEA,UAAA,MAAA,CAAO,KAAP,CAAa,uCAAuC,OAAA,CAAQ,IAA/C,GAAsD,GAAnE;EATJ;EASuE,KAXzE;;EAcA,QAAI,iBAAJ,EAAI;EACF,WAAK,OAAL,CAAa,WAAb,CAAyB;EAAE,QAAA,IAAA,EAAM,MAAR;EAAgB,QAAA,aAAA,EAAe;EAAE,UAAA,UAAA,EAAY;EAAd;EAA/B,OAAzB;EAAsE,KADxE,MACwE;EAEtE,WAAK,OAAL,CAAa,WAAb,CAAyB;EAAE,QAAA,IAAA,EAAM,MAAR;EAAgB,QAAA,aAAA,EAAe;EAA/B,OAAzB;EAAwD;EAAA;;;;+BAI5D,QAAA,MAAA;EACE,WAAK,MAAL,CAAY,MAAZ,IAAsB,IAAtB;EAAsB;;;qCAGxB,MAAA;EACE,WAAK,YAAL,IAAqB,IAArB;EAAqB;;;kCAGvB,QAAA,SAAA,QAAA;EACE,WAAK,UAAL,CAAgB,MAAhB,IAA0B;EAAE,QAAA,OAAA,EAAA,OAAF;EAAW,QAAA,MAAA,EAAA;EAAX,OAA1B;EAAqC;;;6BAGvC,QAAA,YAAA,QAAA;EACE,WAAK,OAAL,CAAa,WAAb,CAAyB;EAAE,QAAA,IAAA,EAAM,QAAR;EAAkB,QAAA,EAAA,EAAI,MAAtB;EAA8B,QAAA,UAAA,EAAA,UAA9B;EAA0C,QAAA,MAAA,EAAA;EAA1C,OAAzB,EAA6E,CAAC,MAAD,CAA7E;EAA8E;;;kCAGhF,QAAA;EACE,WAAK,YAAL,IAAqB,KAAK,MAAL,CAAY,MAAZ,CAArB;EACA,aAAO,KAAK,UAAL,CAAgB,MAAhB,CAAP;EACA,aAAO,KAAK,MAAL,CAAY,MAAZ,CAAP;EAAmB;;;0BA9CjB;EACF,aAAO,KAAK,YAAZ;EAAY;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ECThB,SAAA,QAAA,CAAkB,GAAlB,EAAkB;EAChB,SAAO,sBAAsB,IAAtB,CAA2B,GAA3B,CAAP;EAAkC;;EAHpC,IAAA,YAAA;EAAA;;EAAA;;EAAA;EAAA;;EAAA;EAAA;;EAAA;EAAA;EAAA,yBAOE,IAPF,EAOE;EACE,UAAA,GAAA,GAAY,IAAA,CAAK,GAAjB;;EACA,UAAI,QAAA,CAAS,GAAT,CAAJ,EAAa;EACX,eAAO,IAAI,YAAJ,CAAiB,UAAA,OAAA,EAAA;EACtB,cAAA,SAAA,GAAkB,GAAA,CAAI,KAAJ,CAAU,KAAK,MAAA,CAAO,EAAP,CAAU,MAAzB,CAAlB;EACA,cAAA,MAAA,GAAe,UAAA,CAAW,IAAX,CAAgB,IAAA,CAAK,SAAL,CAAhB,EAAiC,UAAA,CAAA;EAAA,mBAAO,CAAA,CAAE,UAAF,CAAa,CAAb,CAAP;EAAA,WAAjC,CAAf;EACA,UAAA,OAAA,CAAQ,MAAA,CAAO,MAAf,CAAA;EAAe,SAHV,CAAP;EAGiB;;EAGnB,aAAO,KAAK,OAAL,CAAa,GAAb,oCACF,IADE;EAEL,QAAA,IAAA,EAAM;EAFD,SAAP;EAEQ;EAlBZ;;EAAA;EAAA,EAM2B,MAN3B,CAAA;;EAAA,YAAA,GAAAC,YAAA,CAAA,CAKC,cAAA,CAAeC,iBAAA,CAAU,MAAzB,EAAiC,CAAC,KAAD,EAAQ,OAAR,CAAjC,EAAmD,KAAnD,CALD,CAAA,EAAA,YAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ECYA,IAAI,WAAA,GAAsC,EAA1C;;EAEA,SAAA,UAAA,CAAA,GAAA,EAAA;EACE,MAAA,KAAA,GAAc,GAAA,CAAI,KAAJ,CAAU,IAAV,CAAd;EACA,MAAA,WAAA,GAAqB,CAAA,KAAA,CAAM,MAAN,GAAe,CAAf,EAAkB,QAAlB,GAA6B,MAA7B,GAAsC,CAA3D;EACA,MAAA,MAAA;EACA,SAAO,KAAA,CACJ,GADI,CACA,UAAA,IAAA,EAAA,KAAA,EAAA;EACH,IAAA,MAAA,eAAc,KAAA,GAAQ,CAAtB,CAAA;EACA,QAAI,MAAA,CAAO,MAAP,IAAiB,WAArB,EAAkC,OAAO,MAAA,CAAO,SAAP,CAAiB,CAAjB,EAAoB,WAApB,IAAmC,IAA1C;;EAElC,SAAA,IAAA,CAAA,GAAa,CAAb,EAAgB,CAAA,GAAI,WAAA,GAAc,MAAA,CAAO,MAAzC,EAAiD,CAAA,EAAjD;EAAsD,MAAA,MAAA,IAAU,GAAV;EAAtD;;EAEA,WAAO,MAAA,GAAS,IAAhB;EAAgB,GAPb,EASJ,IATI,CASC,IATD,CAAP;EASQ;;;EA2DR,2BAAA,EAAA,EAAA,OAAA,EAAA;EAAA;;EAA+C,SAAA,OAAA,GAAA,OAAA;EAC7C,SAAK,GAAL,GAAW,EAAX;EAGA,SAAK,aAAL,GAAqB,IAArB;EAGA,SAAK,eAAL,GAAuB,IAAvB;EAGA,SAAK,mBAAL,GAA2B,IAA3B;EACA,SAAK,qBAAL,GAA6B,IAA7B;EAGA,SAAK,QAAL,GAAgB,IAAhB;EAGA,SAAK,eAAL,GAAuB,EAAvB;EACA,SAAK,aAAL,GAAqB,EAArB;EAAqB;;;;uCAiBvB,cAAA,gBAAA,cAAA;EACE,UAAA,EAAA,GAAW,KAAK,GAAhB;;EAGA,UAAA,YAAA,GAAqB,KAAK,cAAL,CAAoB,EAAA,CAAG,aAAvB,EAAsC,YAAtC,CAArB;;EACA,UAAI,CAAC,YAAL,EAAK;EACH,eAAO,KAAP;EAAO;;EAGT,UAAA,cAAA,GAAuB,KAAK,cAAL,CAAoB,EAAA,CAAG,eAAvB,EAAwC,cAAxC,CAAvB;;EACA,UAAI,CAAC,cAAL,EAAK;EACH,eAAO,KAAP;EAAO;;EAIT,UAAA,OAAA,GAAgB,EAAA,CAAG,aAAH,EAAhB;EACA,MAAA,EAAA,CAAG,YAAH,CAAgB,OAAhB,EAAyB,YAAzB;EACA,MAAA,EAAA,CAAG,YAAH,CAAgB,OAAhB,EAAyB,cAAzB;;EACA,UAAI,YAAJ,EAAI;EACF,aAAA,IAAA,UAAA,IAAyB,YAAzB,EAAyB;EACvB,UAAA,EAAA,CAAG,kBAAH,CAAsB,OAAtB,EAA+B,YAAA,CAAa,UAAb,CAA/B,EAAyD,UAAzD;EAAyD;EAAA;;EAG7D,MAAA,EAAA,CAAG,WAAH,CAAe,OAAf;EACA,MAAA,EAAA,CAAG,eAAH,CAAmB,OAAnB;;EAEA,UAAI,EAAA,CAAG,aAAH,EAAJ,EAAO;EACL,QAAA,MAAA,CAAO,KAAP,CAAa,oCAAb;EACA,QAAA,EAAA,CAAG,YAAH,CAAgB,YAAhB;EACA,QAAA,EAAA,CAAG,YAAH,CAAgB,cAAhB;EACA,eAAO,IAAP;EAAO;;EAKT,UAAI,CAAC,EAAA,CAAG,mBAAH,CAAuB,OAAvB,EAAgC,EAAA,CAAG,WAAnC,CAAD,IAAoD,CAAC,EAAA,CAAG,aAAH,EAAzD,EAA4D;EAC1D,YAAA,GAAA,GAAY,qCAAqC,EAAA,CAAG,iBAAH,CAAqB,OAArB,CAAjD;EACA,QAAA,OAAA,CAAQ,KAAR,CAAc,GAAd;;EACA,aAAK,OAAL,CAAa,QAAb,CAAsB,kBAAtB,EAA0C,GAA1C;;EACA,QAAA,EAAA,CAAG,aAAH,CAAiB,OAAjB;EACA,eAAO,KAAP;EAAO;;EAKT,WAAK,aAAL,GAAqB,YAArB;EACA,WAAK,eAAL,GAAuB,cAAvB;EACA,WAAK,mBAAL,GAA2B,YAA3B;EACA,WAAK,qBAAL,GAA6B,cAA7B;EACA,WAAK,QAAL,GAAgB,OAAhB;EACA,aAAO,IAAP;EAAO;;;qCASD,YAAA,cAAA;EACN,UAAA,EAAA,GAAW,KAAK,GAAhB;EACA,UAAA,MAAA,GAAe,EAAA,CAAG,YAAH,CAAgB,UAAhB,CAAf;EACA,MAAA,EAAA,CAAG,YAAH,CAAgB,MAAhB,EAAwB,YAAxB;EACA,MAAA,EAAA,CAAG,aAAH,CAAiB,MAAjB;;EAEA,UAAI,EAAA,CAAG,aAAH,EAAJ,EAAO;EACL,QAAA,MAAA,CAAO,KAAP,CAAa,qCAAb;EACA,QAAA,EAAA,CAAG,YAAH,CAAgB,MAAhB;EACA,eAAO,IAAP;EAAO;;EAIT,UAAI,CAAC,EAAA,CAAG,kBAAH,CAAsB,MAAtB,EAA8B,EAAA,CAAG,cAAjC,CAAD,IAAqD,CAAC,EAAA,CAAG,aAAH,EAA1D,EAA6D;EAC3D,YAAA,GAAA,8CAAgD,UAAA,CAAW,YAAX,CAAhD,eAA6E,EAAA,CAAG,gBAAH,CAAoB,MAApB,CAA7E,CAAA;EACA,QAAA,OAAA,CAAQ,KAAR,CAAc,GAAd;;EACA,aAAK,OAAL,CAAa,QAAb,CAAsB,oBAAtB,EAA4C,GAA5C;;EAGA,QAAA,EAAA,CAAG,YAAH,CAAgB,MAAhB;EACA,eAAO,IAAP;EAAO;;EAGT,aAAO,MAAP;EAAO;;;wCAMT,WAAA,MAAA;EACE,UAAI,KAAK,eAAL,CAAqB,cAArB,CAAoC,IAApC,CAAJ,EAAwC;EACtC,eAAO,KAAK,eAAL,CAAqB,IAArB,CAAP;EAA4B,OAD9B,MAC8B;EAE5B,eAAQ,KAAK,eAAL,CAAqB,IAArB,IAA6B,KAAK,GAAL,CAAS,iBAAT,CAA2B,SAA3B,EAAsC,IAAtC,CAArC;EAA2E;EAAA;;;yCAO/E,WAAA,MAAA;EACE,UAAI,KAAK,aAAL,CAAmB,cAAnB,CAAkC,IAAlC,CAAJ,EAAsC;EACpC,eAAO,KAAK,aAAL,CAAmB,IAAnB,CAAP;EAA0B,OAD5B,MAC4B;EAE1B,eAAQ,KAAK,aAAL,CAAmB,IAAnB,IAA2B,KAAK,GAAL,CAAS,kBAAT,CAA4B,SAA5B,EAAuC,IAAvC,CAAnC;EAA0E;EAAA;;;iCAO9E;EACE,UAAA,EAAA,GAAW,KAAK,GAAhB;;EACA,UAAI,KAAK,aAAT,EAAS;EACP,QAAA,EAAA,CAAG,YAAH,CAAgB,KAAK,aAArB;EAAqB;;EAGvB,UAAI,KAAK,eAAT,EAAS;EACP,QAAA,EAAA,CAAG,YAAH,CAAgB,KAAK,eAArB;EAAqB;;EAGvB,UAAI,KAAK,QAAT,EAAS;EACP,QAAA,EAAA,CAAG,aAAH,CAAiB,KAAK,QAAtB;EAAsB;;EAGxB,WAAK,aAAL,GAAqB,IAArB;EACA,WAAK,eAAL,GAAuB,IAAvB;EACA,WAAK,mBAAL,GAA2B,IAA3B;EACA,WAAK,qBAAL,GAA6B,IAA7B;EACA,WAAK,QAAL,GAAgB,IAAhB;EACA,WAAK,eAAL,GAAuB,EAAvB;EACA,WAAK,aAAL,GAAqB,EAArB;EACA,MAAA,eAAA,CAAgB,cAAhB,CAA+B,IAA/B;EAA+B;;;0BA5I7B;EACF,aAAO,KAAK,QAAZ;EAAY;;;qCAvEP,MAAA,IAAA,QAAA;EACL,UAAA,OAAA,GAA+B,IAA/B;EAEA,MAAA,WAAA,CAAY,IAAZ,CAAiB,UAAA,CAAA,EAAA;EACf,YACE,CAAA,CAAE,GAAF,KAAU,EAAV,IACA,CAAA,CAAE,mBAAF,KAA0B,IAAA,CAAK,YAD/B,IAEA,CAAA,CAAE,qBAAF,KAA4B,IAAA,CAAK,cAHnC,EAGmC;EAEjC,UAAA,OAAA,GAAU,CAAV;EACA,iBAAO,IAAP;EAAO;EAAA,OAPX;;EAWA,UAAI,CAAC,OAAL,EAAK;EACH,QAAA,OAAA,GAAU,IAAI,eAAJ,CAAoB,EAApB,EAAwB,MAAxB,CAAV;EACA,YAAA,MAAA,GAAe,OAAA,CAAQ,gBAAR,CAAyB,IAAA,CAAK,YAA9B,EAA4C,IAAA,CAAK,cAAjD,EAAiE,IAAA,CAAK,YAAtE,CAAf;EACA,YAAI,CAAC,MAAL,EAAa,OAAO,IAAP;EACb,QAAA,WAAA,CAAY,IAAZ,CAAiB,OAAjB;EAAiB;;EAGnB,aAAO,OAAP;EAAO;;;qCAOF,SAAA;EACL,UAAA,KAAA,GAAY,WAAA,CAAY,OAAZ,CAAoB,OAApB,CAAZ;;EACA,UAAI,KAAA,KAAU,CAAA,CAAd,EAAc;EACZ,QAAA,WAAA,CAAY,MAAZ,CAAmB,KAAnB,EAA0B,CAA1B;EAA0B;EAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ECnDhCC,MAAM,CAACC,kBAAP,CAA0B,IAA1B,EAAgC;EAC9BC,EAAAA,SAAS,EAATA,SAD8B;EAE9BC,EAAAA,cAAc,EAAdA,cAF8B;EAG9BC,EAAAA,UAAU,EAAVA,UAH8B;EAI9BC,EAAAA,YAAY,EAAZA,YAJ8B;EAK9BC,EAAAA,WAAW,EAAXA,WAL8B;EAM9BC,EAAAA,mBAAmB,EAAnBA,mBAN8B;EAO9BC,EAAAA,QAAQ,EAARA,QAP8B;EAQ9BC,EAAAA,MAAM,EAANA,MAR8B;EAS9BC,EAAAA,WAAW,EAAXA,WAT8B;EAU9BC,EAAAA,gBAAgB,EAAhBA,gBAV8B;EAW9BC,EAAAA,MAAM,EAANA,cAX8B;EAY9BC,EAAAA,SAAS,EAATA,SAZ8B;EAa9BC,EAAAA,cAAc,EAAdA,cAb8B;EAc9BC,EAAAA,UAAU,EAAVA,UAd8B;EAe9BC,EAAAA,KAAK,EAALA;EAf8B,CAAhC;;MAmBaC,OAAO;EAEpBC,OAAO,CAACC,GAAR,iCAAqCF,OAArC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}