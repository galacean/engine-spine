import { Vector3, Quaternion, Matrix, MathUtil, Matrix3x3, BoundingBox, Vector4, Vector2, Ray, RaycastHit } from '@oasis-engine/math';

var AssetPromiseStatus;
(function(AssetPromiseStatus2) {
  AssetPromiseStatus2[AssetPromiseStatus2["Success"] = 0] = "Success";
  AssetPromiseStatus2[AssetPromiseStatus2["Pending"] = 1] = "Pending";
  AssetPromiseStatus2[AssetPromiseStatus2["Failed"] = 2] = "Failed";
})(AssetPromiseStatus || (AssetPromiseStatus = {}));
class AssetPromise extends Promise {
  static all(promises) {
    return new AssetPromise((resolve, reject, setProgress) => {
      if (!Array.isArray(promises)) {
        return resolve([promises]);
      }
      let completed = 0;
      let total = promises.length;
      let results = new Array(total);
      promises.forEach((value, index) => {
        Promise.resolve(value).then((result) => {
          results[index] = result;
          completed += 1;
          setProgress(completed / total);
          if (completed == total) {
            resolve(results);
          }
        }).catch((err) => reject(err));
      });
    });
  }
  get status() {
    return this._status;
  }
  get progress() {
    return this._progress;
  }
  onProgress(callback) {
    this._listeners.add(callback);
    return this;
  }
  cancel() {
    if (this._status !== 1) {
      return this;
    }
    this._reject("Promise Canceled");
    return this;
  }
  constructor(executor) {
    let newReject;
    const setProgress = (progress) => {
      if (progress <= this._progress) {
        return;
      }
      this._progress = progress;
      for (const listener of this._listeners) {
        listener(progress);
      }
    };
    super((resolve, reject) => {
      newReject = (reason) => {
        Promise.resolve().then(() => {
          this._status = 2;
          reject(reason);
        });
      };
      executor((value) => {
        Promise.resolve().then(() => {
          setProgress(1);
          this._status = 0;
          resolve(value);
        });
      }, newReject, (progress) => {
        Promise.resolve().then(() => {
          setProgress(progress);
        });
      });
    });
    this._reject = newReject;
    this._listeners = new Set();
    this._progress = 0;
    this._status = 1;
  }
}

const Util = {
  isArray: "isArray" in Array ? Array.isArray : (value) => {
    return toString.call(value) === "[object Array]";
  },
  isArrayLike(x) {
    return !!x && typeof x.length === "number" && typeof x !== "function";
  },
  clone(obj) {
    if (typeof obj !== "object" || obj === null) {
      return obj;
    }
    let rst;
    if (Util.isArrayLike(obj)) {
      rst = obj.slice();
      for (let i = 0, l = obj.length; i < l; i++) {
        rst[i] = Util.clone(obj[i]);
      }
    } else {
      rst = {};
      for (const k in obj) {
        if (obj.hasOwnProperty(k)) {
          rst[k] = Util.clone(obj[k]);
        }
      }
    }
    return rst;
  },
  downloadBlob(blob, fileName = "") {
    if (navigator && navigator.msSaveBlob) {
      navigator.msSaveBlob(blob, fileName);
      return;
    }
    let url = window.URL.createObjectURL(blob);
    let a = document.createElement("a");
    document.body.appendChild(a);
    a.style.display = "none";
    a.href = url;
    a.download = fileName;
    a.addEventListener("click", () => {
      if (a.parentElement) {
        a.parentElement.removeChild(a);
      }
    });
    a.click();
    window.URL.revokeObjectURL(url);
  }
};
function removeFromArray(array, item) {
  const index = array.indexOf(item);
  if (index < 0) {
    return false;
  }
  const last = array.length - 1;
  if (index !== last) {
    const end = array[last];
    array[index] = end;
  }
  array.length--;
  return true;
}
function ObjectValues(obj) {
  return Object.keys(obj).map((key) => obj[key]);
}

class ResourceManager {
  constructor(engine) {
    this.engine = engine;
    this.retryCount = 1;
    this.retryInterval = 0;
    this.timeout = 2e4;
    this._assetPool = Object.create(null);
    this._assetUrlPool = Object.create(null);
    this._refObjectPool = Object.create(null);
    this._loadingPromises = {};
  }
  static _addLoader(type, loader, extnames) {
    this._loaders[type] = loader;
    for (let i = 0, len = extnames.length; i < len; i++) {
      this._extTypeMapping[extnames[i]] = type;
    }
  }
  static _getTypeByUrl(url) {
    const path = url.split("?")[0];
    return this._extTypeMapping[path.substring(path.lastIndexOf(".") + 1)];
  }
  load(assetInfo) {
    if (!Array.isArray(assetInfo)) {
      return this._loadSingleItem(assetInfo);
    }
    const promises = assetInfo.map((item) => this._loadSingleItem(item));
    return AssetPromise.all(promises);
  }
  cancelNotLoaded(url) {
    if (!url) {
      ObjectValues(this._loadingPromises).forEach((promise) => {
        promise.cancel();
      });
    } else if (typeof url === "string") {
      this._loadingPromises[url]?.cancel();
    } else {
      url.forEach((p) => {
        this._loadingPromises[p]?.cancel();
      });
    }
  }
  gc() {
    const objects = ObjectValues(this._refObjectPool);
    for (let i = 0, len = objects.length; i < len; i++) {
      if (!objects[i].isGCIgnored) {
        objects[i].destroy();
      }
    }
  }
  getAssetPath(instanceId) {
    return this._assetPool[instanceId];
  }
  _addAsset(path, asset) {
    this._assetPool[asset.instanceId] = path;
    this._assetUrlPool[path] = asset;
  }
  _deleteAsset(asset) {
    const id = asset.instanceId;
    const path = this._assetPool[id];
    if (path) {
      delete this._assetPool[id];
      delete this._assetUrlPool[path];
    }
  }
  _addRefObject(id, asset) {
    this._refObjectPool[id] = asset;
  }
  _deleteRefObject(id) {
    delete this._refObjectPool[id];
  }
  _assignDefaultOptions(assetInfo) {
    assetInfo.type = assetInfo.type ?? ResourceManager._getTypeByUrl(assetInfo.url);
    if (assetInfo.type === void 0) {
      throw `asset type should be specified: ${assetInfo.url}`;
    }
    assetInfo.retryCount = assetInfo.retryCount ?? this.retryCount;
    assetInfo.timeout = assetInfo.timeout ?? this.timeout;
    assetInfo.retryInterval = assetInfo.retryInterval ?? this.retryInterval;
    assetInfo.url = assetInfo.url ?? assetInfo.urls.join(",");
    return assetInfo;
  }
  _loadSingleItem(item) {
    const info = this._assignDefaultOptions(typeof item === "string" ? {url: item} : item);
    const url = info.url;
    if (this._assetUrlPool[url]) {
      return new AssetPromise((resolve) => {
        resolve(this._assetUrlPool[url]);
      });
    }
    if (this._loadingPromises[url]) {
      return this._loadingPromises[info.url];
    }
    const loader = ResourceManager._loaders[info.type];
    const promise = loader.load(info, this);
    this._loadingPromises[url] = promise;
    promise.then((res) => {
      if (loader.useCache)
        this._addAsset(url, res);
      delete this._loadingPromises[url];
    }).catch(() => {
    });
    return promise;
  }
}
ResourceManager._loaders = {};
ResourceManager._extTypeMapping = {};
function resourceLoader(assetType, extnames, useCache = true) {
  return (Target) => {
    const loader = new Target(useCache);
    ResourceManager._addLoader(assetType, loader, extnames);
  };
}

class Event {
  get propagationStopped() {
    return this._propagationStopped;
  }
  get target() {
    return this._target;
  }
  set target(t) {
    this._target = t;
  }
  get timeStamp() {
    return this._timeStamp;
  }
  get currentTarget() {
    return this._currentTarget;
  }
  set currentTarget(t) {
    this._currentTarget = t;
  }
  get bubbles() {
    return this._bubbles;
  }
  get type() {
    return this._type;
  }
  constructor(type, target = null, data = {}, bubbles = true) {
    this._timeStamp = new Date().getTime();
    this._target = target;
    this.data = data;
    this._currentTarget = null;
    this._bubbles = bubbles;
    this._propagationStopped = false;
    this._type = type;
  }
  stopPropagation() {
    this._propagationStopped = true;
  }
}

var CloneMode;
(function(CloneMode2) {
  CloneMode2[CloneMode2["Ignore"] = 0] = "Ignore";
  CloneMode2[CloneMode2["Assignment"] = 1] = "Assignment";
  CloneMode2[CloneMode2["Shallow"] = 2] = "Shallow";
  CloneMode2[CloneMode2["Deep"] = 3] = "Deep";
})(CloneMode || (CloneMode = {}));

function ignoreClone(target, propertyKey) {
  CloneManager.registerCloneMode(target, propertyKey, CloneMode.Ignore);
}
function shallowClone(target, propertyKey) {
  CloneManager.registerCloneMode(target, propertyKey, CloneMode.Shallow);
}
function deepClone(target, propertyKey) {
  CloneManager.registerCloneMode(target, propertyKey, CloneMode.Deep);
}
class CloneManager {
  static registerCloneMode(target, propertyKey, mode) {
    let targetMap = CloneManager._subCloneModeMap.get(target.constructor);
    if (!targetMap) {
      targetMap = Object.create(null);
      CloneManager._subCloneModeMap.set(target.constructor, targetMap);
    }
    targetMap[propertyKey] = mode;
  }
  static getCloneModeMode(type) {
    let cloneModes = CloneManager._cloneModeMap.get(type);
    if (!cloneModes) {
      cloneModes = Object.create(null);
      CloneManager._cloneModeMap.set(type, cloneModes);
      const obejctType = CloneManager._obejctType;
      const cloneModeMap = CloneManager._subCloneModeMap;
      while (type !== obejctType) {
        const subCloneModes = cloneModeMap.get(type);
        if (subCloneModes) {
          Object.assign(cloneModes, subCloneModes);
        }
        type = Object.getPrototypeOf(type);
      }
    }
    return cloneModes;
  }
}
CloneManager._subCloneModeMap = new Map();
CloneManager._cloneModeMap = new Map();
CloneManager._obejctType = Object.getPrototypeOf(Object);

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorate = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};
class EngineObject {
  constructor(engine) {
    this.instanceId = ++EngineObject._instanceIdCounter;
    this._engine = engine;
  }
}
EngineObject._instanceIdCounter = 0;
__decorate([
  ignoreClone
], EngineObject.prototype, "instanceId", 2);
__decorate([
  ignoreClone
], EngineObject.prototype, "_engine", 2);

var __defProp$1 = Object.defineProperty;
var __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor;
var __decorate$1 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$1(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$1(target, key, result);
  return result;
};
class EventDispatcher extends EngineObject {
  constructor() {
    super(...arguments);
    this._evts = Object.create(null);
    this._evtCount = 0;
  }
  hasEvent(event) {
    return this._evts[event] != null;
  }
  eventNames() {
    if (this._evtCount === 0)
      return [];
    return Object.keys(this._evts);
  }
  listenerCount(event) {
    const listeners = this._evts[event];
    if (!listeners)
      return 0;
    if (listeners.fn)
      return 1;
    return listeners.length;
  }
  dispatch(event, data) {
    if (!this._evts[event]) {
      return false;
    }
    const listeners = this._evts[event];
    if (listeners.fn) {
      if (listeners.once)
        this.removeEventListener(event, listeners.fn);
      listeners.fn(data);
    } else {
      const l = listeners.length;
      for (let i = 0; i < l; i++) {
        if (listeners[i].once)
          this.removeEventListener(event, listeners[i].fn);
        listeners[i].fn(data);
      }
    }
    return true;
  }
  on(event, fn) {
    return this.addEventListener(event, fn);
  }
  once(event, fn) {
    return this.addEventListener(event, fn, true);
  }
  addEventListener(event, fn, once) {
    const listener = {fn, once};
    const events = this._evts;
    if (!events[event]) {
      events[event] = listener;
      this._evtCount++;
    } else if (!events[event].fn) {
      events[event].push(listener);
    } else {
      events[event] = [events[event], listener];
    }
    return this;
  }
  off(event, fn) {
    if (!this._evts[event])
      return this;
    if (!fn) {
      this._clearEvent(event);
      return this;
    }
    const listeners = this._evts[event];
    if (listeners.fn && listeners.fn === fn) {
      this._clearEvent(event);
    } else {
      const index = listeners.indexOf(fn);
      if (index > -1) {
        const temp = listeners[listeners.length - 1];
        listeners[index] = temp;
        listeners.length--;
        if (listeners.length === 1) {
          this._evts[event] = listeners[0];
        }
      }
    }
    return this;
  }
  removeEventListener(event, fn) {
    return this.off(event, fn);
  }
  removeAllEventListeners(event) {
    if (event) {
      if (this._evts[event])
        this._clearEvent(event);
    } else {
      this._evts = Object.create(null);
      this._evtCount = 0;
    }
  }
  trigger(e) {
    this.dispatch(e.type, e.data);
  }
  _clearEvent(event) {
    if (--this._evtCount === 0) {
      this._evts = Object.create(null);
    } else {
      delete this._evts[event];
    }
  }
}
__decorate$1([
  ignoreClone
], EventDispatcher.prototype, "_evts", 2);

const noop = (message, ...optionalParams) => {
};
const debug = console.log.bind(console);
const info = console.info.bind(console);
const warn = console.warn.bind(console);
const error = console.error.bind(console);
const Logger = {
  debug: noop,
  info: noop,
  warn: noop,
  error: noop,
  isEnabled: false,
  enable() {
    this.debug = debug;
    this.info = info;
    this.warn = warn;
    this.error = error;
    this.isEnabled = true;
  },
  disable() {
    this.debug = noop;
    this.info = noop;
    this.warn = noop;
    this.error = noop;
    this.isEnabled = false;
  }
};

class Time {
  constructor() {
    this._clock = performance ? performance : Date;
    this._timeScale = 1;
    this._deltaTime = 1e-4;
    const now = this._clock.now();
    this._startTime = now;
    this._lastTickTime = now;
  }
  reset() {
    this._lastTickTime = this._clock.now();
  }
  get nowTime() {
    return this._clock.now();
  }
  get deltaTime() {
    return this._deltaTime;
  }
  get timeScale() {
    return this._timeScale;
  }
  set timeScale(s) {
    this._timeScale = s;
  }
  get unscaledDeltaTime() {
    return this._deltaTime / this._timeScale;
  }
  get timeSinceStartup() {
    return this.nowTime - this._startTime;
  }
  tick() {
    const now = this.nowTime;
    this._deltaTime = (now - this._lastTickTime) * this._timeScale;
    this._lastTickTime = now;
  }
}

var InternalAssetType;
(function(InternalAssetType2) {
  InternalAssetType2[InternalAssetType2["Scene"] = 1] = "Scene";
  InternalAssetType2[InternalAssetType2["Cache"] = 2] = "Cache";
})(InternalAssetType || (InternalAssetType = {}));
var ClearMode;
(function(ClearMode2) {
  ClearMode2[ClearMode2["DONT_CLEAR"] = 0] = "DONT_CLEAR";
  ClearMode2[ClearMode2["SOLID_COLOR"] = 1] = "SOLID_COLOR";
  ClearMode2[ClearMode2["DEPTH_ONLY"] = 2] = "DEPTH_ONLY";
  ClearMode2[ClearMode2["COLOR_ONLY"] = 3] = "COLOR_ONLY";
  ClearMode2[ClearMode2["STENCIL_ONLY"] = 4] = "STENCIL_ONLY";
  ClearMode2[ClearMode2["ALL_CLEAR"] = 5] = "ALL_CLEAR";
})(ClearMode || (ClearMode = {}));
var MaterialType;
(function(MaterialType2) {
  MaterialType2[MaterialType2["OPAQUE"] = 1e3] = "OPAQUE";
  MaterialType2[MaterialType2["TRANSPARENT"] = 2e3] = "TRANSPARENT";
})(MaterialType || (MaterialType = {}));
var RenderState;
(function(RenderState2) {
  RenderState2[RenderState2["BLEND"] = 3042] = "BLEND";
  RenderState2[RenderState2["CULL_FACE"] = 2884] = "CULL_FACE";
  RenderState2[RenderState2["DEPTH_TEST"] = 2929] = "DEPTH_TEST";
  RenderState2[RenderState2["ALPHA_TEST"] = 3008] = "ALPHA_TEST";
  RenderState2[RenderState2["POLYGON_OFFSET_FILL"] = 32823] = "POLYGON_OFFSET_FILL";
  RenderState2[RenderState2["SAMPLE_ALPHA_TO_COVERAGE"] = 32926] = "SAMPLE_ALPHA_TO_COVERAGE";
  RenderState2[RenderState2["SCISSOR_TEST"] = 3089] = "SCISSOR_TEST";
})(RenderState || (RenderState = {}));
var FrontFace;
(function(FrontFace2) {
  FrontFace2[FrontFace2["CW"] = 2304] = "CW";
  FrontFace2[FrontFace2["CCW"] = 2305] = "CCW";
})(FrontFace || (FrontFace = {}));
var CullFace;
(function(CullFace2) {
  CullFace2[CullFace2["FRONT"] = 1028] = "FRONT";
  CullFace2[CullFace2["BACK"] = 1029] = "BACK";
  CullFace2[CullFace2["FRONT_AND_BACK"] = 1032] = "FRONT_AND_BACK";
})(CullFace || (CullFace = {}));
var Side;
(function(Side2) {
  Side2[Side2["FRONT"] = 0] = "FRONT";
  Side2[Side2["BACK"] = 1] = "BACK";
  Side2[Side2["NONE"] = 2] = "NONE";
  Side2[Side2["DOUBLE"] = 3] = "DOUBLE";
})(Side || (Side = {}));
var CompFunc;
(function(CompFunc2) {
  CompFunc2[CompFunc2["NEVER"] = 512] = "NEVER";
  CompFunc2[CompFunc2["LESS"] = 513] = "LESS";
  CompFunc2[CompFunc2["EQUAL"] = 514] = "EQUAL";
  CompFunc2[CompFunc2["LEQUAL"] = 515] = "LEQUAL";
  CompFunc2[CompFunc2["GREATER"] = 516] = "GREATER";
  CompFunc2[CompFunc2["NOTEQUAL"] = 517] = "NOTEQUAL";
  CompFunc2[CompFunc2["GEQUAL"] = 518] = "GEQUAL";
  CompFunc2[CompFunc2["ALWAYS"] = 519] = "ALWAYS";
})(CompFunc || (CompFunc = {}));
var TextureFilter;
(function(TextureFilter2) {
  TextureFilter2[TextureFilter2["NEAREST"] = 9728] = "NEAREST";
  TextureFilter2[TextureFilter2["LINEAR"] = 9729] = "LINEAR";
  TextureFilter2[TextureFilter2["NEAREST_MIPMAP_NEAREST"] = 9984] = "NEAREST_MIPMAP_NEAREST";
  TextureFilter2[TextureFilter2["LINEAR_MIPMAP_NEAREST"] = 9985] = "LINEAR_MIPMAP_NEAREST";
  TextureFilter2[TextureFilter2["NEAREST_MIPMAP_LINEAR"] = 9986] = "NEAREST_MIPMAP_LINEAR";
  TextureFilter2[TextureFilter2["LINEAR_MIPMAP_LINEAR"] = 9987] = "LINEAR_MIPMAP_LINEAR";
})(TextureFilter || (TextureFilter = {}));
var DataType;
(function(DataType2) {
  DataType2[DataType2["FLOAT"] = 5126] = "FLOAT";
  DataType2[DataType2["FLOAT_VEC2"] = 35664] = "FLOAT_VEC2";
  DataType2[DataType2["FLOAT_VEC3"] = 35665] = "FLOAT_VEC3";
  DataType2[DataType2["FLOAT_VEC4"] = 35666] = "FLOAT_VEC4";
  DataType2[DataType2["INT"] = 5124] = "INT";
  DataType2[DataType2["INT_VEC2"] = 35667] = "INT_VEC2";
  DataType2[DataType2["INT_VEC3"] = 35668] = "INT_VEC3";
  DataType2[DataType2["INT_VEC4"] = 35669] = "INT_VEC4";
  DataType2[DataType2["BOOL"] = 35670] = "BOOL";
  DataType2[DataType2["BOOL_VEC2"] = 35671] = "BOOL_VEC2";
  DataType2[DataType2["BOOL_VEC3"] = 35672] = "BOOL_VEC3";
  DataType2[DataType2["BOOL_VEC4"] = 35673] = "BOOL_VEC4";
  DataType2[DataType2["FLOAT_MAT2"] = 35674] = "FLOAT_MAT2";
  DataType2[DataType2["FLOAT_MAT3"] = 35675] = "FLOAT_MAT3";
  DataType2[DataType2["FLOAT_MAT4"] = 35676] = "FLOAT_MAT4";
  DataType2[DataType2["FLOAT_ARRAY"] = 35677] = "FLOAT_ARRAY";
  DataType2[DataType2["FLOAT_VEC2_ARRAY"] = 1e5] = "FLOAT_VEC2_ARRAY";
  DataType2[DataType2["FLOAT_VEC3_ARRAY"] = 100001] = "FLOAT_VEC3_ARRAY";
  DataType2[DataType2["FLOAT_VEC4_ARRAY"] = 100002] = "FLOAT_VEC4_ARRAY";
  DataType2[DataType2["INT_ARRAY"] = 100003] = "INT_ARRAY";
  DataType2[DataType2["INT_VEC2_ARRAY"] = 100004] = "INT_VEC2_ARRAY";
  DataType2[DataType2["INT_VEC3_ARRAY"] = 100005] = "INT_VEC3_ARRAY";
  DataType2[DataType2["INT_VEC4_ARRAY"] = 100006] = "INT_VEC4_ARRAY";
  DataType2[DataType2["FLOAT_MAT2_ARRAY"] = 100007] = "FLOAT_MAT2_ARRAY";
  DataType2[DataType2["FLOAT_MAT3_ARRAY"] = 100008] = "FLOAT_MAT3_ARRAY";
  DataType2[DataType2["FLOAT_MAT4_ARRAY"] = 100009] = "FLOAT_MAT4_ARRAY";
  DataType2[DataType2["SAMPLER_2D_ARRAY"] = 100010] = "SAMPLER_2D_ARRAY";
  DataType2[DataType2["SAMPLER_CUBE_ARRAY"] = 100011] = "SAMPLER_CUBE_ARRAY";
  DataType2[DataType2["SAMPLER_2D"] = 35678] = "SAMPLER_2D";
  DataType2[DataType2["SAMPLER_CUBE"] = 35680] = "SAMPLER_CUBE";
  DataType2[DataType2["BYTE"] = 5120] = "BYTE";
  DataType2[DataType2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  DataType2[DataType2["SHORT"] = 5122] = "SHORT";
  DataType2[DataType2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  DataType2[DataType2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
})(DataType || (DataType = {}));
var UniformSemantic;
(function(UniformSemantic2) {
  UniformSemantic2[UniformSemantic2["LOCAL"] = 1] = "LOCAL";
  UniformSemantic2[UniformSemantic2["MODEL"] = 2] = "MODEL";
  UniformSemantic2[UniformSemantic2["VIEW"] = 3] = "VIEW";
  UniformSemantic2[UniformSemantic2["PROJECTION"] = 4] = "PROJECTION";
  UniformSemantic2[UniformSemantic2["MODELVIEW"] = 5] = "MODELVIEW";
  UniformSemantic2[UniformSemantic2["VIEWPROJECTION"] = 21] = "VIEWPROJECTION";
  UniformSemantic2[UniformSemantic2["MODELVIEWPROJECTION"] = 6] = "MODELVIEWPROJECTION";
  UniformSemantic2[UniformSemantic2["MODELINVERSE"] = 7] = "MODELINVERSE";
  UniformSemantic2[UniformSemantic2["VIEWINVERSE"] = 8] = "VIEWINVERSE";
  UniformSemantic2[UniformSemantic2["PROJECTIONINVERSE"] = 9] = "PROJECTIONINVERSE";
  UniformSemantic2[UniformSemantic2["MODELVIEWINVERSE"] = 10] = "MODELVIEWINVERSE";
  UniformSemantic2[UniformSemantic2["MODELVIEWPROJECTIONINVERSE"] = 11] = "MODELVIEWPROJECTIONINVERSE";
  UniformSemantic2[UniformSemantic2["MODELINVERSETRANSPOSE"] = 12] = "MODELINVERSETRANSPOSE";
  UniformSemantic2[UniformSemantic2["MODELVIEWINVERSETRANSPOSE"] = 13] = "MODELVIEWINVERSETRANSPOSE";
  UniformSemantic2[UniformSemantic2["VIEWPORT"] = 14] = "VIEWPORT";
  UniformSemantic2[UniformSemantic2["JOINTMATRIX"] = 15] = "JOINTMATRIX";
  UniformSemantic2[UniformSemantic2["MORPHWEIGHTS"] = 16] = "MORPHWEIGHTS";
  UniformSemantic2[UniformSemantic2["EYEPOS"] = 17] = "EYEPOS";
  UniformSemantic2[UniformSemantic2["TIME"] = 18] = "TIME";
  UniformSemantic2[UniformSemantic2["JOINTTEXTURE"] = 19] = "JOINTTEXTURE";
  UniformSemantic2[UniformSemantic2["JOINTCOUNT"] = 20] = "JOINTCOUNT";
})(UniformSemantic || (UniformSemantic = {}));
var BlendFunc;
(function(BlendFunc2) {
  BlendFunc2[BlendFunc2["ZERO"] = 0] = "ZERO";
  BlendFunc2[BlendFunc2["ONE"] = 1] = "ONE";
  BlendFunc2[BlendFunc2["SRC_COLOR"] = 768] = "SRC_COLOR";
  BlendFunc2[BlendFunc2["ONE_MINUS_SRC_COLOR"] = 769] = "ONE_MINUS_SRC_COLOR";
  BlendFunc2[BlendFunc2["SRC_ALPHA"] = 770] = "SRC_ALPHA";
  BlendFunc2[BlendFunc2["ONE_MINUS_SRC_ALPHA"] = 771] = "ONE_MINUS_SRC_ALPHA";
  BlendFunc2[BlendFunc2["DST_ALPHA"] = 772] = "DST_ALPHA";
  BlendFunc2[BlendFunc2["ONE_MINUS_DST_ALPHA"] = 773] = "ONE_MINUS_DST_ALPHA";
  BlendFunc2[BlendFunc2["DST_COLOR"] = 774] = "DST_COLOR";
  BlendFunc2[BlendFunc2["ONE_MINUS_DST_COLOR"] = 775] = "ONE_MINUS_DST_COLOR";
  BlendFunc2[BlendFunc2["SRC_ALPHA_SATURATE"] = 776] = "SRC_ALPHA_SATURATE";
  BlendFunc2[BlendFunc2["enumANT_COLOR"] = 32769] = "enumANT_COLOR";
  BlendFunc2[BlendFunc2["ONE_MINUS_enumANT_COLOR"] = 32770] = "ONE_MINUS_enumANT_COLOR";
  BlendFunc2[BlendFunc2["enumANT_ALPHA"] = 32771] = "enumANT_ALPHA";
  BlendFunc2[BlendFunc2["ONE_MINUS_enumANT_ALPHA"] = 32772] = "ONE_MINUS_enumANT_ALPHA";
})(BlendFunc || (BlendFunc = {}));
var MaskList;
(function(MaskList2) {
  MaskList2[MaskList2["MASK1"] = 1] = "MASK1";
  MaskList2[MaskList2["MASK2"] = 2] = "MASK2";
  MaskList2[MaskList2["MASK3"] = 4] = "MASK3";
  MaskList2[MaskList2["MASK4"] = 8] = "MASK4";
  MaskList2[MaskList2["MASK5"] = 16] = "MASK5";
  MaskList2[MaskList2["MASK6"] = 32] = "MASK6";
  MaskList2[MaskList2["MASK7"] = 64] = "MASK7";
  MaskList2[MaskList2["MASK8"] = 128] = "MASK8";
  MaskList2[MaskList2["MASK9"] = 256] = "MASK9";
  MaskList2[MaskList2["MASK10"] = 512] = "MASK10";
  MaskList2[MaskList2["MASK11"] = 1024] = "MASK11";
  MaskList2[MaskList2["MASK12"] = 2048] = "MASK12";
  MaskList2[MaskList2["MASK13"] = 4096] = "MASK13";
  MaskList2[MaskList2["MASK14"] = 8192] = "MASK14";
  MaskList2[MaskList2["MASK15"] = 16384] = "MASK15";
  MaskList2[MaskList2["MASK16"] = 32768] = "MASK16";
  MaskList2[MaskList2["MASK17"] = 65536] = "MASK17";
  MaskList2[MaskList2["MASK18"] = 131072] = "MASK18";
  MaskList2[MaskList2["MASK19"] = 262144] = "MASK19";
  MaskList2[MaskList2["MASK20"] = 524288] = "MASK20";
  MaskList2[MaskList2["EVERYTHING"] = 268435455] = "EVERYTHING";
  MaskList2[MaskList2["SHADOW"] = 268435456] = "SHADOW";
  MaskList2[MaskList2["SHADOW_MAP"] = 536870912] = "SHADOW_MAP";
})(MaskList || (MaskList = {}));
var RefreshRate;
(function(RefreshRate2) {
  RefreshRate2[RefreshRate2["ONCE"] = 1] = "ONCE";
  RefreshRate2[RefreshRate2["EVERYFRAME"] = 2] = "EVERYFRAME";
})(RefreshRate || (RefreshRate = {}));
var BoundingType;
(function(BoundingType2) {
  BoundingType2[BoundingType2["AABB"] = 0] = "AABB";
  BoundingType2[BoundingType2["OBB"] = 1] = "OBB";
  BoundingType2[BoundingType2["SPHERE"] = 2] = "SPHERE";
})(BoundingType || (BoundingType = {}));
var GLCapabilityType;
(function(GLCapabilityType2) {
  GLCapabilityType2["standardDerivatives"] = "OES_standard_derivatives";
  GLCapabilityType2["shaderTextureLod"] = "EXT_shader_texture_lod";
  GLCapabilityType2["elementIndexUint"] = "OES_element_index_uint";
  GLCapabilityType2["depthTexture"] = "WEBGL_depth_texture";
  GLCapabilityType2["drawBuffers"] = "WEBGL_draw_buffers";
  GLCapabilityType2["vertexArrayObject"] = "OES_vertex_array_object";
  GLCapabilityType2["instancedArrays"] = "ANGLE_instanced_arrays";
  GLCapabilityType2["multipleSample"] = "multipleSampleOnlySupportedInWebGL2";
  GLCapabilityType2["textureFloat"] = "OES_texture_float";
  GLCapabilityType2["textureFloatLinear"] = "OES_texture_float_linear";
  GLCapabilityType2["textureHalfFloat"] = "OES_texture_half_float";
  GLCapabilityType2["textureHalfFloatLinear"] = "OES_texture_half_float_linear";
  GLCapabilityType2["WEBGL_colorBufferFloat"] = "WEBGL_color_buffer_float";
  GLCapabilityType2["colorBufferFloat"] = "EXT_color_buffer_float";
  GLCapabilityType2["colorBufferHalfFloat"] = "EXT_color_buffer_half_float";
  GLCapabilityType2["textureFilterAnisotropic"] = "EXT_texture_filter_anisotropic";
  GLCapabilityType2["astc"] = "WEBGL_compressed_texture_astc";
  GLCapabilityType2["astc_webkit"] = "WEBKIT_WEBGL_compressed_texture_astc";
  GLCapabilityType2["etc"] = "WEBGL_compressed_texture_etc";
  GLCapabilityType2["etc_webkit"] = "WEBKIT_WEBGL_compressed_texture_etc";
  GLCapabilityType2["etc1"] = "WEBGL_compressed_texture_etc1";
  GLCapabilityType2["etc1_webkit"] = "WEBKIT_WEBGL_compressed_texture_etc1";
  GLCapabilityType2["pvrtc"] = "WEBGL_compressed_texture_pvrtc";
  GLCapabilityType2["pvrtc_webkit"] = "WEBKIT_WEBGL_compressed_texture_pvrtc";
  GLCapabilityType2["s3tc"] = "WEBGL_compressed_texture_s3tc";
  GLCapabilityType2["s3tc_webkit"] = "WEBKIT_WEBGL_compressed_texture_s3tc";
})(GLCapabilityType || (GLCapabilityType = {}));
var OITMode;
(function(OITMode2) {
  OITMode2[OITMode2["WEIGHTED_AVERAGE"] = 0] = "WEIGHTED_AVERAGE";
  OITMode2[OITMode2["DEPTH_PEEL"] = 1] = "DEPTH_PEEL";
  OITMode2[OITMode2["DUAL_DEPTH_PEEL"] = 2] = "DUAL_DEPTH_PEEL";
})(OITMode || (OITMode = {}));

class DisorderedArray {
  constructor(count = 0) {
    this.length = 0;
    this._elements = new Array(count);
  }
  add(element) {
    if (this.length === this._elements.length)
      this._elements.push(element);
    else
      this._elements[this.length] = element;
    this.length++;
  }
  delete(element) {
    const index = this._elements.indexOf(element);
    this.deleteByIndex(index);
  }
  deleteByIndex(index) {
    var elements = this._elements;
    let end = null;
    const lastIndex = this.length - 1;
    if (index !== lastIndex) {
      end = elements[lastIndex];
      elements[index] = end;
    }
    this.length--;
    return end;
  }
  garbageCollection() {
    this._elements.length = this.length;
  }
}

class ComponentsManager {
  constructor() {
    this._onStartScripts = new DisorderedArray();
    this._onUpdateScripts = new DisorderedArray();
    this._onLateUpdateScripts = new DisorderedArray();
    this._destoryComponents = [];
    this._onUpdateAnimations = new DisorderedArray();
    this._renderers = new DisorderedArray();
    this._onUpdateRenderers = new DisorderedArray();
    this._componentsContainerPool = [];
  }
  addRenderer(renderer) {
    renderer._rendererIndex = this._renderers.length;
    this._renderers.add(renderer);
  }
  removeRenderer(renderer) {
    const replaced = this._renderers.deleteByIndex(renderer._rendererIndex);
    replaced && (replaced._rendererIndex = renderer._rendererIndex);
    renderer._rendererIndex = -1;
  }
  addOnStartScript(script) {
    script._onStartIndex = this._onStartScripts.length;
    this._onStartScripts.add(script);
  }
  removeOnStartScript(script) {
    const replaced = this._onStartScripts.deleteByIndex(script._onStartIndex);
    replaced && (replaced._onStartIndex = script._onStartIndex);
    script._onStartIndex = -1;
  }
  addOnUpdateScript(script) {
    script._onUpdateIndex = this._onUpdateScripts.length;
    this._onUpdateScripts.add(script);
  }
  removeOnUpdateScript(script) {
    const replaced = this._onUpdateScripts.deleteByIndex(script._onUpdateIndex);
    replaced && (replaced._onUpdateIndex = script._onUpdateIndex);
    script._onUpdateIndex = -1;
  }
  addOnLateUpdateScript(script) {
    script._onLateUpdateIndex = this._onLateUpdateScripts.length;
    this._onLateUpdateScripts.add(script);
  }
  removeOnLateUpdateScript(script) {
    const replaced = this._onLateUpdateScripts.deleteByIndex(script._onLateUpdateIndex);
    replaced && (replaced._onLateUpdateIndex = script._onLateUpdateIndex);
    script._onLateUpdateIndex = -1;
  }
  addOnUpdateAnimations(animation) {
    animation._onUpdateIndex = this._onUpdateAnimations.length;
    this._onUpdateAnimations.add(animation);
  }
  removeOnUpdateAnimations(animation) {
    const replaced = this._onUpdateAnimations.deleteByIndex(animation._onUpdateIndex);
    replaced && (replaced._onUpdateIndex = animation._onUpdateIndex);
    animation._onUpdateIndex = -1;
  }
  addOnUpdateRenderers(renderer) {
    renderer._onUpdateIndex = this._onUpdateRenderers.length;
    this._onUpdateRenderers.add(renderer);
  }
  removeOnUpdateRenderers(renderer) {
    const replaced = this._onUpdateRenderers.deleteByIndex(renderer._onUpdateIndex);
    replaced && (replaced._onUpdateIndex = renderer._onUpdateIndex);
    renderer._onUpdateIndex = -1;
  }
  addDestoryComponent(component) {
    this._destoryComponents.push(component);
  }
  callScriptOnStart() {
    const onStartScripts = this._onStartScripts;
    if (onStartScripts.length > 0) {
      const elements = onStartScripts._elements;
      for (let i = 0; i < onStartScripts.length; i++) {
        const script = elements[i];
        script._started = true;
        script._onStartIndex = -1;
        script.onStart();
      }
      onStartScripts.length = 0;
    }
  }
  callScriptOnUpdate(deltaTime) {
    const elements = this._onUpdateScripts._elements;
    for (let i = this._onUpdateScripts.length - 1; i >= 0; --i) {
      const element = elements[i];
      if (element._started) {
        element.onUpdate(deltaTime);
      }
    }
  }
  callScriptOnLateUpdate(deltaTime) {
    const elements = this._onLateUpdateScripts._elements;
    for (let i = this._onLateUpdateScripts.length - 1; i >= 0; --i) {
      const element = elements[i];
      if (element._started) {
        element.onLateUpdate(deltaTime);
      }
    }
  }
  callAnimationUpdate(deltaTime) {
    const elements = this._onUpdateAnimations._elements;
    for (let i = this._onUpdateAnimations.length - 1; i >= 0; --i) {
      elements[i].update(deltaTime);
    }
  }
  callRendererOnUpdate(deltaTime) {
    const elements = this._onUpdateRenderers._elements;
    for (let i = this._onUpdateRenderers.length - 1; i >= 0; --i) {
      elements[i].update(deltaTime);
    }
  }
  callRender(camera) {
    const elements = this._renderers._elements;
    for (let i = this._renderers.length - 1; i >= 0; --i) {
      elements[i]._render(camera);
    }
  }
  callComponentDestory() {
    const destoryComponents = this._destoryComponents;
    const length = destoryComponents.length;
    if (length > 0) {
      for (let i = length - 1; i >= 0; --i) {
        destoryComponents[i].onDestroy();
      }
      destoryComponents.length = 0;
    }
  }
  callCameraOnBeginRender(camera) {
    const camComps = camera.entity._components;
    for (let i = camComps.length - 1; i >= 0; --i) {
      const camComp = camComps[i];
      camComp.onBeginRender && camComp.onBeginRender(camera);
    }
  }
  callCameraOnEndRender(camera) {
    const camComps = camera.entity._components;
    for (let i = camComps.length - 1; i >= 0; --i) {
      const camComp = camComps[i];
      camComp.onBeginRender && camComp.onEndRender(camera);
    }
  }
  getActiveChangedTempList() {
    return this._componentsContainerPool.length ? this._componentsContainerPool.pop() : [];
  }
  putActiveChangedTempList(componentContainer) {
    componentContainer.length = 0;
    this._componentsContainerPool.push(componentContainer);
  }
}

class ComponentCloner {
  static cloneComponent(source, target) {
    const cloneModes = CloneManager.getCloneModeMode(source.constructor);
    const keys = Object.keys(source);
    for (let i = 0, n = keys.length; i < n; i++) {
      const k = keys[i];
      const cloneMode = cloneModes[k];
      switch (cloneMode) {
        case void 0:
        case CloneMode.Assignment:
          target[k] = source[k];
          break;
        case CloneMode.Shallow:
          const sourcePropS = source[k];
          if (sourcePropS instanceof Object) {
            let tarProp = target[k];
            tarProp == null && (tarProp = target[k] = sourcePropS.constructor());
            Object.assign(tarProp, sourcePropS);
          } else {
            target[k] = sourcePropS;
          }
          break;
        case CloneMode.Deep:
          const sourcePropD = source[k];
          if (sourcePropD instanceof Object) {
            let tarProp = target[k];
            tarProp == null && (tarProp = target[k] = sourcePropD.constructor());
            ComponentCloner._cloneComponentProp(sourcePropD, tarProp);
          } else {
            target[k] = sourcePropD;
          }
          break;
      }
    }
  }
  static _cloneComponentProp(source, target) {
    const type = source.constructor;
    if (type === Object) {
      const keys = Object.keys(source);
      for (let i = 0, n = keys.length; i < n; i++) {
        const k = keys[i];
        const sourceItem = source[k];
        if (sourceItem instanceof Object) {
          let targetItem = target[k];
          targetItem == null && (target[k] = targetItem = sourceItem.constructor());
          ComponentCloner._cloneComponentProp(sourceItem, targetItem);
        } else {
          target[k] = sourceItem;
        }
      }
    } else if (type === Array) {
      const arraySource = source;
      const arrayTarget = target;
      const length = arraySource.length;
      arrayTarget.length = length;
      for (let i = 0; i < length; i++) {
        const sourceItem = arraySource[i];
        if (sourceItem instanceof Object) {
          let targetItem = arrayTarget[i];
          targetItem == null && (arrayTarget[i] = targetItem = sourceItem.constructor());
          ComponentCloner._cloneComponentProp(sourceItem, targetItem);
        } else {
          arrayTarget[i] = sourceItem;
        }
      }
    } else {
      source.cloneTo(target);
    }
  }
}

class ComponentsDependencies {
  static register(currentComponent, dependentComponent) {
    this._addDependency(currentComponent, dependentComponent, this._dependenciesMap);
    this._addDependency(dependentComponent, currentComponent, this._invDependenciesMap);
  }
  static _addCheck(entity, type) {
    const dependencies2 = ComponentsDependencies._dependenciesMap.get(type);
    if (dependencies2) {
      for (let i = 0, len = dependencies2.length; i < len; i++) {
        if (!entity.getComponent(dependencies2[i])) {
          throw `you should add ${dependencies2[i]} before adding ${type}`;
        }
      }
    }
  }
  static _removeCheck(entity, type) {
    const invDenpendencies = ComponentsDependencies._invDependenciesMap.get(type);
    if (invDenpendencies) {
      for (let i = 0, len = invDenpendencies.length; i < len; i++) {
        if (entity.getComponent(invDenpendencies[i])) {
          throw `you should remove ${invDenpendencies[i]} before adding ${type}`;
        }
      }
    }
  }
  static _addDependency(currentComponent, dependentComponent, map) {
    let components = map.get(currentComponent);
    if (!components) {
      components = [];
      map.set(currentComponent, components);
    }
    if (components.indexOf(dependentComponent) === -1) {
      components.push(dependentComponent);
    }
  }
  constructor() {
  }
}
ComponentsDependencies._dependenciesMap = new Map();
ComponentsDependencies._invDependenciesMap = new Map();
function dependencies(...abilityClass) {
  return function(target) {
    abilityClass.forEach((ability) => ComponentsDependencies.register(target, ability));
  };
}

var Layer;
(function(Layer2) {
  Layer2[Layer2["Layer0"] = 1] = "Layer0";
  Layer2[Layer2["Layer1"] = 2] = "Layer1";
  Layer2[Layer2["Layer2"] = 4] = "Layer2";
  Layer2[Layer2["Layer3"] = 8] = "Layer3";
  Layer2[Layer2["Layer4"] = 16] = "Layer4";
  Layer2[Layer2["Layer5"] = 32] = "Layer5";
  Layer2[Layer2["Layer6"] = 64] = "Layer6";
  Layer2[Layer2["Layer7"] = 128] = "Layer7";
  Layer2[Layer2["Layer8"] = 256] = "Layer8";
  Layer2[Layer2["Layer9"] = 512] = "Layer9";
  Layer2[Layer2["Layer10"] = 1024] = "Layer10";
  Layer2[Layer2["Layer11"] = 2048] = "Layer11";
  Layer2[Layer2["Layer12"] = 4096] = "Layer12";
  Layer2[Layer2["Layer13"] = 8192] = "Layer13";
  Layer2[Layer2["Layer14"] = 16384] = "Layer14";
  Layer2[Layer2["Layer15"] = 32768] = "Layer15";
  Layer2[Layer2["Layer16"] = 65536] = "Layer16";
  Layer2[Layer2["Layer17"] = 131072] = "Layer17";
  Layer2[Layer2["Layer18"] = 262144] = "Layer18";
  Layer2[Layer2["Layer19"] = 524288] = "Layer19";
  Layer2[Layer2["Layer20"] = 1048576] = "Layer20";
  Layer2[Layer2["Layer21"] = 2097152] = "Layer21";
  Layer2[Layer2["Layer22"] = 4194304] = "Layer22";
  Layer2[Layer2["Layer23"] = 8388608] = "Layer23";
  Layer2[Layer2["Layer24"] = 16777216] = "Layer24";
  Layer2[Layer2["Layer25"] = 33554432] = "Layer25";
  Layer2[Layer2["Layer26"] = 67108864] = "Layer26";
  Layer2[Layer2["Layer27"] = 134217728] = "Layer27";
  Layer2[Layer2["Layer28"] = 268435456] = "Layer28";
  Layer2[Layer2["Layer29"] = 536870912] = "Layer29";
  Layer2[Layer2["Layer30"] = 1073741824] = "Layer30";
  Layer2[Layer2["Layer31"] = 2147483648] = "Layer31";
  Layer2[Layer2["Everything"] = 4294967295] = "Everything";
  Layer2[Layer2["Nothing"] = 0] = "Nothing";
})(Layer || (Layer = {}));

var __defProp$2 = Object.defineProperty;
var __getOwnPropDesc$2 = Object.getOwnPropertyDescriptor;
var __decorate$2 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$2(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$2(target, key, result);
  return result;
};
class Component extends EventDispatcher {
  constructor(entity) {
    super(entity.engine);
    this._destroyed = false;
    this._enabled = true;
    this._awaked = false;
    this._renderPriority = 0;
    this._cullDistanceSq = 0;
    this._entity = entity;
    this._renderPassFlag = MaskList.EVERYTHING;
    this._passMasks = [MaskList.EVERYTHING];
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    if (value === this._enabled) {
      return;
    }
    this._enabled = value;
    if (value) {
      this._entity.isActiveInHierarchy && this._onEnable();
    } else {
      this._entity.isActiveInHierarchy && this._onDisable();
    }
  }
  get destroyed() {
    return this._destroyed;
  }
  get entity() {
    return this._entity;
  }
  get scene() {
    return this._entity.scene;
  }
  get engine() {
    return this._entity.engine;
  }
  destroy() {
    if (this._destroyed)
      return;
    this._entity._removeComponent(this);
    if (this._entity.isActiveInHierarchy) {
      this._enabled && this._onDisable();
      this._onInActive();
    }
    this._destroyed = true;
    this._onDestroy();
  }
  _onAwake() {
  }
  _onEnable() {
  }
  _onDisable() {
  }
  _onDestroy() {
  }
  _onActive() {
  }
  _onInActive() {
  }
  _setActive(value) {
    if (value) {
      if (!this._awaked) {
        this._awaked = true;
        this._onAwake();
      }
      if (this._entity._isActiveInHierarchy) {
        this._onActive();
        this._enabled && this._onEnable();
      }
    } else {
      this._enabled && this._onDisable();
      this._onInActive();
    }
  }
  get renderPriority() {
    return this._renderPriority;
  }
  set renderPriority(val) {
    this._renderPriority = val;
  }
  get cullDistanceSq() {
    return this._cullDistanceSq;
  }
  get cullDistance() {
    return Math.sqrt(this._cullDistanceSq);
  }
  set cullDistance(val) {
    this._cullDistanceSq = val * val;
  }
  get renderPassFlag() {
    return this._renderPassFlag;
  }
  set renderPassFlag(val) {
    this._renderPassFlag = val;
  }
  setPassMasks(...masks) {
    this._passMasks = masks;
    this._renderPassFlag = masks.reduce((a, b) => a | b, 0);
  }
  addPassMasks(...masks) {
    for (const mask of masks) {
      const idx = this._passMasks.indexOf(mask);
      if (idx < 0) {
        this._passMasks.push(mask);
      }
    }
    this.setPassMasks(...this._passMasks);
  }
  removePassMasks(...masks) {
    for (const mask of masks) {
      const idx = this._passMasks.indexOf(mask);
      if (idx > -1) {
        this._passMasks.splice(idx, 1);
      }
    }
    this.setPassMasks(...this._passMasks);
  }
}
__decorate$2([
  ignoreClone
], Component.prototype, "_entity", 2);
__decorate$2([
  ignoreClone
], Component.prototype, "_destroyed", 2);
__decorate$2([
  ignoreClone
], Component.prototype, "_enabled", 2);
__decorate$2([
  ignoreClone
], Component.prototype, "_awaked", 2);

class UpdateFlag {
  constructor(_flags = []) {
    this._flags = _flags;
    this.flag = true;
  }
  destroy() {
    const flags = this._flags;
    removeFromArray(flags, this);
    this._flags = null;
  }
}

var __defProp$3 = Object.defineProperty;
var __getOwnPropDesc$3 = Object.getOwnPropertyDescriptor;
var __decorate$3 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$3(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$3(target, key, result);
  return result;
};
class Transform extends Component {
  constructor() {
    super(...arguments);
    this._position = new Vector3();
    this._rotation = new Vector3();
    this._rotationQuaternion = new Quaternion();
    this._scale = new Vector3(1, 1, 1);
    this._worldPosition = new Vector3();
    this._worldRotation = new Vector3();
    this._worldRotationQuaternion = new Quaternion();
    this._lossyWorldScale = new Vector3(1, 1, 1);
    this._localMatrix = new Matrix();
    this._worldMatrix = new Matrix();
    this._changeFlags = [];
    this._isParentDirty = true;
    this._parentTransformCache = null;
    this._dirtyFlag = Transform._WM_WP_WE_WQ_WS_FLAGS;
  }
  get position() {
    return this._position;
  }
  set position(value) {
    if (this._position !== value) {
      value.cloneTo(this._position);
    }
    this._setDirtyFlagTrue(Transform._LOCAL_MATRIX_FLAG);
    this._updateWorldPositionFlag();
  }
  get worldPosition() {
    if (this._isContainDirtyFlag(Transform._WORLD_POSITION_FLAG)) {
      if (this._getParentTransform()) {
        this.worldMatrix.getTranslation(this._worldPosition);
      } else {
        this._position.cloneTo(this._worldPosition);
      }
      this._setDirtyFlagFalse(Transform._WORLD_POSITION_FLAG);
    }
    return this._worldPosition;
  }
  set worldPosition(value) {
    if (this._worldPosition !== value) {
      value.cloneTo(this._worldPosition);
    }
    const parent = this._getParentTransform();
    if (parent) {
      Matrix.invert(parent.worldMatrix, Transform._tempMat41);
      Vector3.transformCoordinate(value, Transform._tempMat41, this._position);
    } else {
      value.cloneTo(this._position);
    }
    this.position = this._position;
    this._setDirtyFlagFalse(Transform._WORLD_POSITION_FLAG);
  }
  get rotation() {
    if (this._isContainDirtyFlag(Transform._LOCAL_EULER_FLAG)) {
      this._rotationQuaternion.toEuler(this._rotation);
      this._rotation.scale(MathUtil.radToDegreeFactor);
      this._setDirtyFlagFalse(Transform._LOCAL_EULER_FLAG);
    }
    return this._rotation;
  }
  set rotation(value) {
    if (this._rotation !== value) {
      value.cloneTo(this._rotation);
    }
    this._setDirtyFlagTrue(Transform._LOCAL_MATRIX_FLAG | Transform._LOCAL_QUAT_FLAG);
    this._setDirtyFlagFalse(Transform._LOCAL_EULER_FLAG);
    this._updateWorldRotationFlag();
  }
  get worldRotation() {
    if (this._isContainDirtyFlag(Transform._WORLD_EULER_FLAG)) {
      this.worldRotationQuaternion.toEuler(this._worldRotation);
      this._worldRotation.scale(MathUtil.radToDegreeFactor);
      this._setDirtyFlagFalse(Transform._WORLD_EULER_FLAG);
    }
    return this._worldRotation;
  }
  set worldRotation(value) {
    if (this._worldRotation !== value) {
      value.cloneTo(this._worldRotation);
    }
    Quaternion.rotationEuler(MathUtil.degreeToRadian(value.x), MathUtil.degreeToRadian(value.y), MathUtil.degreeToRadian(value.z), this._worldRotationQuaternion);
    this.worldRotationQuaternion = this._worldRotationQuaternion;
    this._setDirtyFlagFalse(Transform._WORLD_EULER_FLAG);
  }
  get rotationQuaternion() {
    if (this._isContainDirtyFlag(Transform._LOCAL_QUAT_FLAG)) {
      Quaternion.rotationEuler(MathUtil.degreeToRadian(this._rotation.x), MathUtil.degreeToRadian(this._rotation.y), MathUtil.degreeToRadian(this._rotation.z), this._rotationQuaternion);
      this._setDirtyFlagFalse(Transform._LOCAL_QUAT_FLAG);
    }
    return this._rotationQuaternion;
  }
  set rotationQuaternion(value) {
    if (this._rotationQuaternion !== value) {
      value.cloneTo(this._rotationQuaternion);
    }
    this._setDirtyFlagTrue(Transform._LOCAL_MATRIX_FLAG | Transform._LOCAL_EULER_FLAG);
    this._setDirtyFlagFalse(Transform._LOCAL_QUAT_FLAG);
    this._updateWorldRotationFlag();
  }
  get worldRotationQuaternion() {
    if (this._isContainDirtyFlag(Transform._WORLD_QUAT_FLAG)) {
      const parent = this._getParentTransform();
      if (parent != null) {
        Quaternion.multiply(parent.worldRotationQuaternion, this.rotationQuaternion, this._worldRotationQuaternion);
      } else {
        this.rotationQuaternion.cloneTo(this._worldRotationQuaternion);
      }
      this._setDirtyFlagFalse(Transform._WORLD_QUAT_FLAG);
    }
    return this._worldRotationQuaternion;
  }
  set worldRotationQuaternion(value) {
    if (this._worldRotationQuaternion !== value) {
      value.cloneTo(this._worldRotationQuaternion);
    }
    const parent = this._getParentTransform();
    if (parent) {
      Quaternion.invert(parent.worldRotationQuaternion, Transform._tempQuat0);
      Quaternion.multiply(value, Transform._tempQuat0, this._rotationQuaternion);
    } else {
      value.cloneTo(this._rotationQuaternion);
    }
    this.rotationQuaternion = this._rotationQuaternion;
    this._setDirtyFlagFalse(Transform._WORLD_QUAT_FLAG);
  }
  get scale() {
    return this._scale;
  }
  set scale(value) {
    if (this._scale !== value) {
      value.cloneTo(this._scale);
    }
    this._setDirtyFlagTrue(Transform._LOCAL_MATRIX_FLAG);
    this._updateWorldScaleFlag();
  }
  get lossyWorldScale() {
    if (this._isContainDirtyFlag(Transform._WORLD_SCALE_FLAG)) {
      if (this._getParentTransform()) {
        const scaleMat = this._getScaleMatrix();
        const e = scaleMat.elements;
        this._lossyWorldScale.setValue(e[0], e[4], e[8]);
      } else {
        this._scale.cloneTo(this._lossyWorldScale);
      }
      this._setDirtyFlagFalse(Transform._WORLD_SCALE_FLAG);
    }
    return this._lossyWorldScale;
  }
  get localMatrix() {
    if (this._isContainDirtyFlag(Transform._LOCAL_MATRIX_FLAG)) {
      Matrix.affineTransformation(this._scale, this.rotationQuaternion, this._position, this._localMatrix);
      this._setDirtyFlagFalse(Transform._LOCAL_MATRIX_FLAG);
    }
    return this._localMatrix;
  }
  set localMatrix(value) {
    if (this._localMatrix !== value) {
      value.cloneTo(this._localMatrix);
    }
    this._localMatrix.decompose(this._position, this._rotationQuaternion, this._scale);
    this._setDirtyFlagTrue(Transform._LOCAL_EULER_FLAG);
    this._setDirtyFlagFalse(Transform._LOCAL_MATRIX_FLAG);
    this._updateAllWorldFlag();
  }
  get worldMatrix() {
    if (this._isContainDirtyFlag(Transform._WORLD_MATRIX_FLAG)) {
      const parent = this._getParentTransform();
      if (parent) {
        Matrix.multiply(parent.worldMatrix, this.localMatrix, this._worldMatrix);
      } else {
        this.localMatrix.cloneTo(this._worldMatrix);
      }
      this._setDirtyFlagFalse(Transform._WORLD_MATRIX_FLAG);
    }
    return this._worldMatrix;
  }
  set worldMatrix(value) {
    if (this._worldMatrix !== value) {
      value.cloneTo(this._worldMatrix);
    }
    const parent = this._getParentTransform();
    if (parent) {
      Matrix.invert(parent.worldMatrix, Transform._tempMat42);
      Matrix.multiply(value, Transform._tempMat42, this._localMatrix);
    } else {
      value.cloneTo(this._localMatrix);
    }
    this.localMatrix = this._localMatrix;
    this._setDirtyFlagFalse(Transform._WORLD_MATRIX_FLAG);
  }
  setPosition(x, y, z) {
    this._position.setValue(x, y, z);
    this.position = this._position;
  }
  setRotation(x, y, z) {
    this._rotation.setValue(x, y, z);
    this.rotation = this._rotation;
  }
  setRotationQuaternion(x, y, z, w) {
    this._rotationQuaternion.setValue(x, y, z, w);
    this.rotationQuaternion = this._rotationQuaternion;
  }
  setScale(x, y, z) {
    this._scale.setValue(x, y, z);
    this.scale = this._scale;
  }
  setWorldPosition(x, y, z) {
    this._worldPosition.setValue(x, y, z);
    this.worldPosition = this._worldPosition;
  }
  setWorldRotation(x, y, z) {
    this._worldRotation.setValue(x, y, z);
    this.worldRotation = this._worldRotation;
  }
  setWorldRotationQuaternion(x, y, z, w) {
    this._worldRotationQuaternion.setValue(x, y, z, w);
    this.worldRotationQuaternion = this._worldRotationQuaternion;
  }
  getWorldForward(forward) {
    const e = this.worldMatrix.elements;
    forward.setValue(-e[8], -e[9], -e[10]);
    return forward.normalize();
  }
  getWorldRight(right) {
    const e = this.worldMatrix.elements;
    right.setValue(e[0], e[1], e[2]);
    return right.normalize();
  }
  getWorldUp(up) {
    const e = this.worldMatrix.elements;
    up.setValue(e[4], e[5], e[6]);
    return up.normalize();
  }
  translate(translation, relativeToLocal = true) {
    if (relativeToLocal) {
      const rotationMat = Transform._tempMat40;
      Matrix.rotationQuaternion(this.rotationQuaternion, rotationMat);
      Vector3.transformCoordinate(translation, rotationMat, Transform._tempVec3);
      this.position = this._position.add(Transform._tempVec3);
    } else {
      this.worldPosition = this._worldPosition.add(translation);
    }
  }
  translateXYZ(x, y, z, relativeToLocal = true) {
    const translate = Transform._tempVec3;
    translate.setValue(x, y, z);
    this.translate(translate, relativeToLocal);
  }
  rotate(rotation, relativeToLocal = true) {
    this.rotateXYZ(rotation.x, rotation.y, rotation.z, relativeToLocal);
  }
  rotateXYZ(x, y, z, relativeToLocal = true) {
    const radFactor = MathUtil.degreeToRadFactor;
    const rotQuat = Transform._tempQuat0;
    Quaternion.rotationEuler(x * radFactor, y * radFactor, z * radFactor, rotQuat);
    this._rotateByQuat(rotQuat, relativeToLocal);
  }
  rotateByAxis(axis, angle, relativeToLocal = true) {
    const rad = angle * MathUtil.degreeToRadFactor;
    Quaternion.rotationAxisAngle(axis, rad, Transform._tempQuat0);
    this._rotateByQuat(Transform._tempQuat0, relativeToLocal);
  }
  lookAt(worldPosition, worldUp) {
    const position = this.worldPosition;
    const EPSILON = MathUtil.zeroTolerance;
    if (Math.abs(position.x - worldPosition.x) < EPSILON && Math.abs(position.y - worldPosition.y) < EPSILON && Math.abs(position.z - worldPosition.z) < EPSILON) {
      return;
    }
    const rotMat = Transform._tempMat43;
    const worldRotationQuaternion = this._worldRotationQuaternion;
    worldUp = worldUp ?? Transform._tempVec3.setValue(0, 1, 0);
    Matrix.lookAt(position, worldPosition, worldUp, rotMat);
    rotMat.getRotation(worldRotationQuaternion).invert();
    this.worldRotationQuaternion = worldRotationQuaternion;
  }
  registerWorldChangeFlag() {
    const flag = new UpdateFlag(this._changeFlags);
    this._changeFlags.push(flag);
    return flag;
  }
  _parentChange() {
    this._isParentDirty = true;
    this._updateAllWorldFlag();
  }
  _updateWorldPositionFlag() {
    if (!this._isContainDirtyFlags(Transform._WM_WP_FLAGS)) {
      this._worldAssociatedChange(Transform._WM_WP_FLAGS);
      const nodeChildren = this._entity._children;
      for (let i = 0, n = nodeChildren.length; i < n; i++) {
        nodeChildren[i].transform?._updateWorldPositionFlag();
      }
    }
  }
  _updateWorldRotationFlag() {
    if (!this._isContainDirtyFlags(Transform._WM_WE_WQ_FLAGS)) {
      this._worldAssociatedChange(Transform._WM_WE_WQ_FLAGS);
      const nodeChildren = this._entity._children;
      for (let i = 0, n = nodeChildren.length; i < n; i++) {
        nodeChildren[i].transform?._updateWorldPositionAndRotationFlag();
      }
    }
  }
  _updateWorldPositionAndRotationFlag() {
    if (!this._isContainDirtyFlags(Transform._WM_WP_WE_WQ_FLAGS)) {
      this._worldAssociatedChange(Transform._WM_WP_WE_WQ_FLAGS);
      const nodeChildren = this._entity._children;
      for (let i = 0, n = nodeChildren.length; i < n; i++) {
        nodeChildren[i].transform?._updateWorldPositionAndRotationFlag();
      }
    }
  }
  _updateWorldScaleFlag() {
    if (!this._isContainDirtyFlags(Transform._WM_WS_FLAGS)) {
      this._worldAssociatedChange(Transform._WM_WS_FLAGS);
      const nodeChildren = this._entity._children;
      for (let i = 0, n = nodeChildren.length; i < n; i++) {
        nodeChildren[i].transform?._updateWorldPositionAndScaleFlag();
      }
    }
  }
  _updateWorldPositionAndScaleFlag() {
    if (!this._isContainDirtyFlags(Transform._WM_WP_WS_FLAGS)) {
      this._worldAssociatedChange(Transform._WM_WP_WS_FLAGS);
      const nodeChildren = this._entity._children;
      for (let i = 0, n = nodeChildren.length; i < n; i++) {
        nodeChildren[i].transform?._updateWorldPositionAndScaleFlag();
      }
    }
  }
  _updateAllWorldFlag() {
    if (!this._isContainDirtyFlags(Transform._WM_WP_WE_WQ_WS_FLAGS)) {
      this._worldAssociatedChange(Transform._WM_WP_WE_WQ_WS_FLAGS);
      const nodeChildren = this._entity._children;
      for (let i = 0, n = nodeChildren.length; i < n; i++) {
        nodeChildren[i].transform?._updateAllWorldFlag();
      }
    }
  }
  _getParentTransform() {
    if (!this._isParentDirty) {
      return this._parentTransformCache;
    }
    let parentCache = null;
    let parent = this._entity.parent;
    while (parent) {
      const transform = parent.transform;
      if (transform) {
        parentCache = transform;
        break;
      } else {
        parent = parent.parent;
      }
    }
    this._parentTransformCache = parentCache;
    this._isParentDirty = false;
    return parentCache;
  }
  _getScaleMatrix() {
    const invRotation = Transform._tempQuat0;
    const invRotationMat = Transform._tempMat30;
    const worldRotScaMat = Transform._tempMat31;
    const scaMat = Transform._tempMat32;
    worldRotScaMat.setValueByMatrix(this.worldMatrix);
    Quaternion.invert(this.worldRotationQuaternion, invRotation);
    Matrix3x3.rotationQuaternion(invRotation, invRotationMat);
    Matrix3x3.multiply(invRotationMat, worldRotScaMat, scaMat);
    return scaMat;
  }
  _isContainDirtyFlags(targetDirtyFlags) {
    return (this._dirtyFlag & targetDirtyFlags) === targetDirtyFlags;
  }
  _isContainDirtyFlag(type) {
    return (this._dirtyFlag & type) != 0;
  }
  _setDirtyFlagTrue(type) {
    this._dirtyFlag |= type;
  }
  _setDirtyFlagFalse(type) {
    this._dirtyFlag &= ~type;
  }
  _worldAssociatedChange(type) {
    this._dirtyFlag |= type;
    const len = this._changeFlags.length;
    for (let i = len - 1; i >= 0; i--) {
      this._changeFlags[i].flag = true;
    }
  }
  _rotateByQuat(rotateQuat, relativeToLocal) {
    if (relativeToLocal) {
      Quaternion.multiply(this.rotationQuaternion, rotateQuat, this._rotationQuaternion);
      this.rotationQuaternion = this._rotationQuaternion;
    } else {
      Quaternion.multiply(this.worldRotationQuaternion, rotateQuat, this._worldRotationQuaternion);
      this.worldRotationQuaternion = this._worldRotationQuaternion;
    }
  }
}
Transform._tempQuat0 = new Quaternion();
Transform._tempVec3 = new Vector3();
Transform._tempMat30 = new Matrix3x3();
Transform._tempMat31 = new Matrix3x3();
Transform._tempMat32 = new Matrix3x3();
Transform._tempMat40 = new Matrix();
Transform._tempMat41 = new Matrix();
Transform._tempMat42 = new Matrix();
Transform._tempMat43 = new Matrix();
Transform._LOCAL_EULER_FLAG = 1;
Transform._LOCAL_QUAT_FLAG = 2;
Transform._WORLD_POSITION_FLAG = 4;
Transform._WORLD_EULER_FLAG = 8;
Transform._WORLD_QUAT_FLAG = 16;
Transform._WORLD_SCALE_FLAG = 32;
Transform._LOCAL_MATRIX_FLAG = 64;
Transform._WORLD_MATRIX_FLAG = 128;
Transform._WM_WP_FLAGS = 132;
Transform._WM_WE_WQ_FLAGS = 152;
Transform._WM_WP_WE_WQ_FLAGS = 156;
Transform._WM_WS_FLAGS = 160;
Transform._WM_WP_WS_FLAGS = 164;
Transform._WM_WP_WE_WQ_WS_FLAGS = 188;
__decorate$3([
  deepClone
], Transform.prototype, "_position", 2);
__decorate$3([
  deepClone
], Transform.prototype, "_rotation", 2);
__decorate$3([
  deepClone
], Transform.prototype, "_rotationQuaternion", 2);
__decorate$3([
  deepClone
], Transform.prototype, "_scale", 2);
__decorate$3([
  deepClone
], Transform.prototype, "_worldPosition", 2);
__decorate$3([
  deepClone
], Transform.prototype, "_worldRotation", 2);
__decorate$3([
  deepClone
], Transform.prototype, "_worldRotationQuaternion", 2);
__decorate$3([
  deepClone
], Transform.prototype, "_lossyWorldScale", 2);
__decorate$3([
  deepClone
], Transform.prototype, "_localMatrix", 2);
__decorate$3([
  deepClone
], Transform.prototype, "_worldMatrix", 2);
__decorate$3([
  ignoreClone
], Transform.prototype, "_changeFlags", 2);
__decorate$3([
  ignoreClone
], Transform.prototype, "_isParentDirty", 2);
__decorate$3([
  ignoreClone
], Transform.prototype, "_parentTransformCache", 2);

class Entity extends EventDispatcher {
  constructor(engine, name) {
    super(engine);
    this.layer = Layer.Layer0;
    this._isActiveInHierarchy = false;
    this._components = [];
    this._children = [];
    this._isRoot = false;
    this._isActive = true;
    this._parent = null;
    this._invModelMatrix = new Matrix();
    Entity._entitys.add(this);
    this.name = name;
    this.transform = this.addComponent(Transform);
    this._inverseWorldMatFlag = this.transform.registerWorldChangeFlag();
  }
  static findByName(name) {
    const entitys = Entity._entitys;
    const elements = entitys._elements;
    for (let i = entitys.length - 1; i >= 0; i--) {
      const entity = elements[i];
      if (entity.name === name) {
        return entity;
      }
    }
    return null;
  }
  static findByPath(scene, path) {
    return scene.findEntityByPath(path);
  }
  static _findChildByName(root, name) {
    const children = root._children;
    for (let i = children.length - 1; i >= 0; i--) {
      const child = children[i];
      if (child.name === name) {
        return child;
      }
    }
    return null;
  }
  static _traverseSetOwnerScene(entity, scene) {
    entity._scene = scene;
    const children = entity._children;
    for (let i = entity.childCount - 1; i >= 0; i--) {
      this._traverseSetOwnerScene(children[i], scene);
    }
  }
  get isActive() {
    return this._isActive;
  }
  set isActive(value) {
    if (value !== this._isActive) {
      this._isActive = value;
      if (value) {
        const parent = this._parent;
        if (parent?._isActiveInHierarchy || this._isRoot && this._scene._isActiveInEngine) {
          this._processActive();
        }
      } else {
        if (this._isActiveInHierarchy) {
          this._processInActive();
        }
      }
    }
  }
  get isActiveInHierarchy() {
    return this._isActiveInHierarchy;
  }
  get parent() {
    return this._parent;
  }
  set parent(entity) {
    if (entity !== this._parent) {
      const oldParent = this._removeFromParent();
      const newParent = this._parent = entity;
      if (newParent) {
        newParent._children.push(this);
        const parentScene = newParent._scene;
        if (this._scene !== parentScene) {
          Entity._traverseSetOwnerScene(this, parentScene);
        }
        if (newParent._isActiveInHierarchy) {
          !this._isActiveInHierarchy && this._isActive && this._processActive();
        } else {
          this._isActiveInHierarchy && this._processInActive();
        }
      } else {
        this._isActiveInHierarchy && this._processInActive();
        if (oldParent) {
          Entity._traverseSetOwnerScene(this, null);
        }
      }
      this._setTransformDirty();
    }
  }
  get children() {
    return this._children;
  }
  get childCount() {
    return this._children.length;
  }
  get scene() {
    return this._scene;
  }
  get engine() {
    return this._engine;
  }
  addComponent(type) {
    ComponentsDependencies._addCheck(this, type);
    const component = new type(this);
    this._components.push(component);
    if (this._isActiveInHierarchy) {
      component._setActive(true);
    }
    return component;
  }
  getComponent(type) {
    for (let i = this._components.length - 1; i >= 0; i--) {
      const component = this._components[i];
      if (component instanceof type) {
        return component;
      }
    }
  }
  getComponents(type, results) {
    results.length = 0;
    for (let i = this._components.length - 1; i >= 0; i--) {
      const component = this._components[i];
      if (component instanceof type) {
        results.push(component);
      }
    }
    return results;
  }
  getComponentsIncludeChildren(type, results) {
    results.length = 0;
    this._getComponentsIncludeChildren(type, results);
    return results;
  }
  addChild(child) {
    child.parent = this;
  }
  removeChild(child) {
    child.parent = null;
  }
  getChild(index) {
    return this._children[index];
  }
  findByName(name) {
    const children = this._children;
    const child = Entity._findChildByName(this, name);
    if (child)
      return child;
    for (let i = children.length - 1; i >= 0; i--) {
      const child2 = children[i];
      const grandson = child2.findByName(name);
      if (grandson) {
        return grandson;
      }
    }
    return null;
  }
  findByPath(path) {
    const splits = path.split("/");
    let entity = this;
    for (let i = 0, length = splits.length; i < length; ++i) {
      const split = splits[i];
      if (split) {
        entity = Entity._findChildByName(entity, split);
        if (!entity) {
          return null;
        }
      }
    }
    return entity;
  }
  createChild(name) {
    const child = new Entity(this.engine, name);
    child.layer = this.layer;
    child.parent = this;
    return child;
  }
  clearChildren() {
    const children = this._children;
    for (let i = children.length - 1; i >= 0; i--) {
      const child = children[i];
      child._parent = null;
      child._isActiveInHierarchy && child._processInActive();
      Entity._traverseSetOwnerScene(child, null);
    }
    children.length = 0;
  }
  clone() {
    const cloneEntity = new Entity(this._engine, this.name);
    cloneEntity._isActive = this._isActive;
    cloneEntity.transform.localMatrix = this.transform.localMatrix;
    const children = this._children;
    for (let i = 0, len = this._children.length; i < len; i++) {
      const child = children[i];
      cloneEntity.addChild(child.clone());
    }
    const components = this._components;
    for (let i = 0, n = components.length; i < n; i++) {
      const sourceComp = components[i];
      if (!(sourceComp instanceof Transform)) {
        const targetComp = cloneEntity.addComponent(sourceComp.constructor);
        ComponentCloner.cloneComponent(sourceComp, targetComp);
      }
    }
    return cloneEntity;
  }
  destroy() {
    const abilityArray = this._components;
    for (let i = abilityArray.length - 1; i >= 0; i--) {
      abilityArray[i].destroy();
    }
    this._components.length = 0;
    const children = this._children;
    for (let i = children.length - 1; i >= 0; i--) {
      children[i].destroy();
    }
    this._children.length = 0;
    if (this._parent != null) {
      const parentChildren = this._parent._children;
      parentChildren.splice(parentChildren.indexOf(this), 1);
    }
    this._parent = null;
    Entity._entitys.delete(this);
  }
  _removeComponent(component) {
    ComponentsDependencies._removeCheck(this, component.constructor);
    const components = this._components;
    components.splice(components.indexOf(component), 1);
  }
  _removeFromParent() {
    const oldParent = this._parent;
    if (oldParent != null) {
      const oldParentChildren = oldParent._children;
      oldParentChildren.splice(oldParentChildren.indexOf(this), 1);
      this._parent = null;
    }
    return oldParent;
  }
  _processActive() {
    if (this._activeChangedComponents) {
      throw "Note: can't set the 'main inActive entity' active in hierarchy, if the operation is in main inActive entity or it's children script's onDisable Event.";
    }
    this._activeChangedComponents = this._engine._componentsManager.getActiveChangedTempList();
    this._setActiveInHierarchy(this._activeChangedComponents);
    this._setActiveComponents(true);
  }
  _processInActive() {
    if (this._activeChangedComponents) {
      throw "Note: can't set the 'main active entity' inActive in hierarchy, if the operation is in main active entity or it's children script's onEnable Event.";
    }
    this._activeChangedComponents = this._engine._componentsManager.getActiveChangedTempList();
    this._setInActiveInHierarchy(this._activeChangedComponents);
    this._setActiveComponents(false);
  }
  _getComponentsIncludeChildren(type, results) {
    for (let i = this._components.length - 1; i >= 0; i--) {
      const component = this._components[i];
      if (component instanceof type) {
        results.push(component);
      }
    }
    for (let i = this._children.length - 1; i >= 0; i--) {
      this._children[i]._getComponentsIncludeChildren(type, results);
    }
  }
  _setActiveComponents(isActive) {
    const activeChangedComponents = this._activeChangedComponents;
    for (let i = 0, length = activeChangedComponents.length; i < length; ++i) {
      activeChangedComponents[i]._setActive(isActive);
    }
    this._engine._componentsManager.putActiveChangedTempList(activeChangedComponents);
    this._activeChangedComponents = null;
  }
  _setActiveInHierarchy(activeChangedComponents) {
    this._isActiveInHierarchy = true;
    const components = this._components;
    for (let i = components.length - 1; i >= 0; i--) {
      activeChangedComponents.push(components[i]);
    }
    const children = this._children;
    for (let i = children.length - 1; i >= 0; i--) {
      const child = children[i];
      child.isActive && child._setActiveInHierarchy(activeChangedComponents);
    }
  }
  _setInActiveInHierarchy(activeChangedComponents) {
    this._isActiveInHierarchy = false;
    const components = this._components;
    for (let i = components.length - 1; i >= 0; i--) {
      activeChangedComponents.push(components[i]);
    }
    const children = this._children;
    for (let i = children.length - 1; i >= 0; i--) {
      const child = children[i];
      child.isActive && child._setInActiveInHierarchy(activeChangedComponents);
    }
  }
  _setTransformDirty() {
    if (this.transform) {
      this.transform._parentChange();
    } else {
      for (let i = 0, len = this._children.length; i < len; i++) {
        this._children[i]._setTransformDirty();
      }
    }
  }
  get position() {
    return this.transform.position;
  }
  set position(val) {
    this.transform.position = val;
  }
  get worldPosition() {
    return this.transform.worldPosition;
  }
  set worldPosition(val) {
    this.transform.worldPosition = val;
  }
  get rotation() {
    return this.transform.rotationQuaternion;
  }
  set rotation(val) {
    this.transform.rotationQuaternion = val;
  }
  get scale() {
    return this.transform.scale;
  }
  set scale(val) {
    this.transform.scale = val;
  }
  getInvModelMatrix() {
    if (this._inverseWorldMatFlag.flag) {
      Matrix.invert(this.transform.worldMatrix, this._invModelMatrix);
      this._inverseWorldMatFlag.flag = false;
    }
    return this._invModelMatrix;
  }
}
Entity._entitys = new DisorderedArray();

class FeatureManager {
  constructor() {
    this._features = [];
    this._objects = [];
  }
  registerFeature(IFeature) {
    const featureArray = this._features;
    for (let i = 0, len = featureArray.length; i < len; i++) {
      if (featureArray[i] === IFeature) {
        return;
      }
    }
    featureArray.push(IFeature);
    const objectArray = this._objects;
    for (let i = 0, len = objectArray.length; i < len; i++) {
      objectArray[i].features.push(new IFeature());
    }
  }
  addObject(obj) {
    obj.features = [];
    for (let i = 0, len = this._features.length; i < len; i++) {
      obj.features.push(new this._features[i](obj.engine ?? obj));
    }
    this._objects.push(obj);
  }
  callFeatureMethod(obj, method, args) {
    const features = obj.features;
    const count = features.length;
    for (let i = 0; i < count; i++) {
      const feature = features[i];
      if (feature[method]) {
        feature[method].apply(feature, args);
      }
    }
  }
  findFeature(obj, IFeature) {
    const features = obj.features;
    const count = features.length;
    for (let i = 0; i < count; i++) {
      const feature = features[i];
      if (feature.constructor === IFeature) {
        return feature;
      }
    }
    return void 0;
  }
}

class RenderElement {
  static getFromPool() {
    const {_elementPoolIndex: index, _elementPool: pool} = RenderElement;
    RenderElement._elementPoolIndex++;
    if (pool.length === index) {
      const element = new RenderElement();
      pool.push(element);
      return element;
    } else {
      return pool[index];
    }
  }
  static _restPool() {
    RenderElement._elementPoolIndex = 0;
  }
  setValue(component, primitive, subPrimitive, material) {
    this.component = component;
    this.primitive = primitive;
    this.subPrimitive = subPrimitive;
    this.material = material;
  }
}
RenderElement._elementPoolIndex = 0;
RenderElement._elementPool = [];

class Scene extends EventDispatcher {
  constructor(engine, name) {
    super(engine);
    this.clipPlanes = [];
    this._activeCameras = [];
    this._isActiveInEngine = false;
    this._destroyed = false;
    this._rootEntities = [];
    this.features = [];
    this.name = name || "";
    Scene.sceneFeatureManager.addObject(this);
  }
  get engine() {
    return this._engine;
  }
  get rootEntitiesCount() {
    return this._rootEntities.length;
  }
  get rootEntities() {
    return this._rootEntities;
  }
  get destroyed() {
    return this._destroyed;
  }
  createRootEntity(name) {
    const entity = new Entity(this._engine, name);
    this.addRootEntity(entity);
    return entity;
  }
  addRootEntity(entity) {
    const isRoot = entity._isRoot;
    if (!isRoot) {
      entity._isRoot = true;
      entity._removeFromParent();
    }
    const oldScene = entity._scene;
    if (oldScene !== this) {
      if (oldScene && isRoot) {
        oldScene._removeEntity(entity);
      }
      this._rootEntities.push(entity);
      Entity._traverseSetOwnerScene(entity, this);
    } else if (!isRoot) {
      this._rootEntities.push(entity);
    }
    if (this._isActiveInEngine) {
      !entity._isActiveInHierarchy && entity._isActive && entity._processActive();
    } else {
      entity._isActiveInHierarchy && entity._processInActive();
    }
  }
  removeRootEntity(entity) {
    if (entity._isRoot && entity._scene == this) {
      this._removeEntity(entity);
      this._isActiveInEngine && entity._processInActive();
      Entity._traverseSetOwnerScene(entity, null);
    }
  }
  getRootEntity(index = 0) {
    return this._rootEntities[index];
  }
  findEntityByName(name) {
    const children = this._rootEntities;
    for (let i = children.length - 1; i >= 0; i--) {
      const child = children[i];
      if (child.name === name) {
        return child;
      }
    }
    for (let i = children.length - 1; i >= 0; i--) {
      const child = children[i];
      const entity = child.findByName(name);
      if (entity) {
        return entity;
      }
    }
    return null;
  }
  findEntityByPath(path) {
    const splits = path.split("/").filter(Boolean);
    for (let i = 0, n = this.rootEntitiesCount; i < n; i++) {
      let findEntity = this.getRootEntity(i);
      if (findEntity.name != splits[0])
        continue;
      for (let j = 1, m = splits.length; j < m; ++j) {
        findEntity = Entity._findChildByName(findEntity, splits[j]);
        if (!findEntity)
          break;
      }
      return findEntity;
    }
    return null;
  }
  destroy() {
    this._isActiveInEngine && (this._engine.sceneManager.activeScene = null);
    Scene.sceneFeatureManager.callFeatureMethod(this, "destroy", [this]);
    for (let i = 0, n = this.rootEntitiesCount; i < n; i++) {
      this._rootEntities[i].destroy();
    }
    this._rootEntities.length = 0;
    this._activeCameras.length = 0;
    Scene.sceneFeatureManager._objects = [];
    this._destroyed = true;
  }
  attachRenderCamera(camera) {
    const index = this._activeCameras.indexOf(camera);
    if (index === -1) {
      this._activeCameras.push(camera);
    } else {
      Logger.warn("Camera already attached.");
    }
  }
  detachRenderCamera(camera) {
    const index = this._activeCameras.indexOf(camera);
    if (index !== -1) {
      this._activeCameras.splice(index, 1);
    }
  }
  _processActive(active) {
    this._isActiveInEngine = active;
    const rootEntities = this._rootEntities;
    for (let i = rootEntities.length - 1; i >= 0; i--) {
      const entity = rootEntities[i];
      if (entity._isActive) {
        active ? entity._processActive() : entity._processInActive();
      }
    }
  }
  _removeEntity(entity) {
    const oldRootEntities = this._rootEntities;
    oldRootEntities.splice(oldRootEntities.indexOf(entity), 1);
  }
  static registerFeature(Feature) {
    Scene.sceneFeatureManager.registerFeature(Feature);
  }
  findFeature(Feature) {
    return Scene.sceneFeatureManager.findFeature(this, Feature);
  }
  raycast(ray, outPos, tag) {
  }
}
Scene.sceneFeatureManager = new FeatureManager();

class SceneManager {
  constructor(engine) {
    this.engine = engine;
  }
  get activeScene() {
    return this._activeScene;
  }
  set activeScene(scene) {
    const oldScene = this._activeScene;
    if (oldScene !== scene) {
      oldScene && oldScene._processActive(false);
      scene && scene._processActive(true);
      this._activeScene = scene;
    }
  }
  loadScene(url, destroyOldScene = true) {
    const scenePromise = this.engine.resourceManager.load(url);
    scenePromise.then((scene) => {
      const oldScene = this._activeScene;
      this.activeScene = scene;
      if (oldScene && destroyOldScene) {
        oldScene.destroy();
      }
    });
    return scenePromise;
  }
  mergeScenes(sourceScene, destScene) {
    const oldRootEntities = sourceScene.rootEntities;
    for (let i = 0, n = oldRootEntities.length; i < n; i++) {
      destScene.addRootEntity(oldRootEntities[i]);
    }
  }
}

const engineFeatureManager = new FeatureManager();
class Engine extends EventDispatcher {
  constructor(canvas, hardwareRenderer) {
    super(null);
    this._componentsManager = new ComponentsManager();
    this._resourceManager = new ResourceManager(this);
    this._sceneManager = new SceneManager(this);
    this._vSyncCount = 1;
    this._targetFrameRate = 60;
    this._time = new Time();
    this._isPaused = true;
    this._loopCounter = 0;
    this._targetFrameInterval = 1e3 / 60;
    this._animate = () => {
      if (this._vSyncCount) {
        this._requestId = requestAnimationFrame(this._animate);
        if (this._loopCounter++ % this._vSyncCount === 0) {
          this.update();
          this._loopCounter = 1;
        }
      } else {
        this._timeoutId = window.setTimeout(this._animate, this._targetFrameInterval);
        this.update();
      }
    };
    this.features = [];
    this._hardwareRenderer = hardwareRenderer;
    this._hardwareRenderer.init(canvas, this);
    this._canvas = canvas;
    engineFeatureManager.addObject(this);
    this._sceneManager.activeScene = new Scene(this, "DefaultScene");
  }
  get canvas() {
    return this._canvas;
  }
  get resourceManager() {
    return this._resourceManager;
  }
  get sceneManager() {
    return this._sceneManager;
  }
  get time() {
    return this._time;
  }
  get isPaused() {
    return this._isPaused;
  }
  get vSyncCount() {
    return this._vSyncCount;
  }
  set vSyncCount(value) {
    this._vSyncCount = Math.max(0, Math.floor(value));
  }
  get targetFrameRate() {
    return this._targetFrameRate;
  }
  set targetFrameRate(value) {
    value = Math.max(1e-6, value);
    this._targetFrameRate = value;
    this._targetFrameInterval = 1e3 / value;
  }
  get renderhardware() {
    return this._hardwareRenderer;
  }
  createEntity(name) {
    return new Entity(this, name);
  }
  pause() {
    this._isPaused = true;
    cancelAnimationFrame(this._requestId);
    clearTimeout(this._timeoutId);
  }
  resume() {
    if (!this._isPaused)
      return;
    this._isPaused = false;
    this.time.reset();
    requestAnimationFrame(this._animate);
  }
  update() {
    const time = this._time;
    const deltaTime = time.deltaTime;
    time.tick();
    RenderElement._restPool();
    engineFeatureManager.callFeatureMethod(this, "preTick", [this, this._sceneManager._activeScene]);
    this._hardwareRenderer.beginFrame();
    const scene = this._sceneManager._activeScene;
    const componentsManager = this._componentsManager;
    if (scene) {
      componentsManager.callScriptOnStart();
      componentsManager.callScriptOnUpdate(deltaTime);
      componentsManager.callAnimationUpdate(deltaTime);
      componentsManager.callScriptOnLateUpdate(deltaTime);
      this._render(scene);
    }
    this._componentsManager.callComponentDestory();
    this._hardwareRenderer.endFrame();
    engineFeatureManager.callFeatureMethod(this, "postTick", [this, this._sceneManager._activeScene]);
  }
  run() {
    engineFeatureManager.callFeatureMethod(this, "preLoad", [this]);
    this.resume();
    this.trigger(new Event("run", this));
  }
  destroy() {
    if (this._sceneManager) {
      this.trigger(new Event("shutdown", this));
      engineFeatureManager.callFeatureMethod(this, "shutdown", [this]);
      this.pause();
      this._animate = null;
      this._sceneManager._activeScene.destroy();
      this._sceneManager = null;
      this._resourceManager.gc();
      this._resourceManager = null;
      this._canvas = null;
      this.features = [];
      this._time = null;
      engineFeatureManager._objects = [];
    }
  }
  _render(scene) {
    const cameras = scene._activeCameras;
    const componentsManager = this._componentsManager;
    const deltaTime = this.time.deltaTime;
    componentsManager.callRendererOnUpdate(deltaTime);
    if (cameras.length > 0) {
      cameras.sort((camera1, camera2) => camera1.priority - camera2.priority);
      for (let i = 0, l = cameras.length; i < l; i++) {
        const camera = cameras[i];
        const cameraEntity = camera.entity;
        if (camera.enabled && cameraEntity.isActiveInHierarchy) {
          componentsManager.callCameraOnBeginRender(camera);
          Scene.sceneFeatureManager.callFeatureMethod(scene, "preRender", [this, camera]);
          camera.render();
          Scene.sceneFeatureManager.callFeatureMethod(scene, "postRender", [this, camera]);
          componentsManager.callCameraOnEndRender(camera);
        }
      }
    } else {
      Logger.debug("NO active camera.");
    }
  }
  findFeature(Feature) {
    return engineFeatureManager.findFeature(this, Feature);
  }
  static registerFeature(Feature) {
    engineFeatureManager.registerFeature(Feature);
  }
}

class SystemInfo {
  static get devicePixelRatio() {
    return window.devicePixelRatio;
  }
}

class EngineFeature {
  preLoad(engine) {
  }
  preTick(engine, currentScene) {
  }
  postTick(engine, currentScene) {
  }
  shutdown(engine) {
  }
}

class AssetObject extends EngineObject {
}

class SceneVisitor {
}

class SceneFeature {
  preUpdate(scene) {
  }
  postUpdate(scene) {
  }
  preRender(scene, camera) {
  }
  postRender(scene, camera) {
  }
  destroy(scene) {
  }
}

var __defProp$4 = Object.defineProperty;
var __getOwnPropDesc$4 = Object.getOwnPropertyDescriptor;
var __decorate$4 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$4(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$4(target, key, result);
  return result;
};
class Script extends Component {
  constructor() {
    super(...arguments);
    this._started = false;
    this._onStartIndex = -1;
    this._onUpdateIndex = -1;
    this._onLateUpdateIndex = -1;
    this._onPreRenderIndex = -1;
    this._onPostRenderIndex = -1;
  }
  onAwake() {
  }
  onEnable() {
  }
  onStart() {
  }
  onUpdate(deltaTime) {
  }
  onLateUpdate(deltaTime) {
  }
  onBeginRender(camera) {
  }
  onEndRender(camera) {
  }
  onDisable() {
  }
  onDestroy() {
  }
  _onAwake() {
    this.onAwake();
  }
  _onEnable() {
    const componentsManager = this.engine._componentsManager;
    const prototype = Script.prototype;
    if (!this._started) {
      componentsManager.addOnStartScript(this);
    }
    if (this.onUpdate !== prototype.onUpdate) {
      componentsManager.addOnUpdateScript(this);
    }
    if (this.onLateUpdate !== prototype.onLateUpdate) {
      componentsManager.addOnLateUpdateScript(this);
    }
    this.onEnable();
  }
  _onDisable() {
    const componentsManager = this.engine._componentsManager;
    if (this._onStartIndex !== -1) {
      componentsManager.removeOnStartScript(this);
    }
    if (this._onUpdateIndex !== -1) {
      componentsManager.removeOnUpdateScript(this);
    }
    if (this._onLateUpdateIndex !== -1) {
      componentsManager.removeOnLateUpdateScript(this);
    }
    this.onDisable();
  }
  _onDestroy() {
    this.engine._componentsManager.addDestoryComponent(this);
  }
}
__decorate$4([
  ignoreClone
], Script.prototype, "_started", 2);
__decorate$4([
  ignoreClone
], Script.prototype, "_onStartIndex", 2);
__decorate$4([
  ignoreClone
], Script.prototype, "_onUpdateIndex", 2);
__decorate$4([
  ignoreClone
], Script.prototype, "_onLateUpdateIndex", 2);
__decorate$4([
  ignoreClone
], Script.prototype, "_onPreRenderIndex", 2);
__decorate$4([
  ignoreClone
], Script.prototype, "_onPostRenderIndex", 2);

var __defProp$5 = Object.defineProperty;
var __getOwnPropDesc$5 = Object.getOwnPropertyDescriptor;
var __decorate$5 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$5(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$5(target, key, result);
  return result;
};
class RenderableComponent extends Component {
  constructor(entity) {
    super(entity);
    this._onUpdateIndex = -1;
    this._rendererIndex = -1;
    this._overrideUpdate = false;
    this._bounds = new BoundingBox(new Vector3(), new Vector3());
    const prototype = RenderableComponent.prototype;
    this._overrideUpdate = this.update !== prototype.update;
    this._transformChangeFlag = this.entity.transform.registerWorldChangeFlag();
  }
  get bounds() {
    const changeFlag = this._transformChangeFlag;
    if (changeFlag.flag) {
      this._updateBounds(this._bounds);
      changeFlag.flag = false;
    }
    return this._bounds;
  }
  destroy() {
    super.destroy();
    const flag = this._transformChangeFlag;
    if (flag) {
      flag.destroy();
      this._transformChangeFlag = null;
    }
  }
  update(deltaTime) {
  }
  _updateBounds(worldBounds) {
  }
  _onEnable() {
    const componentsManager = this.engine._componentsManager;
    if (this._overrideUpdate) {
      componentsManager.addOnUpdateRenderers(this);
    }
    componentsManager.addRenderer(this);
  }
  _onDisable() {
    const componentsManager = this.engine._componentsManager;
    if (this._overrideUpdate) {
      componentsManager.removeOnUpdateRenderers(this);
    }
    componentsManager.removeRenderer(this);
  }
  _render(camera) {
    let culled = false;
    if (this.cullDistanceSq > 0) {
      const distanceSq = Vector3.distanceSquared(camera._entity.transform.worldPosition, this.entity.transform.worldPosition);
      culled = this.cullDistanceSq < distanceSq;
    }
    if (!culled) {
      this.render(camera);
    }
  }
}
__decorate$5([
  ignoreClone
], RenderableComponent.prototype, "_onUpdateIndex", 2);
__decorate$5([
  ignoreClone
], RenderableComponent.prototype, "_rendererIndex", 2);
__decorate$5([
  ignoreClone
], RenderableComponent.prototype, "_overrideUpdate", 2);
__decorate$5([
  ignoreClone
], RenderableComponent.prototype, "_transformChangeFlag", 2);
__decorate$5([
  deepClone
], RenderableComponent.prototype, "_bounds", 2);

let passNum = 0;
class RenderPass {
  constructor(name = `RENDER_PASS${passNum++}`, priority = 0, renderTarget = null, replaceMaterial = null, mask = null, clearParam = new Vector4(0, 0, 0, 0)) {
    this.name = name;
    this.enabled = true;
    this.priority = priority;
    this.renderTarget = renderTarget;
    this.replaceMaterial = replaceMaterial;
    this.mask = mask || MaskList.EVERYTHING;
    this.renderOverride = false;
    this.clearMode = ClearMode.SOLID_COLOR;
    this._clearParam = clearParam;
  }
  get clearParam() {
    return this._clearParam;
  }
  set clearParam(v) {
    this._clearParam = v;
  }
  render(camera, opaqueQueue, transparentQueue) {
  }
  preRender(camera, opaqueQueue, transparentQueue) {
  }
  postRender(camera, opaqueQueue, transparentQueue) {
  }
}

class RenderContext {
  constructor() {
    this.viewProjectMatrix = new Matrix();
  }
  static _getRenderContext(camera) {
    const context = RenderContext._renderContext;
    context.camera = camera;
    context.viewport = camera.viewport;
    context.cameraPosition = camera.entity.transform.worldPosition;
    context.inverseViewMatrix = camera.inverseViewMatrix;
    context.inverseProjectionMatrix = camera.inverseProjectionMatrix;
    context.viewMatrix = camera.viewMatrix;
    context.projectionMatrix = camera.projectionMatrix;
    Matrix.multiply(context.projectionMatrix, context.viewMatrix, context.viewProjectMatrix);
    return this._renderContext;
  }
}
RenderContext._renderContext = new RenderContext();

class RenderQueue {
  constructor() {
    this._items = [];
  }
  get items() {
    return this._items;
  }
  clear() {
    this._items = [];
  }
  pushPrimitive(element) {
    this._items.push(element);
  }
  sortByDistance(eyePos) {
    const items = this._items;
    if (items.length > 1) {
      this._items = items.sort(function(item1, item2) {
        if (item1.component.renderPriority === item2.component.renderPriority) {
          const pos1 = item1.component.entity.transform.worldPosition;
          const pos2 = item2.component.entity.transform.worldPosition;
          const dis = Vector3.distanceSquared(pos2, eyePos) - Vector3.distanceSquared(pos1, eyePos);
          return dis;
        } else {
          return item1.component.renderPriority - item2.component.renderPriority;
        }
      });
    }
  }
  sortByTechnique() {
    const items = this._items;
    if (items.length > 1) {
      this._items = items.sort(function(item1, item2) {
        if (item1.component.renderPriority === item2.component.renderPriority) {
          const tech1 = item1.material.technique;
          const tech2 = item2.material.technique;
          if (tech1 && tech2) {
            return tech1.name.localeCompare(tech2.name);
          } else {
            return 0;
          }
        } else {
          return item1.component.renderPriority - item2.component.renderPriority;
        }
      });
    }
  }
  pushSprite(component, positionQuad, uvRect, tintColor, texture, renderMode, camera) {
    const element = {
      component,
      positionQuad,
      uvRect,
      tintColor,
      texture,
      renderMode,
      camera
    };
    this._items.push(element);
  }
  render(camera, replaceMaterial, mask) {
    const rhi = camera.scene.engine._hardwareRenderer;
    const items = this._items;
    if (items.length === 0) {
      return;
    }
    this.updateMaxJointsNum(this._items, replaceMaterial);
    const context = RenderContext._getRenderContext(camera);
    const {cullingMask} = camera;
    for (let i = 0, len = items.length; i < len; i++) {
      const item = items[i];
      const {component} = item;
      if (!(cullingMask & component._entity.layer))
        continue;
      const renderPassFlag = component.renderPassFlag;
      if (!(renderPassFlag & mask))
        continue;
      if (this._isPrimitive(item)) {
        const element = item;
        rhi.flushSprite();
        const material = replaceMaterial ? replaceMaterial : element.material;
        material.preRender?.(element.component, element.primitive);
        material.prepareDrawing(context, element.component, element.primitive, element.material);
        rhi.drawPrimitive(element.primitive, element.subPrimitive, material);
        material.postRender?.(element.component, element.primitive);
      } else {
        const spirteElement = item;
        rhi.drawSprite(spirteElement.positionQuad, spirteElement.uvRect, spirteElement.tintColor, spirteElement.texture, spirteElement.renderMode, spirteElement.camera);
      }
    }
    rhi.flushSprite();
  }
  updateMaxJointsNum(items, replaceMaterial) {
    for (let i = 0, len = items.length; i < len; i++) {
      const {component, material} = items[i];
      const materialControl = replaceMaterial ? replaceMaterial : material;
      if (component.jointNodes) {
        materialControl.maxJointsNum = Math.max(materialControl.maxJointsNum, component.jointNodes.length);
      }
    }
  }
  _isPrimitive(item) {
    return !!item.primitive;
  }
}

class SeparateSpritePass extends RenderPass {
  constructor(name = "SeparateSprite", priority = 10) {
    super(name, priority);
    this.clearMode = ClearMode.DONT_CLEAR;
    this.renderOverride = true;
    this._spriteItems = [];
  }
  get isUsed() {
    return this._spriteItems.length > 0;
  }
  preRender() {
    this.enabled = this.isUsed;
  }
  render(camera) {
    const rhi = camera.renderHardware;
    this._sortByDistance(camera.eyePos);
    const items = this._spriteItems;
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      rhi.drawSprite(item.positionQuad, item.uvRect, item.tintColor, item.texture, item.renderMode, item.camera);
    }
    items.length = 0;
  }
  postRender(camera) {
    if (this.enabled) {
      camera.renderHardware.flushSprite();
    }
  }
  _sortByDistance(eyePos) {
    if (this._spriteItems.length > 1) {
      this._spriteItems = this._spriteItems.sort(function(item1, item2) {
        if (item1.component.renderPriority === item2.component.renderPriority) {
          const pos1 = item1.component.node.worldPosition;
          const pos2 = item2.component.node.worldPosition;
          const dis = Vector3.distanceSquared(pos2, eyePos) - Vector3.distanceSquared(pos1, eyePos);
          return dis;
        } else {
          return item1.component.renderPriority - item2.component.renderPriority;
        }
      });
    }
  }
  pushSprite(component, positionQuad, uvRect, tintColor, texture, renderMode, camera) {
    this._spriteItems.push({
      component,
      positionQuad,
      uvRect,
      tintColor,
      texture,
      renderMode,
      camera
    });
  }
}

class BasicRenderPipeline extends SceneVisitor {
  constructor(camera) {
    super();
    this._camera = camera;
    this._opaqueQueue = new RenderQueue();
    this._transparentQueue = new RenderQueue();
    this._renderPassArray = [];
    this._defaultPass = new RenderPass("default", 0, null, null, 0);
    this.addRenderPass(this._defaultPass);
  }
  get defaultRenderPass() {
    return this._defaultPass;
  }
  addRenderPass(nameOrPass, priority = null, renderTarget = null, replaceMaterial = null, mask = null, clearParam = new Vector4(0, 0, 0, 0)) {
    if (typeof nameOrPass === "string") {
      const renderPass = new RenderPass(nameOrPass, priority, renderTarget, replaceMaterial, mask, clearParam);
      this._renderPassArray.push(renderPass);
    } else if (nameOrPass instanceof RenderPass) {
      this._renderPassArray.push(nameOrPass);
    }
    this._renderPassArray.sort(function(p1, p2) {
      return p1.priority - p2.priority;
    });
  }
  removeRenderPass(nameOrPass) {
    let pass;
    if (typeof nameOrPass === "string")
      pass = this.getRenderPass(nameOrPass);
    else if (nameOrPass instanceof RenderPass)
      pass = nameOrPass;
    if (pass) {
      const idx = this._renderPassArray.indexOf(pass);
      this._renderPassArray.splice(idx, 1);
    }
  }
  getRenderPass(name) {
    for (let i = 0, len = this._renderPassArray.length; i < len; i++) {
      const pass = this._renderPassArray[i];
      if (pass.name === name)
        return pass;
    }
    return null;
  }
  get opaqueQueue() {
    return this._opaqueQueue;
  }
  get transparentQueue() {
    return this._transparentQueue;
  }
  destroy() {
  }
  render() {
    const camera = this._camera;
    const opaqueQueue = this._opaqueQueue;
    const transparentQueue = this._transparentQueue;
    opaqueQueue.clear();
    transparentQueue.clear();
    camera.engine._componentsManager.callRender(camera);
    opaqueQueue.sortByTechnique();
    transparentQueue.sortByDistance(camera.entity.transform.worldPosition);
    if (this._canvasDepthPass)
      this._canvasDepthPass.enabled = false;
    if (this._separateSpritePass && this._separateSpritePass.isUsed) {
      if (this._defaultPass.renderTarget) {
        if (!this._canvasDepthPass) {
          this._canvasDepthPass = new RenderPass("CanvasDepthRenderPass", 0, null, null, 0);
          this._canvasDepthPass.clearMode = ClearMode.DONT_CLEAR;
          this.addRenderPass(this._canvasDepthPass);
        }
        this._canvasDepthPass.enabled = true;
      }
    }
    for (let i = 0, len = this._renderPassArray.length; i < len; i++) {
      this._drawRenderPass(this._renderPassArray[i], camera);
    }
  }
  _drawRenderPass(pass, camera) {
    pass.preRender(camera, this.opaqueQueue, this.transparentQueue);
    const rhi = camera.scene.engine._hardwareRenderer;
    const renderTarget = camera.renderTarget || pass.renderTarget;
    rhi.activeRenderTarget(renderTarget, camera);
    if (pass.enabled) {
      rhi.clearRenderTarget(pass.clearMode, pass.clearParam);
      if (pass.renderOverride) {
        pass.render(camera, this.opaqueQueue, this.transparentQueue);
      } else {
        this.opaqueQueue.render(camera, pass.replaceMaterial, pass.mask);
        this.transparentQueue.render(camera, pass.replaceMaterial, pass.mask);
      }
    }
    rhi.blitRenderTarget(renderTarget);
    pass.postRender(camera, this.opaqueQueue, this.transparentQueue);
  }
  pushPrimitive(element) {
    if (element.material.renderType === MaterialType.TRANSPARENT) {
      this._transparentQueue.pushPrimitive(element);
    } else {
      this._opaqueQueue.pushPrimitive(element);
    }
  }
  pushSprite(component, positionQuad, uvRect, tintColor, texture, renderMode, camera) {
    if (component.separateDraw) {
      if (!this._separateSpritePass) {
        this._separateSpritePass = new SeparateSpritePass();
        this.addRenderPass(this._separateSpritePass);
      }
      this._separateSpritePass.pushSprite(component, positionQuad, uvRect, tintColor, texture, renderMode, camera);
      return;
    }
    this._transparentQueue.pushSprite(component, positionQuad, uvRect, tintColor, texture, renderMode, camera);
  }
}

var __defProp$6 = Object.defineProperty;
var __getOwnPropDesc$6 = Object.getOwnPropertyDescriptor;
var __decorate$6 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$6(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$6(target, key, result);
  return result;
};
class MathTemp {
}
MathTemp.tempMat4 = new Matrix();
MathTemp.tempVec4 = new Vector4();
MathTemp.tempVec3 = new Vector3();
var ClearFlags;
(function(ClearFlags2) {
  ClearFlags2[ClearFlags2["DepthSky"] = 0] = "DepthSky";
  ClearFlags2[ClearFlags2["DepthColor"] = 1] = "DepthColor";
  ClearFlags2[ClearFlags2["Depth"] = 2] = "Depth";
  ClearFlags2[ClearFlags2["None"] = 3] = "None";
})(ClearFlags || (ClearFlags = {}));
let Camera = class extends Component {
  constructor(entity) {
    super(entity);
    this.priority = 0;
    this.cullingMask = Layer.Everything;
    this._isOrthographic = false;
    this._isProjMatSetting = false;
    this._clearMode = ClearMode.SOLID_COLOR;
    this._nearClipPlane = 0.1;
    this._farClipPlane = 100;
    this._fieldOfView = 45;
    this._orthographicSize = 10;
    this._isProjectionDirty = true;
    this._isInvProjMatDirty = true;
    this._customAspectRatio = void 0;
    this._renderTarget = null;
    this._projectionMatrix = new Matrix();
    this._viewMatrix = new Matrix();
    this._backgroundColor = new Vector4();
    this._viewport = new Vector4(0, 0, 1, 1);
    this._inverseProjectionMatrix = new Matrix();
    this._inverseViewMatrix = new Matrix();
    this._lastAspectSize = new Vector2(0, 0);
    this._invViewProjMat = new Matrix();
    this._transform = this.entity.transform;
    this._isViewMatrixDirty = this._transform.registerWorldChangeFlag();
    this._isInvViewProjDirty = this._transform.registerWorldChangeFlag();
    this._renderPipeline = new BasicRenderPipeline(this);
    this.setClearMode();
  }
  get nearClipPlane() {
    return this._nearClipPlane;
  }
  set nearClipPlane(value) {
    this._nearClipPlane = value;
    this._projMatChange();
  }
  get farClipPlane() {
    return this._farClipPlane;
  }
  set farClipPlane(value) {
    this._farClipPlane = value;
    this._projMatChange();
  }
  get fieldOfView() {
    return this._fieldOfView;
  }
  set fieldOfView(value) {
    this._fieldOfView = value;
    this._projMatChange();
  }
  get aspectRatio() {
    const canvas = this._entity.engine.canvas;
    return this._customAspectRatio ?? canvas.width * this._viewport.z / (canvas.height * this._viewport.w);
  }
  set aspectRatio(value) {
    this._customAspectRatio = value;
    this._projMatChange();
  }
  get viewport() {
    return this._viewport;
  }
  set viewport(value) {
    if (value !== this._viewport) {
      value.cloneTo(this._viewport);
    }
    this._projMatChange();
  }
  get isOrthographic() {
    return this._isOrthographic;
  }
  set isOrthographic(value) {
    this._isOrthographic = value;
    this._projMatChange();
  }
  get orthographicSize() {
    return this._orthographicSize;
  }
  set orthographicSize(value) {
    this._orthographicSize = value;
    this._projMatChange();
  }
  get clearFlags() {
    throw "not implemented";
  }
  set clearFlags(value) {
    throw "not implemented";
  }
  get backgroundColor() {
    return this._backgroundColor;
  }
  set backgroundColor(value) {
    this.setClearMode(this._clearMode, value);
  }
  get backgroundSky() {
    throw new Error("\u63A5\u53E3\u672A\u5B9E\u73B0");
  }
  get viewMatrix() {
    if (this._isViewMatrixDirty.flag) {
      this._isViewMatrixDirty.flag = false;
      Matrix.invert(this._transform.worldMatrix, this._viewMatrix);
    }
    return this._viewMatrix;
  }
  set projectionMatrix(value) {
    this._projectionMatrix = value;
    this._isProjMatSetting = true;
    this._projMatChange();
  }
  get projectionMatrix() {
    const canvas = this._entity.engine.canvas;
    if ((!this._isProjectionDirty || this._isProjMatSetting) && this._lastAspectSize.x === canvas.width && this._lastAspectSize.y === canvas.height) {
      return this._projectionMatrix;
    }
    this._isProjectionDirty = false;
    this._lastAspectSize.x = canvas.width;
    this._lastAspectSize.y = canvas.height;
    const aspectRatio = this.aspectRatio;
    if (!this._isOrthographic) {
      Matrix.perspective(MathUtil.degreeToRadian(this._fieldOfView), aspectRatio, this._nearClipPlane, this._farClipPlane, this._projectionMatrix);
    } else {
      const width = this._orthographicSize * aspectRatio;
      const height = this._orthographicSize;
      Matrix.ortho(-width, width, -height, height, this._nearClipPlane, this._farClipPlane, this._projectionMatrix);
    }
    return this._projectionMatrix;
  }
  get enableHDR() {
    console.log("not implemention");
    return false;
  }
  set enableHDR(value) {
    console.log("not implemention");
  }
  get renderTarget() {
    return this._renderTarget;
  }
  set renderTarget(value) {
    this._renderTarget = value;
  }
  resetProjectionMatrix() {
    this._isProjMatSetting = false;
    this._projMatChange();
  }
  resetAspectRatio() {
    this._customAspectRatio = void 0;
    this._projMatChange();
  }
  worldToViewportPoint(point, out) {
    Matrix.multiply(this.projectionMatrix, this.viewMatrix, MathTemp.tempMat4);
    MathTemp.tempVec4.setValue(point.x, point.y, point.z, 1);
    Vector4.transform(MathTemp.tempVec4, MathTemp.tempMat4, MathTemp.tempVec4);
    const w = MathTemp.tempVec4.w;
    const nx = MathTemp.tempVec4.x / w;
    const ny = MathTemp.tempVec4.y / w;
    const nz = MathTemp.tempVec4.z / w;
    out.x = (nx + 1) * 0.5;
    out.y = (1 - ny) * 0.5;
    out.z = nz;
    out.w = w;
    return out;
  }
  viewportToWorldPoint(point, out) {
    const invViewProjMat = this.invViewProjMat;
    return this._innerViewportToWorldPoint(point, invViewProjMat, out);
  }
  viewportPointToRay(point, out) {
    const clipPoint = MathTemp.tempVec3;
    clipPoint.setValue(point.x, point.y, 0);
    const origin = this.viewportToWorldPoint(clipPoint, out.origin);
    clipPoint.z = 1;
    const farPoint = this._innerViewportToWorldPoint(clipPoint, this._invViewProjMat, clipPoint);
    Vector3.subtract(farPoint, origin, out.direction);
    out.direction.normalize();
    return out;
  }
  screenToViewportPoint(point, out) {
    const canvas = this.engine.canvas;
    const viewport = this.viewport;
    out.x = (point.x / canvas.width - viewport.x) / viewport.z;
    out.y = (point.y / canvas.height - viewport.y) / viewport.w;
    return out;
  }
  viewportToScreenPoint(point, out) {
    const canvas = this.engine.canvas;
    const viewport = this.viewport;
    out.x = (viewport.x + point.x * viewport.z) * canvas.width;
    out.y = (viewport.y + point.y * viewport.w) * canvas.height;
    return out;
  }
  worldToScreenPoint(point, out) {
    this.worldToViewportPoint(point, out);
    return this.viewportToScreenPoint(out, out);
  }
  screenToWorldPoint(point, out) {
    this.screenToViewportPoint(point, out);
    return this.viewportToWorldPoint(out, out);
  }
  render(cubeFaces) {
    this._renderPipeline.render();
  }
  _onActive() {
    this.entity.scene.attachRenderCamera(this);
  }
  _onInActive() {
    this.entity.scene.detachRenderCamera(this);
  }
  _onDestroy() {
    this._renderPipeline?.destroy();
    this._isInvViewProjDirty.destroy();
    this._isViewMatrixDirty.destroy();
  }
  _projMatChange() {
    this._isProjectionDirty = true;
    this._isInvProjMatDirty = true;
    this._isInvViewProjDirty.flag = true;
  }
  _innerViewportToWorldPoint(point, invViewProjMat, out) {
    const depth = point.z * 2 - 1;
    const clipPoint = MathTemp.tempVec4;
    clipPoint.setValue(point.x * 2 - 1, 1 - point.y * 2, depth, 1);
    Vector4.transform(clipPoint, invViewProjMat, clipPoint);
    const invW = 1 / clipPoint.w;
    out.x = clipPoint.x * invW;
    out.y = clipPoint.y * invW;
    out.z = clipPoint.z * invW;
    return out;
  }
  get invViewProjMat() {
    if (this._isInvViewProjDirty.flag) {
      this._isInvViewProjDirty.flag = false;
      Matrix.multiply(this.inverseViewMatrix, this.inverseProjectionMatrix, this._invViewProjMat);
    }
    return this._invViewProjMat;
  }
  get inverseProjectionMatrix() {
    if (this._isInvProjMatDirty) {
      this._isInvProjMatDirty = false;
      Matrix.invert(this.projectionMatrix, this._inverseProjectionMatrix);
    }
    return this._inverseProjectionMatrix;
  }
  get inverseViewMatrix() {
    this._transform.worldMatrix.cloneTo(this._inverseViewMatrix);
    return this._inverseViewMatrix;
  }
  setClearMode(clearMode = ClearMode.SOLID_COLOR, backgroundColor = new Vector4(0.25, 0.25, 0.25, 1)) {
    this._clearMode = clearMode;
    this._backgroundColor = backgroundColor;
    this._renderPipeline.defaultRenderPass.clearParam = backgroundColor;
    this._renderPipeline.defaultRenderPass.clearMode = clearMode;
  }
};
__decorate$6([
  ignoreClone
], Camera.prototype, "_renderPipeline", 2);
__decorate$6([
  ignoreClone
], Camera.prototype, "_transform", 2);
__decorate$6([
  ignoreClone
], Camera.prototype, "_isViewMatrixDirty", 2);
__decorate$6([
  ignoreClone
], Camera.prototype, "_isInvViewProjDirty", 2);
__decorate$6([
  deepClone
], Camera.prototype, "_projectionMatrix", 2);
__decorate$6([
  deepClone
], Camera.prototype, "_viewMatrix", 2);
__decorate$6([
  deepClone
], Camera.prototype, "_backgroundColor", 2);
__decorate$6([
  deepClone
], Camera.prototype, "_viewport", 2);
__decorate$6([
  deepClone
], Camera.prototype, "_inverseProjectionMatrix", 2);
__decorate$6([
  deepClone
], Camera.prototype, "_inverseViewMatrix", 2);
__decorate$6([
  deepClone
], Camera.prototype, "_lastAspectSize", 2);
__decorate$6([
  deepClone
], Camera.prototype, "_invViewProjMat", 2);
Camera = __decorate$6([
  dependencies(Transform)
], Camera);

const mimeType = {
  json: "json",
  gltf: "json",
  mtl: "json",
  prefab: "json",
  txt: "text",
  bin: "arraybuffer",
  png: "image",
  webp: "image",
  jpg: "image"
};
const defaultRetryCount = 4;
const defaultTimeout = 15e3;
const defaultInterval = 500;
function request(url, config = {}) {
  return new AssetPromise((resolve, reject, setProgress) => {
    const retryCount = config.retryCount ?? defaultRetryCount;
    const retryInterval = config.retryInterval ?? defaultInterval;
    config.timeout = config.timeout ?? defaultTimeout;
    config.type = config.type ?? getMimeTypeFromUrl(url);
    const realRequest = config.type === "image" ? requestImage : requestRes;
    let lastError;
    const executor = new MultiExecutor(() => {
      return realRequest(url, config).onProgress(setProgress).then((res) => {
        resolve(res);
        executor.stop();
      }).catch((err) => lastError = err);
    }, retryCount, retryInterval);
    executor.start(() => {
      reject(lastError);
    });
  });
}
function requestImage(url, config) {
  return new AssetPromise((resolve, reject) => {
    const {timeout} = config;
    const img = new Image();
    const onerror = () => {
      reject(new Error(`request ${url} fail`));
    };
    img.onerror = onerror;
    img.onabort = onerror;
    const timeoutId = setTimeout(() => {
      reject(new Error(`request ${url} timeout`));
    }, timeout);
    img.onload = ((timeoutId2) => {
      return () => {
        requestAnimationFrame(() => {
          resolve(img);
        });
        clearTimeout(timeoutId2);
      };
    })(timeoutId);
    img.crossOrigin = "anonymous";
    img.src = url;
  });
}
function requestRes(url, config) {
  return new AssetPromise((resolve, reject, setProgress) => {
    const xhr = new XMLHttpRequest();
    xhr.timeout = config.timeout;
    config.method = config.method ?? "get";
    xhr.onload = () => {
      if (xhr.status < 200 || xhr.status >= 300) {
        reject(new Error(`request failed from: ${url}`));
        return;
      }
      const result = xhr.response ?? xhr.responseText;
      resolve(result);
    };
    xhr.onerror = () => {
      reject(new Error(`request failed from: ${url}`));
    };
    xhr.ontimeout = () => {
      reject(new Error(`request timeout from: ${url}`));
    };
    xhr.onprogress = (e) => {
      setProgress(e.loaded / e.total);
    };
    xhr.open(config.method, url, true);
    xhr.withCredentials = config.credentials === "include";
    xhr.responseType = config.type;
    const headers = config.headers;
    if (headers) {
      Object.keys(headers).forEach((name) => {
        xhr.setRequestHeader(name, headers[name]);
      });
    }
    xhr.send(config.body);
  });
}
function getMimeTypeFromUrl(url) {
  const extname = url.substring(url.lastIndexOf(".") + 1);
  return mimeType[extname];
}
class MultiExecutor {
  constructor(execFunc, totalCount, interval) {
    this.execFunc = execFunc;
    this.totalCount = totalCount;
    this.interval = interval;
    this._timeoutId = -100;
    this._currentCount = 0;
    this.exec = this.exec.bind(this);
  }
  start(done) {
    this.done = done;
    this.exec();
  }
  stop() {
    clearTimeout(this._timeoutId);
  }
  exec() {
    if (this._currentCount >= this.totalCount) {
      this.done && this.done();
      return;
    }
    this._currentCount++;
    this.execFunc(this._currentCount).then(() => {
      this._timeoutId = setTimeout(this.exec, this.interval);
    });
  }
}

class Loader {
  constructor(useCache) {
    this.useCache = useCache;
    this.request = request;
  }
}

var AssetType;
(function(AssetType2) {
  AssetType2[AssetType2["Text"] = 0] = "Text";
  AssetType2[AssetType2["JSON"] = 1] = "JSON";
  AssetType2[AssetType2["Buffer"] = 2] = "Buffer";
  AssetType2[AssetType2["Texture2D"] = 3] = "Texture2D";
  AssetType2[AssetType2["TextureCube"] = 4] = "TextureCube";
  AssetType2[AssetType2["Material"] = 5] = "Material";
  AssetType2[AssetType2["Mesh"] = 6] = "Mesh";
  AssetType2[AssetType2["AnimationClip"] = 7] = "AnimationClip";
  AssetType2[AssetType2["Perfab"] = 8] = "Perfab";
  AssetType2[AssetType2["KTX"] = 9] = "KTX";
  AssetType2[AssetType2["KTXCube"] = 10] = "KTXCube";
})(AssetType || (AssetType = {}));

class RefObject extends EngineObject {
  constructor(engine) {
    super(engine);
    this.isGCIgnored = false;
    this._refCount = 0;
    this._refChildren = [];
    this._refParent = null;
    this._destroyed = false;
    engine.resourceManager._addRefObject(this.instanceId, this);
  }
  get refCount() {
    return this._refCount;
  }
  get destroyed() {
    return this._destroyed;
  }
  destroy(force = false) {
    if (this._destroyed)
      return true;
    if (!force && this._refCount !== 0)
      return false;
    const resourceManager = this._engine.resourceManager;
    if (resourceManager) {
      resourceManager._deleteAsset(this);
      resourceManager._deleteRefObject(this.instanceId);
    }
    if (this._refParent) {
      removeFromArray(this._refParent._refChildren, this);
    }
    this._engine = null;
    this._onDestroy();
    this._destroyed = true;
    return true;
  }
  _addToResourceManager(path) {
    this._engine.resourceManager._addAsset(path, this);
  }
  _addRefCount(refCount) {
    this._refCount += refCount;
    const refChildren = this._refChildren;
    for (const item of refChildren) {
      item._addRefCount(refCount);
    }
  }
  _addRefChild(obj) {
    this._refChildren.push(obj);
    obj._refParent = this;
    obj._addRefCount(this._refCount);
  }
  _removeRefChild(obj) {
    const refChildren = this._refChildren;
    if (removeFromArray(refChildren, obj)) {
      obj._refParent = null;
      obj._addRefCount(-this._refCount);
    }
  }
}

const _tempVec3 = new Vector3(0, 1, 0);
class Light extends Component {
  static getUniformDefine(uniformName) {
    return {};
  }
  constructor(entity) {
    super(entity);
    entity.addEventListener("removedFromScene", this._onDisable.bind(this));
  }
  _onEnable() {
    this.scene.findFeature(LightFeature).attachRenderLight(this);
  }
  _onDisable() {
    this.scene.findFeature(LightFeature).detachRenderLight(this);
  }
  get viewMatrix() {
    if (!this._viewMat)
      this._viewMat = new Matrix();
    Matrix.invert(this.inverseViewMatrix, this._viewMat);
    return this._viewMat;
  }
  get inverseViewMatrix() {
    if (!this._modelMat)
      this._modelMat = new Matrix();
    Matrix.rotateAxisAngle(this.entity.transform.worldMatrix, _tempVec3, Math.PI, this._modelMat);
    return this._modelMat;
  }
}

class AmbientLight extends Light {
  static getUniformDefine(uniformName) {
    return {
      [uniformName + ".color"]: {
        name: uniformName + ".color",
        type: DataType.FLOAT_VEC3
      },
      [uniformName + ".lightColor"]: {
        name: uniformName + ".lightColor",
        type: DataType.FLOAT_VEC3
      },
      [uniformName + ".intensity"]: {
        name: uniformName + ".intensity",
        type: DataType.FLOAT
      }
    };
  }
  constructor(entity) {
    super(entity);
    this.color = new Vector3(1, 1, 1);
    this.intensity = 1;
    this._lightColor = new Vector3();
  }
  get lightColor() {
    Vector3.scale(this.color, this.intensity, this._lightColor);
    return this._lightColor;
  }
  bindMaterialValues(mtl, uniformName) {
    mtl.setValue(uniformName + ".color", this.color);
    mtl.setValue(uniformName + ".lightColor", this.lightColor);
    mtl.setValue(uniformName + ".intensity", this.intensity);
  }
}

class DirectLight extends Light {
  constructor(entity) {
    super(entity);
    this._forward = new Vector3();
    this.color = new Vector3(1, 1, 1);
    this.intensity = 1;
    this._lightColor = new Vector3();
    this._reverseDirection = new Vector3();
  }
  get direction() {
    this.entity.transform.getWorldForward(this._forward);
    return this._forward;
  }
  get lightColor() {
    Vector3.scale(this.color, this.intensity, this._lightColor);
    return this._lightColor;
  }
  get reverseDirection() {
    Vector3.scale(this.direction, -1, this._reverseDirection);
    return this._reverseDirection;
  }
  static getUniformDefine(uniformName) {
    const uniforms = {};
    uniforms[uniformName + ".color"] = {
      name: uniformName + ".color",
      type: DataType.FLOAT_VEC3
    };
    uniforms[uniformName + ".lightColor"] = {
      name: uniformName + ".lightColor",
      type: DataType.FLOAT_VEC3
    };
    uniforms[uniformName + ".intensity"] = {
      name: uniformName + ".intensity",
      type: DataType.FLOAT
    };
    uniforms[uniformName + ".direction"] = {
      name: uniformName + ".direction",
      type: DataType.FLOAT_VEC3
    };
    return uniforms;
  }
  bindMaterialValues(mtl, uniformName) {
    mtl.setValue(uniformName + ".color", this.color);
    mtl.setValue(uniformName + ".lightColor", this.lightColor);
    mtl.setValue(uniformName + ".intensity", this.intensity);
    mtl.setValue(uniformName + ".direction", this.direction);
  }
}

const cacheMat3 = new Matrix3x3();
class EnvironmentMapLight extends Light {
  static getUniformDefine(uniformName) {
    const uniforms = {};
    uniforms["u_env_diffuseSampler"] = {
      name: "u_env_diffuseSampler",
      type: DataType.SAMPLER_CUBE
    };
    uniforms["u_env_specularSampler"] = {
      name: "u_env_specularSampler",
      type: DataType.SAMPLER_CUBE
    };
    uniforms[uniformName + ".diffuse"] = {
      name: uniformName + ".diffuse",
      type: DataType.FLOAT_VEC3
    };
    uniforms[uniformName + ".specular"] = {
      name: uniformName + ".specular",
      type: DataType.FLOAT_VEC3
    };
    uniforms[uniformName + ".mipMapLevel"] = {
      name: uniformName + ".mipMapLevel",
      type: DataType.FLOAT
    };
    uniforms[uniformName + ".transformMatrix"] = {
      name: uniformName + ".transformMatrix",
      type: DataType.FLOAT_MAT3
    };
    uniforms[uniformName + ".diffuseIntensity"] = {
      name: uniformName + ".diffuseIntensity",
      type: DataType.FLOAT
    };
    uniforms[uniformName + ".specularIntensity"] = {
      name: uniformName + ".specularIntensity",
      type: DataType.FLOAT
    };
    return uniforms;
  }
  constructor(entity) {
    super(entity);
    this.diffuse = new Vector3(0.3, 0.3, 0.3);
    this.specular = new Vector3(0.5, 0.5, 0.5);
    this.diffuseIntensity = 1;
    this.specularIntensity = 1;
  }
  get useDiffuseMap() {
    return !!this.diffuseMap;
  }
  get useSpecularMap() {
    return !!this.specularMap;
  }
  bindMaterialValues(mtl, uniformName) {
    mtl.setValue(uniformName + ".diffuseIntensity", this.diffuseIntensity);
    mtl.setValue(uniformName + ".specularIntensity", this.specularIntensity);
    if (this.useDiffuseMap) {
      mtl.setValue("u_env_diffuseSampler", this.diffuseMap);
    } else {
      mtl.setValue(uniformName + ".diffuse", this.diffuse);
    }
    if (this.useSpecularMap) {
      mtl.setValue("u_env_specularSampler", this.specularMap);
      mtl.setValue(uniformName + ".mipMapLevel", this.specularMap.mipmapCount);
    } else {
      mtl.setValue(uniformName + ".specular", this.specular);
    }
    const transformMatrix = this.entity.transform.worldMatrix;
    cacheMat3.setValueByMatrix(transformMatrix);
    mtl.setValue(uniformName + ".transformMatrix", cacheMat3);
  }
}

class PointLight extends Light {
  constructor() {
    super(...arguments);
    this.color = new Vector3(1, 1, 1);
    this.intensity = 1;
    this.distance = 0;
    this.decay = 0;
    this._lightColor = new Vector3();
  }
  get position() {
    return this.entity.worldPosition;
  }
  get lightColor() {
    Vector3.scale(this.color, this.intensity, this._lightColor);
    return this._lightColor;
  }
  static getUniformDefine(uniformName) {
    const uniforms = {};
    uniforms[uniformName + ".position"] = {
      name: uniformName + ".position",
      type: DataType.FLOAT_VEC3
    };
    uniforms[uniformName + ".color"] = {
      name: uniformName + ".color",
      type: DataType.FLOAT_VEC3
    };
    uniforms[uniformName + ".lightColor"] = {
      name: uniformName + ".lightColor",
      type: DataType.FLOAT_VEC3
    };
    uniforms[uniformName + ".intensity"] = {
      name: uniformName + ".intensity",
      type: DataType.FLOAT
    };
    uniforms[uniformName + ".distance"] = {
      name: uniformName + ".distance",
      type: DataType.FLOAT
    };
    uniforms[uniformName + ".decay"] = {
      name: uniformName + ".decay",
      type: DataType.FLOAT
    };
    return uniforms;
  }
  bindMaterialValues(mtl, uniformName) {
    mtl.setValue(uniformName + ".position", this.position);
    mtl.setValue(uniformName + ".color", this.color);
    mtl.setValue(uniformName + ".lightColor", this.lightColor);
    mtl.setValue(uniformName + ".intensity", this.intensity);
    mtl.setValue(uniformName + ".distance", this.distance);
    mtl.setValue(uniformName + ".decay", this.decay);
  }
}

class SpotLight extends Light {
  constructor(entity) {
    super(entity);
    this._forward = new Vector3();
    this.color = new Vector3(1, 1, 1);
    this.penumbra = 0;
    this.distance = 0;
    this.intensity = 1;
    this.decay = 0;
    this.angle = Math.PI / 6;
    this._lightColor = new Vector3();
    this._inverseDirection = new Vector3();
  }
  get position() {
    return this.entity.worldPosition;
  }
  get direction() {
    this.entity.transform.getWorldForward(this._forward);
    return this._forward;
  }
  get reverseDirection() {
    Vector3.scale(this.direction, -1, this._inverseDirection);
    return this._inverseDirection;
  }
  get lightColor() {
    Vector3.scale(this.color, this.intensity, this._lightColor);
    return this._lightColor;
  }
  static getUniformDefine(uniformName) {
    const uniforms = {};
    uniforms[uniformName + ".position"] = {
      name: uniformName + ".position",
      type: DataType.FLOAT_VEC3
    };
    uniforms[uniformName + ".direction"] = {
      name: uniformName + ".direction",
      type: DataType.FLOAT_VEC3
    };
    uniforms[uniformName + ".color"] = {
      name: uniformName + ".color",
      type: DataType.FLOAT_VEC3
    };
    uniforms[uniformName + ".lightColor"] = {
      name: uniformName + ".lightColor",
      type: DataType.FLOAT_VEC3
    };
    uniforms[uniformName + ".intensity"] = {
      name: uniformName + ".intensity",
      type: DataType.FLOAT
    };
    uniforms[uniformName + ".distance"] = {
      name: uniformName + ".distance",
      type: DataType.FLOAT
    };
    uniforms[uniformName + ".decay"] = {
      name: uniformName + ".decay",
      type: DataType.FLOAT
    };
    uniforms[uniformName + ".angle"] = {
      name: uniformName + ".angle",
      type: DataType.FLOAT
    };
    uniforms[uniformName + ".penumbra"] = {
      name: uniformName + ".penumbra",
      type: DataType.FLOAT
    };
    uniforms[uniformName + ".coneCos"] = {
      name: uniformName + ".coneCos",
      type: DataType.FLOAT
    };
    uniforms[uniformName + ".penumbraCos"] = {
      name: uniformName + ".penumbraCos",
      type: DataType.FLOAT
    };
    return uniforms;
  }
  bindMaterialValues(mtl, uniformName) {
    mtl.setValue(uniformName + ".position", this.position);
    mtl.setValue(uniformName + ".direction", this.direction);
    mtl.setValue(uniformName + ".color", this.color);
    mtl.setValue(uniformName + ".lightColor", this.lightColor);
    mtl.setValue(uniformName + ".intensity", this.intensity);
    mtl.setValue(uniformName + ".distance", this.distance);
    mtl.setValue(uniformName + ".decay", this.decay);
    mtl.setValue(uniformName + ".angle", this.angle);
    mtl.setValue(uniformName + ".penumbra", this.penumbra);
    mtl.setValue(uniformName + ".coneCos", Math.cos(this.angle));
    mtl.setValue(uniformName + ".penumbraCos", Math.cos(this.angle * (1 - this.penumbra)));
  }
}

function hasLight() {
  return this.findFeature(LightFeature).visibleLights.length > 0;
}
class LightFeature extends SceneFeature {
  get lightSortAmount() {
    let ambientLightCount = 0;
    let directLightCount = 0;
    let pointLightCount = 0;
    let spotLightCount = 0;
    let envMapLightCount = 0;
    let useDiffuseEnv = false;
    let useSpecularEnv = false;
    let lights = this.visibleLights;
    for (let i = 0, len = lights.length; i < len; i++) {
      const light = lights[i];
      if (light instanceof AmbientLight) {
        ambientLightCount++;
      } else if (light instanceof DirectLight) {
        directLightCount++;
      } else if (light instanceof PointLight) {
        pointLightCount++;
      } else if (light instanceof SpotLight) {
        spotLightCount++;
      } else if (light instanceof EnvironmentMapLight) {
        envMapLightCount++;
        useDiffuseEnv = light.useDiffuseMap;
        useSpecularEnv = light.useSpecularMap;
      }
    }
    return {
      ambientLightCount,
      directLightCount,
      pointLightCount,
      spotLightCount,
      envMapLightCount,
      useDiffuseEnv,
      useSpecularEnv
    };
  }
  constructor() {
    super();
    this.visibleLights = [];
  }
  attachRenderLight(light) {
    const index = this.visibleLights.indexOf(light);
    if (index == -1) {
      this.visibleLights.push(light);
    } else {
      Logger.warn("Light already attached.");
    }
  }
  detachRenderLight(light) {
    const index = this.visibleLights.indexOf(light);
    if (index != -1) {
      this.visibleLights.splice(index, 1);
    }
  }
  bindMaterialValues(mtl) {
    let directLightCount = 0;
    let pointLightCount = 0;
    let spotLightCount = 0;
    let lights = this.visibleLights;
    for (let i = 0, len = lights.length; i < len; i++) {
      const light = lights[i];
      if (light instanceof AmbientLight) {
        light.bindMaterialValues(mtl, `u_ambientLight`);
      } else if (light instanceof DirectLight) {
        light.bindMaterialValues(mtl, `u_directLights[${directLightCount++}]`);
      } else if (light instanceof PointLight) {
        light.bindMaterialValues(mtl, `u_pointLights[${pointLightCount++}]`);
      } else if (light instanceof SpotLight) {
        light.bindMaterialValues(mtl, `u_spotLights[${spotLightCount++}]`);
      } else if (light instanceof EnvironmentMapLight) {
        light.bindMaterialValues(mtl, `u_envMapLight`);
      }
    }
  }
  getUniformDefine() {
    let uniforms = {};
    let ambientLightCount = 0;
    let directLightCount = 0;
    let pointLightCount = 0;
    let spotLightCount = 0;
    let envMapLightCount = 0;
    let lights = this.visibleLights;
    for (let i = 0, len = lights.length; i < len; i++) {
      const light = lights[i];
      if (light instanceof AmbientLight && !ambientLightCount++) {
        uniforms = {...uniforms, ...AmbientLight.getUniformDefine(`u_ambientLight`)};
      } else if (light instanceof DirectLight) {
        uniforms = {...uniforms, ...DirectLight.getUniformDefine(`u_directLights[${directLightCount++}]`)};
      } else if (light instanceof PointLight) {
        uniforms = {...uniforms, ...PointLight.getUniformDefine(`u_pointLights[${pointLightCount++}]`)};
      } else if (light instanceof SpotLight) {
        uniforms = {...uniforms, ...SpotLight.getUniformDefine(`u_spotLights[${spotLightCount++}]`)};
      } else if (light instanceof EnvironmentMapLight && !envMapLightCount++) {
        uniforms = {...uniforms, ...EnvironmentMapLight.getUniformDefine(`u_envMapLight`)};
      }
    }
    return uniforms;
  }
}

class ColliderFeature extends SceneFeature {
  constructor() {
    super();
    this.colliders = [];
  }
  attachCollider(collider) {
    this.colliders.push(collider);
  }
  detachCollider(collider) {
    const index = this.colliders.indexOf(collider);
    if (index != -1) {
      this.colliders.splice(index, 1);
    }
  }
}

class Collider extends Component {
  constructor(entity) {
    super(entity);
    this.tag = MaskList.EVERYTHING;
  }
  _onEnable() {
    this.scene.findFeature(ColliderFeature).attachCollider(this);
  }
  _onDisable() {
    this.scene.findFeature(ColliderFeature).detachCollider(this);
  }
}

class ABoxCollider extends Collider {
  constructor(entity) {
    super(entity);
    this._corners = [];
    this._cornerFlag = false;
    this.boxMin = new Vector3(-0.5, -0.5, -0.5);
    this.boxMax = new Vector3(0.5, 0.5, 0.5);
  }
  setBoxMinMax(min, max) {
    this.boxMin = min;
    this.boxMax = max;
    this._cornerFlag = true;
  }
  setBoxCenterSize(center, size) {
    const halfSize = ABoxCollider._tempVec3;
    Vector3.scale(size, 0.5, halfSize);
    Vector3.add(center, halfSize, this.boxMax);
    Vector3.subtract(center, halfSize, this.boxMin);
    this._cornerFlag = true;
  }
  getCorners() {
    if (this._cornerFlag) {
      const minX = this.boxMin.x;
      const minY = this.boxMin.y;
      const minZ = this.boxMin.z;
      const w = this.boxMax.x - minX;
      const h = this.boxMax.y - minY;
      const d = this.boxMax.z - minZ;
      if (this._corners.length === 0) {
        for (let i = 0; i < 8; ++i) {
          this._corners.push(new Vector3());
        }
      }
      this._corners[0].setValue(minX + w, minY + h, minZ + d);
      this._corners[1].setValue(minX, minY + h, minZ + d);
      this._corners[2].setValue(minX, minY, minZ + d);
      this._corners[3].setValue(minX + w, minY, minZ + d);
      this._corners[4].setValue(minX + w, minY + h, minZ);
      this._corners[5].setValue(minX, minY + h, minZ);
      this._corners[6].setValue(minX, minY, minZ);
      this._corners[7].setValue(minX + w, minY, minZ);
      this._cornerFlag = false;
    }
    return this._corners;
  }
}
ABoxCollider._tempVec3 = new Vector3();

class ASphereCollider extends Collider {
  constructor(entity) {
    super(entity);
    this.center = new Vector3();
    this.radius = 1;
  }
  raycast(ray, hit) {
  }
  setSphere(center, radius) {
    this.center = center;
    this.radius = radius;
  }
}

class PlaneCollider extends Collider {
  constructor(entity) {
    super(entity);
    this.planePoint = new Vector3();
    this.normal = new Vector3(0, 1, 0);
  }
  setPlane(point, normal) {
    this.planePoint = point;
    this.normal = normal;
  }
}

Scene.prototype.raycast = function(_ray, _outPos, tag = MaskList.EVERYTHING) {
  const ray = new Ray(_ray.origin, _ray.direction);
  const cf = this.findFeature(ColliderFeature);
  const colliders = cf.colliders;
  let nearestHit = new RaycastHit();
  for (let i = 0, len = colliders.length; i < len; i++) {
    const collider = colliders[i];
    if (!collider.entity.isActiveInHierarchy) {
      continue;
    }
    if (!(collider.tag & tag)) {
      continue;
    }
    const hit = new RaycastHit();
    if (collider.raycast(ray, hit)) {
      if (hit.distance < nearestHit.distance) {
        nearestHit = hit;
      }
    }
  }
  if (_outPos && nearestHit.collider) {
    nearestHit.point.cloneTo(_outPos);
  }
  return nearestHit.collider;
};
ABoxCollider.prototype.raycast = function(ray, hit) {
  const localRay = _getLocalRay(this, ray);
  const intersect = localRay.intersectAABB(this.boxMax, this.boxMin);
  if (intersect) {
    _updateHitResult(this, localRay, intersect, hit, ray.origin);
    return true;
  } else {
    return false;
  }
};
ASphereCollider.prototype.raycast = function(ray, hit) {
  const localRay = _getLocalRay(this, ray);
  const intersect = localRay.intersectSphere(this.center, this.radius);
  if (intersect) {
    _updateHitResult(this, localRay, intersect, hit, ray.origin);
    return true;
  } else {
    return false;
  }
};
PlaneCollider.prototype.raycast = function(ray, hit) {
  const localRay = _getLocalRay(this, ray);
  const intersect = localRay.intersectPlane(this.planePoint, this.normal);
  if (intersect) {
    _updateHitResult(this, localRay, intersect, hit, ray.origin);
    return true;
  } else {
    return false;
  }
};
function _updateHitResult(collider, ray, distance, outHit, origin) {
  const hitPos = ray.getPoint(distance);
  Vector3.transformCoordinate(hitPos, collider.entity.transform.worldMatrix, hitPos);
  outHit.distance = Vector3.distance(origin, hitPos);
  outHit.collider = collider;
  outHit.point = hitPos;
}
function _getLocalRay(collider, ray) {
  const worldToLocal = collider.entity.getInvModelMatrix();
  const o = new Vector3();
  Vector3.transformCoordinate(ray.origin, worldToLocal, o);
  const d = new Vector3();
  _transformDirection(d, ray.direction, worldToLocal);
  return new Ray(o, d);
}
function _transformDirection(out, a, m) {
  const x = a.x;
  const y = a.y;
  const z = a.z;
  const e = m.elements;
  out.x = x * e[0] + y * e[4] + z * e[8];
  out.y = x * e[1] + y * e[5] + z * e[9];
  out.z = x * e[2] + y * e[6] + z * e[10];
  return out;
}

class Mesh extends EngineObject {
  constructor(engine, name) {
    super(engine);
    this.primitives = [];
    this.groups = [];
    this.bounds = new BoundingBox(new Vector3(), new Vector3());
    this.name = name;
  }
  updatePrimitiveWeightsIndices(weightsIndices) {
  }
  destroy() {
    this.primitives = null;
  }
}

class Skin extends AssetObject {
  constructor(name) {
    super(null);
    this.inverseBindMatrices = [];
    this.joints = [];
    this.skeleton = "none";
  }
}

var __defProp$7 = Object.defineProperty;
var __getOwnPropDesc$7 = Object.getOwnPropertyDescriptor;
var __decorate$7 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$7(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$7(target, key, result);
  return result;
};
function addPrimitivesRefCount(mesh, refCount) {
  const primitives = mesh.primitives;
  for (let i = 0, l = primitives.length; i < l; i++) {
    primitives[i]._addRefCount(refCount);
  }
}
class MeshRenderer extends RenderableComponent {
  constructor(entity) {
    super(entity);
    this._instanceMaterials = [];
    this._sharedMaterials = [];
    this._mesh = null;
  }
  get mesh() {
    return this._mesh;
  }
  set mesh(mesh) {
    if (this._mesh) {
      addPrimitivesRefCount(this._mesh, -1);
    }
    addPrimitivesRefCount(mesh, 1);
    this._mesh = mesh;
    this._sharedMaterials = [];
    this._instanceMaterials = [];
  }
  setSharedMaterial(primitiveIndex, material) {
    if (this._sharedMaterials[primitiveIndex]) {
      this._sharedMaterials[primitiveIndex]._addRefCount(-1);
    }
    material._addRefCount(1);
    this._sharedMaterials[primitiveIndex] = material;
  }
  setMaterial(primitiveIndex, material) {
    if (this._instanceMaterials[primitiveIndex]) {
      this._instanceMaterials[primitiveIndex]._addRefCount(-1);
    }
    material._addRefCount(1);
    this._instanceMaterials[primitiveIndex] = material;
  }
  getInstanceMaterial(primitiveIndex) {
    return this._instanceMaterials[primitiveIndex];
  }
  getSharedMaterial(primitiveIndex) {
    return this._sharedMaterials[primitiveIndex];
  }
  render(camera) {
    const mesh = this._mesh;
    if (!mesh) {
      return;
    }
    const renderPipeline = camera._renderPipeline;
    const {primitives, groups} = mesh;
    for (let i = 0, len = primitives.length; i < len; i++) {
      const primitive = primitives[i];
      const material = this._instanceMaterials[i] || this._sharedMaterials[i];
      if (material) {
        const element = RenderElement.getFromPool();
        element.setValue(this, primitive, groups[i], material);
        renderPipeline.pushPrimitive(element);
      } else {
        Logger.error("Primitive has no material: " + primitive.name);
      }
    }
  }
  destroy() {
    super.destroy();
    this._mesh = null;
    this._instanceMaterials = [];
    this._sharedMaterials = [];
    for (let i = 0; i < this._instanceMaterials.length; i++) {
      this._instanceMaterials[i]._addRefCount(-1);
    }
    for (let i = 0; i < this._sharedMaterials.length; i++) {
      this._sharedMaterials[i]._addRefCount(-1);
    }
    if (this._mesh) {
      addPrimitivesRefCount(this._mesh, -1);
    }
  }
  _updateBounds(worldBounds) {
    const localBounds = this.mesh.bounds;
    const worldMatrix = this._entity.transform.worldMatrix;
    Vector3.transformCoordinate(localBounds.min, worldMatrix, worldBounds.min);
    Vector3.transformCoordinate(localBounds.max, worldMatrix, worldBounds.max);
  }
}
__decorate$7([
  ignoreClone
], MeshRenderer.prototype, "_instanceMaterials", 2);
__decorate$7([
  shallowClone
], MeshRenderer.prototype, "_sharedMaterials", 2);

var TextureFilterMode;
(function(TextureFilterMode2) {
  TextureFilterMode2[TextureFilterMode2["Point"] = 0] = "Point";
  TextureFilterMode2[TextureFilterMode2["Bilinear"] = 1] = "Bilinear";
  TextureFilterMode2[TextureFilterMode2["Trilinear"] = 2] = "Trilinear";
})(TextureFilterMode || (TextureFilterMode = {}));

var TextureFormat;
(function(TextureFormat2) {
  TextureFormat2[TextureFormat2["R8G8B8"] = 0] = "R8G8B8";
  TextureFormat2[TextureFormat2["R8G8B8A8"] = 1] = "R8G8B8A8";
  TextureFormat2[TextureFormat2["R4G4B4A4"] = 2] = "R4G4B4A4";
  TextureFormat2[TextureFormat2["R5G5B5A1"] = 3] = "R5G5B5A1";
  TextureFormat2[TextureFormat2["R5G6B5"] = 4] = "R5G6B5";
  TextureFormat2[TextureFormat2["Alpha8"] = 5] = "Alpha8";
  TextureFormat2[TextureFormat2["R32G32B32A32"] = 6] = "R32G32B32A32";
  TextureFormat2[TextureFormat2["DXT1"] = 7] = "DXT1";
  TextureFormat2[TextureFormat2["DXT5"] = 8] = "DXT5";
  TextureFormat2[TextureFormat2["ETC1_RGB"] = 9] = "ETC1_RGB";
  TextureFormat2[TextureFormat2["ETC2_RGB"] = 10] = "ETC2_RGB";
  TextureFormat2[TextureFormat2["ETC2_RGBA5"] = 11] = "ETC2_RGBA5";
  TextureFormat2[TextureFormat2["ETC2_RGBA8"] = 12] = "ETC2_RGBA8";
  TextureFormat2[TextureFormat2["PVRTC_RGB2"] = 13] = "PVRTC_RGB2";
  TextureFormat2[TextureFormat2["PVRTC_RGBA2"] = 14] = "PVRTC_RGBA2";
  TextureFormat2[TextureFormat2["PVRTC_RGB4"] = 15] = "PVRTC_RGB4";
  TextureFormat2[TextureFormat2["PVRTC_RGBA4"] = 16] = "PVRTC_RGBA4";
  TextureFormat2[TextureFormat2["ASTC_4x4"] = 17] = "ASTC_4x4";
  TextureFormat2[TextureFormat2["ASTC_5x5"] = 18] = "ASTC_5x5";
  TextureFormat2[TextureFormat2["ASTC_6x6"] = 19] = "ASTC_6x6";
  TextureFormat2[TextureFormat2["ASTC_8x8"] = 20] = "ASTC_8x8";
  TextureFormat2[TextureFormat2["ASTC_10x10"] = 21] = "ASTC_10x10";
  TextureFormat2[TextureFormat2["ASTC_12x12"] = 22] = "ASTC_12x12";
})(TextureFormat || (TextureFormat = {}));

var TextureWrapMode;
(function(TextureWrapMode2) {
  TextureWrapMode2[TextureWrapMode2["Clamp"] = 0] = "Clamp";
  TextureWrapMode2[TextureWrapMode2["Repeat"] = 1] = "Repeat";
  TextureWrapMode2[TextureWrapMode2["Mirror"] = 2] = "Mirror";
})(TextureWrapMode || (TextureWrapMode = {}));

var GLCompressedTextureInternalFormat;
(function(GLCompressedTextureInternalFormat2) {
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_4X4_KHR"] = 37808] = "RGBA_ASTC_4X4_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_5X4_KHR"] = 37809] = "RGBA_ASTC_5X4_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_5X5_KHR"] = 37810] = "RGBA_ASTC_5X5_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_6X5_KHR"] = 37811] = "RGBA_ASTC_6X5_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_6X6_KHR"] = 37812] = "RGBA_ASTC_6X6_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_8X5_KHR"] = 37813] = "RGBA_ASTC_8X5_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_8X6_KHR"] = 37814] = "RGBA_ASTC_8X6_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_8X8_KHR"] = 37815] = "RGBA_ASTC_8X8_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_10X5_KHR"] = 37816] = "RGBA_ASTC_10X5_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_10X6_KHR"] = 37817] = "RGBA_ASTC_10X6_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_10X8_KHR"] = 37818] = "RGBA_ASTC_10X8_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_10X10_KHR"] = 37819] = "RGBA_ASTC_10X10_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_12X10_KHR"] = 37820] = "RGBA_ASTC_12X10_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_ASTC_12X12_KHR"] = 37821] = "RGBA_ASTC_12X12_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_4X4_KHR"] = 37840] = "SRGB8_ALPHA8_ASTC_4X4_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_5X4_KHR"] = 37841] = "SRGB8_ALPHA8_ASTC_5X4_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_5X5_KHR"] = 37842] = "SRGB8_ALPHA8_ASTC_5X5_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_6X5_KHR"] = 37843] = "SRGB8_ALPHA8_ASTC_6X5_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_6X6_KHR"] = 37844] = "SRGB8_ALPHA8_ASTC_6X6_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_8X5_KHR"] = 37845] = "SRGB8_ALPHA8_ASTC_8X5_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_8X6_KHR"] = 37846] = "SRGB8_ALPHA8_ASTC_8X6_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_8X8_KHR"] = 37847] = "SRGB8_ALPHA8_ASTC_8X8_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_10X5_KHR"] = 37848] = "SRGB8_ALPHA8_ASTC_10X5_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_10X6_KHR"] = 37849] = "SRGB8_ALPHA8_ASTC_10X6_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_10X8_KHR"] = 37850] = "SRGB8_ALPHA8_ASTC_10X8_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_10X10_KHR"] = 37851] = "SRGB8_ALPHA8_ASTC_10X10_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_12X10_KHR"] = 37852] = "SRGB8_ALPHA8_ASTC_12X10_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ASTC_12X12_KHR"] = 37853] = "SRGB8_ALPHA8_ASTC_12X12_KHR";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGB_ETC1_WEBGL"] = 36196] = "RGB_ETC1_WEBGL";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["R11_EAC"] = 37488] = "R11_EAC";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SIGNED_R11_EAC"] = 37489] = "SIGNED_R11_EAC";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RG11_EAC"] = 37490] = "RG11_EAC";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SIGNED_RG11_EAC"] = 37491] = "SIGNED_RG11_EAC";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGB8_ETC2"] = 37492] = "RGB8_ETC2";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ETC2"] = 37493] = "SRGB8_ETC2";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37494] = "RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37495] = "SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA8_ETC2_EAC"] = 37496] = "RGBA8_ETC2_EAC";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["SRGB8_ALPHA8_ETC2_EAC"] = 37497] = "SRGB8_ALPHA8_ETC2_EAC";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGB_PVRTC_4BPPV1_IMG"] = 35840] = "RGB_PVRTC_4BPPV1_IMG";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGB_PVRTC_2BPPV1_IMG"] = 35841] = "RGB_PVRTC_2BPPV1_IMG";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "RGBA_PVRTC_4BPPV1_IMG";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "RGBA_PVRTC_2BPPV1_IMG";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGB_S3TC_DXT1_EXT"] = 33776] = "RGB_S3TC_DXT1_EXT";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_S3TC_DXT1_EXT"] = 33777] = "RGBA_S3TC_DXT1_EXT";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_S3TC_DXT3_EXT"] = 33778] = "RGBA_S3TC_DXT3_EXT";
  GLCompressedTextureInternalFormat2[GLCompressedTextureInternalFormat2["RGBA_S3TC_DXT5_EXT"] = 33779] = "RGBA_S3TC_DXT5_EXT";
})(GLCompressedTextureInternalFormat || (GLCompressedTextureInternalFormat = {}));

var RenderBufferColorFormat;
(function(RenderBufferColorFormat2) {
  RenderBufferColorFormat2[RenderBufferColorFormat2["R8G8B8"] = 0] = "R8G8B8";
  RenderBufferColorFormat2[RenderBufferColorFormat2["R8G8B8A8"] = 1] = "R8G8B8A8";
  RenderBufferColorFormat2[RenderBufferColorFormat2["R4G4B4A4"] = 2] = "R4G4B4A4";
  RenderBufferColorFormat2[RenderBufferColorFormat2["R5G5B5A1"] = 3] = "R5G5B5A1";
  RenderBufferColorFormat2[RenderBufferColorFormat2["R5G6B5"] = 4] = "R5G6B5";
  RenderBufferColorFormat2[RenderBufferColorFormat2["Alpha8"] = 5] = "Alpha8";
  RenderBufferColorFormat2[RenderBufferColorFormat2["R16G16B16A16"] = 6] = "R16G16B16A16";
  RenderBufferColorFormat2[RenderBufferColorFormat2["R32G32B32A32"] = 7] = "R32G32B32A32";
})(RenderBufferColorFormat || (RenderBufferColorFormat = {}));

var RenderBufferDepthFormat;
(function(RenderBufferDepthFormat2) {
  RenderBufferDepthFormat2[RenderBufferDepthFormat2["Depth"] = 0] = "Depth";
  RenderBufferDepthFormat2[RenderBufferDepthFormat2["DepthStencil"] = 1] = "DepthStencil";
  RenderBufferDepthFormat2[RenderBufferDepthFormat2["Stencil"] = 2] = "Stencil";
  RenderBufferDepthFormat2[RenderBufferDepthFormat2["Depth16"] = 3] = "Depth16";
  RenderBufferDepthFormat2[RenderBufferDepthFormat2["Depth24"] = 4] = "Depth24";
  RenderBufferDepthFormat2[RenderBufferDepthFormat2["Depth32"] = 5] = "Depth32";
  RenderBufferDepthFormat2[RenderBufferDepthFormat2["Depth24Stencil8"] = 6] = "Depth24Stencil8";
  RenderBufferDepthFormat2[RenderBufferDepthFormat2["Depth32Stencil8"] = 7] = "Depth32Stencil8";
})(RenderBufferDepthFormat || (RenderBufferDepthFormat = {}));

class Texture extends RefObject {
  constructor(engine) {
    super(engine);
    this._anisoLevel = 1;
  }
  static _isPowerOf2(v) {
    return (v & v - 1) === 0;
  }
  static _getFormatDetail(format, gl, isWebGL2) {
    switch (format) {
      case TextureFormat.R8G8B8:
        return {
          internalFormat: isWebGL2 ? gl.RGB8 : gl.RGB,
          baseFormat: gl.RGB,
          dataType: gl.UNSIGNED_BYTE,
          isCompressed: false
        };
      case TextureFormat.R8G8B8A8:
        return {
          internalFormat: isWebGL2 ? gl.RGBA8 : gl.RGBA,
          baseFormat: gl.RGBA,
          dataType: gl.UNSIGNED_BYTE,
          isCompressed: false
        };
      case TextureFormat.R4G4B4A4:
        return {
          internalFormat: isWebGL2 ? gl.RGBA4 : gl.RGBA,
          baseFormat: gl.RGBA,
          dataType: gl.UNSIGNED_SHORT_4_4_4_4,
          isCompressed: false
        };
      case TextureFormat.R5G5B5A1:
        return {
          internalFormat: isWebGL2 ? gl.RGB5_A1 : gl.RGBA,
          baseFormat: gl.RGBA,
          dataType: gl.UNSIGNED_SHORT_5_5_5_1,
          isCompressed: false
        };
      case TextureFormat.R5G6B5:
        return {
          internalFormat: isWebGL2 ? gl.RGB565 : gl.RGB,
          baseFormat: gl.RGB,
          dataType: gl.UNSIGNED_SHORT_5_6_5,
          isCompressed: false
        };
      case TextureFormat.Alpha8:
        return {
          internalFormat: gl.ALPHA,
          baseFormat: gl.ALPHA,
          dataType: gl.UNSIGNED_BYTE,
          isCompressed: false
        };
      case TextureFormat.R32G32B32A32:
        return {
          internalFormat: gl.RGBA32F,
          baseFormat: gl.RGBA,
          dataType: gl.FLOAT,
          isCompressed: false
        };
      case TextureFormat.DXT1:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGB_S3TC_DXT1_EXT,
          isCompressed: true
        };
      case TextureFormat.DXT5:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT,
          isCompressed: true
        };
      case TextureFormat.ETC1_RGB:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGB_ETC1_WEBGL,
          isCompressed: true
        };
      case TextureFormat.ETC2_RGB:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGB8_ETC2,
          isCompressed: true
        };
      case TextureFormat.ETC2_RGBA5:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
          isCompressed: true
        };
      case TextureFormat.ETC2_RGBA8:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGBA8_ETC2_EAC,
          isCompressed: true
        };
      case TextureFormat.PVRTC_RGB2:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGB_PVRTC_2BPPV1_IMG,
          isCompressed: true
        };
      case TextureFormat.PVRTC_RGBA2:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGBA_PVRTC_2BPPV1_IMG,
          isCompressed: true
        };
      case TextureFormat.PVRTC_RGB4:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGB_PVRTC_4BPPV1_IMG,
          isCompressed: true
        };
      case TextureFormat.PVRTC_RGBA4:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGBA_PVRTC_4BPPV1_IMG,
          isCompressed: true
        };
      case TextureFormat.ASTC_4x4:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_4X4_KHR,
          isCompressed: true
        };
      case TextureFormat.ASTC_5x5:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_5X5_KHR,
          isCompressed: true
        };
      case TextureFormat.ASTC_6x6:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_6X6_KHR,
          isCompressed: true
        };
      case TextureFormat.ASTC_8x8:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_8X8_KHR,
          isCompressed: true
        };
      case TextureFormat.ASTC_10x10:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_10X10_KHR,
          isCompressed: true
        };
      case TextureFormat.ASTC_12x12:
        return {
          internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_12X12_KHR,
          isCompressed: true
        };
      default:
        throw new Error(`this TextureFormat is not supported in Oasis Engine: ${format}`);
    }
  }
  static _getRenderBufferColorFormatDetail(format, gl, isWebGL2) {
    switch (format) {
      case RenderBufferColorFormat.R8G8B8:
        return {
          internalFormat: isWebGL2 ? gl.RGB8 : gl.RGB,
          baseFormat: gl.RGB,
          dataType: gl.UNSIGNED_BYTE,
          isCompressed: false
        };
      case RenderBufferColorFormat.R8G8B8A8:
        return {
          internalFormat: isWebGL2 ? gl.RGBA8 : gl.RGBA,
          baseFormat: gl.RGBA,
          dataType: gl.UNSIGNED_BYTE,
          isCompressed: false
        };
      case RenderBufferColorFormat.R4G4B4A4:
        return {
          internalFormat: isWebGL2 ? gl.RGBA4 : gl.RGBA,
          baseFormat: gl.RGBA,
          dataType: gl.UNSIGNED_SHORT_4_4_4_4,
          isCompressed: false
        };
      case RenderBufferColorFormat.R5G5B5A1:
        return {
          internalFormat: isWebGL2 ? gl.RGB5_A1 : gl.RGBA,
          baseFormat: gl.RGBA,
          dataType: gl.UNSIGNED_SHORT_5_5_5_1,
          isCompressed: false
        };
      case RenderBufferColorFormat.R5G6B5:
        return {
          internalFormat: isWebGL2 ? gl.RGB565 : gl.RGB,
          baseFormat: gl.RGB,
          dataType: gl.UNSIGNED_SHORT_5_6_5,
          isCompressed: false
        };
      case RenderBufferColorFormat.Alpha8:
        return {
          internalFormat: gl.ALPHA,
          baseFormat: gl.ALPHA,
          dataType: gl.UNSIGNED_BYTE,
          isCompressed: false
        };
      case RenderBufferColorFormat.R16G16B16A16:
        return {
          internalFormat: gl.RGBA16F,
          baseFormat: gl.RGBA,
          dataType: gl.HALF_FLOAT,
          isCompressed: false
        };
      case RenderBufferColorFormat.R32G32B32A32:
        return {
          internalFormat: gl.RGBA32F,
          baseFormat: gl.RGBA,
          dataType: gl.FLOAT,
          isCompressed: false
        };
      default:
        throw new Error(`this RenderBufferColorFormat is not supported in Oasis Engine: ${format}`);
    }
  }
  static _getRenderBufferDepthFormatDetail(format, gl, isWebGL2) {
    switch (format) {
      case RenderBufferDepthFormat.Depth:
        return {
          internalFormat: isWebGL2 ? gl.DEPTH_COMPONENT32F : gl.DEPTH_COMPONENT16,
          baseFormat: gl.DEPTH_COMPONENT,
          dataType: isWebGL2 ? gl.FLOAT : gl.UNSIGNED_INT,
          isCompressed: false,
          attachment: gl.DEPTH_ATTACHMENT
        };
      case RenderBufferDepthFormat.DepthStencil:
        return {
          internalFormat: isWebGL2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL,
          baseFormat: gl.DEPTH_STENCIL,
          dataType: gl.UNSIGNED_INT_24_8,
          isCompressed: false,
          attachment: gl.DEPTH_STENCIL_ATTACHMENT
        };
      case RenderBufferDepthFormat.Stencil:
        return {
          internalFormat: gl.STENCIL_INDEX8,
          baseFormat: gl.STENCIL_ATTACHMENT,
          dataType: gl.UNSIGNED_BYTE,
          isCompressed: false,
          attachment: gl.STENCIL_ATTACHMENT
        };
      case RenderBufferDepthFormat.Depth16:
        return {
          internalFormat: isWebGL2 ? gl.DEPTH_COMPONENT16 : gl.DEPTH_COMPONENT16,
          baseFormat: gl.DEPTH_COMPONENT,
          dataType: gl.UNSIGNED_INT,
          isCompressed: false,
          attachment: gl.DEPTH_ATTACHMENT
        };
      case RenderBufferDepthFormat.Depth24:
        return {
          internalFormat: gl.DEPTH_COMPONENT24,
          baseFormat: gl.DEPTH_COMPONENT,
          dataType: gl.UNSIGNED_INT,
          isCompressed: false,
          attachment: gl.DEPTH_ATTACHMENT
        };
      case RenderBufferDepthFormat.Depth32:
        return {
          internalFormat: gl.DEPTH_COMPONENT32F,
          baseFormat: gl.DEPTH_COMPONENT,
          dataType: gl.FLOAT,
          isCompressed: false,
          attachment: gl.DEPTH_ATTACHMENT
        };
      case RenderBufferDepthFormat.Depth24Stencil8:
        return {
          internalFormat: isWebGL2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL,
          baseFormat: gl.DEPTH_STENCIL,
          dataType: gl.UNSIGNED_INT_24_8,
          isCompressed: false,
          attachment: gl.DEPTH_STENCIL_ATTACHMENT
        };
      case RenderBufferDepthFormat.Depth32Stencil8:
        return {
          internalFormat: gl.DEPTH32F_STENCIL8,
          baseFormat: gl.DEPTH_STENCIL,
          dataType: gl.FLOAT_32_UNSIGNED_INT_24_8_REV,
          isCompressed: false,
          attachment: gl.DEPTH_STENCIL_ATTACHMENT
        };
      default:
        throw new Error(`this RenderBufferDepthFormat is not supported in Oasis Engine: ${format}`);
    }
  }
  static _supportTextureFormat(format, rhi) {
    let isSupported = true;
    switch (format) {
      case TextureFormat.R32G32B32A32:
        {
          if (!rhi.canIUse(GLCapabilityType.textureFloat)) {
            isSupported = false;
          }
        }
        break;
    }
    return isSupported;
  }
  static _supportRenderBufferColorFormat(format, rhi) {
    let isSupported = true;
    switch (format) {
      case RenderBufferColorFormat.R32G32B32A32:
        {
          if (!rhi.canIUse(GLCapabilityType.colorBufferFloat) || !rhi.canIUse(GLCapabilityType.textureFloat)) {
            isSupported = false;
          }
        }
        break;
      case RenderBufferColorFormat.R16G16B16A16:
        {
          if (!rhi.canIUse(GLCapabilityType.colorBufferHalfFloat) || !rhi.canIUse(GLCapabilityType.textureHalfFloat)) {
            isSupported = false;
          }
        }
        break;
    }
    return isSupported;
  }
  static _supportRenderBufferDepthFormat(format, rhi, isTexture) {
    const isWebGL2 = rhi.isWebGL2;
    let isSupported = true;
    if (isTexture && !rhi.canIUse(GLCapabilityType.depthTexture)) {
      return false;
    }
    switch (format) {
      case RenderBufferDepthFormat.Stencil:
        {
          isSupported = false;
        }
        break;
      case RenderBufferDepthFormat.Depth24:
      case RenderBufferDepthFormat.Depth32:
      case RenderBufferDepthFormat.Depth32Stencil8:
        {
          if (!isWebGL2) {
            isSupported = false;
          }
        }
        break;
    }
    return isSupported;
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  get wrapModeU() {
    return this._wrapModeU;
  }
  set wrapModeU(value) {
    if (value === this._wrapModeU)
      return;
    const gl = this._rhi.gl;
    this._wrapModeU = value;
    this._bind();
    this._setWrapMode(value, gl.TEXTURE_WRAP_S);
    this._unbind();
  }
  get wrapModeV() {
    return this._wrapModeV;
  }
  set wrapModeV(value) {
    if (value === this._wrapModeV)
      return;
    const gl = this._rhi.gl;
    this._wrapModeV = value;
    this._bind();
    this._setWrapMode(value, gl.TEXTURE_WRAP_T);
    this._unbind();
  }
  get mipmapCount() {
    return this._mipmapCount;
  }
  get filterMode() {
    return this._filterMode;
  }
  set filterMode(value) {
    if (value === this._filterMode)
      return;
    const gl = this._rhi.gl;
    this._filterMode = value;
    this._bind();
    switch (value) {
      case TextureFilterMode.Point:
        gl.texParameteri(this._target, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(this._target, gl.TEXTURE_MIN_FILTER, this._mipmap ? gl.NEAREST_MIPMAP_NEAREST : gl.NEAREST);
        break;
      case TextureFilterMode.Bilinear:
        gl.texParameteri(this._target, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(this._target, gl.TEXTURE_MIN_FILTER, this._mipmap ? gl.LINEAR_MIPMAP_NEAREST : gl.LINEAR);
        break;
      case TextureFilterMode.Trilinear:
        gl.texParameteri(this._target, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(this._target, gl.TEXTURE_MIN_FILTER, this._mipmap ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);
        break;
    }
    this._unbind();
  }
  get anisoLevel() {
    return this._anisoLevel;
  }
  set anisoLevel(value) {
    const max = this._rhi.capability.maxAnisoLevel;
    if (value > max) {
      Logger.warn(`anisoLevel:${value}, exceeds the limit and is automatically downgraded to:${max}`);
      value = max;
    }
    if (value < 1) {
      Logger.warn(`anisoLevel:${value}, must be greater than 0, and is automatically downgraded to 1`);
      value = 1;
    }
    if (value === this._anisoLevel)
      return;
    const gl = this._rhi.gl;
    this._anisoLevel = value;
    this._bind();
    gl.texParameterf(this._target, gl.TEXTURE_MAX_ANISOTROPY_EXT, value);
    this._unbind();
  }
  generateMipmaps() {
    if (!this._mipmap)
      return;
    const gl = this._rhi.gl;
    this._bind();
    gl.generateMipmap(this._target);
    this._unbind();
  }
  _onDestroy() {
    const gl = this._rhi.gl;
    gl.deleteTexture(this._glTexture);
    this._glTexture = null;
    this._formatDetail = null;
    this._rhi = null;
  }
  _bind() {
    const gl = this._rhi.gl;
    gl.bindTexture(this._target, this._glTexture);
  }
  _unbind() {
    const gl = this._rhi.gl;
    gl.bindTexture(this._target, null);
  }
  _getPixelBuffer(face, x, y, width, height, out) {
    const gl = this._rhi.gl;
    const {baseFormat, dataType} = this._formatDetail;
    if (!Texture._readFrameBuffer) {
      Texture._readFrameBuffer = gl.createFramebuffer();
    }
    gl.bindFramebuffer(gl.FRAMEBUFFER, Texture._readFrameBuffer);
    if (face != null) {
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, this._glTexture, 0);
    } else {
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._glTexture, 0);
    }
    gl.readPixels(x, y, width, height, baseFormat, dataType, out);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  }
  _initMipmap(isCube) {
    const gl = this._rhi.gl;
    const isWebGL2 = this._rhi.isWebGL2;
    let {internalFormat, baseFormat, dataType} = this._formatDetail;
    this._bind();
    if (isWebGL2) {
      gl.texStorage2D(this._target, this._mipmapCount, internalFormat, this._width, this._height);
    } else {
      if (baseFormat !== internalFormat) {
        internalFormat = baseFormat;
      }
      if (!isCube) {
        for (let i = 0; i < this._mipmapCount; i++) {
          const width = Math.max(1, this._width >> i);
          const height = Math.max(1, this._height >> i);
          gl.texImage2D(this._target, i, internalFormat, width, height, 0, baseFormat, dataType, null);
        }
      } else {
        for (let i = 0; i < this._mipmapCount; i++) {
          const size = Math.max(1, this._width >> i);
          for (let faceIndex = 0; faceIndex < 6; faceIndex++) {
            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, i, internalFormat, size, size, 0, baseFormat, dataType, null);
          }
        }
      }
    }
    this._unbind();
  }
  _getMaxMiplevel(size) {
    return Math.floor(Math.log2(size));
  }
  _getMipmapCount() {
    return this._mipmap ? Math.floor(Math.log2(Math.max(this._width, this._height))) + 1 : 1;
  }
  _setWrapMode(value, pname) {
    const gl = this._rhi.gl;
    const isWebGL2 = this._rhi.isWebGL2;
    if (!isWebGL2 && value !== TextureWrapMode.Clamp && (!Texture._isPowerOf2(this._width) || !Texture._isPowerOf2(this._height))) {
      Logger.warn("non-power-2 texture is not supported for REPEAT or MIRRORED_REPEAT in WebGL1,and has automatically downgraded to CLAMP_TO_EDGE");
      value = TextureWrapMode.Clamp;
    }
    switch (value) {
      case TextureWrapMode.Clamp:
        gl.texParameteri(this._target, pname, gl.CLAMP_TO_EDGE);
        break;
      case TextureWrapMode.Repeat:
        gl.texParameteri(this._target, pname, gl.REPEAT);
        break;
      case TextureWrapMode.Mirror:
        gl.texParameteri(this._target, pname, gl.MIRRORED_REPEAT);
        break;
    }
  }
}
Texture._readFrameBuffer = null;

class Texture2D extends Texture {
  constructor(engine, width, height, format = TextureFormat.R8G8B8A8, mipmap = true) {
    super(engine);
    this._compressedMipFilled = 0;
    const rhi = engine._hardwareRenderer;
    const gl = rhi.gl;
    const isWebGL2 = rhi.isWebGL2;
    if (!Texture._supportTextureFormat(format, rhi)) {
      throw new Error(`Texture format is not supported:${TextureFormat[format]}`);
    }
    if (mipmap && !isWebGL2 && (!Texture._isPowerOf2(width) || !Texture._isPowerOf2(height))) {
      Logger.warn("non-power-2 texture is not supported for mipmap in WebGL1,and has automatically downgraded to non-mipmap");
      mipmap = false;
    }
    const formatDetail = Texture._getFormatDetail(format, gl, isWebGL2);
    this._glTexture = gl.createTexture();
    this._formatDetail = formatDetail;
    this._rhi = rhi;
    this._target = gl.TEXTURE_2D;
    this._mipmap = mipmap;
    this._width = width;
    this._height = height;
    this._format = format;
    this._mipmapCount = this._getMipmapCount();
    formatDetail.isCompressed && !isWebGL2 || this._initMipmap(false);
    this.filterMode = TextureFilterMode.Bilinear;
    this.wrapModeU = this.wrapModeV = TextureWrapMode.Repeat;
  }
  get format() {
    return this._format;
  }
  setPixelBuffer(colorBuffer, mipLevel = 0, x, y, width, height) {
    const gl = this._rhi.gl;
    const isWebGL2 = this._rhi.isWebGL2;
    const {internalFormat, baseFormat, dataType, isCompressed} = this._formatDetail;
    const mipWidth = Math.max(1, this._width >> mipLevel);
    const mipHeight = Math.max(1, this._height >> mipLevel);
    x = x || 0;
    y = y || 0;
    width = width || mipWidth - x;
    height = height || mipHeight - y;
    this._bind();
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
    if (isCompressed) {
      const mipBit = 1 << mipLevel;
      if (isWebGL2 || this._compressedMipFilled & mipBit) {
        gl.compressedTexSubImage2D(this._target, mipLevel, x, y, width, height, internalFormat, colorBuffer);
      } else {
        gl.compressedTexImage2D(this._target, mipLevel, internalFormat, width, height, 0, colorBuffer);
        this._compressedMipFilled |= mipBit;
      }
    } else {
      gl.texSubImage2D(this._target, mipLevel, x, y, width, height, baseFormat, dataType, colorBuffer);
    }
    this._unbind();
  }
  setImageSource(imageSource, mipLevel = 0, flipY = false, premultiplyAlpha = false, x, y) {
    const gl = this._rhi.gl;
    const {baseFormat, dataType} = this._formatDetail;
    this._bind();
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, +flipY);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, +premultiplyAlpha);
    gl.texSubImage2D(this._target, mipLevel, x || 0, y || 0, baseFormat, dataType, imageSource);
    this._unbind();
  }
  getPixelBuffer(x, y, width, height, out) {
    if (this._formatDetail.isCompressed) {
      throw new Error("Unable to read compressed texture");
    }
    super._getPixelBuffer(null, x, y, width, height, out);
  }
}

var __defProp$8 = Object.defineProperty;
var __getOwnPropDesc$8 = Object.getOwnPropertyDescriptor;
var __decorate$8 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$8(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$8(target, key, result);
  return result;
};
class SkinnedMeshRenderer extends MeshRenderer {
  constructor(entity) {
    super(entity);
    this._hasInitJoints = false;
    this.weightsIndices = [];
    this._useJointTexture = false;
    this._mat = new Matrix();
    this._weights = null;
    this._skin = null;
  }
  setWeights(weights) {
    this._weights = weights;
    if (!weights) {
      return;
    }
    const len = weights.length;
    for (let i = 0; i < len; i++) {
      this.weightsIndices[i] = i;
    }
    const weightsIndices = this.weightsIndices;
    for (let i = 0; i < len - 1; i++) {
      for (let j = i + 1; j < len; j++) {
        if (weights[j] > weights[i]) {
          let t = weights[i];
          weights[i] = weights[j];
          weights[j] = t;
          t = weightsIndices[i];
          weightsIndices[i] = weightsIndices[j];
          weightsIndices[j] = t;
        }
      }
    }
    this.mesh.updatePrimitiveWeightsIndices(weightsIndices);
  }
  get skin() {
    return this._skin;
  }
  set skin(skin) {
    this._skin = skin;
  }
  get weights() {
    return this._weights;
  }
  _initJoints() {
    if (!this._skin)
      return;
    const skin = this._skin;
    const joints = skin.joints;
    const jointNodes = [];
    for (let i = joints.length - 1; i >= 0; i--) {
      jointNodes[i] = this.findByNodeName(this.entity, joints[i]);
    }
    this.matrixPalette = new Float32Array(jointNodes.length * 16);
    this.jointNodes = jointNodes;
    const rhi = this.entity.engine._hardwareRenderer;
    if (!rhi)
      return;
    const maxAttribUniformVec4 = rhi.renderStates.getParameter(rhi.gl.MAX_VERTEX_UNIFORM_VECTORS);
    const maxJoints = Math.floor((maxAttribUniformVec4 - 20) / 4);
    if (joints.length > maxJoints && rhi.canIUseMoreJoints) {
      this._useJointTexture = true;
    }
  }
  findByNodeName(entity, nodeName) {
    if (!entity)
      return null;
    const n = entity.findByName(nodeName);
    if (n)
      return n;
    return this.findByNodeName(entity.parent, nodeName);
  }
  _findParent(entity, nodeName) {
    if (entity) {
      const parent = entity.parent;
      if (!parent)
        return null;
      if (parent.name === nodeName)
        return parent;
      const brother = parent.findByName(nodeName);
      if (brother)
        return brother;
      return this._findParent(parent, nodeName);
    }
    return null;
  }
  update() {
    if (!this._hasInitJoints) {
      this._initJoints();
      this._hasInitJoints = true;
    }
    if (this._skin) {
      const joints = this.jointNodes;
      const ibms = this._skin.inverseBindMatrices;
      const matrixPalette = this.matrixPalette;
      const worldToLocal = this.entity.getInvModelMatrix();
      const mat = this._mat;
      for (let i = joints.length - 1; i >= 0; i--) {
        mat.identity();
        if (joints[i]) {
          Matrix.multiply(joints[i].transform.worldMatrix, ibms[i], mat);
        } else {
          ibms[i].cloneTo(mat);
        }
        Matrix.multiply(worldToLocal, mat, mat);
        matrixPalette.set(mat.elements, i * 16);
      }
      if (this._useJointTexture) {
        this.createJointTexture();
      }
    }
  }
  createJointTexture() {
    if (!this.jointTexture) {
      const engine = this.engine;
      const rhi = engine._hardwareRenderer;
      if (!rhi)
        return;
      this.jointTexture = new Texture2D(engine, 4, this.jointNodes.length, TextureFormat.R32G32B32A32, false);
      this.jointTexture.filterMode = TextureFilterMode.Point;
    }
    this.jointTexture.setPixelBuffer(this.matrixPalette);
  }
}
__decorate$8([
  ignoreClone
], SkinnedMeshRenderer.prototype, "matrixPalette", 2);
__decorate$8([
  ignoreClone
], SkinnedMeshRenderer.prototype, "jointNodes", 2);
__decorate$8([
  ignoreClone
], SkinnedMeshRenderer.prototype, "jointTexture", 2);
__decorate$8([
  ignoreClone
], SkinnedMeshRenderer.prototype, "_hasInitJoints", 2);
__decorate$8([
  ignoreClone
], SkinnedMeshRenderer.prototype, "_mat", 2);
__decorate$8([
  ignoreClone
], SkinnedMeshRenderer.prototype, "_weights", 2);
__decorate$8([
  ignoreClone
], SkinnedMeshRenderer.prototype, "weightsIndices", 2);
__decorate$8([
  ignoreClone
], SkinnedMeshRenderer.prototype, "_useJointTexture", 2);

class LODGroup extends RenderableComponent {
  constructor() {
    super(...arguments);
    this._lods = [];
  }
  addLod(distance, rendererAbility) {
    rendererAbility.enabled = false;
    this._lods.push({
      distance,
      rendererAbility
    });
    this._lods.sort((a, b) => b.distance - a.distance);
  }
  render(camera) {
    if (this._lods.length <= 0)
      return;
    const dist = Vector3.distance(camera.eyePos, this.entity.worldPosition);
    const lods = this._lods;
    let activeLevel = 0;
    for (let i = lods.length - 1; i >= 0; i--) {
      const lod2 = lods[i];
      if (dist < lod2.distance) {
        activeLevel = i;
        break;
      }
    }
    const lod = lods[activeLevel];
    lod.rendererAbility.render(camera);
  }
}

class Material extends RefObject {
  constructor(engine, name) {
    super(engine);
    this.name = name;
    this.renderType = MaterialType.OPAQUE;
    this.useFog = true;
    this.maxJointsNum = 0;
    this._technique = null;
    this._values = {};
  }
  clone(name = this.name, cloneTexture = false) {
    const newMtl = new this.constructor(name);
    newMtl.renderType = this.renderType;
    newMtl.useFog = this.useFog;
    for (const name2 in this._values) {
      if (this._values.hasOwnProperty(name2)) {
        const val = this._values[name2];
        if (val instanceof Texture) {
          newMtl.setValue(name2, val);
        } else {
          newMtl.setValue(name2, Util.clone(val));
        }
      }
    }
    return newMtl;
  }
  get transparent() {
    return this.renderType === MaterialType.TRANSPARENT;
  }
  set transparent(val) {
    this.renderType = val ? MaterialType.TRANSPARENT : MaterialType.OPAQUE;
  }
  get technique() {
    return this._technique;
  }
  set technique(tech) {
    this._technique = tech;
    this._values = {};
  }
  setValue(name, value) {
    const oriValue = this.getValue(name);
    const oriIsTexture = oriValue instanceof Texture;
    const curIsTexture = value instanceof Texture;
    if (oriIsTexture) {
      this._removeRefChild(oriValue);
    }
    if (curIsTexture) {
      this._addRefChild(value);
    }
    if (this._generateTechnique && oriIsTexture !== curIsTexture) {
      this._technique = null;
    }
    if (value != null) {
      this._values[name] = value;
    } else {
      this.delValue(name);
    }
  }
  delValue(name) {
    delete this._values[name];
  }
  getValue(name) {
    return this._values[name];
  }
  prepareDrawing(context, component, primitive, originalMaterial) {
    const camera = context.camera;
    const uniforms = this._technique.uniforms;
    for (const name in uniforms) {
      const uniform = uniforms[name];
      this._updateValueBySemantic(uniform, context, component);
    }
    const scene = camera.scene;
    if (scene.hasFogFeature) {
      scene.bindFogToMaterial(this);
    }
    this._technique.compile(camera, component, primitive, this);
  }
  preCompile(tech) {
  }
  postCompile(tech) {
  }
  preRender(component, primitive) {
  }
  postRender(component, primitive) {
  }
  _updateValueBySemantic(uniform, context, component) {
    const values = this._values;
    switch (uniform.semantic) {
      case UniformSemantic.LOCAL: {
        values[uniform.name] = component._entity.transform.localMatrix;
        break;
      }
      case UniformSemantic.MODEL:
        values[uniform.name] = component._entity.transform.worldMatrix;
        break;
      case UniformSemantic.VIEW:
        values[uniform.name] = context.viewMatrix;
        break;
      case UniformSemantic.PROJECTION:
        values[uniform.name] = context.projectionMatrix;
        break;
      case UniformSemantic.MODELVIEW: {
        const view = context.viewMatrix;
        const model = component._entity.transform.worldMatrix;
        let modelView = values[uniform.name];
        if (!modelView)
          modelView = new Matrix();
        Matrix.multiply(view, model, modelView);
        values[uniform.name] = modelView;
        break;
      }
      case UniformSemantic.VIEWPROJECTION: {
        const viewProj = context.viewProjectMatrix;
        values[uniform.name] = viewProj;
        break;
      }
      case UniformSemantic.MODELVIEWPROJECTION: {
        const viewProj = context.viewProjectMatrix;
        const model = component._entity.transform.worldMatrix;
        let MVP = values[uniform.name];
        if (!MVP)
          MVP = new Matrix();
        Matrix.multiply(viewProj, model, MVP);
        values[uniform.name] = MVP;
        break;
      }
      case UniformSemantic.MODELINVERSE:
        values[uniform.name] = component.invModelMatrixs;
        break;
      case UniformSemantic.VIEWINVERSE:
        values[uniform.name] = context.inverseViewMatrix;
        break;
      case UniformSemantic.PROJECTIONINVERSE:
        values[uniform.name] = context.inverseProjectionMatrix;
        break;
      case UniformSemantic.MODELVIEWINVERSE: {
        const view = context.viewMatrix;
        const model = component._entity.transform.worldMatrix;
        let invMV = values[uniform.name];
        if (!invMV)
          invMV = new Matrix();
        Matrix.multiply(view, model, invMV);
        Matrix.invert(invMV, invMV);
        values[uniform.name] = invMV;
        break;
      }
      case UniformSemantic.MODELVIEWPROJECTIONINVERSE: {
        const viewProj = context.viewProjectMatrix;
        const model = component._entity.transform.worldMatrix;
        let invMVP = values[uniform.name];
        if (!invMVP)
          invMVP = new Matrix();
        Matrix.multiply(viewProj, model, invMVP);
        Matrix.invert(invMVP, invMVP);
        values[uniform.name] = invMVP;
        break;
      }
      case UniformSemantic.MODELINVERSETRANSPOSE: {
        let modelIT = values[uniform.name];
        if (!modelIT)
          modelIT = new Matrix3x3();
        Matrix3x3.normalMatrix(component._entity.transform.worldMatrix, modelIT);
        values[uniform.name] = modelIT;
        break;
      }
      case UniformSemantic.MODELVIEWINVERSETRANSPOSE: {
        let modelViewIT = values[uniform.name];
        if (!modelViewIT)
          modelViewIT = new Matrix();
        Matrix.multiply(context.viewMatrix, component._entity.transform.worldMatrix, modelViewIT);
        Matrix.invert(modelViewIT, modelViewIT);
        Matrix.transpose(modelViewIT, modelViewIT);
        values[uniform.name] = modelViewIT;
        break;
      }
      case UniformSemantic.VIEWPORT:
        values[uniform.name] = context.viewport;
        break;
      case UniformSemantic.JOINTMATRIX:
        values[uniform.name] = component.matrixPalette;
        break;
      case UniformSemantic.JOINTTEXTURE:
        values[uniform.name] = component.jointTexture;
        break;
      case UniformSemantic.JOINTCOUNT:
        values[uniform.name] = component.jointNodes?.length;
        break;
      case UniformSemantic.MORPHWEIGHTS:
        values[uniform.name] = component.weights;
        break;
      case UniformSemantic.EYEPOS:
        values[uniform.name] = context.cameraPosition;
        break;
      case UniformSemantic.TIME:
        values[uniform.name] = component.engine.time.timeSinceStartup * 1e-3;
        break;
    }
  }
  _onDestroy() {
    if (this._technique) {
      const values = ObjectValues(this._values);
      for (let i = 0, len = values.length; i < len; i++) {
        const value = values[i];
        if (value instanceof Texture) {
          value._addRefCount(-1);
        }
      }
      this._technique._finalize();
      this._technique = null;
    }
  }
}

class ComplexMaterial extends Material {
  constructor(engine, name) {
    super(engine, name);
    this._techniquePool = {};
  }
  prepareDrawing(context, component, primitive) {
    const camera = context.camera;
    const tech = this._requireTechnique(camera, component, primitive);
    if (tech) {
      this._technique = tech;
      super.prepareDrawing(context, component, primitive);
    }
  }
  clearTechniques() {
    this._techniquePool = {};
  }
  _requireTechnique(camera, component, primitive) {
    const key = this._getTechniqueKey(camera, component, primitive);
    let tech = this._techniquePool[key];
    if (!tech) {
      tech = this._generateTechnique(camera, component, primitive);
      this._techniquePool[key] = tech;
    }
    return tech;
  }
  _generateTechnique(camera, component, primitive) {
  }
  _getTechniqueKey(camera, component, primitive) {
    const isSkin = component.skin != null;
    const jontCount = isSkin ? component.skin.joints.length : 0;
    let key = isSkin ? "skin_" : "static_";
    if (isSkin) {
      key += "jont" + jontCount;
    }
    return key;
  }
}

var BufferUsage;
(function(BufferUsage2) {
  BufferUsage2[BufferUsage2["Static"] = 0] = "Static";
  BufferUsage2[BufferUsage2["Dynamic"] = 1] = "Dynamic";
  BufferUsage2[BufferUsage2["Stream"] = 2] = "Stream";
})(BufferUsage || (BufferUsage = {}));

var VertexElementFormat;
(function(VertexElementFormat2) {
  VertexElementFormat2[VertexElementFormat2["Float"] = 0] = "Float";
  VertexElementFormat2[VertexElementFormat2["Vector2"] = 1] = "Vector2";
  VertexElementFormat2[VertexElementFormat2["Vector3"] = 2] = "Vector3";
  VertexElementFormat2[VertexElementFormat2["Vector4"] = 3] = "Vector4";
  VertexElementFormat2[VertexElementFormat2["Byte4"] = 4] = "Byte4";
  VertexElementFormat2[VertexElementFormat2["UByte4"] = 5] = "UByte4";
  VertexElementFormat2[VertexElementFormat2["NormalizedByte4"] = 6] = "NormalizedByte4";
  VertexElementFormat2[VertexElementFormat2["NormalizedUByte4"] = 7] = "NormalizedUByte4";
  VertexElementFormat2[VertexElementFormat2["Short2"] = 8] = "Short2";
  VertexElementFormat2[VertexElementFormat2["UShort2"] = 9] = "UShort2";
  VertexElementFormat2[VertexElementFormat2["NormalizedShort2"] = 10] = "NormalizedShort2";
  VertexElementFormat2[VertexElementFormat2["NormalizedUShort2"] = 11] = "NormalizedUShort2";
  VertexElementFormat2[VertexElementFormat2["Short4"] = 12] = "Short4";
  VertexElementFormat2[VertexElementFormat2["UShort4"] = 13] = "UShort4";
  VertexElementFormat2[VertexElementFormat2["NormalizedShort4"] = 14] = "NormalizedShort4";
  VertexElementFormat2[VertexElementFormat2["NormalizedUShort4"] = 15] = "NormalizedUShort4";
})(VertexElementFormat || (VertexElementFormat = {}));

var IndexFormat;
(function(IndexFormat2) {
  IndexFormat2[IndexFormat2["UInt8"] = 0] = "UInt8";
  IndexFormat2[IndexFormat2["UInt16"] = 1] = "UInt16";
  IndexFormat2[IndexFormat2["UInt32"] = 2] = "UInt32";
})(IndexFormat || (IndexFormat = {}));

class BufferUtil {
  static _getGLBufferUsage(gl, bufferUsage) {
    switch (bufferUsage) {
      case BufferUsage.Static:
        return gl.STATIC_DRAW;
      case BufferUsage.Dynamic:
        return gl.DYNAMIC_DRAW;
      case BufferUsage.Stream:
        return gl.STREAM_DRAW;
    }
  }
  static _getGLIndexType(indexFormat) {
    switch (indexFormat) {
      case IndexFormat.UInt8:
        return DataType.UNSIGNED_BYTE;
      case IndexFormat.UInt16:
        return DataType.UNSIGNED_SHORT;
      case IndexFormat.UInt32:
        return DataType.UNSIGNED_INT;
    }
  }
  static _getElementInfo(format) {
    let size;
    let type;
    switch (format) {
      case VertexElementFormat.Float:
        size = 1;
        type = DataType.FLOAT;
        break;
      case VertexElementFormat.Vector2:
        size = 2;
        type = DataType.FLOAT;
        break;
      case VertexElementFormat.Vector3:
        size = 3;
        type = DataType.FLOAT;
        break;
      case VertexElementFormat.Vector4:
        size = 4;
        type = DataType.FLOAT;
        break;
      case VertexElementFormat.Byte4:
        size = 4;
        type = DataType.UNSIGNED_BYTE;
        break;
      case VertexElementFormat.Short2:
        size = 2;
        type = DataType.SHORT;
        break;
      case VertexElementFormat.Short4:
        size = 4;
        type = DataType.SHORT;
        break;
      case VertexElementFormat.UShort2:
        size = 2;
        type = DataType.UNSIGNED_SHORT;
        break;
      case VertexElementFormat.UShort4:
        size = 4;
        type = DataType.UNSIGNED_SHORT;
        break;
    }
    return {size, type};
  }
}

var BufferBindFlag;
(function(BufferBindFlag2) {
  BufferBindFlag2[BufferBindFlag2["VertexBuffer"] = 0] = "VertexBuffer";
  BufferBindFlag2[BufferBindFlag2["IndexBuffer"] = 1] = "IndexBuffer";
})(BufferBindFlag || (BufferBindFlag = {}));

var SetDataOptions;
(function(SetDataOptions2) {
  SetDataOptions2[SetDataOptions2["None"] = 0] = "None";
  SetDataOptions2[SetDataOptions2["Discard"] = 1] = "Discard";
})(SetDataOptions || (SetDataOptions = {}));

class Buffer extends RefObject {
  get engine() {
    return this._engine;
  }
  get type() {
    return this._type;
  }
  get byteLength() {
    return this._byteLength;
  }
  get bufferUsage() {
    return this._bufferUsage;
  }
  constructor(engine, type, byteLengthOrData, bufferUsage = BufferUsage.Static) {
    super(engine);
    this._engine = engine;
    this._type = type;
    this._bufferUsage = bufferUsage;
    const hardwareRenderer = engine._hardwareRenderer;
    const gl = hardwareRenderer.gl;
    const glBufferUsage = BufferUtil._getGLBufferUsage(gl, bufferUsage);
    const glBindTarget = type === BufferBindFlag.VertexBuffer ? gl.ARRAY_BUFFER : gl.ELEMENT_ARRAY_BUFFER;
    this._nativeBuffer = gl.createBuffer();
    this._hardwareRenderer = hardwareRenderer;
    this._glBufferUsage = glBufferUsage;
    this._glBindTarget = glBindTarget;
    this.bind();
    if (typeof byteLengthOrData === "number") {
      this._byteLength = byteLengthOrData;
      gl.bufferData(glBindTarget, byteLengthOrData, glBufferUsage);
    } else {
      this._byteLength = byteLengthOrData.byteLength;
      gl.bufferData(glBindTarget, byteLengthOrData, glBufferUsage);
    }
    gl.bindBuffer(glBindTarget, null);
  }
  bind() {
    const gl = this._hardwareRenderer.gl;
    gl.bindBuffer(this._glBindTarget, this._nativeBuffer);
  }
  setData(data, bufferByteOffset = 0, dataOffset = 0, dataLength, options = SetDataOptions.None) {
    const gl = this._hardwareRenderer.gl;
    const isWebGL2 = this._hardwareRenderer.isWebGL2;
    const glBindTarget = this._glBindTarget;
    this.bind();
    if (options === SetDataOptions.Discard) {
      gl.bufferData(glBindTarget, this._byteLength, this._glBufferUsage);
    }
    const byteSize = data.BYTES_PER_ELEMENT || 1;
    const dataByteLength = dataLength ? byteSize * dataLength : data.byteLength;
    if (dataOffset !== 0 || dataByteLength < data.byteLength) {
      const isArrayBufferView = data.byteOffset !== void 0;
      if (isWebGL2 && isArrayBufferView) {
        gl.bufferSubData(glBindTarget, bufferByteOffset, data, dataOffset, dataByteLength / byteSize);
      } else {
        const subData = new Uint8Array(isArrayBufferView ? data.buffer : data, dataOffset * byteSize, dataByteLength);
        gl.bufferSubData(glBindTarget, bufferByteOffset, subData);
      }
    } else {
      gl.bufferSubData(glBindTarget, bufferByteOffset, data);
    }
    gl.bindBuffer(glBindTarget, null);
  }
  getData(data, bufferByteOffset = 0, dataOffset = 0, dataLength) {
    const isWebGL2 = this._hardwareRenderer.isWebGL2;
    if (isWebGL2) {
      const gl = this._hardwareRenderer.gl;
      this.bind();
      gl.getBufferSubData(this._glBindTarget, bufferByteOffset, data, dataOffset, dataLength);
    } else {
      throw "Buffer is write-only on WebGL1.0 platforms.";
    }
  }
  _onDestroy() {
    const gl = this._hardwareRenderer.gl;
    gl.deleteBuffer(this._nativeBuffer);
    this._nativeBuffer = null;
    this._hardwareRenderer = null;
  }
  resize(dataLength) {
    this.bind();
    const gl = this._hardwareRenderer.gl;
    gl.bufferData(this._glBindTarget, dataLength, this._glBufferUsage);
    this._byteLength = dataLength;
  }
}

var PrimitiveTopology;
(function(PrimitiveTopology2) {
  PrimitiveTopology2[PrimitiveTopology2["Points"] = 0] = "Points";
  PrimitiveTopology2[PrimitiveTopology2["Lines"] = 1] = "Lines";
  PrimitiveTopology2[PrimitiveTopology2["LineLoop"] = 2] = "LineLoop";
  PrimitiveTopology2[PrimitiveTopology2["LineStrip"] = 3] = "LineStrip";
  PrimitiveTopology2[PrimitiveTopology2["Triangles"] = 4] = "Triangles";
  PrimitiveTopology2[PrimitiveTopology2["TriangleStrip"] = 5] = "TriangleStrip";
  PrimitiveTopology2[PrimitiveTopology2["TriangleFan"] = 6] = "TriangleFan";
})(PrimitiveTopology || (PrimitiveTopology = {}));

class IndexBufferBinding {
  get buffer() {
    return this._buffer;
  }
  get format() {
    return this._format;
  }
  constructor(buffer, format) {
    this._buffer = buffer;
    this._format = format;
  }
}

class VertexBufferBinding {
  get buffer() {
    return this._buffer;
  }
  get stride() {
    return this._stride;
  }
  constructor(buffer, stride) {
    this._buffer = buffer;
    this._stride = stride;
  }
}

class Primitive extends RefObject {
  constructor(engine, name) {
    super(engine);
    this.instanceCount = 0;
    this._vertexElementMap = {};
    this._vertexBufferBindings = [];
    this._indexBufferBinding = null;
    this._vertexElements = [];
    this.targets = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.isInFrustum = true;
    this.name = name;
    this._platformPrimitive = this._engine._hardwareRenderer.createPlatformPrimitive(this);
  }
  get vertexBufferBindings() {
    return this._vertexBufferBindings;
  }
  get vertexElements() {
    return this._vertexElements;
  }
  get indexBufferBinding() {
    return this._indexBufferBinding;
  }
  setVertexBufferBinding(bufferOrBinding, strideOrFirstIndex = 0, firstIndex = 0) {
    let binding = bufferOrBinding;
    const isBinding = binding.buffer !== void 0;
    isBinding || (binding = new VertexBufferBinding(bufferOrBinding, strideOrFirstIndex));
    const bindings = this._vertexBufferBindings;
    bindings.length <= firstIndex && (bindings.length = firstIndex + 1);
    this._setVertexBufferBinding(isBinding ? strideOrFirstIndex : firstIndex, binding);
  }
  setVertexBufferBindings(bufferBindings, firstIndex = 0) {
    const bindings = this._vertexBufferBindings;
    const multiBindings = bufferBindings;
    const count = multiBindings.length;
    const needLength = firstIndex + count;
    bindings.length < needLength && (bindings.length = needLength);
    for (let i = 0; i < count; i++) {
      this._setVertexBufferBinding(firstIndex + i, multiBindings[i]);
    }
  }
  setIndexBufferBinding(bufferOrBinding, format) {
    let binding = bufferOrBinding;
    const isBinding = binding.buffer !== void 0;
    isBinding || (binding = new IndexBufferBinding(bufferOrBinding, format));
    this._indexBufferBinding = binding;
    this._glIndexType = BufferUtil._getGLIndexType(binding.format);
  }
  setVertexElements(elements) {
    this._clearVertexElements();
    for (let i = 0, n = elements.length; i < n; i++) {
      this._addVertexElement(elements[i]);
    }
  }
  draw(tech, subPrimitive) {
    this._platformPrimitive.draw(tech, subPrimitive);
  }
  _onDestroy() {
    this._vertexBufferBindings = null;
    this._indexBufferBinding = null;
    this._vertexElements = null;
    this._vertexElementMap = null;
    this._platformPrimitive.destroy();
  }
  _clearVertexElements() {
    this._vertexElements.length = 0;
    const vertexElementMap = this._vertexElementMap;
    for (var k in vertexElementMap) {
      delete vertexElementMap[k];
    }
  }
  _addVertexElement(element) {
    this._vertexElementMap[element.semantic] = element;
    this._vertexElements.push(element);
  }
  _setVertexBufferBinding(index, buffer) {
    const originBufferBinding = this._vertexBufferBindings[index];
    if (originBufferBinding) {
      this._removeRefChild(originBufferBinding._buffer);
    }
    this._addRefChild(buffer._buffer);
    this._vertexBufferBindings[index] = buffer;
  }
}

class VertexElement {
  constructor(semantic, offset, format, bindingIndex, instanceStepRate = 0) {
    this.normalized = false;
    this._semantic = semantic;
    this._offset = offset;
    this._format = format;
    this._bindingIndex = bindingIndex;
    this._glElementInfo = BufferUtil._getElementInfo(this.format);
    this._instanceStepRate = Math.floor(instanceStepRate);
  }
  get semantic() {
    return this._semantic;
  }
  get offset() {
    return this._offset;
  }
  get format() {
    return this._format;
  }
  get bindingIndex() {
    return this._bindingIndex;
  }
  get instanceStepRate() {
    return this._instanceStepRate;
  }
  get elementInfo() {
    return this._glElementInfo;
  }
}

class SubPrimitive {
  constructor(start = 0, count = 0, topology = PrimitiveTopology.Triangles) {
    this.start = start;
    this.count = count;
    this.topology = topology;
  }
}

var common2 = "#define PI 3.14159265359\n#define LOG2 1.442695\n\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\n\n// nosie common\n#include <noise_common>\n";

var common_vert2 = "attribute vec3 a_position;\n\n#ifdef O3_HAS_UV\n\nattribute vec2 a_uv;\n\n#endif\n\n#ifdef O3_HAS_NORMAL\n\nattribute vec3 a_normal;\n\n#endif\n\n#ifdef O3_HAS_TANGENT\n\nattribute vec4 a_tangent;\n\n#endif\n\n#ifdef O3_HAS_VERTEXCOLOR\n\nattribute vec4 a_color;\n\n#endif\n\n#if defined( O3_HAS_SKIN ) && ( defined( O3_JOINTS_NUM ) || defined( O3_USE_JOINT_TEXTURE ) )\n    attribute vec4 a_joint;\n    attribute vec4 a_weight;\n\n    #ifdef O3_USE_JOINT_TEXTURE\n        uniform sampler2D u_jointSampler;\n        uniform float u_jointCount;\n\n        mat4 getJointMatrix(sampler2D smp, float index)\n        {\n            float base = index / u_jointCount;\n            float hf = 0.5 / u_jointCount;\n            float v = base + hf;\n\n            vec4 m0 = texture2D(smp, vec2(0.125, v ));\n            vec4 m1 = texture2D(smp, vec2(0.375, v ));\n            vec4 m2 = texture2D(smp, vec2(0.625, v ));\n            vec4 m3 = texture2D(smp, vec2(0.875, v ));\n\n            return mat4(m0, m1, m2, m3);\n\n        }\n\n    #elif defined( O3_JOINTS_NUM )\n        uniform mat4 u_jointMatrix[ O3_JOINTS_NUM ];\n    #endif\n#endif\n\nuniform mat4 u_localMat;\nuniform mat4 u_modelMat;\nuniform mat4 u_viewMat;\nuniform mat4 u_projMat;\nuniform mat4 u_MVMat;\nuniform mat4 u_MVPMat;\nuniform mat3 u_normalMat;\nuniform vec3 u_cameraPos;\nuniform float u_time;\n";

var common_frag2 = "uniform O3_VERTEX_PRECISION mat4 u_localMat;\nuniform O3_VERTEX_PRECISION mat4 u_modelMat;\nuniform O3_VERTEX_PRECISION mat4 u_viewMat;\nuniform O3_VERTEX_PRECISION mat4 u_projMat;\nuniform O3_VERTEX_PRECISION mat4 u_MVMat;\nuniform O3_VERTEX_PRECISION mat4 u_MVPMat;\nuniform O3_VERTEX_PRECISION mat3 u_normalMat;\nuniform O3_VERTEX_PRECISION vec3 u_cameraPos;\nuniform O3_VERTEX_PRECISION float u_time;\n";

var color_share2 = "#ifdef O3_HAS_VERTEXCOLOR\n\nvarying vec4 v_color;\n\n#endif\n";

var normal_share2 = "#ifdef O3_HAS_NORMAL\n\n    #if defined( O3_HAS_TANGENT ) && defined( O3_HAS_NORMALMAP )\n\n    varying mat3 v_TBN;\n\n    #else\n\n    varying vec3 v_normal;\n\n    #endif\n\n#endif\n";

var uv_share2 = "varying vec2 v_uv;\n";

var worldpos_share2 = "#if defined( O3_NEED_WORLDPOS ) || defined( O3_HAS_ENVMAP ) || defined( O3_HAS_LIGHTMAP ) || defined(O3_CLIPPLANE_NUM)\n\nvarying vec3 v_pos;\n\n#endif\n";

var shadow_share2 = "#ifdef O3_GENERATE_SHADOW_MAP\n\nuniform mat4 u_viewMatFromLight;\nuniform mat4 u_projMatFromLight;\n\n#endif\n\n#ifdef O3_SHADOW_MAP_COUNT\n\nuniform mat4 u_viewMatFromLight[O3_SHADOW_MAP_COUNT];\nuniform mat4 u_projMatFromLight[O3_SHADOW_MAP_COUNT];\nvarying vec4 v_PositionFromLight[O3_SHADOW_MAP_COUNT];\n\n#endif\n";

var fog_share2 = "#ifdef O3_HAS_FOG\n\nvarying vec3 v_fogDepth;\n\nuniform O3_VERTEX_PRECISION vec3 u_fogColor;\n\n    #ifdef O3_FOG_EXP2\n\n        uniform O3_VERTEX_PRECISION float u_fogDensity;\n\n    #else\n\n        uniform O3_VERTEX_PRECISION float u_fogNear;\n        uniform O3_VERTEX_PRECISION float u_fogFar;\n\n    #endif\n\n#endif\n";

var begin_normal_vert2 = "    #ifdef O3_HAS_NORMAL\n\n    vec3 normal = vec3( a_normal );\n\n        #if defined( O3_HAS_TANGENT ) && defined( O3_HAS_NORMALMAP )\n\n        vec4 tangent = vec4( a_tangent );\n\n        #endif\n\n    #endif\n";

var begin_position_vert2 = "    vec4 position = vec4( a_position , 1.0 );\n";

var morph_target_vert2 = "#ifdef O3_HAS_MORPH\n\n    uniform float u_morphWeights[ O3_MORPH_NUM ];\n\n    #ifdef O3_MORPH_POSITION\n\n    attribute vec3 a_position0;\n\n    #endif\n\n    #ifdef O3_MORPH_NORMAL\n\n    attribute vec3 a_normal0;\n\n    #endif\n\n    #ifdef O3_MORPH_TANGENT\n\n    attribute vec3 a_tangent0;\n\n    #endif\n\n    #if O3_MORPH_NUM > 1\n\n        #ifdef O3_MORPH_POSITION\n\n        attribute vec3 a_position1;\n\n        #endif\n\n        #ifdef O3_MORPH_NORMAL\n\n        attribute vec3 a_normal1;\n\n        #endif\n\n        #ifdef O3_MORPH_TANGENT\n\n        attribute vec3 a_tangent1;\n\n        #endif\n\n    #endif\n\n    #if O3_MORPH_NUM > 2\n\n        #ifdef O3_MORPH_POSITION\n\n        attribute vec3 a_position2;\n\n        #endif\n\n        #ifdef O3_MORPH_NORMAL\n\n        attribute vec3 a_normal2;\n\n        #endif\n\n        #ifdef O3_MORPH_TANGENT\n\n        attribute vec3 a_tangent2;\n\n        #endif\n\n    #endif\n\n    #if O3_MORPH_NUM > 3\n\n        #ifdef O3_MORPH_POSITION\n\n        attribute vec3 a_position3;\n\n        #endif\n\n        #ifdef O3_MORPH_NORMAL\n\n        attribute vec3 a_normal3;\n\n        #endif\n\n        #ifdef O3_MORPH_TANGENT\n\n        attribute vec3 a_tangent3;\n\n        #endif\n\n    #endif\n\n    #if O3_MORPH_NUM > 4\n\n        #ifdef O3_MORPH_POSITION\n\n        attribute vec3 a_position4;\n\n        #endif\n\n        #ifdef O3_MORPH_NORMAL\n\n        attribute vec3 a_normal4;\n\n        #endif\n\n        #ifdef O3_MORPH_TANGENT\n\n        attribute vec3 a_tangent4;\n\n        #endif\n\n    #endif\n\n    #if O3_MORPH_NUM > 5\n\n        #ifdef O3_MORPH_POSITION\n\n        attribute vec3 a_position5;\n\n        #endif\n\n        #ifdef O3_MORPH_NORMAL\n\n        attribute vec3 a_normal5;\n\n        #endif\n\n        #ifdef O3_MORPH_TANGENT\n\n        attribute vec3 a_tangent5;\n\n        #endif\n\n    #endif\n\n    #if O3_MORPH_NUM > 6\n\n        #ifdef O3_MORPH_POSITION\n\n        attribute vec3 a_position6;\n\n        #endif\n\n        #ifdef O3_MORPH_NORMAL\n\n        attribute vec3 a_normal6;\n\n        #endif\n\n        #ifdef O3_MORPH_TANGENT\n\n        attribute vec3 a_tangent6;\n\n        #endif\n\n    #endif\n\n    #if O3_MORPH_NUM > 7\n\n        #ifdef O3_MORPH_POSITION\n\n        attribute vec3 a_position7;\n\n        #endif\n\n        #ifdef O3_MORPH_NORMAL\n\n        attribute vec3 a_normal7;\n\n        #endif\n\n        #ifdef O3_MORPH_TANGENT\n\n        attribute vec3 a_tangent7;\n\n        #endif\n\n    #endif\n\n#endif\n";

var position_vert2 = "    #ifndef O3_GENERATE_SHADOW_MAP\n\n    gl_Position = u_MVPMat * position;\n\n    #endif\n";

var color_vert2 = "    #ifdef O3_HAS_VERTEXCOLOR\n\n    v_color = a_color;\n\n    #endif\n";

var normal_vert2 = "    #ifdef O3_HAS_NORMAL\n\n        #if defined( O3_HAS_TANGENT ) && defined( O3_HAS_NORMALMAP )\n\n        vec3 normalW = normalize( u_normalMat * normal.xyz );\n        vec3 tangentW = normalize( u_normalMat * tangent.xyz );\n        vec3 bitangentW = cross( normalW, tangentW ) * tangent.w;\n        v_TBN = mat3( tangentW, bitangentW, normalW );\n\n        #else\n\n        v_normal = normalize( u_normalMat * normal );\n\n        #endif\n\n    #endif\n";

var skinning_vert2 = "#if defined( O3_HAS_SKIN ) && ( defined( O3_JOINTS_NUM ) || defined( O3_USE_JOINT_TEXTURE ) )\n\n        #ifdef O3_USE_JOINT_TEXTURE\n            mat4 skinMatrix =\n                a_weight.x * getJointMatrix(u_jointSampler, a_joint.x ) +\n                a_weight.y * getJointMatrix(u_jointSampler, a_joint.y ) +\n                a_weight.z * getJointMatrix(u_jointSampler, a_joint.z ) +\n                a_weight.w * getJointMatrix(u_jointSampler, a_joint.w );\n\n        #elif defined( O3_JOINTS_NUM )\n            mat4 skinMatrix =\n                a_weight.x * u_jointMatrix[ int( a_joint.x ) ] +\n                a_weight.y * u_jointMatrix[ int( a_joint.y ) ] +\n                a_weight.z * u_jointMatrix[ int( a_joint.z ) ] +\n                a_weight.w * u_jointMatrix[ int( a_joint.w ) ];\n        #endif\n\n        position = skinMatrix * position;\n\n        #ifdef O3_HAS_NORMAL\n            normal = vec4( skinMatrix * vec4( normal, 0.0 ) ).xyz;\n            #if defined( O3_HAS_TANGENT ) && defined( O3_HAS_NORMALMAP )\n                tangent.xyz = vec4( skinMatrix * vec4( tangent.xyz, 0.0 ) ).xyz;\n            #endif\n\n        #endif\n\n#endif\n";

var uv_vert2 = "    #ifdef O3_HAS_UV\n\n    v_uv = a_uv;\n\n    #else\n\n    // may need this calculate normal\n    v_uv = vec2( 0., 0. );\n\n    #endif\n";

var worldpos_vert2 = "    #if defined( O3_NEED_WORLDPOS ) || defined( O3_HAS_ENVMAP ) || defined( O3_HAS_LIGHTMAP ) || defined(O3_CLIPPLANE_NUM)\n\n    vec4 temp_pos = u_modelMat * position;\n    v_pos = temp_pos.xyz / temp_pos.w;\n\n    #endif\n";

var shadow_vert2 = "    #ifdef O3_GENERATE_SHADOW_MAP\n\n    gl_Position = u_projMatFromLight * u_viewMatFromLight * u_modelMat * position;\n\n    #endif\n\n    #ifdef O3_SHADOW_MAP_COUNT\n\n    for (int i = 0; i < O3_SHADOW_MAP_COUNT; i++) {\n\n        v_PositionFromLight[i] = u_projMatFromLight[i] * u_viewMatFromLight[i] * u_modelMat * vec4( a_position, 1.0 );\n\n    }\n\n    #endif\n";

var morph_vert2 = "    #ifdef O3_HAS_MORPH\n\n        #if defined( O3_MORPH_POSITION )\n\n        position.xyz += u_morphWeights[ 0 ] * a_position0;\n\n            #if O3_MORPH_NUM > 1\n\n            position.xyz += u_morphWeights[ 1 ] * a_position1;\n\n            #endif\n\n            #if O3_MORPH_NUM > 2\n\n            position.xyz += u_morphWeights[ 2 ] * a_position2;\n\n            #endif\n\n            #if O3_MORPH_NUM > 3\n\n            position.xyz += u_morphWeights[ 3 ] * a_position3;\n\n            #endif\n\n            #if O3_MORPH_NUM > 4\n\n            position.xyz += u_morphWeights[ 4 ] * a_position4;\n\n            #endif\n\n            #if O3_MORPH_NUM > 5\n\n            position.xyz += u_morphWeights[ 5 ] * a_position5;\n\n            #endif\n\n            #if O3_MORPH_NUM > 6\n\n            position.xyz += u_morphWeights[ 6 ] * a_position6;\n\n            #endif\n\n            #if O3_MORPH_NUM > 7\n\n            position.xyz += u_morphWeights[ 7 ] * a_position7;\n\n            #endif\n\n        #endif\n\n        #if defined( O3_HAS_NORMAL ) && defined( O3_MORPH_NORMAL )\n\n        normal.xyz += u_morphWeights[ 0 ] * a_normal0;\n\n            #if O3_MORPH_NUM > 1\n\n            normal.xyz += u_morphWeights[ 1 ] * a_normal1;\n\n            #endif\n\n            #if O3_MORPH_NUM > 2\n\n            normal.xyz += u_morphWeights[ 2 ] * a_normal2;\n\n            #endif\n\n            #if O3_MORPH_NUM > 3\n\n            normal.xyz += u_morphWeights[ 3 ] * a_normal3;\n\n            #endif\n\n            #if O3_MORPH_NUM > 4\n\n            normal.xyz += u_morphWeights[ 4 ] * a_normal4;\n\n            #endif\n\n            #if O3_MORPH_NUM > 5\n\n            normal.xyz += u_morphWeights[ 5 ] * a_normal5;\n\n            #endif\n\n            #if O3_MORPH_NUM > 6\n\n            normal.xyz += u_morphWeights[ 6 ] * a_normal6;\n\n            #endif\n\n            #if O3_MORPH_NUM > 7\n\n            normal.xyz += u_morphWeights[ 7 ] * a_normal7;\n\n            #endif\n\n        #endif\n\n        #if defined( O3_HAS_TANGENT ) && defined( O3_MORPH_TANGENT ) && defined( O3_HAS_NORMALMAP )\n\n        tangent.xyz += u_morphWeights[ 0 ] * a_tangent0;\n\n            #if O3_MORPH_NUM > 1\n\n            tangent.xyz += u_morphWeights[ 1 ] * a_tangent1;\n\n            #endif\n\n            #if O3_MORPH_NUM > 2\n\n            tangent.xyz += u_morphWeights[ 2 ] * a_tangent2;\n\n            #endif\n\n            #if O3_MORPH_NUM > 3\n\n            tangent.xyz += u_morphWeights[ 3 ] * a_tangent3;\n\n            #endif\n\n            #if O3_MORPH_NUM > 4\n\n            tangent.xyz += u_morphWeights[ 4 ] * a_tangent4;\n\n            #endif\n\n            #if O3_MORPH_NUM > 5\n\n            tangent.xyz += u_morphWeights[ 5 ] * a_tangent5;\n\n            #endif\n\n            #if O3_MORPH_NUM > 6\n\n            tangent.xyz += u_morphWeights[ 6 ] * a_tangent6;\n\n            #endif\n\n            #if O3_MORPH_NUM > 7\n\n            tangent.xyz += u_morphWeights[ 7 ] * a_tangent7;\n\n            #endif\n\n        #endif\n\n    #endif\n";

var fog_vert2 = "    #ifdef O3_HAS_FOG\n\n    v_fogDepth = ( u_MVMat * position ).xyz;\n\n    #endif\n";

var ambient_light_frag2 = "#ifdef O3_HAS_AMBIENT_LIGHT\n\nstruct AmbientLight {\n    vec3 color;\n    vec3 lightColor;\n    float intensity;\n};\nuniform AmbientLight u_ambientLight;\n\n#endif\n";

var direct_light_frag2 = "#ifdef O3_DIRECT_LIGHT_COUNT\n\nstruct DirectLight {\n    vec3 color;\n    vec3 lightColor;\n    float intensity;\n    vec3 direction;\n};\nuniform DirectLight u_directLights[ O3_DIRECT_LIGHT_COUNT ];\n\n#endif\n";

var point_light_frag2 = "#ifdef O3_POINT_LIGHT_COUNT\n\nstruct PointLight {\n    vec3 color;\n    vec3 lightColor;\n    vec3 position;\n    float intensity;\n    float distance;\n    float decay;\n};\nuniform PointLight u_pointLights[ O3_POINT_LIGHT_COUNT ];\n\n#endif\n";

var spot_light_frag2 = "#ifdef O3_SPOT_LIGHT_COUNT\n\nstruct SpotLight {\n    vec3 color;\n    vec3 lightColor;\n    vec3 position;\n    vec3 direction;\n    float intensity;\n    float distance;\n    float decay;\n    float angle;\n    float penumbra;\n    float coneCos;\n    float penumbraCos;\n};\nuniform SpotLight u_spotLights[ O3_SPOT_LIGHT_COUNT ];\n\n#endif\n";

var mobile_material_frag2 = "uniform float u_shininess;\n\n#ifdef O3_EMISSION_TEXTURE\n\nuniform sampler2D u_emission;\n\n#else\n\nuniform vec4 u_emission;\n\n#endif\n\n#ifdef O3_AMBIENT_TEXTURE\n\nuniform sampler2D u_ambient;\n\n#else\n\nuniform vec4 u_ambient;\n\n#endif\n\n#ifdef O3_DIFFUSE_TEXTURE\n\nuniform sampler2D u_diffuse;\n\n#else\n\nuniform vec4 u_diffuse;\n\n#endif\n\n#ifdef O3_SPECULAR_TEXTURE\n\nuniform sampler2D u_specular;\n\n#else\n\nuniform vec4 u_specular;\n\n#endif\n";

var fog_frag2 = "    #ifdef O3_HAS_FOG\n\n    float fogDepth = length( v_fogDepth );\n\n        #ifdef O3_FOG_EXP2\n\n            float fogFactor = whiteCompliment( exp2( - u_fogDensity * u_fogDensity * fogDepth * fogDepth * LOG2 ) );\n\n        #else\n\n            float fogFactor = smoothstep( u_fogNear, u_fogFar, fogDepth );\n\n        #endif\n\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, u_fogColor, fogFactor );\n\n    #endif\n";

var begin_mobile_frag2 = "    #ifdef O3_EMISSION_TEXTURE\n\n    vec4 emission = texture2D(u_emission, v_uv);\n\n    #else\n\n    vec4 emission = u_emission;\n\n    #endif\n\n    vec4 ambient = vec4(0);\n    #ifdef O3_HAS_AMBIENT_LIGHT\n        #ifdef O3_AMBIENT_TEXTURE\n            ambient = texture2D(u_ambient, v_uv) * vec4(u_ambientLight.lightColor, 1.0);\n         #else\n            ambient = u_ambient * vec4(u_ambientLight.lightColor, 1.0);\n         #endif\n    #endif\n\n    #ifdef O3_DIFFUSE_TEXTURE\n\n    vec4 diffuse = texture2D(u_diffuse, v_uv);\n\n    #else\n\n    vec4 diffuse = u_diffuse;\n\n    #endif\n\n    #ifdef O3_SPECULAR_TEXTURE\n\n    vec4 specular = texture2D(u_specular, v_uv);\n\n    #else\n\n    vec4 specular = u_specular;\n\n    #endif\n";

var begin_normal_frag2 = "    #ifdef O3_HAS_NORMAL\n\n        #if defined( O3_HAS_TANGENT ) && defined( O3_HAS_NORMALMAP )\n\n        vec3 N = normalize( v_TBN[ 2 ] );\n\n        #else\n\n        vec3 N = normalize( v_normal );\n\n        #endif\n\n    #endif\n";

var begin_viewdir_frag2 = "    #if defined( O3_NEED_WORLDPOS ) || defined( O3_HAS_ENVMAP ) || defined( O3_HAS_LIGHTMAP )\n\n    vec3 V =  normalize( u_cameraPos - v_pos );\n\n    #endif\n";

var mobile_blinnphong_frag2 = "    #ifdef O3_HAS_NORMAL\n         N *= float( gl_FrontFacing ) * 2.0 - 1.0;\n    #else\n         vec3 N = vec3(0, 0, 1);\n    #endif\n\n\n    vec3 lightDiffuse = vec3( 0.0, 0.0, 0.0 );\n    vec3 lightSpecular = vec3( 0.0, 0.0, 0.0 );\n\n    #ifdef O3_DIRECT_LIGHT_COUNT\n\n    for( int i = 0; i < O3_DIRECT_LIGHT_COUNT; i++ ) {\n        DirectLight lgt = u_directLights[ i ];\n\n        float d = max(dot(N, -lgt.direction), 0.0)*lgt.intensity;\n        lightDiffuse += lgt.color*d;\n\n        vec3 halfDir = normalize( V - lgt.direction );\n        float s = pow( clamp( dot( N, halfDir ), 0.0, 1.0 ), u_shininess ) * lgt.intensity;\n        lightSpecular += lgt.color * s;\n    }\n\n    #endif\n\n    #ifdef O3_POINT_LIGHT_COUNT\n\n    for( int i = 0; i < O3_POINT_LIGHT_COUNT; i++ ) {\n        PointLight lgt = u_pointLights[ i ];\n        vec3 direction = v_pos - lgt.position;\n        float dist = length( direction );\n        direction /= dist;\n        float decay = pow( max( 0.0, 1.0-dist/lgt.distance ), 2.0 );\n\n        float d =  max( dot( N, -direction ), 0.0 )*lgt.intensity*decay;\n        lightDiffuse += lgt.color*d;\n\n        vec3 halfDir = normalize( V - direction );\n        float s = pow( clamp( dot( N, halfDir ), 0.0, 1.0 ), u_shininess ) * lgt.intensity * decay;\n        lightSpecular += lgt.color * s;\n\n    }\n\n    #endif\n\n    #ifdef O3_SPOT_LIGHT_COUNT\n\n    for( int i = 0; i < O3_SPOT_LIGHT_COUNT; i++) {\n        SpotLight lgt = u_spotLights[ i ];\n        vec3 direction = v_pos - lgt.position;\n        float angle = acos( dot( normalize( direction ), normalize( lgt.direction ) ) );\n        float dist = length( direction );\n        direction /= dist;\n        float decay = pow( max( 0.0, 1.0 - dist / lgt.distance ), 2.0 );\n\n        float hasLight = step( angle, lgt.angle );\n        float hasPenumbra = step( lgt.angle, angle ) * step( angle, lgt.angle * ( 1.0 + lgt.penumbra ) );\n        float penumbra = hasPenumbra * ( 1.0 - ( angle - lgt.angle ) / ( lgt.angle * lgt.penumbra ) );\n        float d = max( dot( N, -direction ), 0.0 ) * lgt.intensity * decay * ( penumbra + hasLight );\n        lightDiffuse += lgt.color * d;\n\n        vec3 halfDir = normalize( V - direction );\n        float s = pow( clamp( dot( N, halfDir ), 0.0, 1.0 ), u_shininess ) * lgt.intensity * decay * ( penumbra + hasLight );\n        lightSpecular += lgt.color * s;\n\n    }\n\n    #endif\n\n    diffuse *= vec4( lightDiffuse, 1.0 );\n    specular *= vec4( lightSpecular, 1.0 );\n";

var mobile_lambert_frag2 = "    vec3 totalLight = vec3(0.0, 0.0, 0.0);\n    #ifdef O3_DIRECT_LIGHT_COUNT\n    for( int i = 0; i < O3_DIRECT_LIGHT_COUNT; i++ ){\n        vec3 lightColor = u_directLights[ i ].color * u_directLights[ i ].intensity;\n        lightColor *= max( dot( N, -u_directLights[ i ].direction ), 0.0 );\n\n        totalLight += lightColor;\n    }\n    #endif\n    diffuse *= vec4( totalLight, 1.0 );\n";

var noise_common2 = "// Modulo 289 without a division (only multiplications)\nvec4 mod289( vec4 x ) {\n\n    return x - floor( x * ( 1.0 / 289.0 ) ) * 289.0;\n\n}\n\nvec3 mod289( vec3 x ) {\n\n    return x - floor( x * ( 1.0 / 289.0 ) ) * 289.0;\n\n}\n\nvec2 mod289( vec2 x ) {\n\n    return x - floor( x * ( 1.0 / 289.0 ) ) * 289.0;\n\n}\n\nfloat mod289( float x ) {\n\n    return x - floor( x * ( 1.0 / 289.0 ) ) * 289.0;\n\n}\n\n// Modulo 7 without a division\nvec4 mod7( vec4 x ) {\n\n    return x - floor( x * ( 1.0 / 7.0 ) ) * 7.0;\n\n}\n\nvec3 mod7( vec3 x ) {\n\n    return x - floor( x * ( 1.0 / 7.0 ) ) * 7.0;\n\n}\n\n// Permutation polynomial: (34x^2 + x) mod 289\nvec4 permute( vec4 x ) {\n\n    return mod289( ( 34.0 * x + 1.0 ) * x);\n\n}\n\nvec3 permute( vec3 x ) {\n\n    return mod289( ( 34.0 * x + 1.0 ) * x );\n\n}\n\nfloat permute( float x ) {\n\n  return mod289( ( ( x * 34.0 ) + 1.0 ) * x );\n\n}\n\nvec4 taylorInvSqrt( vec4 r ) {\n\n    return 1.79284291400159 - 0.85373472095314 * r;\n\n}\n\nfloat taylorInvSqrt( float r ) {\n\n    return 1.79284291400159 - 0.85373472095314 * r;\n\n}\n\nvec4 fade( vec4 t ) {\n\n    return t * t * t * ( t * ( t * 6.0 - 15.0 ) + 10.0 );\n\n}\n\nvec3 fade( vec3 t ) {\n\n    return t * t * t * ( t * ( t * 6.0 - 15.0 ) + 10.0 );\n\n}\n\nvec2 fade( vec2 t ) {\n\n    return t * t * t * ( t * ( t * 6.0 - 15.0 ) + 10.0 );\n\n}\n\n#define K 0.142857142857 // 1/7\n#define Ko 0.428571428571 // 1/2-K/2\n#define K2 0.020408163265306 // 1/(7*7)\n#define Kd2 0.0714285714285 // K/2\n#define Kz 0.166666666667 // 1/6\n#define Kzo 0.416666666667 // 1/2-1/6*2\n#define jitter 1.0 // smaller jitter gives more regular pattern\n#define jitter1 0.8 // smaller jitter gives less errors in F1 F2\n";

var noise_cellular_2D2 = "\n// Cellular noise (\"Worley noise\") in 2D in GLSL.\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n// This code is released under the conditions of the MIT license.\n// See LICENSE file for details.\n// https://github.com/stegu/webgl-noise\n\n// Cellular noise, returning F1 and F2 in a vec2.\n// Standard 3x3 search window for good F1 and F2 values\nvec2 cellular( vec2 P ) {\n\n\tvec2 Pi = mod289( floor( P ) );\n \tvec2 Pf = fract( P );\n\tvec3 oi = vec3( -1.0, 0.0, 1.0);\n\tvec3 of = vec3( -0.5, 0.5, 1.5);\n\tvec3 px = permute( Pi.x + oi );\n\tvec3 p = permute( px.x + Pi.y + oi ); // p11, p12, p13\n\tvec3 ox = fract( p * K ) - Ko;\n\tvec3 oy = mod7( floor( p * K ) ) * K - Ko;\n\tvec3 dx = Pf.x + 0.5 + jitter * ox;\n\tvec3 dy = Pf.y - of + jitter * oy;\n\tvec3 d1 = dx * dx + dy * dy; // d11, d12 and d13, squared\n\tp = permute( px.y + Pi.y + oi ); // p21, p22, p23\n\tox = fract( p * K ) - Ko;\n\toy = mod7( floor( p * K ) ) * K - Ko;\n\tdx = Pf.x - 0.5 + jitter * ox;\n\tdy = Pf.y - of + jitter * oy;\n\tvec3 d2 = dx * dx + dy * dy; // d21, d22 and d23, squared\n\tp = permute( px.z + Pi.y + oi ); // p31, p32, p33\n\tox = fract( p * K ) - Ko;\n\toy = mod7( floor( p * K ) ) * K - Ko;\n\tdx = Pf.x - 1.5 + jitter * ox;\n\tdy = Pf.y - of + jitter * oy;\n\tvec3 d3 = dx * dx + dy * dy; // d31, d32 and d33, squared\n\t// Sort out the two smallest distances (F1, F2)\n\tvec3 d1a = min( d1, d2 );\n\td2 = max( d1, d2 ); // Swap to keep candidates for F2\n\td2 = min( d2, d3 ); // neither F1 nor F2 are now in d3\n\td1 = min( d1a, d2 ); // F1 is now in d1\n\td2 = max( d1a, d2 ); // Swap to keep candidates for F2\n\td1.xy = ( d1.x < d1.y ) ? d1.xy : d1.yx; // Swap if smaller\n\td1.xz = ( d1.x < d1.z ) ? d1.xz : d1.zx; // F1 is in d1.x\n\td1.yz = min( d1.yz, d2.yz ); // F2 is now not in d2.yz\n\td1.y = min( d1.y, d1.z ); // nor in  d1.z\n\td1.y = min( d1.y, d2.x ); // F2 is in d1.y, we're done.\n\treturn sqrt( d1.xy );\n\n}\n";

var noise_cellular_2x22 = "\n// Cellular noise (\"Worley noise\") in 2D in GLSL.\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n// This code is released under the conditions of the MIT license.\n// See LICENSE file for details.\n// https://github.com/stegu/webgl-noise\n\n// Cellular noise, returning F1 and F2 in a vec2.\n// Speeded up by using 2x2 search window instead of 3x3,\n// at the expense of some strong pattern artifacts.\n// F2 is often wrong and has sharp discontinuities.\n// If you need a smooth F2, use the slower 3x3 version.\n// F1 is sometimes wrong, too, but OK for most purposes.\nvec2 cellular2x2( vec2 P ) {\n\n\tvec2 Pi = mod289( floor( P ) );\n \tvec2 Pf = fract( P );\n\tvec4 Pfx = Pf.x + vec4( -0.5, -1.5, -0.5, -1.5 );\n\tvec4 Pfy = Pf.y + vec4( -0.5, -0.5, -1.5, -1.5 );\n\tvec4 p = permute( Pi.x + vec4( 0.0, 1.0, 0.0, 1.0 ) );\n\tp = permute( p + Pi.y + vec4( 0.0, 0.0, 1.0, 1.0 ) );\n\tvec4 ox = mod7( p ) * K + Kd2;\n\tvec4 oy = mod7( floor( p * K ) ) * K + Kd2;\n\tvec4 dx = Pfx + jitter1 * ox;\n\tvec4 dy = Pfy + jitter1 * oy;\n\tvec4 d = dx * dx + dy * dy; // d11, d12, d21 and d22, squared\n\n\t// Do it right and find both F1 and F2\n\td.xy = ( d.x < d.y ) ? d.xy : d.yx; // Swap if smaller\n\td.xz = ( d.x < d.z ) ? d.xz : d.zx;\n\td.xw = ( d.x < d.w ) ? d.xw : d.wx;\n\td.y = min( d.y, d.z );\n\td.y = min( d.y, d.w );\n\treturn sqrt( d.xy );\n\n}\n";

var noise_cellular_2x2x22 = "\n// Cellular noise (\"Worley noise\") in 3D in GLSL.\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n// This code is released under the conditions of the MIT license.\n// See LICENSE file for details.\n// https://github.com/stegu/webgl-noise\n\n// Cellular noise, returning F1 and F2 in a vec2.\n// Speeded up by using 2x2x2 search window instead of 3x3x3,\n// at the expense of some pattern artifacts.\n// F2 is often wrong and has sharp discontinuities.\n// If you need a good F2, use the slower 3x3x3 version.\nvec2 cellular2x2x2(vec3 P) {\n\n\tvec3 Pi = mod289( floor( P ) );\n \tvec3 Pf = fract( P );\n\tvec4 Pfx = Pf.x + vec4( 0.0, -1.0, 0.0, -1.0 );\n\tvec4 Pfy = Pf.y + vec4( 0.0, 0.0, -1.0, -1.0 );\n\tvec4 p = permute( Pi.x + vec4( 0.0, 1.0, 0.0, 1.0 ) );\n\tp = permute( p + Pi.y + vec4( 0.0, 0.0, 1.0, 1.0 ) );\n\tvec4 p1 = permute( p + Pi.z ); // z+0\n\tvec4 p2 = permute( p + Pi.z + vec4( 1.0 ) ); // z+1\n\tvec4 ox1 = fract( p1 * K ) - Ko;\n\tvec4 oy1 = mod7( floor( p1 * K ) ) * K - Ko;\n\tvec4 oz1 = floor( p1 * K2 ) * Kz - Kzo; // p1 < 289 guaranteed\n\tvec4 ox2 = fract( p2 * K ) - Ko;\n\tvec4 oy2 = mod7( floor( p2 * K ) ) * K - Ko;\n\tvec4 oz2 = floor( p2 * K2 ) * Kz - Kzo;\n\tvec4 dx1 = Pfx + jitter1 * ox1;\n\tvec4 dy1 = Pfy + jitter1 * oy1;\n\tvec4 dz1 = Pf.z + jitter1 * oz1;\n\tvec4 dx2 = Pfx + jitter1 * ox2;\n\tvec4 dy2 = Pfy + jitter1 * oy2;\n\tvec4 dz2 = Pf.z - 1.0 + jitter1 * oz2;\n\tvec4 d1 = dx1 * dx1 + dy1 * dy1 + dz1 * dz1; // z+0\n\tvec4 d2 = dx2 * dx2 + dy2 * dy2 + dz2 * dz2; // z+1\n\n\t// Do it right and sort out both F1 and F2\n\tvec4 d = min( d1, d2 ); // F1 is now in d\n\td2 = max( d1, d2 ); // Make sure we keep all candidates for F2\n\td.xy = ( d.x < d.y ) ? d.xy : d.yx; // Swap smallest to d.x\n\td.xz = ( d.x < d.z ) ? d.xz : d.zx;\n\td.xw = ( d.x < d.w ) ? d.xw : d.wx; // F1 is now in d.x\n\td.yzw = min( d.yzw, d2.yzw ); // F2 now not in d2.yzw\n\td.y = min( d.y, d.z ); // nor in d.z\n\td.y = min( d.y, d.w ); // nor in d.w\n\td.y = min( d.y, d2.x ); // F2 is now in d.y\n\treturn sqrt( d.xy ); // F1 and F2\n\n}\n";

var noise_cellular_3D2 = "\n// Cellular noise (\"Worley noise\") in 3D in GLSL.\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n// This code is released under the conditions of the MIT license.\n// See LICENSE file for details.\n// https://github.com/stegu/webgl-noise\n\n// Cellular noise, returning F1 and F2 in a vec2.\n// 3x3x3 search region for good F2 everywhere, but a lot\n// slower than the 2x2x2 version.\n// The code below is a bit scary even to its author,\n// but it has at least half decent performance on a\n// modern GPU. In any case, it beats any software\n// implementation of Worley noise hands down.\n\nvec2 cellular( vec3 P ) {\n\n\tvec3 Pi = mod289( floor( P ) );\n \tvec3 Pf = fract( P ) - 0.5;\n\n\tvec3 Pfx = Pf.x + vec3( 1.0, 0.0, -1.0 );\n\tvec3 Pfy = Pf.y + vec3( 1.0, 0.0, -1.0 );\n\tvec3 Pfz = Pf.z + vec3( 1.0, 0.0, -1.0 );\n\n\tvec3 p = permute( Pi.x + vec3( -1.0, 0.0, 1.0 ) );\n\tvec3 p1 = permute( p + Pi.y - 1.0 );\n\tvec3 p2 = permute( p + Pi.y );\n\tvec3 p3 = permute( p + Pi.y + 1.0 );\n\n\tvec3 p11 = permute( p1 + Pi.z - 1.0 );\n\tvec3 p12 = permute( p1 + Pi.z );\n\tvec3 p13 = permute( p1 + Pi.z + 1.0 );\n\n\tvec3 p21 = permute( p2 + Pi.z - 1.0 );\n\tvec3 p22 = permute( p2 + Pi.z );\n\tvec3 p23 = permute( p2 + Pi.z + 1.0 );\n\n\tvec3 p31 = permute( p3 + Pi.z - 1.0 );\n\tvec3 p32 = permute( p3 + Pi.z );\n\tvec3 p33 = permute( p3 + Pi.z + 1.0 );\n\n\tvec3 ox11 = fract( p11 * K ) - Ko;\n\tvec3 oy11 = mod7( floor( p11 * K ) ) * K - Ko;\n\tvec3 oz11 = floor( p11 * K2 ) * Kz - Kzo; // p11 < 289 guaranteed\n\n\tvec3 ox12 = fract( p12 * K ) - Ko;\n\tvec3 oy12 = mod7( floor( p12 * K ) ) * K - Ko;\n\tvec3 oz12 = floor( p12 * K2 ) * Kz - Kzo;\n\n\tvec3 ox13 = fract( p13 * K ) - Ko;\n\tvec3 oy13 = mod7( floor( p13 * K ) ) * K - Ko;\n\tvec3 oz13 = floor( p13 * K2 ) * Kz - Kzo;\n\n\tvec3 ox21 = fract( p21 * K ) - Ko;\n\tvec3 oy21 = mod7( floor( p21 * K ) ) * K - Ko;\n\tvec3 oz21 = floor( p21 * K2 ) * Kz - Kzo;\n\n\tvec3 ox22 = fract( p22 * K ) - Ko;\n\tvec3 oy22 = mod7( floor( p22 * K ) ) * K - Ko;\n\tvec3 oz22 = floor( p22 * K2 ) * Kz - Kzo;\n\n\tvec3 ox23 = fract( p23 * K ) - Ko;\n\tvec3 oy23 = mod7( floor( p23 * K ) ) * K - Ko;\n\tvec3 oz23 = floor( p23 * K2 ) * Kz - Kzo;\n\n\tvec3 ox31 = fract( p31 * K ) - Ko;\n\tvec3 oy31 = mod7( floor( p31 * K ) ) * K - Ko;\n\tvec3 oz31 = floor( p31 * K2 ) * Kz - Kzo;\n\n\tvec3 ox32 = fract( p32 * K ) - Ko;\n\tvec3 oy32 = mod7( floor( p32 * K ) ) * K - Ko;\n\tvec3 oz32 = floor( p32 * K2 ) * Kz - Kzo;\n\n\tvec3 ox33 = fract( p33 * K ) - Ko;\n\tvec3 oy33 = mod7( floor( p33 * K ) ) * K - Ko;\n\tvec3 oz33 = floor( p33 * K2 ) * Kz - Kzo;\n\n\tvec3 dx11 = Pfx + jitter * ox11;\n\tvec3 dy11 = Pfy.x + jitter * oy11;\n\tvec3 dz11 = Pfz.x + jitter * oz11;\n\n\tvec3 dx12 = Pfx + jitter * ox12;\n\tvec3 dy12 = Pfy.x + jitter * oy12;\n\tvec3 dz12 = Pfz.y + jitter * oz12;\n\n\tvec3 dx13 = Pfx + jitter * ox13;\n\tvec3 dy13 = Pfy.x + jitter * oy13;\n\tvec3 dz13 = Pfz.z + jitter * oz13;\n\n\tvec3 dx21 = Pfx + jitter * ox21;\n\tvec3 dy21 = Pfy.y + jitter * oy21;\n\tvec3 dz21 = Pfz.x + jitter * oz21;\n\n\tvec3 dx22 = Pfx + jitter * ox22;\n\tvec3 dy22 = Pfy.y + jitter * oy22;\n\tvec3 dz22 = Pfz.y + jitter * oz22;\n\n\tvec3 dx23 = Pfx + jitter * ox23;\n\tvec3 dy23 = Pfy.y + jitter * oy23;\n\tvec3 dz23 = Pfz.z + jitter * oz23;\n\n\tvec3 dx31 = Pfx + jitter * ox31;\n\tvec3 dy31 = Pfy.z + jitter * oy31;\n\tvec3 dz31 = Pfz.x + jitter * oz31;\n\n\tvec3 dx32 = Pfx + jitter * ox32;\n\tvec3 dy32 = Pfy.z + jitter * oy32;\n\tvec3 dz32 = Pfz.y + jitter * oz32;\n\n\tvec3 dx33 = Pfx + jitter * ox33;\n\tvec3 dy33 = Pfy.z + jitter * oy33;\n\tvec3 dz33 = Pfz.z + jitter * oz33;\n\n\tvec3 d11 = dx11 * dx11 + dy11 * dy11 + dz11 * dz11;\n\tvec3 d12 = dx12 * dx12 + dy12 * dy12 + dz12 * dz12;\n\tvec3 d13 = dx13 * dx13 + dy13 * dy13 + dz13 * dz13;\n\tvec3 d21 = dx21 * dx21 + dy21 * dy21 + dz21 * dz21;\n\tvec3 d22 = dx22 * dx22 + dy22 * dy22 + dz22 * dz22;\n\tvec3 d23 = dx23 * dx23 + dy23 * dy23 + dz23 * dz23;\n\tvec3 d31 = dx31 * dx31 + dy31 * dy31 + dz31 * dz31;\n\tvec3 d32 = dx32 * dx32 + dy32 * dy32 + dz32 * dz32;\n\tvec3 d33 = dx33 * dx33 + dy33 * dy33 + dz33 * dz33;\n\n\t// Do it right and sort out both F1 and F2\n\tvec3 d1a = min( d11, d12 );\n\td12 = max( d11, d12 );\n\td11 = min( d1a, d13 ); // Smallest now not in d12 or d13\n\td13 = max( d1a, d13 );\n\td12 = min( d12, d13 ); // 2nd smallest now not in d13\n\tvec3 d2a = min( d21, d22 );\n\td22 = max( d21, d22 );\n\td21 = min( d2a, d23 ); // Smallest now not in d22 or d23\n\td23 = max( d2a, d23 );\n\td22 = min( d22, d23 ); // 2nd smallest now not in d23\n\tvec3 d3a = min( d31, d32 );\n\td32 = max( d31, d32 );\n\td31 = min( d3a, d33 ); // Smallest now not in d32 or d33\n\td33 = max( d3a, d33 );\n\td32 = min( d32, d33 ); // 2nd smallest now not in d33\n\tvec3 da = min( d11, d21 );\n\td21 = max( d11, d21 );\n\td11 = min( da, d31 ); // Smallest now in d11\n\td31 = max( da, d31 ); // 2nd smallest now not in d31\n\td11.xy = ( d11.x < d11.y ) ? d11.xy : d11.yx;\n\td11.xz = ( d11.x < d11.z ) ? d11.xz : d11.zx; // d11.x now smallest\n\td12 = min( d12, d21 ); // 2nd smallest now not in d21\n\td12 = min( d12, d22 ); // nor in d22\n\td12 = min( d12, d31 ); // nor in d31\n\td12 = min( d12, d32 ); // nor in d32\n\td11.yz = min( d11.yz, d12.xy ); // nor in d12.yz\n\td11.y = min( d11.y, d12.z ); // Only two more to go\n\td11.y = min( d11.y, d11.z ); // Done! (Phew! )\n\treturn sqrt( d11.xy ); // F1, F2\n\n}\n";

var noise_cellular2 = "#include <noise_cellular_2D>\n#include <noise_cellular_3D>\n#include <noise_cellular_2x2>\n#include <noise_cellular_2x2x2>\n";

var noise_perlin_2D2 = "//\n// GLSL textureless classic 2D noise \"cnoise\",\n// with an RSL-style periodic variant \"pnoise\".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/stegu/webgl-noise\n//\n\n// Classic Perlin noise\nfloat perlin( vec2 P ) {\n\n    vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n    Pi = mod289(Pi); // To avoid truncation effects in permutation\n    vec4 ix = Pi.xzxz;\n    vec4 iy = Pi.yyww;\n    vec4 fx = Pf.xzxz;\n    vec4 fy = Pf.yyww;\n\n    vec4 i = permute(permute(ix) + iy);\n\n    vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n    vec4 gy = abs(gx) - 0.5 ;\n    vec4 tx = floor(gx + 0.5);\n    gx = gx - tx;\n\n    vec2 g00 = vec2(gx.x,gy.x);\n    vec2 g10 = vec2(gx.y,gy.y);\n    vec2 g01 = vec2(gx.z,gy.z);\n    vec2 g11 = vec2(gx.w,gy.w);\n\n    vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n    g00 *= norm.x;\n    g01 *= norm.y;\n    g10 *= norm.z;\n    g11 *= norm.w;\n\n    float n00 = dot(g00, vec2(fx.x, fy.x));\n    float n10 = dot(g10, vec2(fx.y, fy.y));\n    float n01 = dot(g01, vec2(fx.z, fy.z));\n    float n11 = dot(g11, vec2(fx.w, fy.w));\n\n    vec2 fade_xy = fade(Pf.xy);\n    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n    return 2.3 * n_xy;\n\n}\n\n// Classic Perlin noise, periodic variant\nfloat perlin( vec2 P, vec2 rep ) {\n\n    vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n    Pi = mod(Pi, rep.xyxy); // To create noise with explicit period\n    Pi = mod289(Pi);        // To avoid truncation effects in permutation\n    vec4 ix = Pi.xzxz;\n    vec4 iy = Pi.yyww;\n    vec4 fx = Pf.xzxz;\n    vec4 fy = Pf.yyww;\n\n    vec4 i = permute(permute(ix) + iy);\n\n    vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n    vec4 gy = abs(gx) - 0.5 ;\n    vec4 tx = floor(gx + 0.5);\n    gx = gx - tx;\n\n    vec2 g00 = vec2(gx.x,gy.x);\n    vec2 g10 = vec2(gx.y,gy.y);\n    vec2 g01 = vec2(gx.z,gy.z);\n    vec2 g11 = vec2(gx.w,gy.w);\n\n    vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n    g00 *= norm.x;\n    g01 *= norm.y;\n    g10 *= norm.z;\n    g11 *= norm.w;\n\n    float n00 = dot(g00, vec2(fx.x, fy.x));\n    float n10 = dot(g10, vec2(fx.y, fy.y));\n    float n01 = dot(g01, vec2(fx.z, fy.z));\n    float n11 = dot(g11, vec2(fx.w, fy.w));\n\n    vec2 fade_xy = fade(Pf.xy);\n    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n    return 2.3 * n_xy;\n\n}\n";

var noise_perlin_3D2 = "//\n// GLSL textureless classic 3D noise \"cnoise\",\n// with an RSL-style periodic variant \"pnoise\".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/stegu/webgl-noise\n//\n\n// Classic Perlin noise\nfloat perlin( vec3 P ) {\n\n    vec3 Pi0 = floor(P); // Integer part for indexing\n    vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 2.2 * n_xyz;\n\n}\n\n// Classic Perlin noise, periodic variant\nfloat perlin( vec3 P, vec3 rep ) {\n\n    vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n    vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 2.2 * n_xyz;\n\n}\n";

var noise_perlin_4D2 = "//\n// GLSL textureless classic 4D noise \"cnoise\",\n// with an RSL-style periodic variant \"pnoise\".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/stegu/webgl-noise\n//\n\n// Classic Perlin noise\nfloat perlin( vec4 P ) {\n\n    vec4 Pi0 = floor(P); // Integer part for indexing\n    vec4 Pi1 = Pi0 + 1.0; // Integer part + 1\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec4 Pf0 = fract(P); // Fractional part for interpolation\n    vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = vec4(Pi0.zzzz);\n    vec4 iz1 = vec4(Pi1.zzzz);\n    vec4 iw0 = vec4(Pi0.wwww);\n    vec4 iw1 = vec4(Pi1.wwww);\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n    vec4 ixy00 = permute(ixy0 + iw0);\n    vec4 ixy01 = permute(ixy0 + iw1);\n    vec4 ixy10 = permute(ixy1 + iw0);\n    vec4 ixy11 = permute(ixy1 + iw1);\n\n    vec4 gx00 = ixy00 * (1.0 / 7.0);\n    vec4 gy00 = floor(gx00) * (1.0 / 7.0);\n    vec4 gz00 = floor(gy00) * (1.0 / 6.0);\n    gx00 = fract(gx00) - 0.5;\n    gy00 = fract(gy00) - 0.5;\n    gz00 = fract(gz00) - 0.5;\n    vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\n    vec4 sw00 = step(gw00, vec4(0.0));\n    gx00 -= sw00 * (step(0.0, gx00) - 0.5);\n    gy00 -= sw00 * (step(0.0, gy00) - 0.5);\n\n    vec4 gx01 = ixy01 * (1.0 / 7.0);\n    vec4 gy01 = floor(gx01) * (1.0 / 7.0);\n    vec4 gz01 = floor(gy01) * (1.0 / 6.0);\n    gx01 = fract(gx01) - 0.5;\n    gy01 = fract(gy01) - 0.5;\n    gz01 = fract(gz01) - 0.5;\n    vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\n    vec4 sw01 = step(gw01, vec4(0.0));\n    gx01 -= sw01 * (step(0.0, gx01) - 0.5);\n    gy01 -= sw01 * (step(0.0, gy01) - 0.5);\n\n    vec4 gx10 = ixy10 * (1.0 / 7.0);\n    vec4 gy10 = floor(gx10) * (1.0 / 7.0);\n    vec4 gz10 = floor(gy10) * (1.0 / 6.0);\n    gx10 = fract(gx10) - 0.5;\n    gy10 = fract(gy10) - 0.5;\n    gz10 = fract(gz10) - 0.5;\n    vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\n    vec4 sw10 = step(gw10, vec4(0.0));\n    gx10 -= sw10 * (step(0.0, gx10) - 0.5);\n    gy10 -= sw10 * (step(0.0, gy10) - 0.5);\n\n    vec4 gx11 = ixy11 * (1.0 / 7.0);\n    vec4 gy11 = floor(gx11) * (1.0 / 7.0);\n    vec4 gz11 = floor(gy11) * (1.0 / 6.0);\n    gx11 = fract(gx11) - 0.5;\n    gy11 = fract(gy11) - 0.5;\n    gz11 = fract(gz11) - 0.5;\n    vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\n    vec4 sw11 = step(gw11, vec4(0.0));\n    gx11 -= sw11 * (step(0.0, gx11) - 0.5);\n    gy11 -= sw11 * (step(0.0, gy11) - 0.5);\n\n    vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);\n    vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);\n    vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);\n    vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);\n    vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);\n    vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);\n    vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);\n    vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);\n    vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);\n    vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);\n    vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);\n    vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);\n    vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);\n    vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);\n    vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);\n    vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);\n\n    vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\n    g0000 *= norm00.x;\n    g0100 *= norm00.y;\n    g1000 *= norm00.z;\n    g1100 *= norm00.w;\n\n    vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\n    g0001 *= norm01.x;\n    g0101 *= norm01.y;\n    g1001 *= norm01.z;\n    g1101 *= norm01.w;\n\n    vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\n    g0010 *= norm10.x;\n    g0110 *= norm10.y;\n    g1010 *= norm10.z;\n    g1110 *= norm10.w;\n\n    vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\n    g0011 *= norm11.x;\n    g0111 *= norm11.y;\n    g1011 *= norm11.z;\n    g1111 *= norm11.w;\n\n    float n0000 = dot(g0000, Pf0);\n    float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));\n    float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));\n    float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));\n    float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));\n    float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\n    float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));\n    float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));\n    float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));\n    float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));\n    float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\n    float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));\n    float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));\n    float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));\n    float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));\n    float n1111 = dot(g1111, Pf1);\n\n    vec4 fade_xyzw = fade(Pf0);\n    vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\n    vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\n    vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);\n    vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);\n    float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\n    return 2.2 * n_xyzw;\n\n}\n\n// Classic Perlin noise, periodic version\nfloat perlin( vec4 P, vec4 rep ) {\n\n    vec4 Pi0 = mod(floor(P), rep); // Integer part modulo rep\n    vec4 Pi1 = mod(Pi0 + 1.0, rep); // Integer part + 1 mod rep\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec4 Pf0 = fract(P); // Fractional part for interpolation\n    vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = vec4(Pi0.zzzz);\n    vec4 iz1 = vec4(Pi1.zzzz);\n    vec4 iw0 = vec4(Pi0.wwww);\n    vec4 iw1 = vec4(Pi1.wwww);\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n    vec4 ixy00 = permute(ixy0 + iw0);\n    vec4 ixy01 = permute(ixy0 + iw1);\n    vec4 ixy10 = permute(ixy1 + iw0);\n    vec4 ixy11 = permute(ixy1 + iw1);\n\n    vec4 gx00 = ixy00 * (1.0 / 7.0);\n    vec4 gy00 = floor(gx00) * (1.0 / 7.0);\n    vec4 gz00 = floor(gy00) * (1.0 / 6.0);\n    gx00 = fract(gx00) - 0.5;\n    gy00 = fract(gy00) - 0.5;\n    gz00 = fract(gz00) - 0.5;\n    vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\n    vec4 sw00 = step(gw00, vec4(0.0));\n    gx00 -= sw00 * (step(0.0, gx00) - 0.5);\n    gy00 -= sw00 * (step(0.0, gy00) - 0.5);\n\n    vec4 gx01 = ixy01 * (1.0 / 7.0);\n    vec4 gy01 = floor(gx01) * (1.0 / 7.0);\n    vec4 gz01 = floor(gy01) * (1.0 / 6.0);\n    gx01 = fract(gx01) - 0.5;\n    gy01 = fract(gy01) - 0.5;\n    gz01 = fract(gz01) - 0.5;\n    vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\n    vec4 sw01 = step(gw01, vec4(0.0));\n    gx01 -= sw01 * (step(0.0, gx01) - 0.5);\n    gy01 -= sw01 * (step(0.0, gy01) - 0.5);\n\n    vec4 gx10 = ixy10 * (1.0 / 7.0);\n    vec4 gy10 = floor(gx10) * (1.0 / 7.0);\n    vec4 gz10 = floor(gy10) * (1.0 / 6.0);\n    gx10 = fract(gx10) - 0.5;\n    gy10 = fract(gy10) - 0.5;\n    gz10 = fract(gz10) - 0.5;\n    vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\n    vec4 sw10 = step(gw10, vec4(0.0));\n    gx10 -= sw10 * (step(0.0, gx10) - 0.5);\n    gy10 -= sw10 * (step(0.0, gy10) - 0.5);\n\n    vec4 gx11 = ixy11 * (1.0 / 7.0);\n    vec4 gy11 = floor(gx11) * (1.0 / 7.0);\n    vec4 gz11 = floor(gy11) * (1.0 / 6.0);\n    gx11 = fract(gx11) - 0.5;\n    gy11 = fract(gy11) - 0.5;\n    gz11 = fract(gz11) - 0.5;\n    vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\n    vec4 sw11 = step(gw11, vec4(0.0));\n    gx11 -= sw11 * (step(0.0, gx11) - 0.5);\n    gy11 -= sw11 * (step(0.0, gy11) - 0.5);\n\n    vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);\n    vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);\n    vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);\n    vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);\n    vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);\n    vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);\n    vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);\n    vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);\n    vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);\n    vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);\n    vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);\n    vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);\n    vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);\n    vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);\n    vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);\n    vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);\n\n    vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\n    g0000 *= norm00.x;\n    g0100 *= norm00.y;\n    g1000 *= norm00.z;\n    g1100 *= norm00.w;\n\n    vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\n    g0001 *= norm01.x;\n    g0101 *= norm01.y;\n    g1001 *= norm01.z;\n    g1101 *= norm01.w;\n\n    vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\n    g0010 *= norm10.x;\n    g0110 *= norm10.y;\n    g1010 *= norm10.z;\n    g1110 *= norm10.w;\n\n    vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\n    g0011 *= norm11.x;\n    g0111 *= norm11.y;\n    g1011 *= norm11.z;\n    g1111 *= norm11.w;\n\n    float n0000 = dot(g0000, Pf0);\n    float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));\n    float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));\n    float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));\n    float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));\n    float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\n    float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));\n    float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));\n    float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));\n    float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));\n    float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\n    float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));\n    float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));\n    float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));\n    float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));\n    float n1111 = dot(g1111, Pf1);\n\n    vec4 fade_xyzw = fade(Pf0);\n    vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\n    vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\n    vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);\n    vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);\n    float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\n    return 2.2 * n_xyzw;\n\n}\n";

var noise_perlin2 = "#include <noise_perlin_2D>\n#include <noise_perlin_3D>\n#include <noise_perlin_4D>\n";

var noise_psrd_2D2 = "// Periodic (tiling) 2-D simplex noise (hexagonal lattice gradient noise)\n// with rotating gradients and analytic derivatives.\n// Variants also without the derivative (no \"d\" in the name), without\n// the tiling property (no \"p\" in the name) and without the rotating\n// gradients (no \"r\" in the name).\n//\n// This is (yet) another variation on simplex noise. It's similar to the\n// version presented by Ken Perlin, but the grid is axis-aligned and\n// slightly stretched in the y direction to permit rectangular tiling.\n//\n// The noise can be made to tile seamlessly to any integer period in x and\n// any even integer period in y. Odd periods may be specified for y, but\n// then the actual tiling period will be twice that number.\n//\n// The rotating gradients give the appearance of a swirling motion, and can\n// serve a similar purpose for animation as motion along z in 3-D noise.\n// The rotating gradients in conjunction with the analytic derivatives\n// can make \"flow noise\" effects as presented by Perlin and Neyret.\n//\n// vec3 {p}s{r}dnoise(vec2 pos {, vec2 per} {, float rot})\n// \"pos\" is the input (x,y) coordinate\n// \"per\" is the x and y period, where per.x is a positive integer\n//    and per.y is a positive even integer\n// \"rot\" is the angle to rotate the gradients (any float value,\n//    where 0.0 is no rotation and 1.0 is one full turn)\n// The first component of the 3-element return vector is the noise value.\n// The second and third components are the x and y partial derivatives.\n//\n// float {p}s{r}noise(vec2 pos {, vec2 per} {, float rot})\n// \"pos\" is the input (x,y) coordinate\n// \"per\" is the x and y period, where per.x is a positive integer\n//    and per.y is a positive even integer\n// \"rot\" is the angle to rotate the gradients (any float value,\n//    where 0.0 is no rotation and 1.0 is one full turn)\n// The return value is the noise value.\n// Partial derivatives are not computed, making these functions faster.\n//\n// Author: Stefan Gustavson (stefan.gustavson@gmail.com)\n// Version 2016-05-10.\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// idea of using a permutation polynomial.\n//\n// Copyright (c) 2016 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/stegu/webgl-noise\n//\n\n// Hashed 2-D gradients with an extra rotation.\n// (The constant 0.0243902439 is 1/41)\nvec2 rgrad2( vec2 p, float rot ) {\n\n    // For more isotropic gradients, sin/cos can be used instead.\n    float u = permute( permute( p.x ) + p.y ) * 0.0243902439 + rot; // Rotate by shift\n    u = fract( u ) * 6.28318530718; // 2*pi\n    return vec2( cos( u ), sin( u ));\n\n}\n\n//\n// 2-D tiling simplex noise with rotating gradients and analytical derivative.\n// The first component of the 3-element return vector is the noise value,\n// and the second and third components are the x and y partial derivatives.\n//\nvec3 psrdnoise(vec2 pos, vec2 per, float rot) {\n  // Hack: offset y slightly to hide some rare artifacts\n  pos.y += 0.01;\n  // Skew to hexagonal grid\n  vec2 uv = vec2(pos.x + pos.y*0.5, pos.y);\n\n  vec2 i0 = floor(uv);\n  vec2 f0 = fract(uv);\n  // Traversal order\n  vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\n  // Unskewed grid points in (x,y) space\n  vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y);\n  vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y);\n  vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);\n\n  // Integer grid point indices in (u,v) space\n  i1 = i0 + i1;\n  vec2 i2 = i0 + vec2(1.0, 1.0);\n\n  // Vectors in unskewed (x,y) coordinates from\n  // each of the simplex corners to the evaluation point\n  vec2 d0 = pos - p0;\n  vec2 d1 = pos - p1;\n  vec2 d2 = pos - p2;\n\n  // Wrap i0, i1 and i2 to the desired period before gradient hashing:\n  // wrap points in (x,y), map to (u,v)\n  vec3 xw = mod(vec3(p0.x, p1.x, p2.x), per.x);\n  vec3 yw = mod(vec3(p0.y, p1.y, p2.y), per.y);\n  vec3 iuw = xw + 0.5 * yw;\n  vec3 ivw = yw;\n\n  // Create gradients from indices\n  vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), rot);\n  vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), rot);\n  vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), rot);\n\n  // Gradients dot vectors to corresponding corners\n  // (The derivatives of this are simply the gradients)\n  vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2));\n\n  // Radial weights from corners\n  // 0.8 is the square of 2/sqrt(5), the distance from\n  // a grid point to the nearest simplex boundary\n  vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2));\n\n  // Partial derivatives for analytical gradient computation\n  vec3 dtdx = -2.0 * vec3(d0.x, d1.x, d2.x);\n  vec3 dtdy = -2.0 * vec3(d0.y, d1.y, d2.y);\n\n  // Set influence of each surflet to zero outside radius sqrt(0.8)\n  if (t.x < 0.0) {\n    dtdx.x = 0.0;\n    dtdy.x = 0.0;\n\tt.x = 0.0;\n  }\n  if (t.y < 0.0) {\n    dtdx.y = 0.0;\n    dtdy.y = 0.0;\n\tt.y = 0.0;\n  }\n  if (t.z < 0.0) {\n    dtdx.z = 0.0;\n    dtdy.z = 0.0;\n\tt.z = 0.0;\n  }\n\n  // Fourth power of t (and third power for derivative)\n  vec3 t2 = t * t;\n  vec3 t4 = t2 * t2;\n  vec3 t3 = t2 * t;\n\n  // Final noise value is:\n  // sum of ((radial weights) times (gradient dot vector from corner))\n  float n = dot(t4, w);\n\n  // Final analytical derivative (gradient of a sum of scalar products)\n  vec2 dt0 = vec2(dtdx.x, dtdy.x) * 4.0 * t3.x;\n  vec2 dn0 = t4.x * g0 + dt0 * w.x;\n  vec2 dt1 = vec2(dtdx.y, dtdy.y) * 4.0 * t3.y;\n  vec2 dn1 = t4.y * g1 + dt1 * w.y;\n  vec2 dt2 = vec2(dtdx.z, dtdy.z) * 4.0 * t3.z;\n  vec2 dn2 = t4.z * g2 + dt2 * w.z;\n\n  return 11.0*vec3(n, dn0 + dn1 + dn2);\n}\n\n//\n// 2-D tiling simplex noise with fixed gradients\n// and analytical derivative.\n// This function is implemented as a wrapper to \"psrdnoise\",\n// at the minimal cost of three extra additions.\n//\nvec3 psdnoise(vec2 pos, vec2 per) {\n  return psrdnoise(pos, per, 0.0);\n}\n\n//\n// 2-D tiling simplex noise with rotating gradients,\n// but without the analytical derivative.\n//\nfloat psrnoise(vec2 pos, vec2 per, float rot) {\n  // Offset y slightly to hide some rare artifacts\n  pos.y += 0.001;\n  // Skew to hexagonal grid\n  vec2 uv = vec2(pos.x + pos.y*0.5, pos.y);\n\n  vec2 i0 = floor(uv);\n  vec2 f0 = fract(uv);\n  // Traversal order\n  vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\n  // Unskewed grid points in (x,y) space\n  vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y);\n  vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y);\n  vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);\n\n  // Integer grid point indices in (u,v) space\n  i1 = i0 + i1;\n  vec2 i2 = i0 + vec2(1.0, 1.0);\n\n  // Vectors in unskewed (x,y) coordinates from\n  // each of the simplex corners to the evaluation point\n  vec2 d0 = pos - p0;\n  vec2 d1 = pos - p1;\n  vec2 d2 = pos - p2;\n\n  // Wrap i0, i1 and i2 to the desired period before gradient hashing:\n  // wrap points in (x,y), map to (u,v)\n  vec3 xw = mod(vec3(p0.x, p1.x, p2.x), per.x);\n  vec3 yw = mod(vec3(p0.y, p1.y, p2.y), per.y);\n  vec3 iuw = xw + 0.5 * yw;\n  vec3 ivw = yw;\n\n  // Create gradients from indices\n  vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), rot);\n  vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), rot);\n  vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), rot);\n\n  // Gradients dot vectors to corresponding corners\n  // (The derivatives of this are simply the gradients)\n  vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2));\n\n  // Radial weights from corners\n  // 0.8 is the square of 2/sqrt(5), the distance from\n  // a grid point to the nearest simplex boundary\n  vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2));\n\n  // Set influence of each surflet to zero outside radius sqrt(0.8)\n  t = max(t, 0.0);\n\n  // Fourth power of t\n  vec3 t2 = t * t;\n  vec3 t4 = t2 * t2;\n\n  // Final noise value is:\n  // sum of ((radial weights) times (gradient dot vector from corner))\n  float n = dot(t4, w);\n\n  // Rescale to cover the range [-1,1] reasonably well\n  return 11.0*n;\n}\n\n//\n// 2-D tiling simplex noise with fixed gradients,\n// without the analytical derivative.\n// This function is implemented as a wrapper to \"psrnoise\",\n// at the minimal cost of three extra additions.\n//\nfloat psnoise(vec2 pos, vec2 per) {\n  return psrnoise(pos, per, 0.0);\n}\n\n//\n// 2-D non-tiling simplex noise with rotating gradients and analytical derivative.\n// The first component of the 3-element return vector is the noise value,\n// and the second and third components are the x and y partial derivatives.\n//\nvec3 srdnoise(vec2 pos, float rot) {\n  // Offset y slightly to hide some rare artifacts\n  pos.y += 0.001;\n  // Skew to hexagonal grid\n  vec2 uv = vec2(pos.x + pos.y*0.5, pos.y);\n\n  vec2 i0 = floor(uv);\n  vec2 f0 = fract(uv);\n  // Traversal order\n  vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\n  // Unskewed grid points in (x,y) space\n  vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y);\n  vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y);\n  vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);\n\n  // Integer grid point indices in (u,v) space\n  i1 = i0 + i1;\n  vec2 i2 = i0 + vec2(1.0, 1.0);\n\n  // Vectors in unskewed (x,y) coordinates from\n  // each of the simplex corners to the evaluation point\n  vec2 d0 = pos - p0;\n  vec2 d1 = pos - p1;\n  vec2 d2 = pos - p2;\n\n  vec3 x = vec3(p0.x, p1.x, p2.x);\n  vec3 y = vec3(p0.y, p1.y, p2.y);\n  vec3 iuw = x + 0.5 * y;\n  vec3 ivw = y;\n\n  // Avoid precision issues in permutation\n  iuw = mod289(iuw);\n  ivw = mod289(ivw);\n\n  // Create gradients from indices\n  vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), rot);\n  vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), rot);\n  vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), rot);\n\n  // Gradients dot vectors to corresponding corners\n  // (The derivatives of this are simply the gradients)\n  vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2));\n\n  // Radial weights from corners\n  // 0.8 is the square of 2/sqrt(5), the distance from\n  // a grid point to the nearest simplex boundary\n  vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2));\n\n  // Partial derivatives for analytical gradient computation\n  vec3 dtdx = -2.0 * vec3(d0.x, d1.x, d2.x);\n  vec3 dtdy = -2.0 * vec3(d0.y, d1.y, d2.y);\n\n  // Set influence of each surflet to zero outside radius sqrt(0.8)\n  if (t.x < 0.0) {\n    dtdx.x = 0.0;\n    dtdy.x = 0.0;\n\tt.x = 0.0;\n  }\n  if (t.y < 0.0) {\n    dtdx.y = 0.0;\n    dtdy.y = 0.0;\n\tt.y = 0.0;\n  }\n  if (t.z < 0.0) {\n    dtdx.z = 0.0;\n    dtdy.z = 0.0;\n\tt.z = 0.0;\n  }\n\n  // Fourth power of t (and third power for derivative)\n  vec3 t2 = t * t;\n  vec3 t4 = t2 * t2;\n  vec3 t3 = t2 * t;\n\n  // Final noise value is:\n  // sum of ((radial weights) times (gradient dot vector from corner))\n  float n = dot(t4, w);\n\n  // Final analytical derivative (gradient of a sum of scalar products)\n  vec2 dt0 = vec2(dtdx.x, dtdy.x) * 4.0 * t3.x;\n  vec2 dn0 = t4.x * g0 + dt0 * w.x;\n  vec2 dt1 = vec2(dtdx.y, dtdy.y) * 4.0 * t3.y;\n  vec2 dn1 = t4.y * g1 + dt1 * w.y;\n  vec2 dt2 = vec2(dtdx.z, dtdy.z) * 4.0 * t3.z;\n  vec2 dn2 = t4.z * g2 + dt2 * w.z;\n\n  return 11.0*vec3(n, dn0 + dn1 + dn2);\n}\n\n//\n// 2-D non-tiling simplex noise with fixed gradients and analytical derivative.\n// This function is implemented as a wrapper to \"srdnoise\",\n// at the minimal cost of three extra additions.\n//\nvec3 sdnoise(vec2 pos) {\n  return srdnoise(pos, 0.0);\n}\n\n//\n// 2-D non-tiling simplex noise with rotating gradients,\n// without the analytical derivative.\n//\nfloat srnoise(vec2 pos, float rot) {\n  // Offset y slightly to hide some rare artifacts\n  pos.y += 0.001;\n  // Skew to hexagonal grid\n  vec2 uv = vec2(pos.x + pos.y*0.5, pos.y);\n\n  vec2 i0 = floor(uv);\n  vec2 f0 = fract(uv);\n  // Traversal order\n  vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\n  // Unskewed grid points in (x,y) space\n  vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y);\n  vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y);\n  vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);\n\n  // Integer grid point indices in (u,v) space\n  i1 = i0 + i1;\n  vec2 i2 = i0 + vec2(1.0, 1.0);\n\n  // Vectors in unskewed (x,y) coordinates from\n  // each of the simplex corners to the evaluation point\n  vec2 d0 = pos - p0;\n  vec2 d1 = pos - p1;\n  vec2 d2 = pos - p2;\n\n  // Wrap i0, i1 and i2 to the desired period before gradient hashing:\n  // wrap points in (x,y), map to (u,v)\n  vec3 x = vec3(p0.x, p1.x, p2.x);\n  vec3 y = vec3(p0.y, p1.y, p2.y);\n  vec3 iuw = x + 0.5 * y;\n  vec3 ivw = y;\n\n  // Avoid precision issues in permutation\n  iuw = mod289(iuw);\n  ivw = mod289(ivw);\n\n  // Create gradients from indices\n  vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), rot);\n  vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), rot);\n  vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), rot);\n\n  // Gradients dot vectors to corresponding corners\n  // (The derivatives of this are simply the gradients)\n  vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2));\n\n  // Radial weights from corners\n  // 0.8 is the square of 2/sqrt(5), the distance from\n  // a grid point to the nearest simplex boundary\n  vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2));\n\n  // Set influence of each surflet to zero outside radius sqrt(0.8)\n  t = max(t, 0.0);\n\n  // Fourth power of t\n  vec3 t2 = t * t;\n  vec3 t4 = t2 * t2;\n\n  // Final noise value is:\n  // sum of ((radial weights) times (gradient dot vector from corner))\n  float n = dot(t4, w);\n\n  // Rescale to cover the range [-1,1] reasonably well\n  return 11.0*n;\n}\n\n//\n// 2-D non-tiling simplex noise with fixed gradients,\n// without the analytical derivative.\n// This function is implemented as a wrapper to \"srnoise\",\n// at the minimal cost of three extra additions.\n// Note: if this kind of noise is all you want, there are faster\n// GLSL implementations of non-tiling simplex noise out there.\n// This one is included mainly for completeness and compatibility\n// with the other functions in the file.\n//\nfloat snoise(vec2 pos) {\n  return srnoise(pos, 0.0);\n}\n";

var noise_simplex_2D2 = "//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n//\n\nfloat simplex( vec2 v ) {\n\n    const vec4 C = vec4( 0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439 ); // 1.0 / 41.0\n    // First corner\n    vec2 i  = floor( v + dot( v, C.yy ) );\n    vec2 x0 = v - i + dot( i, C.xx );\n\n    // Other corners\n    vec2 i1;\n    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n    //i1.y = 1.0 - i1.x;\n    i1 = ( x0.x > x0.y ) ? vec2( 1.0, 0.0 ) : vec2( 0.0, 1.0 );\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\n    // x1 = x0 - i1 + 1.0 * C.xx ;\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod289( i ); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3( 0.0, i1.y, 1.0 ) )\n        + i.x + vec3( 0.0, i1.x, 1.0 ) );\n\n    vec3 m = max( 0.5 - vec3( dot( x0, x0 ), dot( x12.xy, x12.xy ), dot( x12.zw, x12.zw ) ), 0.0 );\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract( p * C.www ) - 1.0;\n    vec3 h = abs( x ) - 0.5;\n    vec3 ox = floor( x + 0.5 );\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0 * a0 + h * h );\n\n    // Compute final noise value at P\n    vec3 g;\n    g.x  = a0.x * x0.x + h.x * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot( m, g );\n\n}\n";

var noise_simplex_3D_grad2 = "//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20150104 (JcBernack)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n//\n\nfloat simplex( vec3 v, out vec3 gradient ) {\n\n    const vec2  C = vec2( 1.0 / 6.0, 1.0 / 3.0 );\n    const vec4  D = vec4( 0.0, 0.5, 1.0, 2.0 );\n\n    // First corner\n    vec3 i  = floor( v + dot( v, C.yyy ) );\n    vec3 x0 = v - i + dot( i, C.xxx ) ;\n\n    // Other corners\n    vec3 g = step( x0.yzx, x0.xyz );\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n    // Permutations\n    i = mod289( i );\n    vec4 p = permute( permute( permute(\n                i.z + vec4( 0.0, i1.z, i2.z, 1.0 ) )\n            + i.y + vec4( 0.0, i1.y, i2.y, 1.0 ) )\n            + i.x + vec4( 0.0, i1.x, i2.x, 1.0 ) );\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3 ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ * ns.x + ns.yyyy;\n    vec4 y = y_ * ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs( x ) - abs( y );\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    vec4 s0 = floor( b0 ) * 2.0 + 1.0;\n    vec4 s1 = floor( b1 ) * 2.0 + 1.0;\n    vec4 sh = - step( h, vec4( 0.0 ) );\n\n    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww ;\n\n    vec3 p0 = vec3( a0.xy, h.x );\n    vec3 p1 = vec3( a0.zw, h.y );\n    vec3 p2 = vec3( a1.xy, h.z );\n    vec3 p3 = vec3( a1.zw, h.w );\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt( vec4( dot( p0, p0 ), dot( p1, p1 ), dot( p2, p2 ), dot( p3, p3 ) ) );\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max( 0.6 - vec4( dot( x0, x0 ), dot( x1, x1 ), dot( x2, x2 ), dot( x3, x3 ) ), 0.0 );\n    vec4 m2 = m * m;\n    vec4 m4 = m2 * m2;\n    vec4 pdotx = vec4( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 ), dot( p3, x3 ) );\n\n    // Determine noise gradient\n    vec4 temp = m2 * m * pdotx;\n    gradient = - 8.0 * ( temp.x * x0 + temp.y * x1 + temp.z * x2 + temp.w * x3 );\n    gradient += m4.x * p0 + m4.y * p1 + m4.z * p2 + m4.w * p3;\n    gradient *= 42.0;\n\n    return 42.0 * dot( m4, pdotx );\n\n}\n";

var noise_simplex_3D2 = "//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n//\n\nfloat simplex( vec3 v ) {\n\n    const vec2 C = vec2( 1.0 / 6.0, 1.0 / 3.0 );\n    const vec4 D = vec4( 0.0, 0.5, 1.0, 2.0 );\n\n    // First corner\n    vec3 i  = floor( v + dot( v, C.yyy ) );\n    vec3 x0 = v - i + dot( i, C.xxx );\n\n    // Other corners\n    vec3 g = step( x0.yzx, x0.xyz );\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n    // Permutations\n    i = mod289( i );\n    vec4 p = permute( permute( permute(\n                i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n            + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n            + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3 ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor( p * ns.z * ns.z );  //  mod(p,7*7)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs( x ) - abs( y );\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    vec4 s0 = floor( b0 ) * 2.0 + 1.0;\n    vec4 s1 = floor( b1 ) * 2.0 + 1.0;\n    vec4 sh = - step( h, vec4( 0.0 ) );\n\n    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww ;\n\n    vec3 p0 = vec3( a0.xy, h.x );\n    vec3 p1 = vec3( a0.zw, h.y );\n    vec3 p2 = vec3( a1.xy, h.z );\n    vec3 p3 = vec3( a1.zw, h.w );\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt( vec4( dot( p0, p0 ), dot( p1, p1 ), dot( p2, p2 ), dot( p3, p3 ) ) );\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max( 0.6 - vec4( dot( x0, x0 ), dot( x1, x1 ), dot( x2, x2 ), dot( x3, x3 ) ), 0.0 );\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot( p0, x0 ), dot( p1, x1 ),\n                                dot( p2, x2 ), dot( p3, x3 ) ) );\n\n}\n";

var noise_simplex_4D2 = "//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n//\n\nvec4 grad4( float j, vec4 ip ) {\n\n    const vec4 ones = vec4( 1.0, 1.0, 1.0, -1.0 );\n    vec4 p, s;\n\n    p.xyz = floor( fract( vec3( j ) * ip.xyz ) * 7.0 ) * ip.z - 1.0;\n    p.w = 1.5 - dot( abs( p.xyz ), ones.xyz );\n    s = vec4( lessThan( p, vec4( 0.0 ) ) );\n    p.xyz = p.xyz + ( s.xyz * 2.0 - 1.0 ) * s.www;\n\n    return p;\n\n}\n\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\n\nfloat simplex(vec4 v) {\n\n    const vec4 C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                        -0.447213595499958); // -1 + 4 * G4\n\n    // First corner\n    vec4 i  = floor( v + dot( v, vec4( F4 ) ) );\n    vec4 x0 = v - i + dot( i, C.xxxx );\n\n    // Other corners\n\n    // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n    vec4 i0;\n    vec3 isX = step( x0.yzw, x0.xxx );\n    vec3 isYZ = step( x0.zww, x0.yyz );\n    i0.x = isX.x + isX.y + isX.z;\n    i0.yzw = 1.0 - isX;\n    i0.y += isYZ.x + isYZ.y;\n    i0.zw += 1.0 - isYZ.xy;\n    i0.z += isYZ.z;\n    i0.w += 1.0 - isYZ.z;\n\n    vec4 i3 = clamp( i0, 0.0, 1.0 );\n    vec4 i2 = clamp( i0 - 1.0, 0.0, 1.0 );\n    vec4 i1 = clamp( i0 - 2.0, 0.0, 1.0 );\n\n    vec4 x1 = x0 - i1 + C.xxxx;\n    vec4 x2 = x0 - i2 + C.yyyy;\n    vec4 x3 = x0 - i3 + C.zzzz;\n    vec4 x4 = x0 + C.wwww;\n\n    // Permutations\n    i = mod289( i );\n    float j0 = permute( permute( permute( permute( i.w ) + i.z ) + i.y ) + i.x );\n    vec4 j1 = permute( permute( permute( permute (\n                i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n            + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n            + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n            + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n    // Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n    // 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n    vec4 ip = vec4( 1.0 / 294.0, 1.0 / 49.0, 1.0 / 7.0, 0.0 );\n\n    vec4 p0 = grad4(j0,   ip);\n    vec4 p1 = grad4(j1.x, ip);\n    vec4 p2 = grad4(j1.y, ip);\n    vec4 p3 = grad4(j1.z, ip);\n    vec4 p4 = grad4(j1.w, ip);\n\n    // Normalise gradients\n    vec4 norm = taylorInvSqrt( vec4( dot( p0, p0 ), dot( p1, p1 ), dot( p2, p2 ), dot( p3, p3 ) ) );\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    p4 *= taylorInvSqrt( dot( p4, p4 ) );\n\n    // Mix contributions from the five corners\n    vec3 m0 = max( 0.6 - vec3( dot( x0, x0 ), dot( x1, x1 ), dot( x2, x2 ) ), 0.0 );\n    vec2 m1 = max( 0.6 - vec2( dot( x3, x3 ), dot( x4, x4 ) ), 0.0 );\n    m0 = m0 * m0;\n    m1 = m1 * m1;\n    return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n                + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n}\n";

var noise_simplex2 = "#include <noise_simplex_2D>\n#include <noise_simplex_3D>\n#include <noise_simplex_3D_grad>\n#include <noise_simplex_4D>\n";

var perturbation_share2 = "#ifdef HAS_PERTURBATIONMAP\n  uniform sampler2D u_perturbationSampler;\n  uniform float u_perturbationUOffset;\n  uniform float u_perturbationVOffset;\n#endif\n";

var perturbation_frag2 = "#ifdef HAS_PERTURBATIONMAP\n  vec2 getScreenUv(){\n    return gl_FragCoord.xy / u_resolution;\n  }\n\n  vec4 screenColor = texture2D(u_perturbationSampler, getScreenUv() + normalize(u_viewMat * vec4(normal, 1.)).xy * vec2(u_perturbationUOffset, u_perturbationVOffset));\n  gl_FragColor = mix(screenColor, gl_FragColor, gl_FragColor.a);\n\n#endif\n";

var refraction_share2 = "#ifdef HAS_REFRACTIONMAP\n\n    uniform sampler2D u_refractionSampler;\n    uniform mat4 u_PTMMatrix;\n    uniform float u_refractionDepth;\n\n#endif\n";

var refraction_frag2 = "#ifdef HAS_REFRACTIONMAP\n  vec4 refractionColor = vec4(0.);\n  vec3 refractDir = normalize(refract(-geometry.viewDir, geometry.normal, u_refractionRatio));\n  vec3 newPos = v_pos + refractDir * u_refractionDepth;\n  vec4 projectionPos = u_PTMMatrix * u_projMat * u_viewMat * vec4(newPos, 1.0);\n  vec2 projectionUv = projectionPos.xy / projectionPos.w;\n  refractionColor = texture2D(u_refractionSampler, projectionUv);\n  gl_FragColor = mix(refractionColor, gl_FragColor, gl_FragColor.a);\n\n#endif\n";

var clipPlane_vert_define2 = "#ifdef O3_CLIPPLANE_NUM\n    uniform vec4 u_clipPlanes[O3_CLIPPLANE_NUM];\n    varying float v_clipDistances[O3_CLIPPLANE_NUM];\n#endif\n";

var clipPlane_vert2 = "#ifdef O3_CLIPPLANE_NUM\n    for(int i = 0; i < O3_CLIPPLANE_NUM; i++){\n        v_clipDistances[i] = dot(vec4(v_pos,1.0), u_clipPlanes[i]);\n    }\n#endif\n";

var clipPlane_frag_define2 = "#ifdef O3_CLIPPLANE_NUM\n    varying float v_clipDistances[O3_CLIPPLANE_NUM];\n#endif\n";

var clipPlane_frag2 = "#ifdef O3_CLIPPLANE_NUM\n    for(int i = 0; i < O3_CLIPPLANE_NUM; i++){\n        if(v_clipDistances[i] < 0.0){\n            discard;\n        }\n    }\n#endif\n";

var gamma_frag2 = "#ifdef GAMMA\n    float gamma = 2.2;\n    gl_FragColor.rgb = pow(gl_FragColor.rgb, vec3(1.0 / gamma));\n#endif\n";

var pbr_common_frag_define = "#ifndef EPSILON\n#define EPSILON 1e-6\n#endif\n\n#ifndef RECIPROCAL_PI\n    #define RECIPROCAL_PI 0.31830988618\n#endif\n\n\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\n\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n";

var pbr_util_frag_define = "vec4 SRGBtoLINEAR(vec4 srgbIn)\n{\n    #ifdef MANUAL_SRGB\n\n        #ifdef SRGB_FAST_APPROXIMATION\n\n            vec3 linOut = pow(srgbIn.xyz, vec3(2.2));\n        #else\n\n         vec3 bLess = step(vec3(0.04045), srgbIn.xyz);\n         vec3 linOut = mix(srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055), vec3(2.4)), bLess);\n\n        #endif\n\n    return vec4(linOut, srgbIn.w);;\n\n    #else\n\n    return srgbIn;\n\n    #endif\n}\n\nfloat pow2( const in float x ) {\n    return x * x;\n}\n\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n    return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\n\n// todo: enhance\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\n    if( decayExponent > 0.0 ) {\n\n        #if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\n        // based upon Frostbite 3 Moving to Physically-based Rendering\n        // page 32, equation 26: E[window1]\n        // https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n        // this is intended to be used on spot and point lights who are represented as luminous intensity\n        // but who must be converted to luminous irradiance for surface lighting calculation\n        float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n        float maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n        return distanceFalloff * maxDistanceCutoffFactor;\n\n        #else\n\n        return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\n        #endif\n\n    }\n\n    return 1.0;\n\n}\n\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\n\treturn RECIPROCAL_PI * diffuseColor;\n\n}\n\n// source: http://simonstechblog.blogspot.ca/2011/12/microfacet-brdf.html\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n    return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\n\n\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\n    return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n\n}\n\n// \nfloat getLuminance(vec3 color)\n{\n    return dot(color, vec3(0.2126, 0.7152, 0.0722));\n}\n";

var pbr_envmap_light_frag_define = "#ifdef O3_HAS_ENVMAP_LIGHT\n\nstruct EnvMapLight {\n    vec3 diffuse;\n    vec3 specular;\n    float mipMapLevel;\n    float diffuseIntensity;\n    float specularIntensity;\n    mat3 transformMatrix;\n};\n\n\nuniform EnvMapLight u_envMapLight;\n\n#ifdef O3_USE_DIFFUSE_ENV\n    uniform samplerCube u_env_diffuseSampler;\n#endif\n\n#ifdef O3_USE_SPECULAR_ENV\n    uniform samplerCube u_env_specularSampler;\n#endif\n\n#endif\n";

var pbr_base_frag_define = "#ifdef ALPHA_MASK\nuniform float u_alphaCutoff;\n#endif\n\nuniform vec4 u_baseColorFactor;\nuniform vec2 u_metallicRoughnessValue;\nuniform vec3 u_specularFactor;\nuniform float u_glossinessFactor;\n\nuniform float u_envMapIntensity;\nuniform float u_refractionRatio;\n\nuniform vec2 u_resolution;\n\n// todo: delete\nuniform float u_normalScale;\nuniform float u_occlusionStrength;\n\n";

var pbr_texture_frag_define = "#ifdef HAS_BASECOLORMAP\n\nuniform sampler2D u_baseColorSampler;\n\n#endif\n\n#ifdef O3_HAS_NORMALMAP\n\nuniform sampler2D u_normalSampler;\n\n#endif\n\n#ifdef HAS_EMISSIVEMAP\n\nuniform sampler2D u_emissiveSampler;\nuniform vec3 u_emissiveFactor;\n\n#endif\n\n#ifdef HAS_METALMAP\n\nuniform sampler2D u_metallicSampler;\n\n#endif\n\n#ifdef HAS_ROUGHNESSMAP\n\nuniform sampler2D u_roughnessSampler;\n\n#endif\n\n#ifdef HAS_METALROUGHNESSMAP\n\nuniform sampler2D u_metallicRoughnessSampler;\n\n#endif\n\n\n#ifdef HAS_SPECULARGLOSSINESSMAP\n\nuniform sampler2D u_specularGlossinessSampler;\n\n#endif\n\n#ifdef HAS_OCCLUSIONMAP\n\nuniform sampler2D u_occlusionSampler;\n\n#endif\n\n#ifdef HAS_OPACITYMAP\n\nuniform sampler2D u_opacitySampler;\n\n#endif\n\n#ifdef HAS_REFLECTIONMAP\n\nuniform samplerCube u_reflectionSampler;\n\n#endif\n";

var pbr_runtime_frag_define = "struct IncidentLight {\n    vec3 color;\n    vec3 direction;\n    bool visible;\n};\nstruct ReflectedLight {\n    vec3 directDiffuse;\n    vec3 directSpecular;\n    vec3 indirectDiffuse;\n    vec3 indirectSpecular;\n};\nstruct GeometricContext {\n    vec3 position;\n    vec3 normal;\n    vec3 viewDir;\n};\nstruct PhysicalMaterial {\n    vec3    diffuseColor;\n    float   specularRoughness;\n    vec3    specularColor;\n};\n";

var pbr_normal_frag_define = "vec3 getNormal()\n{\n  #ifdef O3_HAS_NORMALMAP\n    #ifndef O3_HAS_TANGENT\n        #ifdef HAS_DERIVATIVES\n            vec3 pos_dx = dFdx(v_pos);\n            vec3 pos_dy = dFdy(v_pos);\n            vec3 tex_dx = dFdx(vec3(v_uv, 0.0));\n            vec3 tex_dy = dFdy(vec3(v_uv, 0.0));\n            vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n            #ifdef O3_HAS_NORMAL\n                vec3 ng = normalize(v_normal);\n            #else\n                vec3 ng = normalize( cross(pos_dx, pos_dy) );\n            #endif\n            t = normalize(t - ng * dot(ng, t));\n            vec3 b = normalize(cross(ng, t));\n            mat3 tbn = mat3(t, b, ng);\n        #else\n            #ifdef O3_HAS_NORMAL\n                vec3 ng = normalize(v_normal);\n            #else\n                vec3 ng = vec3(0.0, 0.0, 1.0);\n            #endif\n            mat3 tbn = mat3(vec3(0.0), vec3(0.0), ng);\n        #endif\n    #else\n        mat3 tbn = v_TBN;\n    #endif\n        vec3 n = texture2D(u_normalSampler, v_uv ).rgb;\n        n = normalize(tbn * ((2.0 * n - 1.0) * vec3(u_normalScale, u_normalScale, 1.0)));\n  #else\n    #ifdef O3_HAS_NORMAL\n        vec3 n = normalize(v_normal);\n    #elif defined(HAS_DERIVATIVES)\n        vec3 pos_dx = dFdx(v_pos);\n        vec3 pos_dy = dFdy(v_pos);\n        vec3 n = normalize( cross(pos_dx, pos_dy) );\n    #else\n        vec3 n= vec3(0.0,0.0,1.0);\n    #endif\n  #endif\n\n  n *= float( gl_FrontFacing ) * 2.0 - 1.0;\n\n  return n;\n}\n";

var pbr_brdf_cook_torrance_frag_define = "vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\n\t// Original approximation by Christophe Schlick '94\n\t// float fresnel = pow( 1.0 - dotLH, 5.0 );\n\n\t// Optimized variant (presented by Epic at SIGGRAPH '13)\n\t// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n\n} // validated\n\n// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\n// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\n\tfloat a2 = pow2( alpha );\n\n\t// dotNL and dotNV are explicitly swapped. This is not a mistake.\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\n\treturn 0.5 / max( gv + gl, EPSILON );\n\n}\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is \"roughness squared\" in Disneys reparameterization\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\n\tfloat a2 = pow2( alpha );\n\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1\n\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n\n}\n\n// GGX Distribution, Schlick Fresnel, GGX-Smith Visibility\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\n\tfloat alpha = pow2( roughness ); // UE4's roughness\n\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\n\tfloat D = D_GGX( alpha, dotNH );\n\n\treturn F * ( G * D );\n\n} // validated\n";

var pbr_direct_irradiance_frag_define = "void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n    float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\n    vec3 irradiance = dotNL * directLight.color;\n\n    #ifndef PHYSICALLY_CORRECT_LIGHTS\n\n        irradiance *= PI; // punctual light\n\n    #endif\n\n\n\n    reflectedLight.directSpecular += irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\n    reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n}\n\n\n\n#ifdef O3_DIRECT_LIGHT_COUNT\n\n    void getDirectionalDirectLightIrradiance( const in DirectLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n        directLight.color = directionalLight.lightColor;\n        directLight.direction = -directionalLight.direction;\n        directLight.visible = true;\n    }\n\n#endif\n\n#ifdef O3_POINT_LIGHT_COUNT\n\n\t// directLight is an out parameter as having it as a return value caused compiler errors on some devices\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\n\t\tfloat lightDistance = length( lVector );\n\n\t\tdirectLight.color = pointLight.lightColor;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\n\t}\n\n#endif\n\n#ifdef O3_SPOT_LIGHT_COUNT\n\n\t// directLight is an out parameter as having it as a return value caused compiler errors on some devices\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\n\t\tif ( angleCos > spotLight.coneCos ) {\n\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\n\t\t\tdirectLight.color = spotLight.lightColor;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\n\t\t} else {\n\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\n\t\t}\n\t}\n\n\n#endif\n";

var pbr_ibl_specular_frag_define = "// ref: https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\n    float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\n    const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\n    const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\n    vec4 r = roughness * c0 + c1;\n\n    float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\n    vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\n    return specularColor * AB.x + AB.y;\n\n} // validated\n\n\n// taken from here: http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html\nfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\n    //float envMapWidth = pow( 2.0, maxMIPLevelScalar );\n    //float desiredMIPLevel = log2( envMapWidth * sqrt( 3.0 ) ) - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\n    float maxMIPLevelScalar = float( maxMIPLevel );\n    float desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\n    // clamp to allowable LOD ranges.\n    return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\n}\n\n#ifdef O3_HAS_ENVMAP_LIGHT\n\nvec3 getLightProbeIndirectRadiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\n    #if !defined(O3_USE_SPECULAR_ENV) && !defined(HAS_REFLECTIONMAP)\n\n        return u_envMapLight.specular * u_envMapLight.specularIntensity * u_envMapIntensity;\n\n    #else\n\n    #ifdef ENVMAPMODE_REFRACT\n\n        vec3 reflectVec = refract( -geometry.viewDir, geometry.normal, u_refractionRatio );\n\n    #else\n\n        vec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\n    #endif\n//        reflectVec = inverseTransformDirection( reflectVec, u_viewMat );\n\n        reflectVec =  u_envMapLight.transformMatrix * reflectVec;\n\n        float specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\n        #ifdef HAS_TEX_LOD\n            #ifdef HAS_REFLECTIONMAP\n                 vec4 envMapColor = textureCubeLodEXT( u_reflectionSampler, reflectVec, specularMIPLevel );\n            #else\n                vec4 envMapColor = textureCubeLodEXT( u_env_specularSampler, reflectVec, specularMIPLevel );\n            #endif\n\n        #else\n            #ifdef HAS_REFLECTIONMAP\n                 vec4 envMapColor = textureCube( u_reflectionSampler, reflectVec, specularMIPLevel );\n            #else\n                 vec4 envMapColor = textureCube( u_env_specularSampler, reflectVec, specularMIPLevel );\n            #endif\n        #endif\n\n        envMapColor.rgb = SRGBtoLINEAR( envMapColor * u_envMapLight.specularIntensity * u_envMapIntensity).rgb;\n\n        return envMapColor.rgb;\n\n    #endif\n\n}\n#endif\n\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n    float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n    float dotNL = dotNV;\n\n\treflectedLight.indirectSpecular += radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\n}\n";

var pbr_ibl_diffuse_frag_define = "void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n    reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n}\n\n#ifdef O3_HAS_AMBIENT_LIGHT\n\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\n    vec3 irradiance = ambientLightColor;\n\n    #ifndef PHYSICALLY_CORRECT_LIGHTS\n\n        irradiance *= PI;\n\n    #endif\n\n    return irradiance;\n\n}\n\n#endif\n";

var pbr_begin_frag = "    vec3 normal = getNormal();\n    vec4 diffuseColor = u_baseColorFactor;\n    vec3 totalEmissiveRadiance = vec3(0.0);\n    float metalnessFactor = u_metallicRoughnessValue.r;\n    float roughnessFactor = u_metallicRoughnessValue.g;\n    vec3 specularFactor = u_specularFactor;\n    float glossinessFactor = u_glossinessFactor;\n\n    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n    PhysicalMaterial material;\n    GeometricContext geometry;\n    IncidentLight directLight;\n\n    #ifdef HAS_BASECOLORMAP\n\n        vec4 baseMapColor = texture2D( u_baseColorSampler, v_uv );\n        baseMapColor = SRGBtoLINEAR( baseMapColor );\n        diffuseColor *= baseMapColor;\n\n    #endif\n\n    #ifdef O3_HAS_VERTEXCOLOR\n\n        diffuseColor.rgb *= v_color.rgb;\n\n        #ifdef O3_HAS_VERTEXALPHA\n\n            diffuseColor.a *= v_color.a;\n\n        #endif\n\n    #endif\n\n    #ifdef ALPHA_MASK\n\n        if( diffuseColor.a < u_alphaCutoff ) {\n            discard;\n        }\n\n    #endif\n\n\n    #if defined(ALPHA_BLEND) && defined(HAS_OPACITYMAP)\n\n        #ifdef GETOPACITYFROMRGB\n            diffuseColor.a *= getLuminance(texture2D( u_opacitySampler, v_uv ).rgb);\n        #else\n            diffuseColor.a *= texture2D( u_opacitySampler, v_uv ).a;\n        #endif\n\n    #endif\n\n    #ifdef UNLIT\n\n        gl_FragColor = vec4( diffuseColor.rgb, diffuseColor.a );\n\n    #else\n\n\n\n        #ifdef HAS_METALROUGHNESSMAP\n\n            vec4 metalRoughMapColor = texture2D( u_metallicRoughnessSampler, v_uv );\n            metalnessFactor *= metalRoughMapColor.b;\n            roughnessFactor *= metalRoughMapColor.g;\n\n        #else\n            #ifdef HAS_METALMAP\n\n            vec4 metalMapColor = texture2D( u_metallicSampler, v_uv );\n            metalnessFactor *= metalMapColor.b;\n\n            #endif\n\n            #ifdef HAS_ROUGHNESSMAP\n\n            vec4 roughMapColor = texture2D( u_roughnessSampler, v_uv );\n            roughnessFactor *= roughMapColor.g;\n\n            #endif\n        #endif\n\n        #ifdef HAS_SPECULARGLOSSINESSMAP\n\n            vec4 specularGlossinessColor = texture2D(u_specularGlossinessSampler, v_uv );\n            specularFactor *= specularGlossinessColor.rgb;\n            glossinessFactor *= specularGlossinessColor.a;\n\n        #endif\n\n\n        #ifdef IS_METALLIC_WORKFLOW\n            material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\n            material.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n//          material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n            material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT /* pow2( reflectivity )*/ ), diffuseColor.rgb, metalnessFactor );\n        #else\n            float specularStrength = max( max( specularFactor.r, specularFactor.g ), specularFactor.b );\n            material.diffuseColor = diffuseColor.rgb * ( 1.0 - specularStrength );\n            material.specularRoughness = clamp( 1.0 - glossinessFactor, 0.04, 1.0 );\n            material.specularColor = specularFactor;\n        #endif\n\n        geometry.position = v_pos;\n        geometry.normal = normal;\n        geometry.viewDir = normalize( u_cameraPos - v_pos );\n";

var pbr_direct_irradiance_frag = "        #if defined( O3_DIRECT_LIGHT_COUNT ) && defined( RE_Direct )\n\n            DirectLight directionalLight;\n\n            for ( int i = 0; i < O3_DIRECT_LIGHT_COUNT; i ++ ) {\n\n                directionalLight = u_directLights[ i ];\n\n                getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\n                RE_Direct( directLight, geometry, material, reflectedLight );\n\n            }\n\n        #endif\n\n        #if defined( O3_POINT_LIGHT_COUNT ) && defined( RE_Direct )\n\n            PointLight pointLight;\n\n            for ( int i = 0; i < O3_POINT_LIGHT_COUNT; i ++ ) {\n\n                pointLight = u_pointLights[ i ];\n\n                getPointDirectLightIrradiance( pointLight, geometry, directLight );\n\n                RE_Direct( directLight, geometry, material, reflectedLight );\n\n            }\n\n        #endif\n\n        #if defined( O3_SPOT_LIGHT_COUNT ) && defined( RE_Direct )\n\n            SpotLight spotLight;\n\n            for ( int i = 0; i < O3_SPOT_LIGHT_COUNT; i ++ ) {\n\n                spotLight = u_spotLights[ i ];\n\n                getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\n                RE_Direct( directLight, geometry, material, reflectedLight );\n\n            }\n\n        #endif\n";

var pbr_ibl_diffuse_frag = "#if defined(RE_IndirectDiffuse)\n\n    vec3 irradiance = vec3(0);\n\n    #if defined(O3_HAS_AMBIENT_LIGHT)\n        irradiance += getAmbientLightIrradiance(u_ambientLight.lightColor);\n    #endif\n\n    #if defined(O3_HAS_ENVMAP_LIGHT)\n\n        #ifdef O3_USE_DIFFUSE_ENV\n            vec3 lightMapIrradiance = textureCube(u_env_diffuseSampler, geometry.normal).rgb * u_envMapLight.diffuseIntensity;\n        #else\n            vec3 lightMapIrradiance = u_envMapLight.diffuse * u_envMapLight.diffuseIntensity;\n        #endif\n\n        #ifndef PHYSICALLY_CORRECT_LIGHTS\n            lightMapIrradiance *= PI;\n        #endif\n\n        irradiance += lightMapIrradiance;\n\n    #endif\n\n    RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n\n#endif\n\n\n";

var pbr_ibl_specular_frag = "#if defined( RE_IndirectSpecular )\n\n    vec3 radiance = vec3( 0.0 );\n\n#endif\n\n\n\n#if defined( O3_HAS_ENVMAP_LIGHT ) && defined( RE_IndirectSpecular )\n\n    radiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), int(u_envMapLight.mipMapLevel) );\n\n#endif\n\n\n#if defined( RE_IndirectSpecular )\n\n    RE_IndirectSpecular( radiance, geometry, material, reflectedLight );\n\n#endif\n";

var pbr_end_frag = "#ifdef HAS_OCCLUSIONMAP\n\n    float ambientOcclusion = (texture2D(u_occlusionSampler, v_uv).r - 1.0) * u_occlusionStrength + 1.0;\n    reflectedLight.indirectDiffuse *= ambientOcclusion;\n\n    #if defined(O3_USE_SPECULAR_ENV)\n\n        float dotNV = saturate(dot(geometry.normal, geometry.viewDir));\n        reflectedLight.indirectSpecular *= computeSpecularOcclusion(dotNV, ambientOcclusion, material.specularRoughness);\n\n    #endif\n\n#endif\n\n#ifdef HAS_EMISSIVEMAP\n\n    vec4 emissiveMapColor = texture2D(u_emissiveSampler, v_uv);\n    emissiveMapColor = SRGBtoLINEAR(emissiveMapColor);\n    totalEmissiveRadiance += u_emissiveFactor * emissiveMapColor.rgb;\n\n#endif\n\nvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\ngl_FragColor = vec4(outgoingLight, diffuseColor.a);\n\n#endif\n";

var PBRShaderLib = {
  pbr_common_frag_define,
  pbr_util_frag_define,
  pbr_envmap_light_frag_define,
  pbr_base_frag_define,
  pbr_texture_frag_define,
  pbr_runtime_frag_define,
  pbr_normal_frag_define,
  pbr_brdf_cook_torrance_frag_define,
  pbr_direct_irradiance_frag_define,
  pbr_ibl_specular_frag_define,
  pbr_ibl_diffuse_frag_define,
  pbr_begin_frag,
  pbr_direct_irradiance_frag,
  pbr_ibl_diffuse_frag,
  pbr_ibl_specular_frag,
  pbr_end_frag
};

var oit_frag2 = "#if defined(ALPHA_BLEND) && defined(OIT_ENABLE)\n    if(gl_FragCoord.z > texture2D(u_depthSampler, gl_FragCoord.xy / u_resolution).r){\n        discard;\n    }\n    vec4 oitColor = gl_FragColor;\n\n    // Bavoil and Myers Method\n    gl_FragData[0]= vec4(oitColor.rgb * oitColor.a, oitColor.a);\n    gl_FragData[1]= vec4(1)/ 255.0; // \n\n\n    // Depth Weights Improve Occlusion\n//    float w = weight(gl_FragCoord.z, oitColor.a);\n//    gl_FragData[0] = vec4(oitColor.rgb * oitColor.a * w, oitColor.a);\n//    gl_FragData[1].r =oitColor.a * w;\n#endif\n";

var oit_frag_define2 = "#if defined(ALPHA_BLEND) && defined(OIT_ENABLE)\n\n    uniform sampler2D u_depthSampler;\n\n    float weight(float z, float a) {\n        return a * clamp(3e3 * pow(1.0 - z, 3.0), 1e-2, 3e3);\n//          return pow(z,-5.0);\n    }\n#endif\n";

const ShaderLib = {
  common: common2,
  common_vert: common_vert2,
  common_frag: common_frag2,
  color_share: color_share2,
  normal_share: normal_share2,
  uv_share: uv_share2,
  worldpos_share: worldpos_share2,
  shadow_share: shadow_share2,
  fog_share: fog_share2,
  begin_normal_vert: begin_normal_vert2,
  begin_position_vert: begin_position_vert2,
  morph_target_vert: morph_target_vert2,
  position_vert: position_vert2,
  color_vert: color_vert2,
  normal_vert: normal_vert2,
  skinning_vert: skinning_vert2,
  uv_vert: uv_vert2,
  worldpos_vert: worldpos_vert2,
  shadow_vert: shadow_vert2,
  morph_vert: morph_vert2,
  fog_vert: fog_vert2,
  ambient_light_frag: ambient_light_frag2,
  direct_light_frag: direct_light_frag2,
  point_light_frag: point_light_frag2,
  spot_light_frag: spot_light_frag2,
  mobile_material_frag: mobile_material_frag2,
  fog_frag: fog_frag2,
  begin_mobile_frag: begin_mobile_frag2,
  begin_normal_frag: begin_normal_frag2,
  begin_viewdir_frag: begin_viewdir_frag2,
  mobile_blinnphong_frag: mobile_blinnphong_frag2,
  mobile_lambert_frag: mobile_lambert_frag2,
  noise_common: noise_common2,
  noise_cellular_2D: noise_cellular_2D2,
  noise_cellular_2x2: noise_cellular_2x22,
  noise_cellular_2x2x2: noise_cellular_2x2x22,
  noise_cellular_3D: noise_cellular_3D2,
  noise_cellular: noise_cellular2,
  noise_perlin_2D: noise_perlin_2D2,
  noise_perlin_3D: noise_perlin_3D2,
  noise_perlin_4D: noise_perlin_4D2,
  noise_perlin: noise_perlin2,
  noise_psrd_2D: noise_psrd_2D2,
  noise_simplex_2D: noise_simplex_2D2,
  noise_simplex_3D_grad: noise_simplex_3D_grad2,
  noise_simplex_3D: noise_simplex_3D2,
  noise_simplex_4D: noise_simplex_4D2,
  noise_simplex: noise_simplex2,
  perturbation_share: perturbation_share2,
  perturbation_frag: perturbation_frag2,
  refraction_share: refraction_share2,
  refraction_frag: refraction_frag2,
  clipPlane_vert_define: clipPlane_vert_define2,
  clipPlane_vert: clipPlane_vert2,
  clipPlane_frag_define: clipPlane_frag_define2,
  clipPlane_frag: clipPlane_frag2,
  gamma_frag: gamma_frag2,
  oit_frag: oit_frag2,
  oit_frag_define: oit_frag_define2,
  ...PBRShaderLib
};
function InjectShaderSlices(obj) {
  Object.assign(ShaderLib, obj);
}

class ShaderFactory {
  static parseVersion(version = "100") {
    return `#version ${version}
`;
  }
  static parsePrecision(vertP, fragP, compileVert) {
    const downgrade = "mediump";
    return `
        #ifdef GL_FRAGMENT_PRECISION_HIGH
          precision ${compileVert ? vertP : fragP} float;
          precision ${compileVert ? vertP : fragP} int;

          #define O3_VERTEX_PRECISION ${vertP}
          #define O3_FRAGMENT_PRECISION ${fragP}
        #else
          precision ${downgrade} float;
          precision ${downgrade} int;

          #define O3_VERTEX_PRECISION ${downgrade}
          #define O3_FRAGMENT_PRECISION ${downgrade}
        #endif
      `;
  }
  static parseShaderName(name) {
    return `#define O3_SHADER_NAME ${name}
`;
  }
  static parseAttributeMacros(macros) {
    return "#define O3_ATTRIBUTE_MACROS_START\n" + macros.map((m) => `#define ${m}
`).join("") + "#define O3_ATTRIBUTE_MACROS_END\n";
  }
  static parseCustomMacros(macros) {
    return "#define O3_CUSTOM_MACROS_START\n" + macros.map((m) => `#define ${m}
`).join("") + "#define O3_CUSTOM_MACROS_END\n";
  }
  static parseShader(src) {
    return ShaderFactory.parseIncludes(src);
  }
  static parseIncludes(src) {
    const regex = /^[ \t]*#include +<([\w\d.]+)>/gm;
    function replace(match, slice) {
      var replace2 = ShaderLib[slice];
      if (replace2 === void 0) {
        Logger.error(`Shader slice "${match.trim()}" not founded.`);
        return "";
      }
      return ShaderFactory.parseIncludes(replace2);
    }
    return src.replace(regex, replace);
  }
  static InjectShaderSlices(slices) {
    InjectShaderSlices(slices);
  }
  static parseExtension(extensions) {
    return `#define O3_EXTENSION_START
` + extensions.map((e) => `#extension ${e} : enable
`).join("") + `#define O3_EXTENSION_END
`;
  }
  static convertTo300(shader, isFrag) {
    const isGLSL300 = shader.includes("#version 300 es");
    if (isGLSL300)
      return shader;
    shader = shader.replace(/#version 100/, "#version 300 es");
    shader = shader.replace(/\battribute\b/g, "in");
    shader = shader.replace(/\bvarying\b/g, isFrag ? "in" : "out");
    shader = shader.replace(/\btexture(2D|Cube)\s*\(/g, "texture(");
    shader = shader.replace(/\btexture(2D|Cube)LodEXT\s*\(/g, "textureLod(");
    if (isFrag) {
      const isMRT = /\bgl_FragData\[.+?\]/g.test(shader);
      if (isMRT) {
        shader = shader.replace(/\bgl_FragColor\b/g, "gl_FragData[0]");
        const result = shader.match(/\bgl_FragData\[.+?\]/g);
        shader = this.replaceMRTShader(shader, result);
      } else {
        shader = shader.replace(/void\s+?main\s*\(/g, `out vec4 glFragColor;
void main(`);
        shader = shader.replace(/\bgl_FragColor\b/g, "glFragColor");
      }
    }
    return shader;
  }
  static getMaxDrawBuffers(shader) {
    const mrtIndexSet = new Set();
    const result = shader.match(/\bgl_FragData\[.+?\]/g) || [];
    for (let i = 0; i < result.length; i++) {
      const res = result[i].match(/\bgl_FragData\[(.+?)\]/);
      mrtIndexSet.add(res[1]);
    }
    return mrtIndexSet.size;
  }
  static compatible(fragmentShader) {
    const hasFragData = /\bgl_FragData\[.+?\]/g.test(fragmentShader);
    if (hasFragData) {
      fragmentShader = fragmentShader.replace(/\bgl_FragColor\b/g, "gl_FragData[0]");
    }
    return fragmentShader;
  }
  static replaceMRTShader(shader, result) {
    let declaration = "";
    const mrtIndexSet = new Set();
    for (let i = 0; i < result.length; i++) {
      const res = result[i].match(/\bgl_FragData\[(.+?)\]/);
      mrtIndexSet.add(res[1]);
    }
    mrtIndexSet.forEach((index) => {
      declaration += `layout(location=${index}) out vec4 fragOutColor${index};
`;
    });
    declaration += `void main(`;
    shader = shader.replace(/\bgl_FragData\[(.+?)\]/g, "fragOutColor$1");
    shader = shader.replace(/void\s+?main\s*\(/g, declaration);
    return shader;
  }
}

class RenderTechnique extends AssetObject {
  constructor(name) {
    super(null);
    this.name = name;
    this.isValid = false;
    this._uniforms = RenderTechnique.commonUniforms;
    this._attributes = RenderTechnique.commonAttributes;
    this.states = null;
    this.vertexShader = "";
    this.fragmentShader = "";
    this.version = "100";
    this.autoConvert = true;
    this.vertexPrecision = "highp";
    this.fragmentPrecision = "mediump";
    this.customMacros = [];
    this.shaderExtension100 = ["GL_EXT_shader_texture_lod", "GL_OES_standard_derivatives", "GL_EXT_draw_buffers"];
    this.shaderExtension300 = [];
    this._needCompile = true;
  }
  get attributes() {
    return this._attributes;
  }
  set attributes(v) {
    this._attributes = Object.assign({}, RenderTechnique.commonAttributes, v);
  }
  get uniforms() {
    return this._uniforms;
  }
  set uniforms(v) {
    this._uniforms = Object.assign({}, RenderTechnique.commonUniforms, v);
  }
  compile(camera, component, primitive, material) {
    this.parseFog(camera);
    if (this._needCompile) {
      const rhi = camera.engine._hardwareRenderer;
      const isWebGL2 = rhi?.isWebGL2;
      material.preCompile?.(this);
      const attribMacros = this.getAttributeDefines(camera, component, primitive, material);
      if (this._recreateHeader) {
        this.attributes = this.attributes;
        this.uniforms = this.uniforms;
      }
      if (!this._vsHeader || this._recreateHeader)
        this._vsHeader = ShaderFactory.parseVersion(this.version) + ShaderFactory.parseShaderName((this.name || "VOID").toUpperCase() + "_VERT") + "\n" + ShaderFactory.parsePrecision(this.vertexPrecision, this.fragmentPrecision, true) + "\n" + ShaderFactory.parseAttributeMacros(attribMacros) + "\n" + ShaderFactory.parseCustomMacros(this.customMacros) + "\n";
      if (!this._vsCode)
        this._vsCode = ShaderFactory.parseShader(this.vertexShader);
      this.vertexShader = this._vsHeader + this._vsCode;
      if (!this._fsHeader || this._recreateHeader)
        this._fsHeader = ShaderFactory.parseVersion(this.version) + ShaderFactory.parseShaderName((this.name || "VOID").toUpperCase() + "_FRAG") + "\n" + ShaderFactory.parseExtension(isWebGL2 ? this.shaderExtension300 : this.shaderExtension100) + ShaderFactory.parsePrecision(this.vertexPrecision, this.fragmentPrecision) + "\n" + ShaderFactory.parseAttributeMacros(attribMacros) + "\n" + ShaderFactory.parseCustomMacros(this.customMacros) + "\n";
      if (!this._fsCode)
        this._fsCode = ShaderFactory.parseShader(this.fragmentShader);
      this.fragmentShader = this._fsHeader + this._fsCode;
      if (this.autoConvert && isWebGL2 && this.version !== "300 es") {
        const maxDrawBuffers = rhi.capability.maxDrawBuffers;
        const shaderMaxDrawBuffers = ShaderFactory.getMaxDrawBuffers(this.fragmentShader);
        if (shaderMaxDrawBuffers <= maxDrawBuffers) {
          this.vertexShader = ShaderFactory.convertTo300(this.vertexShader);
          this.fragmentShader = ShaderFactory.convertTo300(this.fragmentShader, true);
        }
      } else if (!isWebGL2 && this.version !== "300es") {
        this.fragmentShader = ShaderFactory.compatible(this.fragmentShader);
      }
      this._needCompile = false;
      this._recreateHeader = false;
      material.postCompile?.(this);
    }
  }
  getAttributeDefines(camera, component, primitive, material) {
    const rhi = camera.scene.engine._hardwareRenderer;
    const gl = rhi.gl;
    const _macros = [];
    if (!primitive)
      return _macros;
    const attribNames = Object.keys(primitive._vertexElementMap);
    if (attribNames.indexOf("TEXCOORD_0") > -1)
      _macros.push("O3_HAS_UV");
    if (attribNames.indexOf("NORMAL") > -1)
      _macros.push("O3_HAS_NORMAL");
    if (attribNames.indexOf("TANGENT") > -1)
      _macros.push("O3_HAS_TANGENT");
    if (attribNames.indexOf("JOINTS_0") > -1) {
      _macros.push("O3_HAS_SKIN");
      if (component.jointNodes?.length) {
        const maxAttribUniformVec4 = rhi.renderStates.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
        const maxJoints = Math.floor((maxAttribUniformVec4 - 20) / 4);
        const joints = component.jointNodes.length;
        if (joints > maxJoints) {
          if (rhi.canIUseMoreJoints) {
            _macros.push("O3_USE_JOINT_TEXTURE");
          } else {
            Logger.error(`component's joints count(${joints}) greater than device's MAX_VERTEX_UNIFORM_VECTORS number ${maxAttribUniformVec4}, suggest joint count less than ${maxJoints}.`, component);
          }
        } else if (material.maxJointsNum > 0) {
          _macros.push(`O3_JOINTS_NUM ${material.maxJointsNum}`);
        }
      }
    }
    if (attribNames.indexOf("COLOR_0") > -1) {
      _macros.push("O3_HAS_VERTEXCOLOR");
      if (primitive._vertexElementMap["COLOR_0"].format === VertexElementFormat.Vector4)
        _macros.push("O3_HAS_VERTEXALPHA");
    }
    const scene = camera.scene;
    if (scene.hasFogFeature) {
      _macros.push(...scene.getFogMacro());
    }
    return _macros;
  }
  parseFog(camera) {
    const scene = camera.scene;
    if (scene.hasFogFeature) {
      const fogMacro = scene.getFogMacro();
      if (this._fogMacro !== fogMacro) {
        this._needCompile = true;
        this._recreateHeader = true;
        this._fogMacro = fogMacro;
      }
    }
  }
  createMorphConfig(primitive, targetNum) {
    const attributes = Object.keys(primitive._vertexElementMap);
    const morphConfig = {};
    for (let i = 0; i < targetNum; i++) {
      if (attributes.indexOf(`POSITION_${i}`) > -1)
        morphConfig[`a_position${i}`] = {
          name: `a_position${i}`,
          semantic: `POSITION_${i}`,
          type: DataType.FLOAT_VEC3
        };
      if (attributes.indexOf(`NORMAL_${i}`) > -1)
        morphConfig[`a_normal${i}`] = {
          name: `a_normal${i}`,
          semantic: `NORMAL_${i}`,
          type: DataType.FLOAT_VEC3
        };
      if (attributes.indexOf(`TANGENT_${i}`) > -1)
        morphConfig[`a_tangent${i}`] = {
          name: `a_tangent${i}`,
          semantic: `TANGENT_${i}`,
          type: DataType.FLOAT_VEC3
        };
    }
    return morphConfig;
  }
  _finalize() {
    if (this._glTechnique) {
      this._glTechnique.finalize(true);
      this._glTechnique = null;
    }
  }
}
RenderTechnique.commonAttributes = {
  a_position: {
    name: "a_position",
    semantic: "POSITION",
    type: DataType.FLOAT_VEC3
  },
  a_uv: {
    name: "a_uv",
    semantic: "TEXCOORD_0",
    type: DataType.FLOAT_VEC2
  },
  a_normal: {
    name: "a_noraml",
    semantic: "NORMAL",
    type: DataType.FLOAT_VEC3
  },
  a_tangent: {
    name: "a_tangent",
    semantic: "TANGENT",
    type: DataType.FLOAT_VEC4
  },
  a_color: {
    name: "a_color",
    semantic: "COLOR_0",
    type: DataType.FLOAT_VEC4
  },
  a_joint: {
    name: "a_joint",
    semantic: "JOINTS_0",
    type: DataType.FLOAT_VEC4
  },
  a_weight: {
    name: "a_weight",
    semantic: "WEIGHTS_0",
    type: DataType.FLOAT_VEC4
  }
};
RenderTechnique.commonUniforms = {
  u_localMat: {
    name: "u_localMat",
    semantic: UniformSemantic.LOCAL,
    type: DataType.FLOAT_MAT4
  },
  u_modelMat: {
    name: "u_modelMat",
    semantic: UniformSemantic.MODEL,
    type: DataType.FLOAT_MAT4
  },
  u_viewMat: {
    name: "u_viewMat",
    semantic: UniformSemantic.VIEW,
    type: DataType.FLOAT_MAT4
  },
  u_projMat: {
    name: "u_projMat",
    semantic: UniformSemantic.PROJECTION,
    type: DataType.FLOAT_MAT4
  },
  u_MVMat: {
    name: "u_MVMat",
    semantic: UniformSemantic.MODELVIEW,
    type: DataType.FLOAT_MAT4
  },
  u_MVPMat: {
    name: "u_MVPMat",
    semantic: UniformSemantic.MODELVIEWPROJECTION,
    type: DataType.FLOAT_MAT4
  },
  u_normalMat: {
    name: "u_normalMat",
    semantic: UniformSemantic.MODELINVERSETRANSPOSE,
    type: DataType.FLOAT_MAT3
  },
  u_cameraPos: {
    name: "u_cameraPos",
    type: DataType.FLOAT_VEC3,
    semantic: UniformSemantic.EYEPOS
  },
  u_time: {
    name: "u_time",
    type: DataType.FLOAT,
    semantic: UniformSemantic.TIME
  },
  u_jointMatrix: {
    name: "u_jointMatrix",
    semantic: UniformSemantic.JOINTMATRIX,
    type: DataType.FLOAT_MAT4_ARRAY
  },
  u_jointSampler: {
    name: "u_jointSampler",
    semantic: UniformSemantic.JOINTTEXTURE,
    type: DataType.SAMPLER_2D
  },
  u_jointCount: {
    name: "u_jointCount",
    semantic: UniformSemantic.JOINTCOUNT,
    type: DataType.FLOAT
  },
  u_fogColor: {
    name: "u_fogColor",
    type: DataType.FLOAT_VEC3
  },
  u_fogDensity: {
    name: "u_fogDensity",
    type: DataType.FLOAT
  },
  u_fogNear: {
    name: "u_fogNear",
    type: DataType.FLOAT
  },
  u_fogFar: {
    name: "u_fogFar",
    type: DataType.FLOAT
  }
};

var TextureCubeFace;
(function(TextureCubeFace2) {
  TextureCubeFace2[TextureCubeFace2["PositiveX"] = 0] = "PositiveX";
  TextureCubeFace2[TextureCubeFace2["NegativeX"] = 1] = "NegativeX";
  TextureCubeFace2[TextureCubeFace2["PositiveY"] = 2] = "PositiveY";
  TextureCubeFace2[TextureCubeFace2["NegativeY"] = 3] = "NegativeY";
  TextureCubeFace2[TextureCubeFace2["PositiveZ"] = 4] = "PositiveZ";
  TextureCubeFace2[TextureCubeFace2["NegativeZ"] = 5] = "NegativeZ";
})(TextureCubeFace || (TextureCubeFace = {}));

class TextureCubeMap extends Texture {
  constructor(engine, size, format = TextureFormat.R8G8B8A8, mipmap = true) {
    super(engine);
    this._compressedFaceFilled = [0, 0, 0, 0, 0, 0];
    const rhi = engine._hardwareRenderer;
    const gl = rhi.gl;
    const isWebGL2 = rhi.isWebGL2;
    if (!Texture._supportTextureFormat(format, rhi)) {
      throw new Error(`Texture format is not supported:${TextureFormat[format]}`);
    }
    if (mipmap && !isWebGL2 && !Texture._isPowerOf2(size)) {
      Logger.warn("non-power-2 texture is not supported for mipmap in WebGL1,and has automatically downgraded to non-mipmap");
      mipmap = false;
    }
    const formatDetail = Texture._getFormatDetail(format, gl, isWebGL2);
    this._glTexture = gl.createTexture();
    this._formatDetail = formatDetail;
    this._rhi = rhi;
    this._target = gl.TEXTURE_CUBE_MAP;
    this._mipmap = mipmap;
    this._width = size;
    this._height = size;
    this._format = format;
    this._mipmapCount = this._getMipmapCount();
    formatDetail.isCompressed && !isWebGL2 || this._initMipmap(true);
    this.filterMode = TextureFilterMode.Bilinear;
    this.wrapModeU = this.wrapModeV = TextureWrapMode.Clamp;
  }
  get format() {
    return this._format;
  }
  setPixelBuffer(face, colorBuffer, mipLevel = 0, x, y, width, height) {
    const gl = this._rhi.gl;
    const isWebGL2 = this._rhi.isWebGL2;
    const {internalFormat, baseFormat, dataType, isCompressed} = this._formatDetail;
    const mipSize = Math.max(1, this._width >> mipLevel);
    x = x || 0;
    y = y || 0;
    width = width || mipSize - x;
    height = height || mipSize - y;
    this._bind();
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
    if (isCompressed) {
      const mipBit = 1 << mipLevel;
      if (isWebGL2 || this._compressedFaceFilled[face] & mipBit) {
        gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, x, y, width, height, internalFormat, colorBuffer);
      } else {
        gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, internalFormat, width, height, 0, colorBuffer);
        this._compressedFaceFilled[face] |= mipBit;
      }
    } else {
      gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, x, y, width, height, baseFormat, dataType, colorBuffer);
    }
    this._unbind();
  }
  setImageSource(face, imageSource, mipLevel = 0, flipY = false, premultiplyAlpha = false, x, y) {
    const gl = this._rhi.gl;
    const {baseFormat, dataType} = this._formatDetail;
    this._bind();
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, +flipY);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, +premultiplyAlpha);
    gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, x || 0, y || 0, baseFormat, dataType, imageSource);
    this._unbind();
  }
  getPixelBuffer(face, x, y, width, height, out) {
    if (this._formatDetail.isCompressed) {
      throw new Error("Unable to read compressed texture");
    }
    super._getPixelBuffer(face, x, y, width, height, out);
  }
}

class RenderDepthTexture extends Texture {
  constructor(engine, width, height, format = RenderBufferDepthFormat.Depth, mipmap = false, isCube = false) {
    super(engine);
    this._isCube = false;
    this._autoMipmap = false;
    const rhi = engine._hardwareRenderer;
    const gl = rhi.gl;
    const isWebGL2 = rhi.isWebGL2;
    if (!Texture._supportRenderBufferDepthFormat(format, rhi, true)) {
      throw new Error(`RenderBufferDepthFormat is not supported:${RenderBufferDepthFormat[format]}`);
    }
    if (isCube && width !== height) {
      throw new Error("The cube texture must have the same width and height");
    }
    if (mipmap && !isWebGL2 && (!Texture._isPowerOf2(width) || !Texture._isPowerOf2(height))) {
      Logger.warn("non-power-2 texture is not supported for mipmap in WebGL1,and has automatically downgraded to non-mipmap");
      mipmap = false;
    }
    this._glTexture = gl.createTexture();
    this._formatDetail = Texture._getRenderBufferDepthFormatDetail(format, gl, isWebGL2);
    this._isCube = isCube;
    this._rhi = rhi;
    this._target = isCube ? gl.TEXTURE_CUBE_MAP : gl.TEXTURE_2D;
    this._mipmap = mipmap;
    this._width = width;
    this._height = height;
    this._format = format;
    this._mipmapCount = this._getMipmapCount();
    this._initMipmap(isCube);
    this.filterMode = TextureFilterMode.Bilinear;
    this.wrapModeU = this.wrapModeV = TextureWrapMode.Clamp;
  }
  get format() {
    return this._format;
  }
  get autoGenerateMipmaps() {
    return this._autoMipmap;
  }
  set autoGenerateMipmaps(value) {
    this._autoMipmap = value;
  }
}

class RenderTarget extends EngineObject {
  constructor(engine, width, height, renderTexture, depth = RenderBufferDepthFormat.Depth, antiAliasing = 1) {
    super(engine);
    this._MSAAColorRenderBuffers = [];
    const rhi = engine._hardwareRenderer;
    const gl = rhi.gl;
    if (!(depth instanceof RenderDepthTexture) && !Texture._supportRenderBufferDepthFormat(depth, rhi, false)) {
      throw new Error(`RenderBufferDepthFormat is not supported:${RenderBufferDepthFormat[depth]}`);
    }
    if (renderTexture?.length > 1 && !rhi.canIUse(GLCapabilityType.drawBuffers)) {
      throw new Error("MRT is not supported");
    }
    if (renderTexture) {
      this._colorTextures = renderTexture instanceof Array ? renderTexture.slice() : [renderTexture];
    } else {
      this._colorTextures = [];
    }
    if (this._colorTextures.some((v) => v.width !== width || v.height !== height)) {
      throw new Error("RenderColorTexture's size must as same as RenderTarget");
    }
    if (depth instanceof RenderDepthTexture && (depth.width !== width || depth.height !== height)) {
      throw new Error("RenderDepthTexture's size must as same as RenderTarget");
    }
    if (this._colorTextures.length > 1 && this._colorTextures.some((v) => v._isCube)) {
      throw new Error("MRT+Cube+[,MSAA] is not supported");
    }
    const maxAntiAliasing = rhi.capability.maxAntiAliasing;
    if (antiAliasing > maxAntiAliasing) {
      Logger.warn(`MSAA antiAliasing exceeds the limit and is automatically downgraded to:${maxAntiAliasing}`);
      antiAliasing = maxAntiAliasing;
    }
    this._rhi = rhi;
    this._width = width;
    this._height = height;
    this._frameBuffer = gl.createFramebuffer();
    this._antiAliasing = antiAliasing;
    if (depth instanceof RenderDepthTexture) {
      this._depthTexture = depth;
    }
    this._bindMainFBO(depth);
    if (antiAliasing > 1) {
      this._MSAAFrameBuffer = gl.createFramebuffer();
      this._bindMSAAFBO(depth);
    }
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  get colorTextureCount() {
    return this._colorTextures.length;
  }
  get depthTexture() {
    return this._depthTexture;
  }
  get antiAliasing() {
    return this._antiAliasing;
  }
  getColorTexture(index = 0) {
    return this._colorTextures[index];
  }
  destroy() {
    const gl = this._rhi.gl;
    gl.deleteFramebuffer(this._frameBuffer);
    this._depthRenderBuffer && gl.deleteRenderbuffer(this._depthRenderBuffer);
    this._MSAAFrameBuffer && gl.deleteFramebuffer(this._MSAAFrameBuffer);
    this._MSAADepthRenderBuffer && gl.deleteRenderbuffer(this._MSAADepthRenderBuffer);
    for (let i = 0; i < this._colorTextures.length; i++) {
      this._colorTextures[i].destroy();
    }
    for (let i = 0; i < this._MSAAColorRenderBuffers.length; i++) {
      gl.deleteRenderbuffer(this._MSAAColorRenderBuffers[i]);
    }
    this._depthTexture && this._depthTexture.destroy();
    this._frameBuffer = null;
    this._colorTextures.length = 0;
    this._depthTexture = null;
    this._depthRenderBuffer = null;
    this._MSAAFrameBuffer = null;
    this._MSAAColorRenderBuffers.length = 0;
    this._MSAADepthRenderBuffer = null;
  }
  _activeRenderTarget() {
    const gl = this._rhi.gl;
    if (this._MSAAFrameBuffer) {
      gl.bindFramebuffer(gl.FRAMEBUFFER, this._MSAAFrameBuffer);
    } else {
      gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);
    }
  }
  _setRenderTargetFace(faceIndex) {
    const gl = this._rhi.gl;
    const colorTexture = this._colorTextures[0];
    const depthTexture = this._depthTexture;
    gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);
    if (colorTexture?._isCube) {
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, colorTexture._glTexture, 0);
    }
    if (depthTexture?._isCube) {
      gl.framebufferTexture2D(gl.FRAMEBUFFER, depthTexture._formatDetail.attachment, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, depthTexture._glTexture, 0);
    }
    this._activeRenderTarget();
  }
  _blitRenderTarget() {
    const gl = this._rhi.gl;
    const mask = gl.COLOR_BUFFER_BIT | (this._depthTexture ? gl.DEPTH_BUFFER_BIT : 0);
    const colorTextureLength = this._colorTextures.length;
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this._MSAAFrameBuffer);
    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this._frameBuffer);
    for (let textureIndex = 0; textureIndex < colorTextureLength; textureIndex++) {
      const attachment = gl.COLOR_ATTACHMENT0 + textureIndex;
      this._blitDrawBuffers[textureIndex] = attachment;
      gl.readBuffer(attachment);
      gl.drawBuffers(this._blitDrawBuffers);
      gl.blitFramebuffer(0, 0, this._width, this._height, 0, 0, this._width, this._height, mask, gl.NEAREST);
      this._blitDrawBuffers[textureIndex] = gl.NONE;
    }
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  }
  _bindMainFBO(renderDepth) {
    const gl = this._rhi.gl;
    const isWebGL2 = this._rhi.isWebGL2;
    const colorTextureLength = this._colorTextures.length;
    const drawBuffers = new Array(colorTextureLength);
    gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);
    for (let i = 0; i < colorTextureLength; i++) {
      const colorTexture = this._colorTextures[i];
      const attachment = gl.COLOR_ATTACHMENT0 + i;
      drawBuffers[i] = attachment;
      if (!colorTexture._isCube) {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, colorTexture._glTexture, 0);
      }
    }
    if (colorTextureLength > 1) {
      gl.drawBuffers(drawBuffers);
    }
    this._oriDrawBuffers = drawBuffers;
    if (renderDepth !== null) {
      if (renderDepth instanceof RenderDepthTexture) {
        if (!renderDepth._isCube) {
          gl.framebufferTexture2D(gl.FRAMEBUFFER, renderDepth._formatDetail.attachment, gl.TEXTURE_2D, renderDepth._glTexture, 0);
        }
      } else if (this._antiAliasing <= 1) {
        const {internalFormat, attachment} = Texture._getRenderBufferDepthFormatDetail(renderDepth, gl, isWebGL2);
        const depthRenderBuffer = gl.createRenderbuffer();
        this._depthRenderBuffer = depthRenderBuffer;
        gl.bindRenderbuffer(gl.RENDERBUFFER, depthRenderBuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, internalFormat, this._width, this._height);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, depthRenderBuffer);
      }
    }
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
  }
  _bindMSAAFBO(renderDepth) {
    const gl = this._rhi.gl;
    const isWebGL2 = this._rhi.isWebGL2;
    const MSAADepthRenderBuffer = gl.createRenderbuffer();
    const colorTextureLength = this._colorTextures.length;
    this._blitDrawBuffers = new Array(colorTextureLength);
    this._MSAADepthRenderBuffer = MSAADepthRenderBuffer;
    gl.bindFramebuffer(gl.FRAMEBUFFER, this._MSAAFrameBuffer);
    for (let i = 0; i < colorTextureLength; i++) {
      const MSAAColorRenderBuffer = gl.createRenderbuffer();
      this._MSAAColorRenderBuffers[i] = MSAAColorRenderBuffer;
      this._blitDrawBuffers[i] = gl.NONE;
      gl.bindRenderbuffer(gl.RENDERBUFFER, MSAAColorRenderBuffer);
      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, this._antiAliasing, this._colorTextures[i]._formatDetail.internalFormat, this._width, this._height);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, MSAAColorRenderBuffer);
    }
    gl.drawBuffers(this._oriDrawBuffers);
    if (renderDepth !== null) {
      const {internalFormat, attachment} = renderDepth instanceof RenderDepthTexture ? renderDepth._formatDetail : Texture._getRenderBufferDepthFormatDetail(renderDepth, gl, isWebGL2);
      gl.bindRenderbuffer(gl.RENDERBUFFER, MSAADepthRenderBuffer);
      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, this._antiAliasing, internalFormat, this._width, this._height);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, MSAADepthRenderBuffer);
    }
    this._checkFrameBuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
  }
  _checkFrameBuffer() {
    const gl = this._rhi.gl;
    const isWebGL2 = this._rhi.isWebGL2;
    const e = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    switch (e) {
      case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
        throw new Error("The attachment types are mismatched or not all framebuffer attachment points are framebuffer attachment complete");
      case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
        throw new Error("There is no attachment");
      case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
        throw new Error(" Height and width of the attachment are not the same.");
      case gl.FRAMEBUFFER_UNSUPPORTED:
        throw new Error("The format of the attachment is not supported or if depth and stencil attachments are not the same renderbuffer");
    }
    if (isWebGL2 && e === gl.FRAMEBUFFER_INCOMPLETE_MULTISAMPLE) {
      throw new Error("The values of gl.RENDERBUFFER_SAMPLES are different among attached renderbuffers, or are non-zero if the attached images are a mix of renderbuffers and textures.");
    }
  }
}

class RenderColorTexture extends Texture {
  constructor(engine, width, height, format = RenderBufferColorFormat.R8G8B8A8, mipmap = false, isCube = false) {
    super(engine);
    this._isCube = false;
    this._autoMipmap = false;
    const rhi = engine._hardwareRenderer;
    const gl = rhi.gl;
    const isWebGL2 = rhi.isWebGL2;
    if (!Texture._supportRenderBufferColorFormat(format, rhi)) {
      throw new Error(`RenderBufferColorFormat is not supported:${RenderBufferColorFormat[format]}`);
    }
    if (isCube && width !== height) {
      throw new Error("The cube texture must have the same width and height");
    }
    if (mipmap && !isWebGL2 && (!Texture._isPowerOf2(width) || !Texture._isPowerOf2(height))) {
      Logger.warn("non-power-2 texture is not supported for mipmap in WebGL1,and has automatically downgraded to non-mipmap");
      mipmap = false;
    }
    this._glTexture = gl.createTexture();
    this._formatDetail = Texture._getRenderBufferColorFormatDetail(format, gl, isWebGL2);
    this._isCube = isCube;
    this._rhi = rhi;
    this._target = isCube ? gl.TEXTURE_CUBE_MAP : gl.TEXTURE_2D;
    this._mipmap = mipmap;
    this._width = width;
    this._height = height;
    this._format = format;
    this._mipmapCount = this._getMipmapCount();
    this._initMipmap(isCube);
    this.filterMode = TextureFilterMode.Bilinear;
    this.wrapModeU = this.wrapModeV = TextureWrapMode.Clamp;
  }
  get format() {
    return this._format;
  }
  get autoGenerateMipmaps() {
    return this._autoMipmap;
  }
  set autoGenerateMipmaps(value) {
    this._autoMipmap = value;
  }
  getPixelBuffer(face, x, y, width, height, out) {
    super._getPixelBuffer(face, x, y, width, height, out);
  }
}

class SpriteRenderer extends RenderableComponent {
  constructor(entity) {
    super(entity);
    this._worldSize = [];
    this._rotationAngle = 0;
    this.renderMode = "2D";
    this.tintColor = new Vector4(1, 1, 1, 1);
    this._worldSizeFactor = 100;
    this.setTexture(void 0);
    this.setRect(void 0);
    this.setAnchor(void 0);
    this.setUvRect();
    this.setWorldSize();
    this._positionQuad = {
      leftTop: new Vector3(),
      leftBottom: new Vector3(),
      rightTop: new Vector3(),
      rightBottom: new Vector3()
    };
  }
  set texture(v) {
    this.setTexture(v);
    this.setRect();
    this.setUvRect();
    this.setWorldSize();
  }
  get texture() {
    return this._texture;
  }
  set anchor(v) {
    this._anchor = v || [0.5, 0.5];
  }
  get anchor() {
    return this._anchor;
  }
  set rect(v) {
    this.setRect(v);
    this.setUvRect();
    this.setWorldSize();
  }
  get rect() {
    return this._rect;
  }
  setTexture(texture) {
    if (texture && texture.asset) {
      texture = texture.asset;
    }
    this._texture = texture;
  }
  get rotationAngle() {
    return this._rotationAngle;
  }
  set rotationAngle(v) {
    this._rotationAngle = v;
  }
  setRect(rect) {
    let rectObject;
    try {
      if (rect) {
        rectObject = JSON.parse(rect);
      }
    } catch (error) {
      Logger.warn("Rect is not valid JSON format");
    }
    this._rect = rect || {
      x: 0,
      y: 0,
      width: this._texture?.width ?? 0,
      height: this._texture?.height ?? 0
    };
  }
  setAnchor(anchor) {
    this._anchor = anchor || [0.5, 0.5];
  }
  setWorldSize() {
    const {_worldSizeFactor} = this;
    this._worldSize = [this._rect.width / _worldSizeFactor, this._rect.height / _worldSizeFactor];
  }
  setUvRect() {
    let w, h;
    if (this._texture) {
      w = this._texture.width;
      h = this._texture.height;
    } else {
      w = this._rect.width;
      h = this._rect.height;
    }
    this._uvRect = {
      u: this._rect.x / w,
      v: this._rect.y / h,
      width: this._rect.width / w,
      height: this._rect.height / h
    };
  }
  render(camera) {
    this._updatePositionQuad(camera);
    this._transformByMatrix();
    camera._renderPipeline.pushSprite(this, this._positionQuad, this._uvRect, this.tintColor, this.texture, this.renderMode, camera);
  }
  _transformByMatrix() {
    if (!this.transformMatrix)
      return;
    const matrix = this.transformMatrix;
    let temp = this._positionQuad.leftTop;
    const leftTop = SpriteRenderer._tempVec40;
    leftTop.setValue(temp.x, temp.y, temp.z, 1);
    temp = this._positionQuad.leftBottom;
    const leftBottom = SpriteRenderer._tempVec41;
    leftBottom.setValue(temp.x, temp.y, temp.z, 1);
    temp = this._positionQuad.rightTop;
    const rightTop = SpriteRenderer._tempVec42;
    rightTop.setValue(temp.x, temp.y, temp.z, 1);
    temp = this._positionQuad.rightBottom;
    const rightBottom = SpriteRenderer._tempVec43;
    rightBottom.setValue(temp.x, temp.y, temp.z, 1);
    Vector4.transform(leftTop, matrix, leftTop);
    Vector4.transform(leftBottom, matrix, leftBottom);
    Vector4.transform(rightTop, matrix, rightTop);
    Vector4.transform(rightBottom, matrix, rightBottom);
    this._positionQuad.leftTop.setValue(leftTop.x, leftTop.y, leftTop.z);
    this._positionQuad.leftBottom.setValue(leftBottom.x, leftBottom.y, leftBottom.z);
    this._positionQuad.rightTop.setValue(rightTop.x, rightTop.y, rightTop.z);
    this._positionQuad.rightBottom.setValue(rightBottom.x, rightBottom.y, rightBottom.z);
  }
  _updatePositionQuad(camera) {
    if (this.renderMode === "2D") {
      const m = camera.viewMatrix.elements;
      const vx = new Vector3(m[0], m[4], m[8]);
      const vy = new Vector3(m[1], m[5], m[9]);
      const c = this.entity.worldPosition.clone();
      const s = this._worldSize;
      const ns = this.entity.scale;
      vx.scale(s[0] * ns.x);
      vy.scale(s[1] * ns.y);
      if (this._rotationAngle !== 0) {
        const vz = new Vector3(m[2], m[6], m[10]);
        const rotation = new Quaternion();
        Quaternion.rotationAxisAngle(vz, this._rotationAngle, rotation);
        Vector3.transformByQuat(vx, rotation, vx);
        Vector3.transformByQuat(vy, rotation, vy);
      }
      const cx = new Vector3();
      const cy = new Vector3();
      Vector3.scale(vx, (this.anchor[0] - 0.5) * 2, cx);
      Vector3.scale(vy, (this.anchor[1] - 0.5) * 2, cy);
      c.subtract(cx).add(cy);
      const leftTop = this._positionQuad.leftTop;
      Vector3.subtract(c, vx, leftTop);
      leftTop.add(vy);
      const leftBottom = this._positionQuad.leftBottom;
      Vector3.subtract(c, vx, leftBottom);
      leftBottom.subtract(vy);
      const rightBottom = this._positionQuad.rightBottom;
      Vector3.add(c, vx, rightBottom);
      rightBottom.subtract(vy);
      const rightTop = this._positionQuad.rightTop;
      Vector3.add(c, vx, rightTop);
      rightTop.add(vy);
    }
  }
}
SpriteRenderer._tempVec40 = new Vector4();
SpriteRenderer._tempVec41 = new Vector4();
SpriteRenderer._tempVec42 = new Vector4();
SpriteRenderer._tempVec43 = new Vector4();

var WrapMode;
(function(WrapMode2) {
  WrapMode2[WrapMode2["ONCE"] = 0] = "ONCE";
  WrapMode2[WrapMode2["LOOP"] = 1] = "LOOP";
})(WrapMode || (WrapMode = {}));
var AnimationEventType;
(function(AnimationEventType2) {
  AnimationEventType2[AnimationEventType2["FINISHED"] = 0] = "FINISHED";
  AnimationEventType2[AnimationEventType2["LOOP_END"] = 1] = "LOOP_END";
  AnimationEventType2[AnimationEventType2["FRAME_EVENT"] = 2] = "FRAME_EVENT";
})(AnimationEventType || (AnimationEventType = {}));
var InterpolationType;
(function(InterpolationType2) {
  InterpolationType2[InterpolationType2["LINEAR"] = 0] = "LINEAR";
  InterpolationType2[InterpolationType2["CUBICSPLINE"] = 1] = "CUBICSPLINE";
  InterpolationType2[InterpolationType2["STEP"] = 2] = "STEP";
})(InterpolationType || (InterpolationType = {}));

var TagetType;
(function(TagetType2) {
  TagetType2[TagetType2["position"] = 0] = "position";
  TagetType2[TagetType2["rotation"] = 1] = "rotation";
  TagetType2[TagetType2["scale"] = 2] = "scale";
  TagetType2[TagetType2["other"] = 3] = "other";
})(TagetType || (TagetType = {}));
class AnimationClip extends AssetObject {
  constructor(name) {
    super(null);
    this.name = name;
    this.samplers = [];
    this.channels = [];
  }
  addSampler(_input, _output, _outputSize, _interpolation = InterpolationType.LINEAR) {
    if (_interpolation === InterpolationType.CUBICSPLINE) {
      if (_outputSize <= 4) {
        _interpolation = InterpolationType.LINEAR;
      } else {
        _outputSize /= 3;
      }
    }
    const sampler = {
      input: _input,
      output: _output,
      outputSize: _outputSize,
      interpolation: _interpolation
    };
    this.samplers.push(sampler);
  }
  addChannel(samplerIndex, targetID, targetPath) {
    const bindSampler = this.samplers[samplerIndex];
    let tagetType = AnimationClip._tagetTypeMap[targetPath];
    const channel = {
      sampler: bindSampler,
      target: {
        id: targetID,
        path: targetPath,
        pathType: tagetType ?? 3
      }
    };
    this.channels.push(channel);
  }
  getChannelCount() {
    return this.channels.length;
  }
  getChannelObject(channelIndex) {
    return this.channels[channelIndex];
  }
  getFrameCount(channelIndex) {
    const sampler = this.channels[channelIndex].sampler;
    return sampler.input.length;
  }
  getFrameTime(channelIndex, frameIndex) {
    const sampler = this.channels[channelIndex].sampler;
    return sampler.input[frameIndex];
  }
  getChannelTimeLength(channelIndex) {
    const sampler = this.channels[channelIndex].sampler;
    const frameCount = sampler.input.length;
    return sampler.input[frameCount - 1];
  }
  createChannelValue(channelIndex) {
    const sampler = this.channels[channelIndex].sampler;
    return new Float32Array(sampler.outputSize);
  }
  evaluate(outValue, channelIndex, frameIndex, nextFrameIndex, alpha) {
    const channel = this.channels[channelIndex];
    const output = channel.sampler.output;
    const outputSize = channel.sampler.outputSize;
    switch (channel.sampler.interpolation) {
      case InterpolationType.CUBICSPLINE:
        this.evaluateCubicSpline(outValue, output, outputSize, frameIndex, nextFrameIndex, alpha);
        break;
      case InterpolationType.LINEAR:
        this.evaluateLinear(outValue, output, outputSize, frameIndex, nextFrameIndex, alpha);
        break;
    }
    return outValue;
  }
  evaluateCubicSpline(outValue, output, outputSize, frameIndex, nextFrameIndex, alpha) {
    const squared = alpha * alpha;
    const cubed = alpha * squared;
    const part1 = 2 * cubed - 3 * squared + 1;
    const part2 = -2 * cubed + 3 * squared;
    const part3 = cubed - 2 * squared + alpha;
    const part4 = cubed - squared;
    for (let i = outputSize; i >= 0; i--) {
      const t1 = output[frameIndex * outputSize * 3 + i];
      const v1 = output[frameIndex * outputSize * 3 + outputSize + i];
      const t2 = output[frameIndex * outputSize * 3 + outputSize * 2 + i];
      const v2 = output[nextFrameIndex * outputSize * 3 + outputSize + i];
      outValue[i] = v1 * part1 + v2 * part2 + t1 * part3 + t2 * part4;
    }
  }
  evaluateLinear(outValue, output, outputSize, frameIndex, nextFrameIndex, alpha) {
    switch (outputSize) {
      case 1:
        outValue[0] = output[frameIndex] * (1 - alpha) + output[nextFrameIndex] * alpha;
        break;
      case 4:
        this._quaSlerp(outValue, output, frameIndex * outputSize, output, nextFrameIndex * outputSize, alpha);
        break;
      default:
        for (let i = outputSize; i >= 0; i--) {
          outValue[i] = output[frameIndex * outputSize + i] * (1 - alpha) + output[nextFrameIndex * outputSize + i] * alpha;
        }
        break;
    }
  }
  _quaSlerp(out, a, aIndex, b, bIndex, t) {
    let ax = a[0 + aIndex], ay = a[1 + aIndex], az = a[2 + aIndex], aw = a[3 + aIndex];
    let bx = b[0 + bIndex], by = b[1 + bIndex], bz = b[2 + bIndex], bw = b[3 + bIndex];
    let omega, cosom, sinom, scale0, scale1;
    cosom = ax * bx + ay * by + az * bz + aw * bw;
    if (cosom < 0) {
      cosom = -cosom;
      bx = -bx;
      by = -by;
      bz = -bz;
      bw = -bw;
    }
    if (1 - cosom > 1e-6) {
      omega = Math.acos(cosom);
      sinom = Math.sin(omega);
      scale0 = Math.sin((1 - t) * omega) / sinom;
      scale1 = Math.sin(t * omega) / sinom;
    } else {
      scale0 = 1 - t;
      scale1 = t;
    }
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    return out;
  }
}
AnimationClip._tagetTypeMap = {
  position: 0,
  rotation: 1,
  scale: 2
};

class AnimationLayer extends EventDispatcher {
  get isPlaying() {
    return this._animClip && this._isPlaying;
  }
  constructor() {
    super(null);
    this.layerWeight = 1;
    this._activedEvents = [];
  }
  canMix(nextAnimClip, rootEntity) {
    if (!this._animClip || !this._isPlaying || this.isMixLayer || this.isFading) {
      return false;
    }
    if (this._animClip.getChannelCount() !== nextAnimClip.getChannelCount()) {
      return false;
    }
    const count = this._animClip.getChannelCount();
    for (let i = count - 1; i >= 0; i--) {
      const curChannel = this._animClip.getChannelObject(i);
      const curTargetObject = this._findChannelTarget(rootEntity, curChannel.target);
      const nextChannel = nextAnimClip.getChannelObject(i);
      const nextTargetObject = this._findChannelTarget(rootEntity, nextChannel.target);
      if (curTargetObject !== nextTargetObject) {
        return false;
      }
    }
    return true;
  }
  mix(animClip, targetLayer, rootEntity, mixEntity, options = {}) {
    this._isPlaying = targetLayer.isPlaying;
    this._animClip = animClip;
    this._wrapMode = typeof options.wrapMode !== "undefined" ? options.wrapMode : targetLayer._wrapMode;
    this._addEvents(options);
    this._channelStates = [];
    this._animClipLength = 0;
    if (this._isPlaying) {
      const targetChannelStates = targetLayer._channelStates;
      const count = this._animClip.getChannelCount();
      for (let i = count - 1; i >= 0; i--) {
        const channel = this._animClip.getChannelObject(i);
        const targetObject = this._findChannelTarget(mixEntity, channel.target);
        this._channelStates[i] = {
          frameTime: 0,
          currentFrame: 0,
          currentValue: this._animClip.createChannelValue(i),
          mixWeight: targetObject ? 1 : 0
        };
        targetChannelStates[i].mixWeight = targetChannelStates[i].mixWeight === void 0 ? 1 : targetChannelStates[i].mixWeight;
        if (targetChannelStates[i].mixWeight === 1) {
          targetChannelStates[i].mixWeight = targetObject ? 0 : 1;
        }
        const channelTimeLength = this._animClip.getChannelTimeLength(i);
        this._animClipLength = this._animClipLength > channelTimeLength ? this._animClipLength : channelTimeLength;
      }
      return true;
    }
    return false;
  }
  removeMixWeight() {
    const count = this._channelStates.length;
    for (let i = count - 1; i >= 0; i--) {
      if (this._channelStates[i].mixWeight === 1) {
        this.mixTagetLayer._channelStates[i].mixWeight = 1;
      }
    }
  }
  play(animClip, rootEntity, options = {wrapMode: WrapMode.LOOP}) {
    this._isPlaying = !!animClip;
    this._animClip = animClip;
    this._wrapMode = typeof options.wrapMode !== "undefined" ? options.wrapMode : WrapMode.LOOP;
    this._addEvents(options);
    this._channelStates = [];
    this._animClipLength = 0;
    if (this._isPlaying) {
      const count = this._animClip.getChannelCount();
      const channelTargets = [];
      for (let i = count - 1; i >= 0; i--) {
        const channel = this._animClip.getChannelObject(i);
        const targetObject = this._findChannelTarget(rootEntity, channel.target);
        if (!targetObject) {
          Logger.warn("Can not find channel target:" + channel.target.id);
        }
        this._channelStates[i] = {
          frameTime: 0,
          currentFrame: 0,
          currentValue: this._animClip.createChannelValue(i)
        };
        channelTargets[i] = {
          targetObject,
          path: channel.target.path,
          pathType: channel.target.pathType,
          outputSize: channel.sampler.outputSize
        };
        const channelTimeLength = this._animClip.getChannelTimeLength(i);
        this._animClipLength = this._animClipLength > channelTimeLength ? this._animClipLength : channelTimeLength;
      }
      return channelTargets;
    }
    return false;
  }
  stop(rightnow) {
    if (!this._animClip || !this._isPlaying) {
      return;
    }
    if (rightnow) {
      this._isPlaying = false;
    } else {
      this._wrapMode = WrapMode.ONCE;
    }
  }
  updateState(deltaTime) {
    if (!this._animClip || !this._isPlaying) {
      return;
    }
    if (this.isFading) {
      this.fadeDeltaTime += deltaTime;
      this.layerWeight = 1 - this.fadeDeltaTime / this.fadeDuration;
      if (this.layerWeight <= 0) {
        this._isPlaying = false;
      }
    } else if (this.crossFadeDuration) {
      this.crossFadeDeltaTime += deltaTime;
      this.layerWeight = this.crossFadeDeltaTime / this.crossFadeDuration;
      if (this.layerWeight >= 1) {
        this.layerWeight = 1;
        delete this.crossFadeDuration;
      }
    }
    deltaTime = deltaTime / 1e3;
    this._activeEvents(deltaTime);
    const count = this._animClip.getChannelCount();
    let playingCount = 0;
    for (let i = count - 1; i >= 0; i--) {
      if (this._updateChannelState(deltaTime, i)) {
        playingCount++;
      }
    }
    if (playingCount === 0) {
      this._isPlaying = false;
      if (this.isMixLayer) {
        this.removeMixWeight();
      }
    }
  }
  getChannelLayerWeight(channelIndex) {
    if ((this.hasMixLayer || this.isMixLayer) && channelIndex < this._channelStates.length) {
      const mixWeight = this._channelStates[channelIndex].mixWeight;
      const layerWeight = this.isMixLayer ? this.mixTagetLayer.layerWeight : this.layerWeight;
      return mixWeight * layerWeight;
    }
    return this.layerWeight;
  }
  getChannelValue(channelIndex) {
    return this._channelStates[channelIndex].currentValue;
  }
  triggerEvents() {
    this._activedEvents && this._activedEvents.forEach((event) => {
      this.trigger(event);
    });
    this._activedEvents.length = 0;
  }
  jumpToFrame(frameTime) {
    const count = this._animClip.getChannelCount();
    for (let i = count - 1; i >= 0; i--) {
      const channelState = this._channelStates[i];
      channelState.frameTime = 0;
      this._updateChannelState(frameTime, i);
    }
  }
  _updateChannelState(deltaTime, channelIndex) {
    const animClip = this._animClip;
    const channelState = this._channelStates[channelIndex];
    const animClipLength = animClip.getChannelTimeLength(channelIndex);
    channelState.frameTime += deltaTime;
    if (channelState.frameTime > animClipLength) {
      switch (this._wrapMode) {
        case WrapMode.ONCE:
          channelState.frameTime = animClipLength;
          break;
        case WrapMode.LOOP:
          channelState.frameTime = channelState.frameTime % this._animClipLength;
          break;
        default:
          Logger.error("Unknown Anim wrap Mode: " + this._wrapMode);
      }
    }
    if (channelState.mixWeight && channelState.mixWeight === 0) {
      return true;
    }
    const frameTime = Math.min(channelState.frameTime, animClipLength);
    const lerpState = this._getKeyAndAlpha(animClip.getChannelObject(channelIndex), frameTime);
    channelState.currentValue = animClip.evaluate(channelState.currentValue, channelIndex, lerpState.currentKey, lerpState.nextKey, lerpState.alpha);
    if (this._wrapMode === WrapMode.ONCE && channelState.frameTime >= animClipLength) {
      return false;
    }
    return true;
  }
  _addEvents(options) {
    this.removeAllEventListeners();
    this._frameEvents = [];
    if (options.events) {
      let frameEventIndex = 0;
      for (let i = options.events.length - 1; i >= 0; i--) {
        const event = options.events[i];
        let eventType = event.type;
        if (event.type === AnimationEventType.FRAME_EVENT) {
          eventType = "frameEvent" + frameEventIndex;
          frameEventIndex++;
          this._frameEvents.push({
            eventType,
            triggerTime: event.triggerTime,
            triggered: false
          });
        }
        this.addEventListener(eventType, (e) => {
          event.callback();
        });
      }
    }
  }
  _activeEvents(deltaTime) {
    const index = this._animClip.durationIndex;
    if (this._frameEvents.length > 0 && this._channelStates.length > 0) {
      const curFrameTime = this._channelStates[index].frameTime + deltaTime;
      for (let i = this._frameEvents.length - 1; i >= 0; i--) {
        const frameEvent = this._frameEvents[i];
        if (!frameEvent.triggered && curFrameTime > frameEvent.triggerTime) {
          this._activedEvents.push(new Event(frameEvent.eventType, this));
          frameEvent.triggered = true;
        }
      }
    }
    if (this._channelStates.length > 0 && this._channelStates[index].frameTime + deltaTime >= this._animClip.duration) {
      if (this._wrapMode === WrapMode.LOOP) {
        if (this._frameEvents.length > 0) {
          for (let i = this._frameEvents.length - 1; i >= 0; i--) {
            this._frameEvents[i].triggered = false;
          }
        }
        if (this.hasEvent(AnimationEventType.LOOP_END)) {
          this._activedEvents.push(new Event(AnimationEventType.LOOP_END, this));
        }
      } else if (this.hasEvent(AnimationEventType.FINISHED)) {
        this._activedEvents.push(new Event(AnimationEventType.FINISHED, this));
      }
    }
  }
  _findChannelTarget(rootNode, target) {
    const targetID = target.id;
    let targetSceneObject = null;
    if (rootNode.name === targetID) {
      targetSceneObject = rootNode;
    } else {
      targetSceneObject = rootNode.findByName(targetID);
    }
    if (target.path === "weights") {
      return targetSceneObject.getComponent(SkinnedMeshRenderer);
    } else {
      return targetSceneObject;
    }
  }
  _getKeyAndAlpha(channel, time) {
    let keyTime = 0;
    let currentKey = 0;
    let nextKey = 0;
    const timeKeys = channel.sampler.input;
    const numKeys = timeKeys.length;
    for (let i = numKeys - 1; i >= 0; i--) {
      if (time > timeKeys[i]) {
        keyTime = time - timeKeys[i];
        currentKey = i;
        break;
      }
    }
    nextKey = currentKey + 1;
    if (nextKey >= numKeys) {
      switch (this._wrapMode) {
        case WrapMode.ONCE:
          nextKey = numKeys - 1;
          break;
        case WrapMode.LOOP:
          nextKey = 0;
          break;
      }
    }
    const keyLength = timeKeys[nextKey] - timeKeys[currentKey];
    const alpha = nextKey === currentKey || keyLength < 1e-5 ? 1 : keyTime / keyLength;
    return {
      currentKey,
      nextKey,
      alpha
    };
  }
}

var __defProp$9 = Object.defineProperty;
var __getOwnPropDesc$9 = Object.getOwnPropertyDescriptor;
var __decorate$9 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$9(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$9(target, key, result);
  return result;
};
class Animation extends Component {
  constructor(entity) {
    super(entity);
    this._onUpdateIndex = -1;
    this._animSet = {};
    this._animLayers = [new AnimationLayer()];
    this._timeScale = 1;
  }
  get timeScale() {
    return this._timeScale;
  }
  set timeScale(val) {
    if (val > 0) {
      this._timeScale = val;
    }
  }
  static lerp(outValue, startValue, endValue, alpha, outputSize) {
    switch (outputSize) {
      case 1:
        outValue = startValue * (1 - alpha) + endValue * alpha;
        break;
      case 4:
        const start = new Quaternion(...startValue);
        const end = new Quaternion(...endValue);
        const quat = new Quaternion();
        Quaternion.slerp(start, end, alpha, quat);
        outValue[0] = quat.x;
        outValue[1] = quat.y;
        outValue[2] = quat.z;
        outValue[3] = quat.w;
        break;
      default:
        for (let i = outputSize; i >= 0; i--) {
          outValue[i] = startValue[i] * (1 - alpha) + endValue[i] * alpha;
        }
        break;
    }
    return outValue;
  }
  update(deltaTime) {
    if (!this.isPlaying()) {
      return;
    }
    deltaTime = deltaTime * this._timeScale;
    for (let i = this._animLayers.length - 1; i >= 0; i--) {
      const animLayer = this._animLayers[i];
      animLayer.updateState(deltaTime);
    }
    this._updateValues();
    for (let i = this._animLayers.length - 1; i >= 0; i--) {
      const animLayer = this._animLayers[i];
      animLayer.triggerEvents();
      if (!animLayer.isPlaying && (animLayer.isFading || animLayer.isMixLayer)) {
        this._animLayers.splice(i, 1);
        this._removeRefMixLayers(animLayer);
      }
    }
  }
  addAnimationClip(animClip, name) {
    this._animSet[name] = animClip;
  }
  removeAnimationClip(name) {
    const animClip = this._animSet[name];
    if (animClip) {
      delete this._animSet[name];
    }
  }
  getAnimationClipLength(name) {
    const animClip = this._animSet[name];
    if (animClip) {
      return animClip.getChannelTimeLength(0);
    } else {
      return 0;
    }
  }
  getAnimationClip(name) {
    return this._animSet[name] || null;
  }
  isPlaying() {
    for (let i = this._animLayers.length - 1; i >= 0; i--) {
      if (this._animLayers[i].isPlaying) {
        return true;
      }
    }
    return false;
  }
  playAnimationClip(name, options) {
    const animClip = this._animSet[name];
    if (!animClip) {
      Logger.error("can not find anim clip: " + name);
      return;
    }
    let animLayer = null;
    for (let i = this._animLayers.length - 1; i >= 0; i--) {
      if (!this._animLayers[i].isFading && !this._animLayers[i].isMixLayer) {
        animLayer = this._animLayers[i];
        break;
      }
    }
    if (!animLayer) {
      animLayer = new AnimationLayer();
      this._animLayers.push(animLayer);
    }
    this._removeRefMixLayers(animLayer);
    this._channelTargets = animLayer.play(animClip, this.entity, options);
  }
  crossFade(name, crossFadeDuration, options) {
    const animClip = this._animSet[name];
    if (!animClip) {
      Logger.error("can not find anim clip: " + name);
      return;
    }
    if (!crossFadeDuration || crossFadeDuration < 0) {
      Logger.error("crossFadeDuration can not less than 0!");
      return;
    }
    let targetAnimLayer = null;
    for (let i = this._animLayers.length - 1; i >= 0; i--) {
      if (this._animLayers[i].canMix(animClip, this.entity)) {
        targetAnimLayer = this._animLayers[i];
        break;
      }
    }
    if (targetAnimLayer) {
      for (let i = this._animLayers.length - 1; i >= 0; i--) {
        if (this._animLayers[i].isFading) {
          this._animLayers.splice(i, 1);
        }
      }
      targetAnimLayer.isFading = true;
      targetAnimLayer.fadeDuration = crossFadeDuration;
      targetAnimLayer.fadeDeltaTime = 0;
      const animLayer = new AnimationLayer();
      animLayer.crossFadeDuration = crossFadeDuration;
      animLayer.crossFadeDeltaTime = 0;
      animLayer.play(animClip, this.entity, options);
      this._animLayers.push(animLayer);
    } else {
      this.playAnimationClip(name, options);
    }
  }
  mix(name, mixBoneName, options) {
    const animClip = this._animSet[name];
    if (!animClip) {
      Logger.error("can not find anim clip: " + name);
      return;
    }
    const mixNode = this.entity.findByName(mixBoneName);
    if (!mixNode) {
      Logger.error("can not find mix bone!");
      return;
    }
    let targetAnimLayer = null;
    for (let i = this._animLayers.length - 1; i >= 0; i--) {
      if (this._animLayers[i].canMix(animClip, this.entity)) {
        targetAnimLayer = this._animLayers[i];
        break;
      }
    }
    if (targetAnimLayer) {
      this._removeRefMixLayers(null, mixNode);
      targetAnimLayer.hasMixLayer = true;
      const animLayer = new AnimationLayer();
      animLayer.isMixLayer = true;
      animLayer.mixTagetLayer = targetAnimLayer;
      animLayer.mixEntity = mixNode;
      animLayer.mix(animClip, targetAnimLayer, this.entity, mixNode, options);
      this._animLayers.push(animLayer);
    }
  }
  stop(rightnow) {
    for (let i = this._animLayers.length - 1; i >= 0; i--) {
      if (this._animLayers[i].isFading) {
        this._animLayers.splice(i, 1);
      } else {
        this._animLayers[i].stop(rightnow);
      }
    }
  }
  jumpToFrame(frameTime) {
    frameTime = frameTime / 1e3;
    for (let i = this._animLayers.length - 1; i >= 0; i--) {
      this._animLayers[i].jumpToFrame(frameTime);
    }
    this._updateValues();
  }
  _removeRefMixLayers(targetLayer, mixNode) {
    if (targetLayer && targetLayer.hasMixLayer) {
      for (let i = this._animLayers.length - 1; i >= 0; i--) {
        const animLayer = this._animLayers[i];
        if (animLayer.isMixLayer && animLayer.mixTagetLayer === targetLayer) {
          animLayer.removeMixWeight();
          this._animLayers.splice(i, 1);
        }
      }
    }
    if (mixNode) {
      for (let i = this._animLayers.length - 1; i >= 0; i--) {
        const animLayer = this._animLayers[i];
        if (animLayer.isMixLayer && (animLayer.mixEntity === mixNode || animLayer.mixEntity.findByName(mixNode) || mixNode.findByName(animLayer.mixEntity))) {
          animLayer.removeMixWeight();
          this._animLayers.splice(i, 1);
        }
      }
    }
  }
  _updateValues() {
    if (this._animLayers.length === 0 || !this._channelTargets) {
      return;
    }
    for (let i = this._channelTargets.length - 1; i >= 0; i--) {
      const channelTarget = this._channelTargets[i];
      const val = this._getChannelValue(i, channelTarget.outputSize);
      const targetObject = channelTarget.targetObject;
      const path = channelTarget.path;
      if (path === "weights") {
        targetObject.setWeights(val);
      } else {
        const v = val;
        const transform = targetObject.transform;
        switch (channelTarget.pathType) {
          case TagetType.position:
            const position = transform.position;
            position.setValue(v[0], v[1], v[2]);
            transform.position = position;
            break;
          case TagetType.rotation:
            const rotation = transform.rotationQuaternion;
            rotation.setValue(v[0], v[1], v[2], v[3]);
            transform.rotationQuaternion = rotation;
            break;
          case TagetType.scale:
            const scale = transform.scale;
            scale.setValue(v[0], v[1], v[2]);
            transform.scale = scale;
            break;
          default:
            targetObject[path] = val;
        }
      }
    }
  }
  _getChannelValue(channelIndex, outputSize) {
    const weights = [];
    const values = [];
    for (let i = this._animLayers.length - 1; i >= 0; i--) {
      const weight = this._animLayers[i].getChannelLayerWeight(channelIndex);
      if (weight > 0) {
        weights.push(weight);
        values.push(this._animLayers[i].getChannelValue(channelIndex));
      }
    }
    if (values.length === 1) {
      return values[0];
    } else if (values.length === 2) {
      return Animation.lerp(values[0], values[0], values[1], weights[1], outputSize);
    }
    Logger.error("Can not get channel value!");
    return false;
  }
  _onEnable() {
    this.engine._componentsManager.addOnUpdateAnimations(this);
  }
  _onDisable() {
    this.engine._componentsManager.removeOnUpdateAnimations(this);
  }
}
__decorate$9([
  ignoreClone
], Animation.prototype, "_onUpdateIndex", 2);
__decorate$9([
  shallowClone
], Animation.prototype, "_animSet", 2);
__decorate$9([
  ignoreClone
], Animation.prototype, "_animLayers", 2);
__decorate$9([
  ignoreClone
], Animation.prototype, "_timeScale", 2);
__decorate$9([
  ignoreClone
], Animation.prototype, "_channelTargets", 2);

var VertexShader = "#include <common>\n#include <common_vert>\n#include <uv_share>\n#include <normal_share>\n#include <worldpos_share>\n#include <shadow_share>\n#include <morph_target_vert>\n\n#include <fog_share>\n\nvoid main() {\n\n    #include <begin_position_vert>\n    #include <begin_normal_vert>\n\n    #include <morph_vert>\n    #include <skinning_vert>\n    #include <uv_vert>\n    #include <normal_vert>\n    #include <worldpos_vert>\n    #include <shadow_vert>\n    #include <position_vert>\n\n    #include <fog_vert>\n\n}\n";

class CommonMaterial extends Material {
  constructor(engine, name) {
    super(engine, name);
    this.renderStates = {
      enable: [],
      disable: [],
      functions: {}
    };
    this.emission = new Vector4(0, 0, 0, 1);
    this.ambient = new Vector4(0, 0, 0, 1);
    this.renderStates = {};
  }
  get emission() {
    return this.getValue("u_emission");
  }
  set emission(val) {
    this.setValue("u_emission", val);
  }
  get ambient() {
    return this.getValue("u_ambient");
  }
  set ambient(val) {
    this.setValue("u_ambient", val);
  }
  prepareDrawing(context, component, primitive) {
    const camera = context.camera;
    const lightMgr = camera.scene.findFeature(LightFeature);
    lightMgr.bindMaterialValues(this);
    const {ambientLightCount} = lightMgr.lightSortAmount;
    if (!this._technique || this._ambientLightCount !== ambientLightCount) {
      this._ambientLightCount = ambientLightCount;
      this._generateTechnique();
      this.bindLightUniformDefine(camera);
    }
    super.prepareDrawing(context, component, primitive);
  }
  bindLightUniformDefine(camera) {
    const lightMgr = camera.scene.findFeature(LightFeature);
    this._technique.uniforms = {
      ...lightMgr.getUniformDefine(),
      ...this._technique.uniforms
    };
  }
  _internalGenerate(name, fragmentShader) {
    const customMacros = this._generateMacros();
    const uniforms = this._generateFragmentUniform();
    const tech = new RenderTechnique(name);
    tech.isValid = true;
    tech.uniforms = uniforms;
    tech.attributes = {};
    tech.states = this.renderStates;
    tech.customMacros = customMacros;
    tech.vertexShader = VertexShader;
    tech.fragmentShader = fragmentShader;
    this._technique = tech;
  }
  _generateMacros() {
    const macros = [];
    if (this.emission instanceof Texture2D)
      macros.push("O3_EMISSION_TEXTURE");
    if (this.ambient instanceof Texture2D)
      macros.push("O3_AMBIENT_TEXTURE");
    if (this._ambientLightCount) {
      macros.push("O3_HAS_AMBIENT_LIGHT");
    }
    return macros;
  }
  _generateFragmentUniform() {
    const fragmentUniform = {
      u_emission: {
        name: "u_emission",
        type: DataType.FLOAT_VEC4
      },
      u_ambient: {
        name: "u_ambient",
        type: DataType.FLOAT_VEC4
      }
    };
    if (this.emission instanceof Texture2D) {
      fragmentUniform.u_emission.type = DataType.SAMPLER_2D;
    }
    if (this.ambient instanceof Texture2D) {
      fragmentUniform.u_ambient.type = DataType.SAMPLER_2D;
    }
    return fragmentUniform;
  }
}

var ConstantShader = "#include <common>\n#include <common_frag>\n#include <uv_share>\n#include <mobile_material_frag>\n\n#include <fog_share>\n#include <ambient_light_frag>\n\nvoid main() {\n\n    #include <begin_mobile_frag>\n\n    gl_FragColor = emission + ambient;\n\n    #include <fog_frag>\n\n}\n";

class ConstantMaterial extends CommonMaterial {
  _generateTechnique() {
    this._internalGenerate("ConstantMaterial", ConstantShader);
  }
}

var LambertShader = "#include <common>\n#include <common_frag>\n#include <uv_share>\n#include <normal_share>\n\n#include <ambient_light_frag>\n#include <direct_light_frag>\n#include <mobile_material_frag>\n\n#include <fog_share>\n\nvoid main() {\n\n    #include <begin_mobile_frag>\n    #include <begin_normal_frag>\n    #include <mobile_lambert_frag>\n\n    gl_FragColor = emission + ambient + diffuse;\n\n    #include <fog_frag>\n\n}\n";

class LambertMaterial extends CommonMaterial {
  constructor(engine, name) {
    super(engine, name);
    this._directLightCount = 0;
    this.diffuse = new Vector4(1, 1, 1, 1);
  }
  get diffuse() {
    return this.getValue("u_diffuse");
  }
  set diffuse(val) {
    this.setValue("u_diffuse", val);
  }
  _generateTechnique() {
    this._internalGenerate("LambertMaterial", LambertShader);
  }
  prepareDrawing(context, component, primitive) {
    const camera = context.camera;
    const scene = camera.scene;
    const lightMgr = scene.findFeature(LightFeature);
    const {directLightCount} = lightMgr.lightSortAmount;
    if (this._technique === null || this._directLightCount != directLightCount) {
      this._directLightCount = directLightCount;
      this._generateTechnique();
      this.bindLightUniformDefine(camera);
    }
    super.prepareDrawing(context, component, primitive);
  }
  _generateFragmentUniform() {
    let uniforms = {};
    if (this.diffuse instanceof Texture2D) {
      uniforms.u_diffuse = {
        name: "u_diffuse",
        type: DataType.SAMPLER_2D
      };
    } else {
      uniforms.u_diffuse = {
        name: "u_diffuse",
        type: DataType.FLOAT_VEC4
      };
    }
    const baseUniforms = super._generateFragmentUniform();
    return Object.assign(baseUniforms, uniforms);
  }
  _generateMacros() {
    const macros = super._generateMacros();
    macros.push("O3_NEED_WORLDPOS");
    if (this._directLightCount > 0)
      macros.push(`O3_DIRECT_LIGHT_COUNT ${this._directLightCount}`);
    if (this.diffuse instanceof Texture2D)
      macros.push("O3_DIFFUSE_TEXTURE");
    return macros;
  }
}

var BlinnPhongShader = "#include <common>\n#include <common_frag>\n\n#include <uv_share>\n#include <normal_share>\n#include <worldpos_share>\n\n#include <ambient_light_frag>\n#include <direct_light_frag>\n#include <point_light_frag>\n#include <spot_light_frag>\n#include <mobile_material_frag>\n\n#include <fog_share>\n\nvoid main() {\n\n    #include <begin_mobile_frag>\n    #include <begin_normal_frag>\n    #include <begin_viewdir_frag>\n    #include <mobile_blinnphong_frag>\n\n    gl_FragColor = emission + ambient + diffuse + specular;\n\n    #include <fog_frag>\n\n}\n";

class BlinnPhongMaterial extends CommonMaterial {
  constructor(engine, name) {
    super(engine, name);
    this._directLightCount = 0;
    this._pointLightCount = 0;
    this._spotLightCount = 0;
    this.diffuse = new Vector4(1, 1, 1, 1);
    this.specular = new Vector4(1, 1, 1, 1);
    this.shininess = 16;
  }
  get diffuse() {
    return this.getValue("u_diffuse");
  }
  set diffuse(val) {
    this.setValue("u_diffuse", val);
  }
  get specular() {
    return this.getValue("u_specular");
  }
  set specular(val) {
    this.setValue("u_specular", val);
  }
  get shininess() {
    return this.getValue("u_shininess");
  }
  set shininess(val) {
    this.setValue("u_shininess", val);
  }
  _generateTechnique() {
    this._internalGenerate("BlinnPhongMaterial", BlinnPhongShader);
  }
  _generateMacros() {
    const macros = super._generateMacros();
    macros.push("O3_NEED_WORLDPOS");
    if (this.diffuse instanceof Texture2D)
      macros.push("O3_DIFFUSE_TEXTURE");
    if (this.specular instanceof Texture2D)
      macros.push("O3_SPECULAR_TEXTURE");
    if (this._directLightCount > 0)
      macros.push(`O3_DIRECT_LIGHT_COUNT ${this._directLightCount}`);
    if (this._pointLightCount > 0)
      macros.push(`O3_POINT_LIGHT_COUNT ${this._pointLightCount}`);
    if (this._spotLightCount > 0)
      macros.push(`O3_SPOT_LIGHT_COUNT ${this._spotLightCount}`);
    return macros;
  }
  prepareDrawing(context, component, primitive) {
    const camera = context.camera;
    const scene = camera.scene;
    const lightMgr = scene.findFeature(LightFeature);
    const {directLightCount, pointLightCount, spotLightCount} = lightMgr.lightSortAmount;
    if (this._technique === null || this._directLightCount != directLightCount || this._pointLightCount != pointLightCount || this._spotLightCount != spotLightCount) {
      this._directLightCount = directLightCount;
      this._pointLightCount = pointLightCount;
      this._spotLightCount = spotLightCount;
      this._generateTechnique();
      this.bindLightUniformDefine(camera);
    }
    super.prepareDrawing(context, component, primitive);
  }
  _generateFragmentUniform() {
    let uniforms = {};
    if (this.diffuse instanceof Texture2D) {
      uniforms.u_diffuse = {
        name: "u_diffuse",
        type: DataType.SAMPLER_2D
      };
    } else {
      uniforms.u_diffuse = {
        name: "u_diffuse",
        type: DataType.FLOAT_VEC4
      };
    }
    if (this.specular instanceof Texture2D) {
      uniforms.u_specular = {
        name: "u_specular",
        type: DataType.SAMPLER_2D
      };
    } else {
      uniforms.u_specular = {
        name: "u_specular",
        type: DataType.FLOAT_VEC4
      };
    }
    uniforms.u_shininess = {
      name: "u_shininess",
      type: DataType.FLOAT
    };
    const baseUniforms = super._generateFragmentUniform();
    return Object.assign(baseUniforms, uniforms);
  }
}

var FRAG_SHADER = "#include <common>\n#include <common_frag>\n\nuniform sampler2D u_diffuse;\nvarying vec3 v_pos;\nuniform vec4 u_tintColor;\nuniform float u_opacity;\n\nvoid main()\n{\n  #ifdef O3_DIFFUSE_TEXTURE\n    gl_FragColor = texture2D(u_diffuse, v_uv);\n  #else\n    gl_FragColor = vec4(1);\n  #endif\n}\n";

class TextureMaterial extends CommonMaterial {
  constructor(engine, name) {
    super(engine, name || "TextureMaterial");
  }
  _generateTechnique() {
    this._internalGenerate("Texture", FRAG_SHADER);
  }
  setValue(name, value) {
    if (name === "doubleSided") {
      this._setDoubleSidedDisplay(value);
    }
    super.setValue(name, value);
  }
  set texture(v) {
    this.setValue("u_diffuse", v);
  }
  get texture() {
    return this.getValue("u_diffuse");
  }
  set doubleSided(v) {
    this.setValue("doubleSided", v);
  }
  get doubleSided() {
    return this.getValue("doubleSided");
  }
  _generateFragmentUniform() {
    const uniforms = {};
    if (this.texture instanceof Texture2D) {
      uniforms.u_diffuse = {
        name: "u_diffuse",
        paramName: "_MainTex",
        type: DataType.SAMPLER_2D
      };
    }
    return {
      ...super._generateFragmentUniform(),
      ...uniforms
    };
  }
  _generateMacros() {
    const macros = super._generateMacros();
    if (this.texture instanceof Texture2D)
      macros.push("O3_DIFFUSE_TEXTURE");
    return macros;
  }
  _setDoubleSidedDisplay(value) {
    this._technique.states.disable = [];
    if (value) {
      this._technique.states.disable.push(RenderState.CULL_FACE);
    }
  }
}
TextureMaterial.TECH_NAME = "Texture";

class TransparentMaterial extends CommonMaterial {
  constructor(engine, name) {
    super(engine, name || "TransparentMaterial");
  }
  _generateTechnique() {
    this.renderStates = {
      enable: [RenderState.BLEND],
      disable: [RenderState.CULL_FACE],
      functions: {
        blendFunc: [BlendFunc.SRC_ALPHA, BlendFunc.ONE_MINUS_SRC_ALPHA],
        depthMask: [false]
      }
    };
    this.renderType = MaterialType.TRANSPARENT;
    this._internalGenerate("Transparent", FRAG_SHADER);
  }
  set texture(v) {
    this.setValue("u_diffuse", v);
  }
  get texture() {
    return this.getValue("u_diffuse");
  }
  _generateFragmentUniform() {
    const uniforms = {};
    if (this.texture instanceof Texture2D) {
      uniforms.u_diffuse = {
        name: "u_diffuse",
        paramName: "_MainTex",
        type: DataType.SAMPLER_2D
      };
    }
    return {
      ...super._generateFragmentUniform(),
      ...uniforms
    };
  }
  _generateMacros() {
    const macros = super._generateMacros();
    if (this.texture instanceof Texture2D)
      macros.push("O3_DIFFUSE_TEXTURE");
    return macros;
  }
}
TransparentMaterial.TECH_NAME = "Transparent";

class ShaderMaterial extends Material {
  constructor(engine, name) {
    super(engine, name);
    this.vertexShader = "";
    this.fragmentShader = "";
    this.isValid = true;
    this.attributes = {};
    this._uniforms = ShaderMaterial.commonUniforms;
    this._renderStates = {
      enable: [],
      disable: [],
      functions: {}
    };
    this._enableConfig = [];
    this._disableConfig = [];
    this._functionsConfig = {
      blendFunc: [BlendFunc.SRC_ALPHA, BlendFunc.ONE_MINUS_SRC_ALPHA]
    };
  }
  prepareDrawing(context, component, primitive) {
    const camera = context.camera;
    if (!this._technique) {
      const tech = this._generateTechnique(camera, component, primitive);
      this._technique = tech;
    }
    super.prepareDrawing(context, component, primitive);
  }
  updateTechnique() {
    this._technique = null;
  }
  _generateTechnique(camera, component, primitive) {
    const tech = new RenderTechnique("ShaderMaterial");
    tech.isValid = this.isValid;
    tech.uniforms = this.uniforms;
    tech.attributes = this.attributes;
    tech.states = this.renderStates;
    tech.vertexShader = this.vertexShader;
    tech.fragmentShader = this.fragmentShader;
    return tech;
  }
  addState(key, state) {
    this.renderStates[key] = union(this.renderStates[key], state);
  }
  removeState(key, state) {
    this.renderStates[key] = this.renderStates[key].filter((value) => value !== state);
  }
  get renderStates() {
    return this._renderStates;
  }
  set renderStates(value) {
    const {enable = [], disable = [], functions = {}} = value;
    const enableState = enable.filter((value2) => ShaderMaterial.commonEnable.indexOf(value2) < 0);
    const disableState = disable.filter((value2) => ShaderMaterial.commonDisable.indexOf(value2) < 0);
    this._renderStates.enable = union(enableState, this._enableConfig);
    this._renderStates.disable = union(disableState, this._disableConfig);
    this._renderStates.functions = Object.assign({}, functions, this._functionsConfig);
  }
  get uniforms() {
    return this._uniforms;
  }
  set uniforms(value) {
    this._uniforms = Object.assign({}, ShaderMaterial.commonUniforms, value);
  }
  set blend(value) {
    if (value) {
      this._enableConfig = union(this._enableConfig, [RenderState.BLEND]);
    } else {
      this._enableConfig = this._enableConfig.filter((state) => state !== RenderState.BLEND);
      this.removeState("enable", RenderState.BLEND);
    }
    this.renderStates = this._renderStates;
  }
  set blendSrcFactor(value) {
    this._functionsConfig.blendFunc[0] = value;
    this.renderStates = this._renderStates;
  }
  set blendDstFactor(value) {
    this._functionsConfig.blendFunc[1] = value;
    this.renderStates = this._renderStates;
  }
  set doubleSide(value) {
    if (value) {
      this._disableConfig = union(this._disableConfig, [RenderState.CULL_FACE]);
    } else {
      this._disableConfig = this._disableConfig.filter((state) => state !== RenderState.CULL_FACE);
      this.removeState("disable", RenderState.CULL_FACE);
    }
    this.renderStates = this._renderStates;
  }
  set depthTest(value) {
    if (!value) {
      this._disableConfig = union(this._disableConfig, [RenderState.DEPTH_TEST]);
    } else {
      this._disableConfig = this._disableConfig.filter((state) => state !== RenderState.DEPTH_TEST);
      this.removeState("disable", RenderState.DEPTH_TEST);
    }
    this.renderStates = this._renderStates;
  }
}
ShaderMaterial.commonUniforms = {
  matModelViewProjection: {
    name: "matModelViewProjection",
    semantic: UniformSemantic.MODELVIEWPROJECTION,
    type: DataType.FLOAT_MAT4
  },
  matModelView: {
    name: "matModelView",
    semantic: UniformSemantic.MODELVIEW,
    type: DataType.FLOAT_MAT4
  }
};
ShaderMaterial.commonEnable = [RenderState.BLEND];
ShaderMaterial.commonDisable = [RenderState.CULL_FACE, RenderState.DEPTH_TEST];
function union(arr1, arr2) {
  return arr1.concat(arr2.filter((v) => !(arr1.indexOf(v) > -1)));
}

class BufferGeometry extends EngineObject {
  constructor(engine, name) {
    super(engine);
    this._subGeometries = [];
    this._primitive = new Primitive(engine);
    this.name = name;
  }
  get vertexBufferBindings() {
    return this._primitive.vertexBufferBindings;
  }
  get indexBufferBinding() {
    return this._primitive.indexBufferBinding;
  }
  get vertexElements() {
    return this._primitive.vertexElements;
  }
  get subGeometry() {
    return this._subGeometries[0] || null;
  }
  get subGeometries() {
    return this._subGeometries;
  }
  get instanceCount() {
    return this._primitive.instanceCount;
  }
  set instanceCount(count) {
    this._primitive.instanceCount = count;
  }
  get bounds() {
    return this._bounds;
  }
  set bounds(value) {
    this._bounds = value;
  }
  setVertexBufferBinding(bufferOrBinding, stride = 0, firstIndex = 0) {
    this._primitive.setVertexBufferBinding(bufferOrBinding, stride, firstIndex);
  }
  setVertexBufferBindings(vertexBufferBindings, firstIndex = 0) {
    this._primitive.setVertexBufferBindings(vertexBufferBindings, firstIndex);
  }
  setIndexBufferBinding(bufferOrBinding, format) {
    this._primitive.setIndexBufferBinding(bufferOrBinding, format);
  }
  setVertexElements(elements) {
    this._primitive.setVertexElements(elements);
  }
  addSubGeometry(start, count, topology = PrimitiveTopology.Triangles) {
    const subGeometry = new SubPrimitive(start, count, topology);
    this._subGeometries.push(subGeometry);
    return subGeometry;
  }
  removeSubGeometry(subGeometry) {
    const subGeometries = this._subGeometries;
    const index = subGeometries.indexOf(subGeometry);
    if (index !== -1) {
      subGeometries.splice(index, 1);
    }
  }
  clearSubGeometry() {
    this._subGeometries.length = 0;
  }
  destroy() {
    if (this._primitive) {
      this._primitive.destroy();
      this._primitive = null;
    }
  }
}

class GeometryRenderer extends RenderableComponent {
  set geometry(value) {
    if (this._geometry) {
      this._geometry._primitive._addRefCount(-1);
    }
    value._primitive._addRefCount(1);
    this._geometry = value;
  }
  get geometry() {
    return this._geometry;
  }
  set material(value) {
    if (this._material) {
      this._material._addRefCount(-1);
    }
    value._addRefCount(1);
    this._material = value;
  }
  get material() {
    return this._material;
  }
  render(camera) {
    const geometry = this.geometry;
    if (geometry) {
      const subGeometries = geometry.subGeometries;
      const renderPipeline = camera._renderPipeline;
      const material = this._material;
      for (let i = 0, n = subGeometries.length; i < n; i++) {
        if (material) {
          const element = RenderElement.getFromPool();
          element.setValue(this, geometry._primitive, subGeometries[i], material);
          renderPipeline.pushPrimitive(element);
        }
      }
    } else {
      Logger.error("geometry is null.");
    }
  }
  _updateBounds(worldBounds) {
    const localBounds = this._geometry.bounds;
    if (localBounds) {
      const worldMatrix = this._entity.transform.worldMatrix;
      Vector3.transformCoordinate(localBounds.min, worldMatrix, worldBounds.min);
      Vector3.transformCoordinate(localBounds.max, worldMatrix, worldBounds.max);
    } else {
      worldBounds.min.setValue(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);
      worldBounds.max.setValue(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);
    }
  }
}

class ShapeGeometry extends BufferGeometry {
  _initialize(engine, vertices, indices) {
    const vertexStride = 32;
    const vertexElements = [
      new VertexElement("POSITION", 0, VertexElementFormat.Vector3, 0),
      new VertexElement("NORMAL", 12, VertexElementFormat.Vector3, 0),
      new VertexElement("TEXCOORD_0", 24, VertexElementFormat.Vector2, 0)
    ];
    this._initBuffer(engine, vertices, indices, vertexStride, vertexElements);
  }
  _initBuffer(engine, vertices, indices, vertexStride, vertexElements) {
    const positionElement = vertexElements[0];
    const vertexBuffer = new Buffer(engine, BufferBindFlag.VertexBuffer, vertices, BufferUsage.Static);
    const indexBuffer = new Buffer(engine, BufferBindFlag.IndexBuffer, indices, BufferUsage.Static);
    this.setVertexBufferBinding(vertexBuffer, vertexStride);
    this.setIndexBufferBinding(indexBuffer, IndexFormat.UInt16);
    this.setVertexElements(vertexElements);
    this.addSubGeometry(0, indices.length);
    this._computeBounds(positionElement, vertices);
  }
  _computeBounds(positionElement, vertices) {
    const vertexElement = positionElement;
    const bufferIndex = vertexElement.bindingIndex;
    const vertexBufferBinding = this._primitive.vertexBufferBindings[bufferIndex];
    const stride = vertexBufferBinding.stride;
    const offset = vertexElement.offset;
    const vertexCount = vertexBufferBinding.buffer.byteLength / stride;
    let arrayBuffer = vertices;
    if (!(arrayBuffer instanceof ArrayBuffer)) {
      arrayBuffer = arrayBuffer.buffer;
    }
    const dataView = new DataView(arrayBuffer, offset);
    let min = new Vector3(Infinity, Infinity, Infinity);
    let max = new Vector3(-Infinity, -Infinity, -Infinity);
    for (let i = 0; i < vertexCount; i++) {
      const base = offset + stride * i;
      const position = new Vector3(dataView.getFloat32(base, true), dataView.getFloat32(base + 4, true), dataView.getFloat32(base + 8, true));
      Vector3.min(min, position, min);
      Vector3.max(max, position, max);
    }
    let bounds = this.bounds;
    if (bounds) {
      min.cloneTo(bounds.min);
      max.cloneTo(bounds.max);
    } else {
      bounds = {min, max};
      this.bounds = bounds;
    }
  }
}

class CuboidGeometry extends ShapeGeometry {
  constructor(engine, width = 1, height = 1, depth = 1) {
    super(engine);
    const halfWidth = width / 2;
    const halfHeight = height / 2;
    const halfDepth = depth / 2;
    const vertices = new Float32Array([
      -halfWidth,
      halfHeight,
      -halfDepth,
      0,
      1,
      0,
      0,
      0,
      halfWidth,
      halfHeight,
      -halfDepth,
      0,
      1,
      0,
      1,
      0,
      halfWidth,
      halfHeight,
      halfDepth,
      0,
      1,
      0,
      1,
      1,
      -halfWidth,
      halfHeight,
      halfDepth,
      0,
      1,
      0,
      0,
      1,
      -halfWidth,
      -halfHeight,
      -halfDepth,
      0,
      -1,
      0,
      0,
      1,
      halfWidth,
      -halfHeight,
      -halfDepth,
      0,
      -1,
      0,
      1,
      1,
      halfWidth,
      -halfHeight,
      halfDepth,
      0,
      -1,
      0,
      1,
      0,
      -halfWidth,
      -halfHeight,
      halfDepth,
      0,
      -1,
      0,
      0,
      0,
      -halfWidth,
      halfHeight,
      -halfDepth,
      -1,
      0,
      0,
      0,
      0,
      -halfWidth,
      halfHeight,
      halfDepth,
      -1,
      0,
      0,
      1,
      0,
      -halfWidth,
      -halfHeight,
      halfDepth,
      -1,
      0,
      0,
      1,
      1,
      -halfWidth,
      -halfHeight,
      -halfDepth,
      -1,
      0,
      0,
      0,
      1,
      halfWidth,
      halfHeight,
      -halfDepth,
      1,
      0,
      0,
      1,
      0,
      halfWidth,
      halfHeight,
      halfDepth,
      1,
      0,
      0,
      0,
      0,
      halfWidth,
      -halfHeight,
      halfDepth,
      1,
      0,
      0,
      0,
      1,
      halfWidth,
      -halfHeight,
      -halfDepth,
      1,
      0,
      0,
      1,
      1,
      -halfWidth,
      halfHeight,
      halfDepth,
      0,
      0,
      1,
      0,
      0,
      halfWidth,
      halfHeight,
      halfDepth,
      0,
      0,
      1,
      1,
      0,
      halfWidth,
      -halfHeight,
      halfDepth,
      0,
      0,
      1,
      1,
      1,
      -halfWidth,
      -halfHeight,
      halfDepth,
      0,
      0,
      1,
      0,
      1,
      -halfWidth,
      halfHeight,
      -halfDepth,
      0,
      0,
      -1,
      1,
      0,
      halfWidth,
      halfHeight,
      -halfDepth,
      0,
      0,
      -1,
      0,
      0,
      halfWidth,
      -halfHeight,
      -halfDepth,
      0,
      0,
      -1,
      0,
      1,
      -halfWidth,
      -halfHeight,
      -halfDepth,
      0,
      0,
      -1,
      1,
      1
    ]);
    const indices = new Uint16Array([
      0,
      2,
      1,
      2,
      0,
      3,
      4,
      6,
      7,
      6,
      4,
      5,
      8,
      10,
      9,
      10,
      8,
      11,
      12,
      14,
      15,
      14,
      12,
      13,
      16,
      18,
      17,
      18,
      16,
      19,
      20,
      22,
      23,
      22,
      20,
      21
    ]);
    this._initialize(engine, vertices, indices);
  }
}

class SphereGeometry extends ShapeGeometry {
  constructor(engine, radius = 1, horizontalSegments = 8, verticalSegments = 6, alphaStart = 0, alphaRange = Math.PI * 2, thetaStart = 0, thetaRange = Math.PI) {
    super(engine);
    this._parameters = {
      radius: radius || 1,
      horizontalSegments: Math.max(3, Math.floor(horizontalSegments)),
      verticalSegments: Math.max(2, Math.floor(verticalSegments)),
      alphaStart,
      alphaRange,
      thetaStart,
      thetaRange
    };
    this._thetaEnd = this._parameters.thetaStart + this._parameters.thetaRange;
    this.initialize(engine);
  }
  initialize(engine) {
    const {verticalSegments, horizontalSegments} = this._parameters;
    let index = 0;
    const grid = [];
    const vertices = new Float32Array((verticalSegments + 1) * (horizontalSegments + 1) * 8);
    const indices = [];
    for (let iy = 0; iy <= verticalSegments; iy++) {
      const verticesRow = [];
      const v = iy / verticalSegments;
      for (let ix = 0; ix <= horizontalSegments; ix++) {
        const u = ix / horizontalSegments;
        let posX = -this._parameters.radius * Math.cos(this._parameters.alphaStart + u * this._parameters.alphaRange) * Math.sin(this._parameters.thetaStart + v * this._parameters.thetaRange);
        let posY = this._parameters.radius * Math.cos(this._parameters.thetaStart + v * this._parameters.thetaRange);
        let posZ = this._parameters.radius * Math.sin(this._parameters.alphaStart + u * this._parameters.alphaRange) * Math.sin(this._parameters.thetaStart + v * this._parameters.thetaRange);
        posX = Math.abs(posX) < 1e-6 ? 0 : posX;
        posY = Math.abs(posY) < 1e-6 ? 0 : posY;
        posZ = Math.abs(posZ) < 1e-6 ? 0 : posZ;
        const offset = index * 8;
        vertices[offset] = posX;
        vertices[offset + 1] = posY;
        vertices[offset + 2] = posZ;
        vertices[offset + 3] = posX;
        vertices[offset + 4] = posY;
        vertices[offset + 5] = posZ;
        vertices[offset + 6] = u;
        vertices[offset + 7] = 1 - v;
        verticesRow.push(index++);
      }
      grid.push(verticesRow);
    }
    for (let iy = 0; iy < verticalSegments; iy++) {
      for (let ix = 0; ix < horizontalSegments; ix++) {
        const a = grid[iy][ix + 1];
        const b = grid[iy][ix];
        const c = grid[iy + 1][ix];
        const d = grid[iy + 1][ix + 1];
        if (iy !== 0 || this._parameters.thetaStart > 0)
          indices.push(a, b, d);
        if (iy !== verticalSegments - 1 || this._thetaEnd < Math.PI)
          indices.push(b, c, d);
      }
    }
    this._initialize(engine, vertices, Uint16Array.from(indices));
  }
}

class PlaneGeometry extends ShapeGeometry {
  constructor(engine, width = 1, height = 1, horizontalSegments = 1, verticalSegments = 1) {
    super(engine);
    this._parameters = {
      width,
      height,
      horizontalSegments: Math.floor(horizontalSegments),
      verticalSegments: Math.floor(verticalSegments)
    };
    this.halfWidth = this._parameters.width / 2;
    this.halfHeight = this._parameters.height / 2;
    this.initialize(engine);
  }
  initialize(engine) {
    const {verticalSegments, horizontalSegments} = this._parameters;
    let index = 0;
    let offset = 0;
    const grid = [];
    const vertices = new Float32Array((verticalSegments + 1) * (horizontalSegments + 1) * 8);
    const indices = new Uint16Array(verticalSegments * horizontalSegments * 6);
    for (let iy = 0; iy <= verticalSegments; iy++) {
      const verticesRow = [];
      const v = iy / verticalSegments;
      for (let ix = 0; ix <= horizontalSegments; ix++) {
        const u = ix / horizontalSegments;
        const posX = u * this._parameters.width - this.halfWidth;
        const posY = v * this._parameters.height - this.halfHeight;
        vertices[offset++] = posX;
        vertices[offset++] = posY;
        vertices[offset++] = 0;
        vertices[offset++] = 0;
        vertices[offset++] = 0;
        vertices[offset++] = 1;
        vertices[offset++] = u;
        vertices[offset++] = 1 - v;
        verticesRow.push(index++);
      }
      grid.push(verticesRow);
    }
    index = 0;
    for (let iy = 0; iy < verticalSegments; iy++) {
      for (let ix = 0; ix < horizontalSegments; ix++) {
        const a = grid[iy][ix + 1];
        const b = grid[iy][ix];
        const c = grid[iy + 1][ix];
        const d = grid[iy + 1][ix + 1];
        indices[index++] = a;
        indices[index++] = c;
        indices[index++] = b;
        indices[index++] = a;
        indices[index++] = d;
        indices[index++] = c;
      }
    }
    this._initialize(engine, vertices, indices);
  }
}

class CylinderGeometry extends ShapeGeometry {
  constructor(engine, radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = 2 * Math.PI, frontFace = FrontFace.CCW) {
    super(engine);
    this.FrontFace = frontFace;
    this._parameters = {
      radiusTop,
      radiusBottom,
      height,
      radialSegments,
      heightSegments,
      openEnded,
      thetaStart,
      thetaLength
    };
    this._vertices = [];
    this._indices = [];
    this.index = 0;
    this.indexArray = [];
    this.halfHeight = this._parameters.height / 2;
    this.generateTorso();
    if (this._parameters.openEnded === false) {
      if (this._parameters.radiusTop > 0)
        this.generateCap(true);
      if (this._parameters.radiusBottom > 0)
        this.generateCap(false);
    }
    this._initialize(engine, Float32Array.from(this._vertices), Uint16Array.from(this._indices));
  }
  generateTorso() {
    const {radialSegments, heightSegments, radiusBottom, radiusTop, height} = this._parameters;
    let x, y;
    const normal = new Vector3();
    const slope = (radiusBottom - radiusTop) / height;
    for (y = 0; y <= heightSegments; y++) {
      const indexRow = [];
      const v = y / heightSegments;
      const radius = v * (radiusBottom - radiusTop) + radiusTop;
      for (x = 0; x <= radialSegments; x++) {
        const u = x / radialSegments;
        const theta = u * this._parameters.thetaLength + this._parameters.thetaStart;
        const sinTheta = Math.sin(theta);
        const cosTheta = Math.cos(theta);
        const vertX = radius * sinTheta;
        const vertY = -v * height + this.halfHeight;
        const vertZ = radius * cosTheta;
        this._vertices.push(vertX, vertY, vertZ);
        normal.setValue(sinTheta, slope, cosTheta);
        normal.normalize();
        this._vertices.push(normal.x, normal.y, normal.z);
        if (this.FrontFace === FrontFace.CCW) {
          this._vertices.push(u, v);
        } else {
          this._vertices.push(1 - u, v);
        }
        indexRow.push(this.index++);
      }
      this.indexArray.push(indexRow);
    }
    for (x = 0; x < radialSegments; x++) {
      for (y = 0; y < heightSegments; y++) {
        var a = this.indexArray[y][x];
        var b = this.indexArray[y + 1][x];
        var c = this.indexArray[y + 1][x + 1];
        var d = this.indexArray[y][x + 1];
        this._indices.push(a, b, d);
        this._indices.push(b, c, d);
      }
    }
  }
  generateCap(isTop) {
    const {radialSegments} = this._parameters;
    let x;
    const radius = isTop === true ? this._parameters.radiusTop : this._parameters.radiusBottom;
    const sign = isTop === true ? 1 : -1;
    const centerIndexStart = this.index;
    for (x = 1; x <= radialSegments; x++) {
      this._vertices.push(0, this.halfHeight * sign, 0);
      this._vertices.push(0, sign, 0);
      this._vertices.push(0.5, 0.5);
      this.index++;
    }
    const centerIndexEnd = this.index;
    for (x = 0; x <= radialSegments; x++) {
      const u = x / radialSegments;
      const theta = u * this._parameters.thetaLength + this._parameters.thetaStart;
      const cosTheta = Math.cos(theta);
      const sinTheta = Math.sin(theta);
      const vertexX = radius * sinTheta;
      const vertexY = this.halfHeight * sign;
      const vertexZ = radius * cosTheta;
      this._vertices.push(vertexX, vertexY, vertexZ);
      this._vertices.push(0, sign, 0);
      const uvX = cosTheta * 0.5 + 0.5;
      const uvY = sinTheta * 0.5 * sign + 0.5;
      this._vertices.push(uvX, uvY);
      this.index++;
    }
    for (x = 0; x < radialSegments; x++) {
      var c = centerIndexStart + x;
      var i = centerIndexEnd + x;
      if (isTop === true) {
        this._indices.push(i, i + 1, c);
      } else {
        this._indices.push(i + 1, i, c);
      }
    }
  }
}

class CircleGeometry extends ShapeGeometry {
  constructor(engine, options = {}) {
    super(engine);
    this.radius = 1;
    this.segments = 16;
    this.thetaStart = 0;
    this.thetaLength = Math.PI * 2;
    this.radius = options.radius || this.radius;
    this.segments = options.segments || this.segments;
    this.thetaStart = options.thetaStart || this.thetaStart;
    this.thetaLength = options.thetaLength || this.thetaLength;
    const {segments, radius} = this;
    const vertices = new Float32Array((segments + 2) * 8);
    vertices.set([0, 0, 0, 0, 0, 1, 0.5, 0.5]);
    let index = 8;
    for (let s = 0; s <= segments; s++) {
      let segment = this.thetaStart + s / segments * this.thetaLength;
      const x = radius * Math.cos(segment);
      const y = radius * Math.sin(segment);
      vertices[index++] = x;
      vertices[index++] = y;
      vertices[index++] = 0;
      vertices[index++] = 0;
      vertices[index++] = 0;
      vertices[index++] = 1;
      vertices[index++] = (x / radius + 1) * 0.5;
      vertices[index++] = (y / radius + 1) * 0.5;
    }
    const indices = new Uint16Array(segments * 3);
    index = 0;
    for (let i = 1; i <= segments; i++) {
      indices[index++] = i;
      indices[index++] = i + 1;
      indices[index++] = 0;
    }
    this._initialize(engine, vertices, indices);
  }
}

class ScreenQuadGeometry extends ShapeGeometry {
  constructor(engine) {
    super(engine);
    const vertices = new Float32Array([-1, -1, 0, 0, 0, 1, -1, 0, 1, 0, 1, 1, 0, 1, 1, -1, 1, 0, 0, 1]);
    const indices = new Uint16Array([0, 1, 2, 3]);
    this._initialize(engine, vertices, indices);
    this.subGeometry.topology = PrimitiveTopology.TriangleFan;
  }
  _initialize(engine, vertices, indices) {
    const vertexStride = 20;
    const vertexElements = [
      new VertexElement("POSITION", 0, VertexElementFormat.Vector3, 0),
      new VertexElement("TEXCOORD_0", 12, VertexElementFormat.Vector2, 0)
    ];
    this._initBuffer(engine, vertices, indices, vertexStride, vertexElements);
  }
}

class TorusGeometry extends ShapeGeometry {
  constructor(parameters = {}, engine) {
    super(engine);
    this.parameters = parameters;
    const radius = this.parameters.radius || 1;
    const tube = this.parameters.tube || 0.4;
    const radialSegments = Math.floor(this.parameters.radialSegments) || 8;
    const tubularSegments = Math.floor(this.parameters.tubularSegments) || 6;
    const arc = this.parameters.arc || Math.PI * 2;
    const vertices = new Float32Array((radialSegments + 1) * (tubularSegments + 1) * 3);
    const indices = new Uint16Array(radialSegments * tubularSegments * 6);
    let index = 0;
    for (let j = 0; j <= radialSegments; j++) {
      for (let i = 0; i <= tubularSegments; i++) {
        const u = i / tubularSegments * arc;
        const v = j / radialSegments * Math.PI * 2;
        vertices[index++] = (radius + tube * Math.cos(v)) * Math.cos(u);
        vertices[index++] = (radius + tube * Math.cos(v)) * Math.sin(u);
        vertices[index++] = tube * Math.sin(v);
      }
    }
    index = 0;
    for (let j = 1; j <= radialSegments; j++) {
      for (let i = 1; i <= tubularSegments; i++) {
        const a = (tubularSegments + 1) * j + i - 1;
        const b = (tubularSegments + 1) * (j - 1) + i - 1;
        const c = (tubularSegments + 1) * (j - 1) + i;
        const d = (tubularSegments + 1) * j + i;
        indices[index++] = a;
        indices[index++] = b;
        indices[index++] = d;
        indices[index++] = b;
        indices[index++] = c;
        indices[index++] = d;
      }
    }
    this._initialize(engine, vertices, indices);
  }
  _initialize(engine, vertices, indices) {
    const vertexStride = 12;
    const vertexElements = [new VertexElement("POSITION", 0, VertexElementFormat.Vector3, 0)];
    this._initBuffer(engine, vertices, indices, vertexStride, vertexElements);
  }
}

class Model extends GeometryRenderer {
  set geometryType(value) {
    switch (value) {
      case "Sphere":
        const {
          sphereRadius,
          sphereHorizontalSegments,
          sphereVerticalSegments,
          sphereAlphaStart,
          sphereAlphaRange,
          sphereThetaStart,
          sphereThetaRange
        } = this._props;
        this.geometry = new SphereGeometry(this.engine, sphereRadius, sphereHorizontalSegments, sphereVerticalSegments, sphereAlphaStart, sphereAlphaRange, sphereThetaStart, sphereThetaRange);
        break;
      case "Cylinder":
        const {
          cylinderRadiusTop,
          cylinderRadiusBottom,
          cylinderHeight,
          cylinderRadialSegments,
          cylinderHeightSegments,
          cylinderOpenEnded
        } = this._props;
        this.geometry = new CylinderGeometry(this.engine, cylinderRadiusTop, cylinderRadiusBottom, cylinderHeight, cylinderRadialSegments, cylinderHeightSegments, cylinderOpenEnded, void 0, void 0, void 0);
        break;
      case "Plane":
        const {planeWidth, planeHeight, planeHorizontalSegments, planeVerticalSegments} = this._props;
        this.geometry = new PlaneGeometry(this.engine, planeWidth, planeHeight, planeHorizontalSegments, planeVerticalSegments);
        break;
      case "Box":
        var {boxWidth, boxHeight, boxDepth} = this._props;
        this.geometry = new CuboidGeometry(this.engine, boxWidth, boxHeight, boxDepth);
        break;
    }
    this._geometryType = value;
  }
  get geometryType() {
    return this._geometryType;
  }
  constructor(entity) {
    super(entity);
  }
  get material() {
    return this._material;
  }
  set material(mtl) {
    if (!mtl) {
      this._material = new BlinnPhongMaterial(this.engine, "mtl");
    } else {
      this._material = mtl;
    }
  }
  init(props) {
    this._props = props;
    const {geometryType = GeometryType.Box} = props;
    this.material = props.material;
    this.geometryType = geometryType;
  }
  setProp(key, value) {
    this._props[key] = value;
    if (key === "material") {
      this.material = value;
    } else {
      this.geometryType = this._props.geometryType;
    }
  }
}
var GeometryType;
(function(GeometryType2) {
  GeometryType2["Box"] = "Box";
  GeometryType2["Cylinder"] = "Cylinder";
  GeometryType2["Plane"] = "Plane";
  GeometryType2["Sphere"] = "Sphere";
})(GeometryType || (GeometryType = {}));

var fs = "uniform samplerCube u_cube;\n\nvarying vec3 v_cubeUV;\n\nvoid main() {\n\n    gl_FragColor = textureCube( u_cube, v_cubeUV );\n\n}\n";

var vs = "#include <common_vert>\n\nuniform mat4 u_mvpNoscale;\n\nvarying vec3 v_cubeUV;\n\nvoid main() {\n\n    v_cubeUV = a_position.xyz;\n    gl_Position = u_mvpNoscale * vec4( a_position, 1.0 );\n    gl_Position.z = gl_Position.w;\n\n}\n";

class SkyBoxMaterial extends Material {
  constructor(engine, name = SkyBoxMaterial.defaultName) {
    super(engine, name);
  }
  setModel(modelMatrix) {
    this.modelMatrix = modelMatrix;
  }
  prepareDrawing(context, component) {
    if (this._technique === null) {
      this._generateTechnique();
    }
    if (!this._cacheMat1) {
      this._cacheMat1 = new Matrix();
      this._cacheMat2 = new Matrix();
    }
    const view = context.viewMatrix;
    const proj = context.projectionMatrix;
    Matrix.multiply(view, this.modelMatrix, this._cacheMat1);
    const e = this._cacheMat1.elements;
    e[12] = e[13] = e[14] = 0;
    Matrix.multiply(proj, this._cacheMat1, this._cacheMat2);
    this.setValue("u_mvpNoscale", this._cacheMat2);
    super.prepareDrawing(context, component, void 0);
  }
  _generateTechnique() {
    const tech = new RenderTechnique(SkyBoxMaterial.techniqueName);
    tech.isValid = true;
    tech.uniforms = SkyBoxMaterial.techniqueConfig.uniforms;
    tech.attributes = SkyBoxMaterial.techniqueConfig.attributes;
    tech.states = SkyBoxMaterial.techniqueConfig.states;
    tech.vertexShader = SkyBoxMaterial.vertexShader;
    tech.fragmentShader = SkyBoxMaterial.fragmentShader;
    this._technique = tech;
  }
}
SkyBoxMaterial.defaultName = "SKY_BOX_MATERIAL";
SkyBoxMaterial.techniqueName = "SKY_BOX_TECHNIQUE";
SkyBoxMaterial.vertexShader = vs;
SkyBoxMaterial.fragmentShader = fs;
SkyBoxMaterial.techniqueConfig = {
  attributes: {},
  uniforms: {
    u_mvpNoscale: {
      name: "u_mvpNoscale",
      type: DataType.FLOAT_MAT4
    },
    u_cube: {
      name: "u_cube",
      type: DataType.SAMPLER_CUBE
    }
  },
  states: {
    disable: [RenderState.CULL_FACE],
    functions: {
      depthFunc: CompFunc.LEQUAL
    }
  }
};

class SkyBox extends GeometryRenderer {
  constructor(entity) {
    super(entity);
    this.geometry = new CuboidGeometry(this.engine, 2, 2, 2);
    this.material = new SkyBoxMaterial(this.engine);
  }
  update() {
    this.material.setModel(this.entity.transform.worldMatrix);
  }
  render(camera) {
    if (!this._skyBoxMap)
      return;
    super.render(camera);
  }
  get skyBoxMap() {
    return this._skyBoxMap;
  }
  set skyBoxMap(v) {
    this._skyBoxMap = v;
    this.material.setValue("u_cube", v);
  }
}

var fs$1 = "#include <common>\n#include <common_frag>\n#include <pbr_common_frag_define>\n#include <pbr_util_frag_define>\n\n#include <fog_share>\n\n#include <uv_share>\n#include <normal_share>\n#include <color_share>\n#include <worldpos_share>\n#include <refraction_share>\n#include <perturbation_share>\n#include <clipPlane_frag_define>\n\n// light\n#include <ambient_light_frag>\n#include <direct_light_frag>\n#include <point_light_frag>\n#include <spot_light_frag>\n#include <pbr_envmap_light_frag_define>\n\n// prop & texture\n#include <pbr_base_frag_define>\n#include <pbr_texture_frag_define>\n\n// runtime context\n#include <pbr_runtime_frag_define>\n\n// todo: generalize\n#include <pbr_normal_frag_define>\n\n\n// todo: BxDF\n#include <pbr_brdf_cook_torrance_frag_define>\n\n\n// direct + indirect\n#include <pbr_direct_irradiance_frag_define>\n#include <pbr_ibl_diffuse_frag_define>\n#include <pbr_ibl_specular_frag_define>\n\n#include <oit_frag_define>\n\n\nvoid main() {\n    #include <clipPlane_frag>\n\n    #include <pbr_begin_frag>\n    #include <pbr_direct_irradiance_frag>\n    #include <pbr_ibl_diffuse_frag>\n    #include <pbr_ibl_specular_frag>\n    // todo: generalize texture logic\n    #include <pbr_end_frag>\n    #include <gamma_frag>\n    #include <refraction_frag>\n    #include <perturbation_frag>\n    #include <fog_frag>\n\n    #include <oit_frag>\n\n    // gl_FragColor = texture2D( u_baseColorSampler, v_uv );\n}\n";

var vs$1 = "#include <common>\n#include <common_vert>\n#include <uv_share>\n#include <color_share>\n#include <normal_share>\n#include <worldpos_share>\n#include <clipPlane_vert_define>\n#include <morph_target_vert>\n\n#include <fog_share>\n\nvoid main() {\n\n    #include <begin_position_vert>\n    #include <begin_normal_vert>\n\n    #include <morph_vert>\n    #include <skinning_vert>\n    #include <uv_vert>\n    #include <color_vert>\n    #include <normal_vert>\n    #include <worldpos_vert>\n    #include <clipPlane_vert>\n    #include <position_vert>\n\n    #include <fog_vert>\n}\n";

class PBRMaterial extends Material {
  constructor(engine, name = PBRMaterial.MATERIAL_NAME, props = {}) {
    super(engine, name);
    this.createDefaulteValues();
    this.setUniforms(props);
    this.setStates(props);
  }
  createDefaulteValues() {
    this._uniformObj = {
      baseColorFactor: new Vector4(1, 1, 1, 1),
      metallicFactor: 1,
      roughnessFactor: 1,
      metallicRoughness: new Vector2(1, 1),
      normalScale: 1,
      emissiveFactor: new Vector3(0, 0, 0),
      occlusionStrength: 1,
      alphaCutoff: 0.5,
      specularFactor: new Vector3(1, 1, 1),
      glossinessFactor: 0,
      envMapIntensity: 1,
      refractionRatio: 1 / 1.33,
      refractionDepth: 1,
      perturbationUOffset: 0,
      perturbationVOffset: 0
    };
    this._stateObj = {
      alphaMode: "OPAQUE",
      doubleSided: false,
      side: Side.FRONT,
      unlit: false,
      srgb: false,
      srgbFast: false,
      gamma: false,
      blendFunc: [],
      blendFuncSeparate: [BlendFunc.SRC_ALPHA, BlendFunc.ONE_MINUS_SRC_ALPHA, BlendFunc.ONE, BlendFunc.ONE],
      depthMask: [false],
      getOpacityFromRGB: false,
      isMetallicWorkflow: true,
      envMapModeRefract: false
    };
    Object.keys(this._uniformObj).forEach((k) => this.setValueByParamName(k, this._uniformObj[k]));
  }
  setUniforms(obj) {
    Object.keys(obj).forEach((key) => {
      switch (key) {
        case "baseColorFactor":
          this.baseColorFactor = obj[key];
          break;
        case "opacity":
          this.opacity = obj[key];
          break;
        case "opacityTexture":
          this.opacityTexture = obj[key];
          break;
        case "baseColorTexture":
          this.baseColorTexture = obj[key];
          break;
        case "metallicFactor":
          this.metallicFactor = obj[key];
          break;
        case "roughnessFactor":
          this.roughnessFactor = obj[key];
          break;
        case "metallicTexture":
          this.metallicTexture = obj[key];
          break;
        case "roughnessTexture":
          this.roughnessTexture = obj[key];
          break;
        case "metallicRoughnessTexture":
          this.metallicRoughnessTexture = obj[key];
          break;
        case "normalTexture":
          this.normalTexture = obj[key];
          break;
        case "normalScale":
          this.normalScale = obj[key];
          break;
        case "emissiveTexture":
          this.emissiveTexture = obj[key];
          break;
        case "emissiveFactor":
          this.emissiveFactor = obj[key];
          break;
        case "occlusionTexture":
          this.occlusionTexture = obj[key];
          break;
        case "occlusionStrength":
          this.occlusionStrength = obj[key];
          break;
        case "alphaCutoff":
          this.alphaCutoff = obj[key];
          break;
        case "specularFactor":
          this.specularFactor = obj[key];
          break;
        case "glossinessFactor":
          this.glossinessFactor = obj[key];
          break;
        case "specularGlossinessTexture":
          this.specularGlossinessTexture = obj[key];
          break;
        case "reflectionTexture":
          this.reflectionTexture = obj[key];
          break;
        case "envMapIntensity":
          this.envMapIntensity = obj[key];
          break;
        case "refractionRatio":
          this.refractionRatio = obj[key];
          break;
        case "refractionDepth":
          this.refractionDepth = obj[key];
          break;
        case "refractionTexture":
          this.refractionTexture = obj[key];
          break;
        case "perturbationTexture":
          this.perturbationTexture = obj[key];
          break;
        case "perturbationUOffset":
          this.perturbationUOffset = obj[key];
          break;
        case "perturbationVOffset":
          this.perturbationVOffset = obj[key];
          break;
      }
    });
  }
  setStates(obj) {
    Object.keys(obj).forEach((key) => {
      switch (key) {
        case "doubleSided":
          this.doubleSided = obj[key];
          break;
        case "side":
          this.side = obj[key];
          break;
        case "alphaMode":
          this.alphaMode = obj[key];
          break;
        case "unlit":
          this.unlit = obj[key];
          break;
        case "srgb":
          this.srgb = obj[key];
          break;
        case "srgbFast":
          this.srgbFast = obj[key];
          break;
        case "gamma":
          this.gamma = obj[key];
          break;
        case "blendFunc":
          this.blendFunc = obj[key];
          break;
        case "blendFuncSeparate":
          this.blendFuncSeparate = obj[key];
          break;
        case "depthMask":
          this.depthMask = obj[key];
          break;
        case "getOpacityFromRGB":
          this.getOpacityFromRGB = obj[key];
          break;
        case "isMetallicWorkflow":
          this.isMetallicWorkflow = obj[key];
          break;
        case "envMapModeRefract":
          this.envMapModeRefract = obj[key];
          break;
      }
    });
  }
  setValueByParamName(paramName, value) {
    const uniforms = PBRMaterial.TECH_CONFIG.uniforms;
    const uniformName = Object.keys(uniforms).find((key) => uniforms[key].paramName === paramName);
    if (uniformName) {
      this.setValue(uniformName, value);
    }
  }
  updateTechnique(stateName, v) {
    if (this[stateName] === v)
      return;
    this._stateObj[stateName] = v;
    const states = this.technique?.states;
    if (!states)
      return;
    switch (stateName) {
      case "doubleSided":
      case "side":
        if (this.doubleSided) {
          states.disable.push(RenderState.CULL_FACE);
        } else {
          const index = states.disable.indexOf(RenderState.CULL_FACE);
          if (index > -1) {
            states.disable.splice(index, 1);
          }
          switch (this.side) {
            case Side.FRONT:
              states.functions.cullFace = [CullFace.BACK];
              break;
            case Side.BACK:
              states.functions.cullFace = [CullFace.FRONT];
              break;
            case Side.NONE:
              states.functions.cullFace = [CullFace.FRONT_AND_BACK];
              break;
            default:
              delete states.functions.cullFace;
          }
        }
        break;
      case "blendFunc":
      case "blendFuncSeparate":
        if (this.blendFunc.length) {
          states.functions.blendFunc = this.blendFunc;
        } else {
          states.functions.blendFuncSeparate = this.blendFuncSeparate;
        }
        break;
      case "depthMask":
        states.functions.depthMask = v;
        break;
      default:
        this._technique = null;
    }
  }
  get baseColorFactor() {
    return this._uniformObj.baseColorFactor;
  }
  set baseColorFactor(v) {
    this._uniformObj.baseColorFactor = v;
    this.setValueByParamName("baseColorFactor", v);
  }
  get opacity() {
    return this.baseColorFactor.w;
  }
  set opacity(val) {
    this.baseColorFactor.w = val;
  }
  get baseColorTexture() {
    return this._uniformObj.baseColorTexture;
  }
  set baseColorTexture(v) {
    this.setValueByParamName("baseColorTexture", v);
    this._uniformObj.baseColorTexture = v;
  }
  get opacityTexture() {
    return this._uniformObj.opacityTexture;
  }
  set opacityTexture(v) {
    this.setValueByParamName("opacityTexture", v);
    this._uniformObj.opacityTexture = v;
  }
  get metallicFactor() {
    return this._uniformObj.metallicFactor;
  }
  set metallicFactor(v) {
    this._uniformObj.metallicFactor = v;
    this._uniformObj.metallicRoughness.x = v;
    this.setValueByParamName("metallicRoughness", this._uniformObj.metallicRoughness);
  }
  get roughnessFactor() {
    return this._uniformObj.roughnessFactor;
  }
  set roughnessFactor(v) {
    this._uniformObj.roughnessFactor = v;
    this._uniformObj.metallicRoughness.y = v;
    this.setValueByParamName("metallicRoughness", this._uniformObj.metallicRoughness);
  }
  get metallicTexture() {
    return this._uniformObj.metallicTexture;
  }
  set metallicTexture(v) {
    this.setValueByParamName("metallicTexture", v);
    this._uniformObj.metallicTexture = v;
  }
  get roughnessTexture() {
    return this._uniformObj.roughnessTexture;
  }
  set roughnessTexture(v) {
    this.setValueByParamName("roughnessTexture", v);
    this._uniformObj.roughnessTexture = v;
  }
  get metallicRoughnessTexture() {
    return this._uniformObj.metallicRoughnessTexture;
  }
  set metallicRoughnessTexture(v) {
    this.setValueByParamName("metallicRoughnessTexture", v);
    this._uniformObj.metallicRoughnessTexture = v;
  }
  get normalTexture() {
    return this._uniformObj.normalTexture;
  }
  set normalTexture(v) {
    this.setValueByParamName("normalTexture", v);
    this._uniformObj.normalTexture = v;
  }
  get normalScale() {
    return this._uniformObj.normalScale;
  }
  set normalScale(v) {
    this._uniformObj.normalScale = v;
    this.setValueByParamName("normalScale", v);
  }
  get emissiveTexture() {
    return this._uniformObj.emissiveTexture;
  }
  set emissiveTexture(v) {
    this.setValueByParamName("emissiveTexture", v);
    this._uniformObj.emissiveTexture = v;
  }
  get emissiveFactor() {
    return this._uniformObj.emissiveFactor;
  }
  set emissiveFactor(v) {
    this._uniformObj.emissiveFactor = v;
    this.setValueByParamName("emissiveFactor", v);
  }
  get occlusionTexture() {
    return this._uniformObj.occlusionTexture;
  }
  set occlusionTexture(v) {
    this.setValueByParamName("occlusionTexture", v);
    this._uniformObj.occlusionTexture = v;
  }
  get occlusionStrength() {
    return this._uniformObj.occlusionStrength;
  }
  set occlusionStrength(v) {
    this._uniformObj.occlusionStrength = v;
    this.setValueByParamName("occlusionStrength", v);
  }
  get alphaCutoff() {
    return this._uniformObj.alphaCutoff;
  }
  set alphaCutoff(v) {
    this._uniformObj.alphaCutoff = v;
    this.setValueByParamName("alphaCutoff", v);
  }
  get specularFactor() {
    return this._uniformObj.specularFactor;
  }
  set specularFactor(v) {
    this.setValueByParamName("specularFactor", v);
    this._uniformObj.specularFactor = v;
  }
  get glossinessFactor() {
    return this._uniformObj.glossinessFactor;
  }
  set glossinessFactor(v) {
    this.setValueByParamName("glossinessFactor", v);
    this._uniformObj.glossinessFactor = v;
  }
  get specularGlossinessTexture() {
    return this._uniformObj.specularGlossinessTexture;
  }
  set specularGlossinessTexture(v) {
    this.setValueByParamName("specularGlossinessTexture", v);
    this._uniformObj.specularGlossinessTexture = v;
  }
  get reflectionTexture() {
    return this._uniformObj.reflectionTexture;
  }
  set reflectionTexture(v) {
    this.setValueByParamName("reflectionTexture", v);
    this._uniformObj.reflectionTexture = v;
  }
  get envMapIntensity() {
    return this._uniformObj.envMapIntensity;
  }
  set envMapIntensity(v) {
    this.setValueByParamName("envMapIntensity", v);
    this._uniformObj.envMapIntensity = v;
  }
  get refractionRatio() {
    return this._uniformObj.refractionRatio;
  }
  set refractionRatio(v) {
    this.setValueByParamName("refractionRatio", v);
    this._uniformObj.refractionRatio = v;
  }
  get refractionDepth() {
    return this._uniformObj.refractionDepth;
  }
  set refractionDepth(v) {
    this.setValueByParamName("refractionDepth", v);
    this._uniformObj.refractionDepth = v;
  }
  get refractionTexture() {
    return this._uniformObj.refractionTexture;
  }
  set refractionTexture(v) {
    this.setValueByParamName("refractionTexture", v);
    this._uniformObj.refractionTexture = v;
  }
  get perturbationTexture() {
    return this._uniformObj.perturbationTexture;
  }
  set perturbationTexture(v) {
    this.setValueByParamName("perturbationTexture", v);
    this._uniformObj.perturbationTexture = v;
  }
  get perturbationUOffset() {
    return this._uniformObj.perturbationUOffset;
  }
  set perturbationUOffset(v) {
    this.setValueByParamName("perturbationUOffset", v);
    this._uniformObj.perturbationUOffset = v;
  }
  get perturbationVOffset() {
    return this._uniformObj.perturbationVOffset;
  }
  set perturbationVOffset(v) {
    this.setValueByParamName("perturbationVOffset", v);
    this._uniformObj.perturbationVOffset = v;
  }
  get alphaMode() {
    return this._stateObj.alphaMode;
  }
  set alphaMode(v) {
    this.updateTechnique("alphaMode", v);
  }
  get doubleSided() {
    return this._stateObj.doubleSided;
  }
  set doubleSided(v) {
    if (v) {
      this._stateObj.side = Side.DOUBLE;
    } else if (this._stateObj.side === Side.DOUBLE) {
      this._stateObj.side = Side.FRONT;
    }
    this.updateTechnique("doubleSided", v);
  }
  get side() {
    return this._stateObj.side;
  }
  set side(v) {
    if (v === Side.DOUBLE) {
      this._stateObj.doubleSided = true;
    } else {
      this._stateObj.doubleSided = false;
    }
    this.updateTechnique("side", v);
  }
  get unlit() {
    return this._stateObj.unlit;
  }
  set unlit(v) {
    this.updateTechnique("unlit", v);
  }
  get srgb() {
    return this._stateObj.srgb;
  }
  set srgb(v) {
    this.updateTechnique("srgb", v);
  }
  get srgbFast() {
    return this._stateObj.srgbFast;
  }
  set srgbFast(v) {
    this.updateTechnique("srgbFast", v);
  }
  get gamma() {
    return this._stateObj.gamma;
  }
  set gamma(v) {
    this.updateTechnique("gamma", v);
  }
  get blendFunc() {
    return this._stateObj.blendFunc;
  }
  set blendFunc(v) {
    this.updateTechnique("blendFunc", v);
  }
  get blendFuncSeparate() {
    return this._stateObj.blendFuncSeparate;
  }
  set blendFuncSeparate(v) {
    this.updateTechnique("blendFuncSeparate", v);
  }
  get depthMask() {
    return this._stateObj.depthMask;
  }
  set depthMask(v) {
    this.updateTechnique("depthMask", v);
  }
  get getOpacityFromRGB() {
    return this._stateObj.getOpacityFromRGB;
  }
  set getOpacityFromRGB(v) {
    this.updateTechnique("getOpacityFromRGB", v);
  }
  get isMetallicWorkflow() {
    return this._stateObj.isMetallicWorkflow;
  }
  set isMetallicWorkflow(v) {
    this.updateTechnique("isMetallicWorkflow", v);
  }
  get envMapModeRefract() {
    return this._stateObj.envMapModeRefract;
  }
  set envMapModeRefract(v) {
    this.updateTechnique("envMapModeRefract", v);
  }
  prepareDrawing(context, component, primitive) {
    const camera = context.camera;
    const scene = camera.scene;
    const canvas = scene.engine.canvas;
    const lightMgr = scene.findFeature(LightFeature);
    const canOIT = camera._renderPipeline.canOIT;
    lightMgr.bindMaterialValues(this);
    this.setValue("u_resolution", new Vector2(canvas.width, canvas.height));
    for (let i = 0; i < this._clipPlaneCount; i++) {
      this.setValue(`u_clipPlanes[${i}]`, scene.clipPlanes[i]);
    }
    if (canOIT) {
      this.setValue("u_depthSampler", camera._renderPipeline.depthTexture);
    }
    const {
      ambientLightCount,
      directLightCount,
      pointLightCount,
      spotLightCount,
      envMapLightCount,
      useDiffuseEnv,
      useSpecularEnv
    } = lightMgr.lightSortAmount;
    if (!this._technique || this._ambientLightCount !== ambientLightCount || this._envMapLightCount !== envMapLightCount || this._useDiffuseEnv !== useDiffuseEnv || this._useSpecularEnv !== useSpecularEnv || this._directLightCount !== directLightCount || this._pointLightCount !== pointLightCount || this._spotLightCount !== spotLightCount || this._clipPlaneCount !== scene.clipPlanes?.length || this._useOIT !== canOIT) {
      this._ambientLightCount = ambientLightCount;
      this._envMapLightCount = envMapLightCount;
      this._useDiffuseEnv = useDiffuseEnv;
      this._useSpecularEnv = useSpecularEnv;
      this._directLightCount = directLightCount;
      this._pointLightCount = pointLightCount;
      this._spotLightCount = spotLightCount;
      this._clipPlaneCount = scene.clipPlanes?.length;
      this._useOIT = canOIT;
      this._generateTechnique(camera, component, primitive);
    }
    super.prepareDrawing(context, component, primitive);
  }
  _generateTechnique(camera, component, primitive) {
    const customMacros = this._generateShaderMacros(camera, component, primitive);
    const techName = PBRMaterial.TECHNIQUE_NAME;
    const vertex = PBRMaterial.STATIC_VERTEX_SHADER;
    const frag = PBRMaterial.STATIC_FRAGMENT_SHADER;
    const config = this._generateConfig();
    const lightMgr = camera.scene.findFeature(LightFeature);
    const tech = new RenderTechnique(techName);
    tech.isValid = true;
    tech.uniforms = {...lightMgr.getUniformDefine(), ...config.uniforms};
    tech.attributes = config.attributes;
    tech.fragmentPrecision = "highp";
    tech.customMacros = customMacros;
    tech.states = config.states;
    tech.vertexShader = vertex;
    tech.fragmentShader = frag;
    this._technique = tech;
    return tech;
  }
  _generateShaderMacros(camera, component, primitive) {
    const rhi = camera.scene.engine._hardwareRenderer;
    const _macros = ["O3_NEED_WORLDPOS"];
    if (!primitive._vertexElementMap.NORMAL || !primitive._vertexElementMap.TANGENT) {
      if (rhi.canIUse(GLCapabilityType.standardDerivatives))
        _macros.push("HAS_DERIVATIVES");
    }
    const uniforms = Object.keys(this._values);
    if (uniforms.indexOf("u_baseColorSampler") > -1)
      _macros.push("HAS_BASECOLORMAP");
    if (uniforms.indexOf("u_normalSampler") > -1)
      _macros.push("O3_HAS_NORMALMAP");
    if (uniforms.indexOf("u_metallicSampler") > -1)
      _macros.push("HAS_METALMAP");
    if (uniforms.indexOf("u_roughnessSampler") > -1)
      _macros.push("HAS_ROUGHNESSMAP");
    if (uniforms.indexOf("u_metallicRoughnessSampler") > -1)
      _macros.push("HAS_METALROUGHNESSMAP");
    if (uniforms.indexOf("u_emissiveSampler") > -1)
      _macros.push("HAS_EMISSIVEMAP");
    if (uniforms.indexOf("u_occlusionSampler") > -1)
      _macros.push("HAS_OCCLUSIONMAP");
    if (uniforms.indexOf("u_specularGlossinessSampler") > -1)
      _macros.push("HAS_SPECULARGLOSSINESSMAP");
    if (uniforms.indexOf("u_perturbationSampler") > -1)
      _macros.push("HAS_PERTURBATIONMAP");
    if (uniforms.indexOf("u_reflectionSampler") > -1)
      _macros.push("HAS_REFLECTIONMAP");
    if (uniforms.indexOf("u_refractionSampler") > -1) {
      this.setValueByParamName("PTMMatrix", new Matrix(0.5, 0, 0, 0, 0, 0.5, 0, 0, 0, 0, 0.5, 0, 0.5, 0.5, 0.5, 1));
      _macros.push("HAS_REFRACTIONMAP");
    }
    if (this.alphaMode === "MASK") {
      _macros.push("ALPHA_MASK");
    } else if (this.alphaMode === "BLEND" && !this.refractionTexture) {
      _macros.push("ALPHA_BLEND");
      if (uniforms.indexOf("u_opacitySampler") > -1) {
        _macros.push("HAS_OPACITYMAP");
        if (this.getOpacityFromRGB) {
          _macros.push("GETOPACITYFROMRGB");
        }
      }
    }
    if (this._envMapLightCount) {
      _macros.push("O3_HAS_ENVMAP_LIGHT");
      if (this._useDiffuseEnv)
        _macros.push("O3_USE_DIFFUSE_ENV");
      if (this._useSpecularEnv)
        _macros.push("O3_USE_SPECULAR_ENV");
      if (rhi.canIUse(GLCapabilityType.shaderTextureLod))
        _macros.push("HAS_TEX_LOD");
    }
    if (this._ambientLightCount) {
      _macros.push("O3_HAS_AMBIENT_LIGHT");
    }
    if (this._directLightCount)
      _macros.push(`O3_DIRECT_LIGHT_COUNT ${this._directLightCount}`);
    if (this._pointLightCount)
      _macros.push(`O3_POINT_LIGHT_COUNT ${this._pointLightCount}`);
    if (this._spotLightCount)
      _macros.push(`O3_SPOT_LIGHT_COUNT ${this._spotLightCount}`);
    if (this._clipPlaneCount)
      _macros.push(`O3_CLIPPLANE_NUM ${this._clipPlaneCount}`);
    if (this._stateObj.unlit)
      _macros.push("UNLIT");
    if (this._stateObj.srgb)
      _macros.push("MANUAL_SRGB");
    if (this._stateObj.srgbFast)
      _macros.push("SRGB_FAST_APPROXIMATION");
    if (this._stateObj.gamma)
      _macros.push("GAMMA");
    if (this._stateObj.isMetallicWorkflow)
      _macros.push("IS_METALLIC_WORKFLOW");
    if (this._stateObj.envMapModeRefract)
      _macros.push("ENVMAPMODE_REFRACT");
    if (camera._renderPipeline.canOIT) {
      _macros.push("OIT_ENABLE");
    }
    return _macros;
  }
  _generateConfig() {
    const defaultState = PBRMaterial.TECH_CONFIG.states;
    const states = {
      disable: defaultState.disable.slice(),
      enable: defaultState.enable.slice(),
      functions: Object.assign({}, defaultState.functions)
    };
    if (this.doubleSided) {
      states.disable.push(RenderState.CULL_FACE);
    } else {
      switch (this.side) {
        case Side.FRONT:
          states.functions.cullFace = [CullFace.BACK];
          break;
        case Side.BACK:
          states.functions.cullFace = [CullFace.FRONT];
          break;
        case Side.NONE:
          states.functions.cullFace = [CullFace.FRONT_AND_BACK];
          break;
        default:
          delete states.functions.cullFace;
      }
    }
    if (this.alphaMode === "BLEND" && !this.refractionTexture) {
      states.enable.push(RenderState.BLEND);
      if (this.blendFunc.length) {
        states.functions.blendFunc = this._stateObj.blendFunc;
      } else {
        states.functions.blendFuncSeparate = this._stateObj.blendFuncSeparate;
      }
      states.functions.depthMask = this._stateObj.depthMask;
      this.renderType = MaterialType.TRANSPARENT;
    } else {
      this.renderType = MaterialType.OPAQUE;
    }
    const clipPlaneUniforms = {};
    for (let i = 0; i < this._clipPlaneCount; i++) {
      clipPlaneUniforms[`u_clipPlanes[${i}]`] = {
        name: `u_clipPlanes[${i}]`,
        type: DataType.FLOAT_VEC4
      };
    }
    PBRMaterial.TECH_CONFIG.uniforms = Object.assign({}, PBRMaterial.TECH_CONFIG.uniforms, clipPlaneUniforms);
    return Object.assign({}, PBRMaterial.TECH_CONFIG, {states});
  }
  clone(name) {
    const newMtl = new PBRMaterial(this._engine, name || this.name);
    newMtl.renderType = this.renderType;
    newMtl.useFog = this.useFog;
    for (const name2 in this._uniformObj) {
      const value = this._uniformObj[name2];
      if (value instanceof Texture) {
        newMtl[name2] = value;
      } else {
        newMtl[name2] = Util.clone(value);
      }
    }
    if (this._stateObj) {
      newMtl._stateObj = Util.clone(this._stateObj);
    }
    return newMtl;
  }
}
PBRMaterial.MATERIAL_NAME = "PBR_MATERIAL";
PBRMaterial.TECHNIQUE_NAME = "PBR_TECHNIQUE";
PBRMaterial.STATIC_VERTEX_SHADER = vs$1;
PBRMaterial.STATIC_FRAGMENT_SHADER = fs$1;
PBRMaterial.attribUniformVec4 = 12;
PBRMaterial.TECH_CONFIG = {
  attributes: {},
  uniforms: Object.assign({
    u_baseColorSampler: {
      name: "u_baseColorSampler",
      paramName: "baseColorTexture",
      type: DataType.SAMPLER_2D
    },
    u_baseColorFactor: {
      name: "u_baseColorFactor",
      paramName: "baseColorFactor",
      type: DataType.FLOAT_VEC4
    },
    u_normalSampler: {
      name: "u_normalSampler",
      paramName: "normalTexture",
      type: DataType.SAMPLER_2D
    },
    u_normalScale: {
      name: "u_normalScale",
      paramName: "normalScale",
      type: DataType.FLOAT
    },
    u_lightDirection: {
      name: "u_lightDirection",
      type: DataType.FLOAT_VEC3
    },
    u_lightColor: {
      name: "u_lightColor",
      type: DataType.FLOAT_VEC3
    },
    u_metallicRoughnessValue: {
      name: "u_metallicRoughnessValue",
      paramName: "metallicRoughness",
      type: DataType.FLOAT_VEC2
    },
    u_metallicSampler: {
      name: "u_metallicSampler",
      paramName: "metallicTexture",
      type: DataType.SAMPLER_2D
    },
    u_roughnessSampler: {
      name: "u_roughnessSampler",
      paramName: "roughnessTexture",
      type: DataType.SAMPLER_2D
    },
    u_metallicRoughnessSampler: {
      name: "u_metallicRoughnessSampler",
      paramName: "metallicRoughnessTexture",
      type: DataType.SAMPLER_2D
    },
    u_emissiveFactor: {
      name: "u_emissiveFactor",
      paramName: "emissiveFactor",
      type: DataType.FLOAT_VEC3
    },
    u_emissiveSampler: {
      name: "u_emissiveSampler",
      paramName: "emissiveTexture",
      type: DataType.SAMPLER_2D
    },
    u_occlusionSampler: {
      name: "u_occlusionSampler",
      paramName: "occlusionTexture",
      type: DataType.SAMPLER_2D
    },
    u_occlusionStrength: {
      name: "u_occlusionStrength",
      paramName: "occlusionStrength",
      type: DataType.FLOAT
    },
    u_alphaCutoff: {
      name: "u_alphaCutoff",
      paramName: "alphaCutoff",
      type: DataType.FLOAT
    },
    u_opacitySampler: {
      name: "u_opacitySampler",
      paramName: "opacityTexture",
      type: DataType.SAMPLER_2D
    },
    u_specularFactor: {
      name: "u_specularFactor",
      paramName: "specularFactor",
      type: DataType.FLOAT_VEC3
    },
    u_glossinessFactor: {
      name: "u_glossinessFactor",
      paramName: "glossinessFactor",
      type: DataType.FLOAT
    },
    u_specularGlossinessSampler: {
      name: "u_specularGlossinessSampler",
      paramName: "specularGlossinessTexture",
      type: DataType.SAMPLER_2D
    },
    u_reflectionSampler: {
      name: "u_reflectionSampler",
      paramName: "reflectionTexture",
      type: DataType.SAMPLER_CUBE
    },
    u_PTMMatrix: {
      name: "u_PTMMatrix",
      paramName: "PTMMatrix",
      type: DataType.FLOAT_MAT4
    },
    u_envMapIntensity: {
      name: "u_envMapIntensity",
      paramName: "envMapIntensity",
      type: DataType.FLOAT
    },
    u_refractionRatio: {
      name: "u_refractionRatio",
      paramName: "refractionRatio",
      type: DataType.FLOAT
    },
    u_refractionDepth: {
      name: "u_refractionDepth",
      paramName: "refractionDepth",
      type: DataType.FLOAT
    },
    u_refractionSampler: {
      name: "u_refractionSampler",
      paramName: "refractionTexture",
      type: DataType.SAMPLER_2D
    },
    u_resolution: {
      name: "u_resolution",
      paramName: "resolution",
      type: DataType.FLOAT_VEC2
    },
    u_perturbationSampler: {
      name: "u_perturbationSampler",
      paramName: "perturbationTexture",
      type: DataType.SAMPLER_2D
    },
    u_perturbationUOffset: {
      name: "u_perturbationUOffset",
      paramName: "perturbationUOffset",
      type: DataType.FLOAT
    },
    u_perturbationVOffset: {
      name: "u_perturbationVOffset",
      paramName: "perturbationVOffset",
      type: DataType.FLOAT
    },
    u_depthSampler: {
      name: "u_depthSampler",
      type: DataType.SAMPLER_2D
    }
  }),
  states: {
    disable: [],
    enable: [],
    functions: {}
  }
};

class GPUParticleSystem extends GeometryRenderer {
  constructor(entity) {
    super(entity);
    this._time = 0;
    this._isInit = false;
    this._isStart = false;
  }
  initialize(props) {
    this.maxCount = props.maxCount !== void 0 ? props.maxCount : 1e3;
    this.once = props.once || false;
    this.options = props.options || {};
    this.getOptions = props.getOptions;
    this.rotateToVelocity = props.rotateToVelocity || false;
    if (props.blendFuncSeparate) {
      this.blendFuncSeparate = props.blendFuncSeparate;
    }
    this.blendFunc = props.blendFunc || [BlendFunc.SRC_ALPHA, BlendFunc.ONE_MINUS_SRC_ALPHA];
    this.useOriginColor = props.useOriginColor !== void 0 ? props.useOriginColor : true;
    this.fragmentShader = props.fragmentShader || null;
    this.vertexShader = props.vertexShader || null;
    this.particleTex = props.texture || null;
    this.fadeIn = props.fadeIn || false;
    this.fadeOut = props.fadeOut === void 0 ? true : props.fadeOut;
    this.particleMaskTex = props.maskTexture || null;
    this.isScaleByLifetime = props.isScaleByLifetime || false;
    this.scaleFactor = props.scaleFactor || 1;
    this.spriteSheet = props.spriteSheet || null;
    this.is2d = props.is2d === void 0 ? true : props.is2d;
    this.interleaved = props.spriteSheet || true;
    this.setMaterial();
    this.geometry = this._createGeometry();
    this._isInit = true;
    const options = this.getOptions ? this.getOptions(this._time) : this.options;
    for (let x = 0; x < this.maxCount; x++) {
      this._spawnParticle(options, x);
    }
    this._vertexBuffer.setData(this._vertices);
    return this;
  }
  update(deltaTime) {
    if (!this._isInit || !this._isStart) {
      return;
    }
    this._time += deltaTime / 1e3;
    this.material.setValue("uTime", this._time);
  }
  setOptions(options) {
    if (options !== void 0) {
      this.options = {...this.options, ...options};
    }
    return this;
  }
  start() {
    this._isStart = true;
    this._time = 0;
    this.material.setValue("uActive", 1);
  }
  stop() {
    this.material.setValue("uActive", 0);
  }
  destroy() {
    super.destroy();
    this.options = null;
    if (this.particleTex) {
      this.particleTex = null;
    }
    if (this.particleMaskTex) {
      this.particleMaskTex = null;
    }
  }
  setMaterial() {
    const technique = this._createTechnique();
    const material = new Material(this.engine, "particleMaterial");
    material.technique = technique;
    material.renderType = MaterialType.TRANSPARENT;
    material.setValue("uOnce", this.once ? 1 : 0);
    material.setValue("uTime", this._time);
    if (this.particleTex) {
      this.particleTex.wrapModeU = this.particleTex.wrapModeV = TextureWrapMode.Clamp;
      material.setValue("particleTex", this.particleTex);
    }
    if (this.particleMaskTex) {
      this.particleMaskTex.wrapModeU = this.particleTex.wrapModeV = TextureWrapMode.Clamp;
      material.setValue("particleMaskTex", this.particleMaskTex);
    }
    this.material = material;
  }
  _createTechnique() {
    const cfg = {
      attributes: {
        positionStart: {
          name: "positionStart",
          semantic: "POSITIONSTART",
          type: DataType.FLOAT_VEC3
        },
        color: {
          name: "color",
          semantic: "COLOR",
          type: DataType.FLOAT_VEC3
        },
        alpha: {
          name: "alpha",
          semantic: "ALPHA",
          type: DataType.FLOAT
        },
        acceleration: {
          name: "acceleration",
          semantic: "ACCELERATION",
          type: DataType.FLOAT_VEC3
        },
        velocity: {
          name: "velocity",
          semantic: "VELOCITY",
          type: DataType.FLOAT_VEC3
        },
        startAngle: {
          name: "startAngle",
          semantic: "STARTANGLE",
          type: DataType.FLOAT
        },
        lifeTime: {
          name: "lifeTime",
          semantic: "LIFETIME",
          type: DataType.FLOAT
        },
        startTime: {
          name: "startTime",
          semantic: "STARTTIME",
          type: DataType.FLOAT
        },
        size: {
          name: "size",
          semantic: "SIZE",
          type: DataType.FLOAT
        },
        rotateRate: {
          name: "rotateRate",
          semantic: "ROTATERATE",
          type: DataType.FLOAT
        },
        scaleFactor: {
          name: "scaleFactor",
          semantic: "SCALEFACTOR",
          type: DataType.FLOAT
        },
        uv: {
          name: "uv",
          semantic: "UV",
          type: DataType.FLOAT_VEC3
        },
        normalizedUv: {
          name: "normalizedUv",
          semantic: "NORMALIZED_UV",
          type: DataType.FLOAT_VEC2
        }
      },
      uniforms: {
        uOnce: {
          name: "uOnce",
          type: DataType.FLOAT
        },
        uActive: {
          name: "uActive",
          type: DataType.FLOAT
        },
        uTime: {
          name: "uTime",
          type: DataType.FLOAT
        },
        matModelViewProjection: {
          name: "matModelViewProjection",
          semantic: UniformSemantic.MODELVIEWPROJECTION,
          type: DataType.FLOAT_MAT4
        },
        matModelView: {
          name: "matModelView",
          semantic: UniformSemantic.MODELVIEW,
          type: DataType.FLOAT_MAT4
        }
      },
      states: {
        enable: [RenderState.BLEND],
        functions: {
          depthMask: [false]
        }
      }
    };
    if (this.is2d) {
      cfg.uniforms.matViewInverse = {
        name: "matViewInverse",
        semantic: UniformSemantic.VIEWINVERSE,
        type: DataType.FLOAT_MAT4
      };
      cfg.uniforms.matProjection = {
        name: "matProjection",
        semantic: UniformSemantic.PROJECTION,
        type: DataType.FLOAT_MAT4
      };
      cfg.uniforms.matView = {
        name: "matView",
        semantic: UniformSemantic.VIEW,
        type: DataType.FLOAT_MAT4
      };
      cfg.uniforms.matWorld = {
        name: "matWorld",
        semantic: UniformSemantic.MODEL,
        type: DataType.FLOAT_MAT4
      };
    } else {
      cfg.states.disable = [RenderState.CULL_FACE];
    }
    if (this.blendFuncSeparate) {
      cfg.states.functions.blendFuncSeparate = this.blendFuncSeparate;
    } else {
      cfg.states.functions.blendFunc = this.blendFunc;
    }
    if (this.particleTex) {
      cfg.uniforms.particleTex = {
        name: "particleTex",
        type: DataType.SAMPLER_2D
      };
    }
    if (this.particleMaskTex) {
      cfg.uniforms.particleMaskTex = {
        name: "particleMaskTex",
        type: DataType.SAMPLER_2D
      };
    }
    const tech = new RenderTechnique("particleTech");
    tech.isValid = true;
    tech.uniforms = cfg.uniforms;
    tech.attributes = cfg.attributes;
    tech.states = cfg.states;
    tech.vertexShader = this._createVertexShader();
    tech.fragmentShader = this._createFragmentShader();
    return tech;
  }
  _createGeometry() {
    const geometry2 = new BufferGeometry(this._entity.engine, "particleGeometry");
    const vertexStride = 96;
    const vertexFloatCount = this.maxCount * 4 * vertexStride;
    const vertices = new Float32Array(vertexFloatCount);
    const indices = new Uint16Array(6 * this.maxCount);
    for (let i = 0, idx = 0; i < this.maxCount; ++i) {
      let startIndex = i * 4;
      indices[idx++] = startIndex + 0;
      indices[idx++] = startIndex + 1;
      indices[idx++] = startIndex + 2;
      indices[idx++] = startIndex + 0;
      indices[idx++] = startIndex + 2;
      indices[idx++] = startIndex + 3;
    }
    const vertexElements = [
      new VertexElement("POSITIONSTART", 0, VertexElementFormat.Vector3, 0),
      new VertexElement("VELOCITY", 12, VertexElementFormat.Vector3, 0),
      new VertexElement("ACCELERATION", 24, VertexElementFormat.Vector3, 0),
      new VertexElement("COLOR", 36, VertexElementFormat.Vector3, 0),
      new VertexElement("ALPHA", 48, VertexElementFormat.Float, 0),
      new VertexElement("SIZE", 52, VertexElementFormat.Float, 0),
      new VertexElement("ROTATERATE", 56, VertexElementFormat.Float, 0),
      new VertexElement("STARTTIME", 60, VertexElementFormat.Float, 0),
      new VertexElement("LIFETIME", 64, VertexElementFormat.Float, 0),
      new VertexElement("STARTANGLE", 68, VertexElementFormat.Float, 0),
      new VertexElement("SCALEFACTOR", 72, VertexElementFormat.Float, 0),
      new VertexElement("UV", 76, VertexElementFormat.Vector3, 0),
      new VertexElement("NORMALIZED_UV", 88, VertexElementFormat.Vector2, 0)
    ];
    const vertexBuffer = new Buffer(this.engine, BufferBindFlag.VertexBuffer, vertexFloatCount * 4, BufferUsage.Dynamic);
    const indexBuffer = new Buffer(this.engine, BufferBindFlag.IndexBuffer, indices, BufferUsage.Dynamic);
    geometry2.setVertexBufferBinding(vertexBuffer, vertexStride);
    geometry2.setIndexBufferBinding(indexBuffer, IndexFormat.UInt16);
    geometry2.setVertexElements(vertexElements);
    geometry2.addSubGeometry(0, indices.length);
    this._vertexBuffer = vertexBuffer;
    this._vertexStride = vertexStride;
    this._vertices = vertices;
    return geometry2;
  }
  _spawnParticle(options, i) {
    const position = options.position !== void 0 ? options.position.clone() : new Vector3();
    const positionRandomness = options.positionRandomness !== void 0 ? options.positionRandomness.clone() : new Vector3();
    const positionArray = options.positionArray;
    const velocity = options.velocity !== void 0 ? options.velocity.clone() : new Vector3();
    const velocityRandomness = options.velocityRandomness !== void 0 ? options.velocityRandomness.clone() : new Vector3();
    const color = options.color !== void 0 ? options.color.clone() : new Vector3(1, 1, 1);
    const colorRandomness = options.colorRandomness !== void 0 ? options.colorRandomness : 1;
    const alpha = options.alpha !== void 0 ? options.alpha : 1;
    const alphaRandomness = options.alphaRandomness !== void 0 ? options.alphaRandomness : 0;
    const lifetime = options.lifetime !== void 0 ? options.lifetime : 5;
    let size = options.size !== void 0 ? options.size : 1;
    const sizeRandomness = options.sizeRandomness !== void 0 ? options.sizeRandomness : 0;
    const smoothPosition = options.smoothPosition !== void 0 ? options.smoothPosition : false;
    const startTimeRandomness = options.startTimeRandomness !== void 0 ? options.startTimeRandomness : 0;
    const acceleration = options.acceleration !== void 0 ? options.acceleration.clone() : new Vector3();
    const accelerationRandomness = options.accelerationRandomness !== void 0 ? options.accelerationRandomness.clone() : new Vector3();
    const startAngle = options.startAngle !== void 0 ? options.startAngle : 0;
    const startAngleRandomness = options.startAngleRandomness !== void 0 ? options.startAngleRandomness : 0;
    const rotateRate = options.rotateRate !== void 0 ? options.rotateRate : 0;
    const rotateRateRandomness = options.rotateRateRandomness !== void 0 ? options.rotateRateRandomness : 0;
    const scaleFactor = options.scaleFactor !== void 0 ? options.scaleFactor : 1;
    let x = position.x;
    let y = position.y;
    let z = position.z;
    if (positionArray) {
      if (positionArray.length !== this.maxCount) {
        throw Error("The length of positionArray must be equal to maxCount.");
      }
      x += positionArray[i].x;
      y += positionArray[i].y;
      z += positionArray[i].z;
    } else {
      x += this._getRandom() * positionRandomness.x;
      y += this._getRandom() * positionRandomness.y;
      z += this._getRandom() * positionRandomness.z;
    }
    if (smoothPosition === true) {
      x += -(velocity.x * this._getRandom());
      y += -(velocity.y * this._getRandom());
      z += -(velocity.z * this._getRandom());
    }
    const velX = velocity.x + this._getRandom() * velocityRandomness.x;
    const velY = velocity.y + this._getRandom() * velocityRandomness.y;
    const velZ = velocity.z + this._getRandom() * velocityRandomness.z;
    const accX = acceleration.x + this._getRandom() * accelerationRandomness.x;
    const accY = acceleration.y + this._getRandom() * accelerationRandomness.y;
    const accZ = acceleration.z + this._getRandom() * accelerationRandomness.z;
    color.x = MathUtil.clamp(color.x + this._getRandom() * colorRandomness, 0, 1);
    color.y = MathUtil.clamp(color.y + this._getRandom() * colorRandomness, 0, 1);
    color.z = MathUtil.clamp(color.z + this._getRandom() * colorRandomness, 0, 1);
    size = Math.max(size + this._getRandom() * sizeRandomness * size * 2, 0);
    const lifeTime = lifetime + this._getRandom() * lifetime;
    const sa = startAngle + this._getRandom() * Math.PI * startAngleRandomness * 2;
    const rr = rotateRate + this._getRandom() * rotateRateRandomness;
    const particleAlpha = MathUtil.clamp(alpha + this._getRandom() * alphaRandomness, 0, 1);
    const startTime = Math.random() * startTimeRandomness;
    const vertices = this._vertices;
    for (let j = 0; j < 4; j++) {
      const k = (i * 4 + j) * this._vertexStride / 4;
      vertices[k] = x;
      vertices[k + 1] = y;
      vertices[k + 2] = z;
      vertices[k + 3] = velX;
      vertices[k + 4] = velY;
      vertices[k + 5] = velZ;
      vertices[k + 6] = accX;
      vertices[k + 7] = accY;
      vertices[k + 8] = accZ;
      vertices[k + 9] = color[0];
      vertices[k + 10] = color[1];
      vertices[k + 11] = color[2];
      vertices[k + 12] = particleAlpha;
      vertices[k + 13] = size;
      vertices[k + 14] = rr;
      vertices[k + 15] = startTime;
      vertices[k + 16] = lifeTime;
      vertices[k + 17] = sa;
      vertices[k + 18] = scaleFactor;
      this._setUvs(i, j, k);
    }
  }
  _setUvs(i, j, k) {
    const {spriteSheet} = this;
    const {particleTex} = this;
    let rects;
    const normalizedRects = [
      [-0.5, -0.5],
      [0.5, -0.5],
      [0.5, 0.5],
      [-0.5, 0.5]
    ];
    if (particleTex) {
      const width = particleTex.image ? particleTex.image.width : particleTex.width;
      const height = particleTex.image ? particleTex.image.height : particleTex.height;
      if (spriteSheet) {
        const {x, y, w, h} = spriteSheet[i % spriteSheet.length];
        const u = x / width;
        const v = y / height;
        const p = u + w / width;
        const q = v + h / height;
        rects = [
          [u, q, h / w],
          [p, q, h / w],
          [p, v, h / w],
          [u, v, h / w]
        ];
      } else {
        rects = [
          [0, 0, height / width],
          [1, 0, height / width],
          [1, 1, height / width],
          [0, 1, height / width]
        ];
      }
    } else {
      rects = [
        [0, 0, 1],
        [1, 0, 1],
        [1, 1, 1],
        [0, 1, 1]
      ];
    }
    const vertices = this._vertices;
    const uv = rects[j];
    vertices[k + 19] = uv[0];
    vertices[k + 20] = uv[1];
    vertices[k + 21] = uv[2];
    const nuv = normalizedRects[j];
    vertices[k + 22] = nuv[0];
    vertices[k + 23] = nuv[1];
  }
  _getRandom() {
    return Math.random() - 0.5;
  }
  _getShader() {
    return {
      vertexShader: `
        precision highp float;
        precision highp int;

        attribute float lifeTime;
        attribute float startTime;
        attribute float size;
        attribute float rotateRate;
        attribute vec3 velocity;
        attribute vec3 acceleration;
        attribute vec3 positionStart;
        attribute vec3 color;
        attribute float alpha;
        attribute float startAngle;
        attribute float scaleFactor;
        attribute vec3 uv;
        attribute vec2 normalizedUv;
        
        uniform float uTime;
        uniform float uOnce;
        uniform float uActive;
        uniform mat4 matModelViewProjection;
        uniform mat4 matModelView;
        uniform mat4 matViewInverse;
        uniform mat4 matView;
        uniform mat4 matProjection;
        uniform mat4 matWorld;

        varying vec3 v_color;
        varying float v_alpha;
        varying float lifeLeft;
        varying mat2 vTextureMat;
        varying vec2 v_uv;

        mat2 rotation2d(float angle) {
          float s = sin(angle);
          float c = cos(angle);
        
          return mat2(
            c, -s,
            s, c
          );
        }

        void main()
        {
          v_color = color;
          v_uv = uv.xy;
          v_alpha = alpha;
          
          // float deltaTime = max(mod(uTime, lifeTime), 0.0);
          // \u771F\u5B9E\u7684\u751F\u547D\u5468\u671F
          float life = lifeTime + startTime;
          // \u5F53\u524D\u5DF2\u8FC7\u53BB\u7684\u65F6\u95F4
          float deltaTime = max(mod(uTime, life) - startTime, 0.0);

          bool isDying = false;

          if (uOnce == 1.0 || uActive == 0.0) {
            isDying = true;
          }

          if ((isDying && uTime > life)) {
            deltaTime = life;
          }

          // \u6CA1\u51FA\u751F\u5C31\u4EE3\u8868\u6B7B\u4EA1\uFF0C\u5426\u5219\u6CA1\u51FA\u751F\u5C31\u663E\u793A\u4E86
          if (deltaTime == 0.0) {
            deltaTime = life;
          }

          lifeLeft = 1.0 - deltaTime / lifeTime;
          float scale = size;
          vec3 position = positionStart + (velocity + acceleration * deltaTime * 0.5) * deltaTime;
      `,
      postionShader: `
        gl_Position = matModelViewProjection * vec4(position, 1.0 );
      `,
      sizeVertexShader: `
          scale *= pow(scaleFactor, deltaTime);
      `,
      isScaleByLifetimeVertexShader: `
          scale *= lifeLeft;
      `,
      rotateToVelocityVertexShader: `
        vec3 v = velocity + acceleration * deltaTime;
        float angle = atan(v.z, v.x) * 2.0;
        float s = sin(angle);
        float c = cos(angle);
      `,
      rotationVertexShader: `
        float deltaAngle = deltaTime * rotateRate;
        float angle = startAngle + deltaAngle;
        float s = sin(angle);
        float c = cos(angle);

      `,
      rotation2dShader: `
        vec2 rotatedPoint = rotation2d(angle) * vec2(normalizedUv.x, normalizedUv.y * uv.z);

        vec3 basisX = matViewInverse[0].xyz;
        vec3 basisZ = matViewInverse[1].xyz;

        vec3 localPosition = vec3(basisX * rotatedPoint.x + 
                    basisZ * rotatedPoint.y) * scale + position;

        gl_Position = matProjection * matView * vec4(localPosition + matWorld[3].xyz, 1.);
      `,
      rotation3dShader: `
        vec4 rotatedPoint = vec4((normalizedUv.x * c + normalizedUv.y * uv.z * s) * scale , 0., 
                                 (normalizedUv.x * s - normalizedUv.y * uv.z * c) * scale, 1.);
      
        vec4 orientation = vec4(0, 0, 0, 1);
        vec4 q2 = orientation + orientation;
        vec4 qx = orientation.xxxw * q2.xyzx;
        vec4 qy = orientation.xyyw * q2.xyzy;
        vec4 qz = orientation.xxzw * q2.xxzz;
      
        mat4 localMatrix = mat4(
            (1.0 - qy.y) - qz.z, 
            qx.y + qz.w, 
            qx.z - qy.w,
            0,
      
            qx.y - qz.w, 
            (1.0 - qx.x) - qz.z, 
            qy.z + qx.w,
            0,
      
            qx.z + qy.w, 
            qy.z - qx.w, 
            (1.0 - qx.x) - qy.y,
            0,
      
            position.x, position.y, position.z, 1);

        rotatedPoint = localMatrix * rotatedPoint;

        gl_Position = matModelViewProjection * rotatedPoint;
      `,
      fragmentShader: `
        precision mediump float;
        precision mediump int;

        varying vec3 v_color;
        varying float v_alpha;
        varying float lifeLeft;
        varying vec2 v_uv;
        uniform sampler2D particleTex;
        uniform sampler2D particleMaskTex;

        void main()
        {
          float alphaFactor = 1.0;
      `,
      fadeInFragmentShader: `
        float fadeInFactor = step(0.5, lifeLeft);
        alphaFactor = 2.0 * fadeInFactor * (1.0 - lifeLeft) + (1.0 - fadeInFactor);
      `,
      fadeOutFragmentShader: `
        float fadeOutFactor = step(0.5, lifeLeft);
        alphaFactor = alphaFactor * 2.0 * (1.0 - fadeOutFactor) * lifeLeft + alphaFactor * fadeOutFactor;
      `,
      noImgFragmentShader: ` 
        gl_FragColor = vec4( v_color, alphaFactor * v_alpha);
      `,
      imgFragmentShader: `
        vec4 tex = texture2D(particleTex, v_uv);
      `,
      originColorFragmentShader: `
        gl_FragColor = vec4(tex.rgb, alphaFactor * tex.a * v_alpha);
      `,
      createColorFragmentShader: `
        gl_FragColor = vec4(v_color * tex.rgb, alphaFactor * tex.a * v_alpha);
      `,
      createColorWithMaskFragmentShader: `
        vec4 maskTex = texture2D( particleMaskTex, v_uv);
        gl_FragColor = vec4(v_color * tex.rgb + maskTex.a, alphaFactor * tex.a * v_alpha);
      `
    };
  }
  _createVertexShader() {
    const shader = this._getShader();
    let vertexShader = "";
    if (this.vertexShader) {
      vertexShader = this.vertexShader;
    } else {
      vertexShader = shader.vertexShader;
      if (this.isScaleByLifetime) {
        vertexShader += shader.isScaleByLifetimeVertexShader;
      } else {
        vertexShader += shader.sizeVertexShader;
      }
      if (this.rotateToVelocity) {
        vertexShader += shader.rotateToVelocityVertexShader;
      } else {
        vertexShader += shader.rotationVertexShader;
      }
      if (this.is2d) {
        vertexShader += shader.rotation2dShader;
      } else {
        vertexShader += shader.rotation3dShader;
      }
      vertexShader += "}";
    }
    return vertexShader;
  }
  _createFragmentShader() {
    const shader = this._getShader();
    let fragmentShader = "";
    if (this.fragmentShader) {
      fragmentShader = this.fragmentShader;
    } else {
      fragmentShader = shader.fragmentShader;
      if (this.fadeIn) {
        fragmentShader += shader.fadeInFragmentShader;
      }
      if (this.fadeOut) {
        fragmentShader += shader.fadeOutFragmentShader;
      }
      if (!this.particleTex) {
        fragmentShader += shader.noImgFragmentShader;
      } else {
        fragmentShader += shader.imgFragmentShader;
        if (this.useOriginColor) {
          fragmentShader += shader.originColorFragmentShader;
        } else {
          if (this.particleMaskTex) {
            fragmentShader += shader.createColorWithMaskFragmentShader;
          } else {
            fragmentShader += shader.createColorFragmentShader;
          }
        }
      }
      fragmentShader += "}";
    }
    return fragmentShader;
  }
}

class Particle extends GPUParticleSystem {
  constructor(entity) {
    super(entity);
  }
  init(props) {
    this._options = {
      position: props.__position,
      positionRandomness: props.__positionRandomness,
      velocity: props.__velocity,
      velocityRandomness: props.__velocityRandomness,
      acceleration: props.__acceleration,
      accelerationRandomness: props.__accelerationRandomness,
      color: props.__color,
      colorRandomness: props.__colorRandomness,
      lifetime: props.__lifetime,
      size: props.__size,
      sizeRandomness: props.__sizeRandomness,
      startAngle: props.__startAngle,
      startAngleRandomness: props.__startAngleRandomness,
      rotateRate: props.__rotateRate,
      rotateRateRandomness: props.__rotateRateRandomness,
      scaleFactor: props.__scaleFactor,
      alpha: props.__alpha,
      alphaRandomness: props.__alphaRandomness,
      startTimeRandomness: props.__startTimeRandomness
    };
    this._config = {
      maxCount: props.__maxCount,
      once: props.__once,
      rotateToVelocity: props.__rotateToVelocity,
      isScaleByLifetime: props.__isScaleByLifetime,
      fadeIn: props.__fadeIn,
      fadeOut: props.__fadeOut,
      texture: props.__texture ? props.__texture : null,
      maskTexture: props.__maskTexture ? props.__maskTexture : null,
      useOriginColor: props.__useOriginColor,
      is2d: props.__is2d,
      options: this._options
    };
    if (props.__spriteSheet) {
      if (typeof props.__spriteSheet === "object" && props.__spriteSheet.length) {
        this._config.spriteSheet = props.__spriteSheet;
      } else if (typeof props.__spriteSheet === "string") {
        try {
          const spriteSheet = JSON.parse(props.__spriteSheet);
          if (spriteSheet.length) {
            this._config.spriteSheet = spriteSheet;
          }
        } catch (e) {
        }
      }
    }
    if (props.__positionArray) {
      if (typeof props.__positionArray === "object" && props.__positionArray.length) {
        this._options.positionArray = props.__positionArray;
      } else if (typeof props.__positionArray === "string") {
        try {
          const positionArray = JSON.parse(props.__positionArray);
          if (positionArray.length) {
            this._options.positionArray = positionArray;
          }
        } catch (e) {
        }
      }
    }
    if (props.__separate) {
      this._config.blendFuncSeparate = [
        BlendFunc[props.__srcRGB || "SRC_ALPHA"],
        BlendFunc[props.__dstRGB || "ONE_MINUS_SRC_ALPHA"],
        BlendFunc[props.__srcAlpha || "SRC_ALPHA"],
        BlendFunc[props.__dstAlpha || "ONE_MINUS_SRC_ALPHA"]
      ];
    } else if (props.__src && props.__dst) {
      this._config.blendFunc = [BlendFunc[props.__src], BlendFunc[props.__dst]];
    }
    this.initialize(this._config);
    if (props.__defaultStart === true || props.__defaultStart === void 0) {
      this.start();
    }
  }
  updateOption(key, value) {
    this._options = {
      ...this._options,
      [key]: value
    };
    this._config = {
      ...this._config,
      options: {
        ...this._options
      }
    };
    this.initialize(this._config);
    this.start();
  }
  updateConfig(key, value) {
    this._config = {
      ...this._config,
      [key]: value
    };
    this.initialize(this._config);
    this.start();
  }
  set __position(value) {
    this.updateOption("position", value);
  }
  set __positionRandomness(value) {
    this.updateOption("positionRandomness", value);
  }
  set __velocity(value) {
    this.updateOption("velocity", value);
  }
  set __velocityRandomness(value) {
    this.updateOption("velocityRandomness", value);
  }
  set __acceleration(value) {
    this.updateOption("acceleration", value);
  }
  set __accelerationRandomness(value) {
    this.updateOption("accelerationRandomness", value);
  }
  set __color(value) {
    this.updateOption("color", value);
  }
  set __colorRandomness(value) {
    this.updateOption("colorRandomness", value);
  }
  set __lifetime(value) {
    this.updateOption("lifetime", value);
  }
  set __size(value) {
    this.updateOption("size", value);
  }
  set __sizeRandomness(value) {
    this.updateOption("sizeRandomness", value);
  }
  set __startAngle(value) {
    this.updateOption("startAngle", value);
  }
  set __startAngleRandomness(value) {
    this.updateOption("startAngleRandomness", value);
  }
  set __rotateRate(value) {
    this.updateOption("rotateRate", value);
  }
  set __rotateRateRandomness(value) {
    this.updateOption("rotateRateRandomness", value);
  }
  set __scaleFactor(value) {
    this.updateOption("scaleFactor", value);
  }
  set __alpha(value) {
    this.updateOption("alpha", value);
  }
  set __alphaRandomness(value) {
    this.updateOption("alphaRandomness", value);
  }
  set __startTimeRandomness(value) {
    this.updateOption("startTimeRandomness", value);
  }
  set __positionArray(value) {
    if (typeof value === "object" && value.length) {
      this.updateOption("positionArray", value);
    } else if (typeof value === "string") {
      try {
        const positionArray = JSON.parse(value);
        if (positionArray.length) {
          this.updateOption("positionArray", positionArray);
        } else {
          this.updateOption("positionArray", null);
        }
      } catch (e) {
        this.updateOption("positionArray", null);
      }
    } else {
      this.updateOption("positionArray", null);
    }
  }
  set __maxCount(value) {
    this.updateConfig("maxCount", value);
  }
  set __useOriginColor(value) {
    this.updateConfig("useOriginColor", value);
  }
  set __once(value) {
    this.updateConfig("once", value);
  }
  set __rotateToVelocity(value) {
    this.updateConfig("rotateToVelocity", value);
  }
  set __isScaleByLifetime(value) {
    this.updateConfig("isScaleByLifetime", value);
  }
  set __fadeIn(value) {
    this.updateConfig("fadeIn", value);
  }
  set __fadeOut(value) {
    this.updateConfig("fadeOut", value);
  }
  set __texture(value) {
    this.updateConfig("texture", value);
  }
  set __maskTexture(value) {
    this.updateConfig("maskTexture", value);
  }
  set __spriteSheet(value) {
    if (typeof value === "object" && value.length) {
      this.updateConfig("spriteSheet", value);
    } else if (typeof value === "string") {
      try {
        const spriteSheet = JSON.parse(value);
        if (spriteSheet.length) {
          this.updateConfig("spriteSheet", spriteSheet);
        } else {
          this.updateConfig("spriteSheet", null);
        }
      } catch (e) {
        this.updateConfig("spriteSheet", null);
      }
    } else {
      this.updateConfig("spriteSheet", null);
    }
  }
  set __is2d(value) {
    this.updateConfig("is2d", value);
  }
}

var FRAG_SHADER$1 = "varying vec2 v_uv;\n\nuniform sampler2D u_texture;\n\nvoid main(void) {\n\n  gl_FragColor = texture2D(u_texture, v_uv);\n\n}\n";

var VERT_SHADER = "attribute vec3 a_position;\nattribute vec2 a_uv;\n\nvarying vec2 v_uv;\n\nuniform mat4 u_projMat;\nuniform mat4 u_viewMat;\n\nvoid main() {\n\n  gl_Position = u_projMat * u_viewMat * vec4( a_position, 1.0 );\n  v_uv = a_uv;\n\n}\n";

class TrailMaterial extends Material {
  _generateTechnique() {
    const tech = new RenderTechnique("trail_tech");
    tech.isValid = true;
    tech.uniforms = {
      u_texture: {
        name: "u_texture",
        type: DataType.SAMPLER_2D
      }
    };
    tech.attributes = {};
    tech.states = {
      enable: [RenderState.BLEND],
      functions: {
        blendFunc: [BlendFunc.SRC_ALPHA, BlendFunc.ONE],
        depthMask: [false]
      }
    };
    tech.customMacros = [];
    tech.vertexShader = VERT_SHADER;
    tech.fragmentShader = FRAG_SHADER$1;
    this._technique = tech;
    this.renderType = MaterialType.TRANSPARENT;
  }
  prepareDrawing(context, component, primitive) {
    if (this._technique === null) {
      this._generateTechnique();
    }
    super.prepareDrawing(context, component, primitive);
  }
}

const _tempVector3 = new Vector3();
class TrailRenderer extends GeometryRenderer {
  constructor(entity, props) {
    super(entity);
    this._stroke = props.stroke || 0.2;
    this._minSeg = props.minSeg || 0.02;
    this._lifetime = props.lifetime || 1e3;
    this._maxPointNum = this._lifetime / 1e3 * entity.engine.targetFrameRate;
    this._points = [];
    this._pointStates = [];
    this._strapPoints = [];
    for (let i = 0; i < this._maxPointNum; i++) {
      this._points.push(new Vector3());
      this._pointStates.push(this._lifetime);
      this._strapPoints.push(new Vector3());
      this._strapPoints.push(new Vector3());
    }
    this._curPointNum = 0;
    const mtl = props.material || new TrailMaterial(this.engine, "trial_mtl");
    this.material = mtl;
    this.setTexture(props.texture);
    this._initGeometry();
  }
  update(deltaTime) {
    let mov = 0, newIdx = 0;
    for (let i = 0; i < this._curPointNum; i++) {
      this._pointStates[i] -= deltaTime;
      if (this._pointStates[i] < 0) {
        mov++;
      } else if (mov > 0) {
        newIdx = i - mov;
        this._pointStates[newIdx] = this._pointStates[i];
        this._points[i].cloneTo(this._points[newIdx]);
      }
    }
    this._curPointNum -= mov;
    let appendNewPoint = true;
    if (this._curPointNum === this._maxPointNum) {
      appendNewPoint = false;
    } else if (this._curPointNum > 0) {
      const lastPoint = this._points[this._points.length - 1];
      if (Vector3.distance(this.entity.worldPosition, lastPoint) < this._minSeg) {
        appendNewPoint = false;
      }
    }
    if (appendNewPoint) {
      this._pointStates[this._curPointNum] = this._lifetime;
      this.entity.worldPosition.cloneTo(this._points[this._curPointNum]);
      this._curPointNum++;
    }
  }
  render(camera) {
    this._updateStrapVertices(camera, this._points);
    this._updateStrapCoords();
    this._vertexBuffer.setData(this._vertices);
    super.render(camera);
  }
  setTexture(texture) {
    if (texture) {
      this.material.setValue("u_texture", texture);
    }
  }
  _initGeometry() {
    const geometry2 = new BufferGeometry(this._entity.engine);
    const vertexStride = 20;
    const vertexCount = this._maxPointNum * 2;
    const vertexFloatCount = vertexCount * vertexStride;
    const vertices = new Float32Array(vertexFloatCount);
    const vertexElements = [
      new VertexElement("POSITION", 0, VertexElementFormat.Vector3, 0),
      new VertexElement("TEXCOORD_0", 12, VertexElementFormat.Vector2, 0)
    ];
    const vertexBuffer = new Buffer(this.engine, vertexFloatCount * 4, BufferUsage.Dynamic);
    geometry2.setVertexBufferBinding(vertexBuffer, vertexStride);
    geometry2.setVertexElements(vertexElements);
    geometry2.addSubGeometry(0, vertexCount, PrimitiveTopology.TriangleStrip);
    this._vertexBuffer = vertexBuffer;
    this._vertexStride = vertexStride;
    this._vertices = vertices;
    this.geometry = geometry2;
  }
  _updateStrapVertices(camera, points) {
    const m = camera.viewMatrix;
    const e = m.elements;
    const vx = new Vector3(e[0], e[4], e[8]);
    const vy = new Vector3(e[1], e[5], e[9]);
    const vz = new Vector3(e[2], e[6], e[10]);
    const s = this._stroke;
    vy.scale(s);
    const up = new Vector3();
    const down = new Vector3();
    const rotation = new Quaternion();
    Vector3.transformByQuat(vx, rotation, vx);
    Vector3.transformByQuat(vy, rotation, vy);
    const dy = new Vector3();
    const cross = new Vector3();
    const perpVector = new Vector3();
    vx.normalize();
    const vertieces = this._vertices;
    for (let i = 0; i < this._maxPointNum; i++) {
      if (i < this._curPointNum) {
        const p = points[i];
        if (i === this._curPointNum - 1 && i !== 0) {
          Vector3.subtract(p, points[i - 1], perpVector);
        } else {
          Vector3.subtract(points[i + 1], p, perpVector);
        }
        this._projectOnPlane(perpVector, vz, perpVector);
        perpVector.normalize();
        let angle = Math.acos(Vector3.dot(vx, perpVector));
        Vector3.cross(vx, perpVector, cross);
        if (Vector3.dot(cross, vz) <= 0) {
          angle = Math.PI * 2 - angle;
        }
        Quaternion.rotationAxisAngle(vz, angle, rotation);
        Vector3.transformByQuat(vy, rotation, dy);
        Vector3.add(p, dy, up);
        Vector3.subtract(p, dy, down);
      }
      const p0 = i * 2 * this._vertexStride / 4;
      const p1 = (i * 2 + 1) * this._vertexStride / 4;
      vertieces[p0] = up.x;
      vertieces[p0 + 1] = up.y;
      vertieces[p0 + 2] = up.z;
      vertieces[p1] = down.x;
      vertieces[p1 + 1] = down.y;
      vertieces[p1 + 2] = down.z;
    }
  }
  _updateStrapCoords() {
    if (this._prePointsNum === this._curPointNum) {
      return;
    }
    this._prePointsNum = this._curPointNum;
    const count = this._curPointNum;
    const texDelta = 1 / count;
    const vertieces = this._vertices;
    for (let i = 0; i < count; i++) {
      const d = 1 - i * texDelta;
      const p0 = i * 2 * this._vertexStride / 4;
      const p1 = (i * 2 + 1) * this._vertexStride / 4;
      vertieces[p0] = 0;
      vertieces[p0 + 1] = d;
      vertieces[p1] = 1;
      vertieces[p1 + 1] = d;
    }
  }
  _projectOnVector(a, p, out) {
    const n_p = p.clone();
    Vector3.normalize(n_p, n_p);
    const cosine = Vector3.dot(a, n_p);
    out.x = n_p.x * cosine;
    out.y = n_p.y * cosine;
    out.z = n_p.z * cosine;
  }
  _projectOnPlane(a, n, out) {
    this._projectOnVector(a, n, _tempVector3);
    Vector3.subtract(a, _tempVector3, out);
  }
}

class BoxCollider extends ABoxCollider {
  constructor(entity) {
    super(entity);
    this._center = new Vector3();
    this._size = new Vector3();
    this.isShowCollider = true;
    this.center = this.center;
    this.size = this.size;
    this.isShowCollider = this.isShowCollider;
  }
  get center() {
    return this._center;
  }
  set center(value) {
    this._center = value;
    this.setBoxCenterSize(this._center, this._size);
  }
  get size() {
    return this._size;
  }
  set size(value) {
    this._size = value;
    this.setBoxCenterSize(this._center, this._size);
  }
}

class SphereCollider extends ASphereCollider {
  constructor(entity) {
    super(entity);
    this.__center = new Vector3();
    this.__radius = 1;
    this.isShowCollider = true;
    this._center = this._center;
    this._radius = this._radius;
    this.isShowCollider = this.isShowCollider;
  }
  get _center() {
    return this.__center;
  }
  set _center(value) {
    this.__center = value;
    this.setSphere(this.__center, this.__radius);
  }
  get _radius() {
    return this.__radius;
  }
  set _radius(value) {
    this.__radius = value;
    this.setSphere(this.__center, this.__radius);
  }
}

Scene.registerFeature(ColliderFeature);

function intersectBox2Box(boxA, boxB) {
  return boxA.min.x <= boxB.max.x && boxA.max.x >= boxB.min.x && boxA.min.y <= boxB.max.y && boxA.max.y >= boxB.min.y && boxA.min.z <= boxB.max.z && boxA.max.z >= boxB.min.z;
}
function intersectSphere2Sphere(sphereA, sphereB) {
  const distance = Vector3.distance(sphereA.center, sphereB.center);
  return distance < sphereA.radius + sphereA.radius;
}
function intersectSphere2Box(sphere, box) {
  const center = sphere.center;
  const closestPoint = new Vector3(Math.max(box.min.x, Math.min(center.x, box.max.x)), Math.max(box.min.y, Math.min(center.y, box.max.y)), Math.max(box.min.z, Math.min(center.z, box.max.z)));
  const distance = Vector3.distance(center, closestPoint);
  return distance < sphere.radius;
}

class CollisionDetection extends Script {
  constructor(entity) {
    super(entity);
    this._colliderManager = null;
    this._myCollider = null;
    this._overlopCollider = null;
  }
  get overlopCollider() {
    return this._overlopCollider;
  }
  onUpdate(deltaTime) {
    super.onUpdate(deltaTime);
    let overlopCollider = null;
    if (this._colliderManager && this._myCollider) {
      const colliders = this._colliderManager.colliders;
      if (this._myCollider instanceof ABoxCollider) {
        this._box = this._getWorldBox(this._myCollider);
        for (let i = 0, len = colliders.length; i < len; i++) {
          const collider2 = colliders[i];
          if (collider2 != this._myCollider && this._boxCollision(collider2)) {
            overlopCollider = collider2;
            this.trigger(new Event("collision", this, {collider: collider2}));
          }
        }
      } else if (this._myCollider instanceof ASphereCollider) {
        this._sphere = this._getWorldSphere(this._myCollider);
        for (let i = 0, len = colliders.length; i < len; i++) {
          const collider2 = colliders[i];
          if (collider2 != this._myCollider && this._sphereCollision(collider2)) {
            overlopCollider = collider2;
            this.trigger(new Event("collision", this, {collider: collider2}));
          }
        }
      }
    }
    if (overlopCollider != null && this._overlopCollider != overlopCollider) {
      this.trigger(new Event("begin_overlop", this, {collider: overlopCollider}));
    }
    if (this._overlopCollider != null && this._overlopCollider != overlopCollider) {
      const e = this._overlopCollider;
      this.trigger(new Event("end_overlop", this, {collider: e}));
    }
    this._overlopCollider = overlopCollider;
  }
  _getWorldBox(boxCollider) {
    const mat = boxCollider.entity.transform.worldMatrix;
    const max = new Vector3();
    const min = new Vector3();
    Vector3.transformCoordinate(boxCollider.boxMax, mat, max);
    Vector3.transformCoordinate(boxCollider.boxMin, mat, min);
    const temp = CollisionDetection._tempVec3;
    const corners = boxCollider.getCorners();
    for (let i = 0; i < 8; i++) {
      Vector3.transformCoordinate(corners[i], mat, temp);
      if (temp.x > max.x)
        max.x = temp.x;
      if (temp.y > max.y)
        max.y = temp.y;
      if (temp.z > max.z)
        max.z = temp.z;
      if (temp.x < min.x)
        min.x = temp.x;
      if (temp.y < min.y)
        min.y = temp.y;
      if (temp.z < min.z)
        min.z = temp.z;
    }
    return {
      min,
      max
    };
  }
  _getWorldSphere(sphereCollider) {
    const center = new Vector3();
    Vector3.transformCoordinate(sphereCollider.center, sphereCollider.entity.transform.worldMatrix, center);
    return {
      radius: sphereCollider.radius,
      center
    };
  }
  _boxCollision(other) {
    if (other instanceof ABoxCollider) {
      const box = this._getWorldBox(other);
      return intersectBox2Box(box, this._box);
    } else if (other instanceof ASphereCollider) {
      const sphere = this._getWorldSphere(other);
      return intersectSphere2Box(sphere, this._box);
    }
    return false;
  }
  _sphereCollision(other) {
    if (other instanceof ABoxCollider) {
      const box = this._getWorldBox(other);
      return intersectSphere2Box(this._sphere, box);
    } else if (other instanceof ASphereCollider) {
      const sphere = this._getWorldSphere(other);
      return intersectSphere2Sphere(sphere, this._sphere);
    }
    return false;
  }
  onAwake() {
    this._colliderManager = this.scene.findFeature(ColliderFeature);
    this._myCollider = this.entity.getComponent(Collider);
  }
}
CollisionDetection._tempVec3 = new Vector3();

class Fog extends Component {
  constructor(node) {
    super(node);
    this.color = new Vector3(1, 0, 0);
  }
  _onEnable() {
    this.scene.findFeature(FogFeature).fog = this;
  }
  _onDisable() {
    this.scene.findFeature(FogFeature).fog = null;
  }
  bindMaterialValues(mtl) {
  }
}

class EXP2Fog extends Fog {
  constructor() {
    super(...arguments);
    this.density = 25e-4;
  }
  bindMaterialValues(mtl) {
    mtl.setValue("u_fogColor", this.color);
    mtl.setValue("u_fogDensity", this.density);
  }
}

function hasFogFeature() {
  return true;
}
function getFogMacro() {
  return this.findFeature(FogFeature).macro;
}
function bindFogToMaterial(mtl) {
  this.findFeature(FogFeature).bindFogToMaterial(mtl);
}
class FogFeature extends SceneFeature {
  constructor() {
    super();
    this._fog = null;
    this._macros = [];
  }
  get fog() {
    return this._fog;
  }
  set fog(v) {
    if (v !== this._fog) {
      this._fog = v;
      const macro = [];
      if (v instanceof Fog) {
        macro.push("O3_HAS_FOG");
        if (v instanceof EXP2Fog) {
          macro.push("O3_FOG_EXP2");
        }
      }
      if (this._macros.length !== macro.length) {
        this._macros = macro;
      }
    }
  }
  get macro() {
    return this._macros;
  }
  bindFogToMaterial(mtl) {
    if (this.fog && mtl.useFog) {
      this.fog.bindMaterialValues(mtl);
    }
    return this;
  }
}

class LinearFog extends Fog {
  constructor() {
    super(...arguments);
    this.near = 1;
    this.far = 1e3;
  }
  bindMaterialValues(mtl) {
    mtl.setValue("u_fogColor", this.color);
    mtl.setValue("u_fogNear", this.near);
    mtl.setValue("u_fogFar", this.far);
  }
}

Scene.registerFeature(FogFeature);
Scene.prototype.hasFogFeature = hasFogFeature;
Scene.prototype.getFogMacro = getFogMacro;
Scene.prototype.bindFogToMaterial = bindFogToMaterial;

let cacheId = 0;
class Probe extends Component {
  set camera(camera) {
    if (camera === this._camera)
      return;
    this._camera && this.renderPipeline.removeRenderPass(this.renderPass);
    this._camera = camera;
    camera && this.renderPipeline.addRenderPass(this.renderPass);
  }
  get camera() {
    return this._camera;
  }
  get texture() {
    return this.renderPass.renderTarget?.getColorTexture();
  }
  get depthTexture() {
    return this.renderPass.renderTarget?.depthTexture;
  }
  get cubeTexture() {
    return this.renderPass.renderTarget?.getColorTexture();
  }
  get renderPipeline() {
    return this.camera._renderPipeline;
  }
  get rhi() {
    return this.camera.scene.engine._hardwareRenderer;
  }
  get renderItems() {
    const opaqueQueue = this.renderPipeline.opaqueQueue;
    const transparentQueue = this.renderPipeline.transparentQueue;
    return opaqueQueue.items.concat(transparentQueue.items).filter((item) => {
      if (!item.primitive)
        return false;
      if (this.excludeRenderList.includes(item.material))
        return false;
      if (this.renderAll)
        return true;
      if (this.renderList.includes(item.material))
        return true;
    });
  }
  get samples() {
    return this.renderTarget.antiAliasing;
  }
  constructor(entity) {
    super(entity);
    this.cacheId = cacheId++;
    this.renderPass = new RenderPass("_renderPass" + this.cacheId, -10);
    this.renderPass.renderOverride = true;
    this.renderPass.preRender = this.preRender.bind(this);
    this.renderPass.render = this.render.bind(this);
    this.renderPass.postRender = this.postRender.bind(this);
    this.addEventListener("enabled", () => {
      this.renderPass.enabled = true;
    });
    this.addEventListener("disabled", () => {
      this.renderPass.enabled = false;
    });
  }
  init(config = {}) {
    this.isCube = !!config.isCube;
    this.camera = config.camera || this.scene._activeCameras[0];
    this.excludeRenderList = config.excludeRenderList || [];
    this.renderAll = !!config.renderAll;
    this.renderList = config.renderList || [];
    this.clipPlanes = config.clipPlanes || [];
    const width = config.width || 1024;
    const height = config.height || 1024;
    const samples = config.samples || 1;
    this.renderTarget = new RenderTarget(this.engine, width, height, new RenderColorTexture(this.engine, width, height, void 0, false, this.isCube), RenderBufferDepthFormat.Depth, samples);
    this.renderTargetSwap = new RenderTarget(this.engine, width, height, new RenderColorTexture(this.engine, width, height, void 0, false, this.isCube), RenderBufferDepthFormat.Depth, samples);
    this.renderPass.renderTarget = this.renderTarget;
  }
  preRender() {
    this.oriClipPlane = this.scene.clipPlanes;
    this.scene.clipPlanes = this.clipPlanes;
  }
  render() {
    const context = RenderContext._getRenderContext(this.camera);
    this.renderItems.forEach((item) => {
      const {component, primitive, subPrimitive, material} = item;
      if (!(component.renderPassFlag & this.renderPassFlag))
        return;
      material.prepareDrawing(context, component, primitive);
      this.rhi.drawPrimitive(primitive, subPrimitive, material);
    });
  }
  postRender() {
    this.scene.clipPlanes = this.oriClipPlane;
    if (this.renderPass.enabled) {
      if (this.onTextureChange) {
        if (this.isCube) {
          this.onTextureChange(this.cubeTexture);
        } else {
          this.onTextureChange(this.texture, this.depthTexture);
        }
      }
      if (this.renderPass.renderTarget === this.renderTarget) {
        this.renderPass.renderTarget = this.renderTargetSwap;
      } else {
        this.renderPass.renderTarget = this.renderTarget;
      }
    }
  }
  destroy() {
    this.enabled = false;
    this.renderPipeline.removeRenderPass(this.renderPass);
    super.destroy();
    this.renderTarget.destroy();
    this.renderTargetSwap.destroy();
  }
  onTextureChange(texture, depthTexture) {
  }
}

class PlaneProbe extends Probe {
  constructor(node) {
    super(node);
  }
  init(config = {}) {
    super.init(config);
  }
  storeMaterial() {
    this.renderItems.forEach((item) => {
      const material = item.material;
      item.initialSide = material.side;
      material.side = Side.BACK;
    });
  }
  restoreMaterial() {
    this.renderItems.forEach((item) => {
      const material = item.material;
      material.side = item.initialSide;
      delete item.initialSide;
    });
  }
  preRender() {
    super.preRender();
    this.storeMaterial();
  }
  postRender() {
    super.postRender();
    this.restoreMaterial();
  }
}

const cacheTarget = new Vector3();
const cacheUp = new Vector3();
const cacheDir = new Vector3();
const fovRadian = 90 * Math.PI / 180;
class CubeProbe extends Probe {
  constructor(node) {
    super(node);
    this.oriViewMatrix = new Matrix();
    this.oriInverseViewMatrix = new Matrix();
    this.oriProjectionMatrix = new Matrix();
    this.oriInverseProjectionMatrix = new Matrix();
  }
  init(config = {}) {
    super.init({
      ...config,
      isCube: true
    });
    this.position = config.position || new Vector3();
  }
  storeCamera() {
    this.camera.viewMatrix.cloneTo(this.oriViewMatrix);
    this.camera.inverseViewMatrix.cloneTo(this.oriInverseViewMatrix);
    this.camera.projectionMatrix.cloneTo(this.oriProjectionMatrix);
    this.camera.inverseProjectionMatrix.cloneTo(this.oriInverseProjectionMatrix);
  }
  restoreCamera() {
    this.oriViewMatrix.cloneTo(this.camera.viewMatrix);
    this.oriInverseViewMatrix.cloneTo(this.camera.inverseViewMatrix);
    this.oriProjectionMatrix.cloneTo(this.camera.projectionMatrix);
    this.oriInverseProjectionMatrix.cloneTo(this.camera.inverseProjectionMatrix);
  }
  preRender() {
    super.preRender();
    this.storeCamera();
  }
  render() {
    for (let faceIndex = 0; faceIndex < 6; faceIndex++) {
      this.rhi.setRenderTargetFace(this.renderPass.renderTarget, faceIndex);
      this.rhi.clearRenderTarget(this.renderPass.clearMode, this.renderPass.clearParam);
      this.setCamera(faceIndex);
      super.render();
      if (faceIndex < 5) {
        this.rhi.blitRenderTarget(this.renderPass.renderTarget);
      }
    }
  }
  postRender() {
    super.postRender();
    this.restoreCamera();
  }
  setCamera(faceIndex) {
    switch (faceIndex) {
      case 0:
        cacheUp.setValue(0, -1, 0);
        cacheDir.setValue(1, 0, 0);
        break;
      case 1:
        cacheUp.setValue(0, -1, 0);
        cacheDir.setValue(-1, 0, 0);
        break;
      case 2:
        cacheUp.setValue(0, 0, 1);
        cacheDir.setValue(0, 1, 0);
        break;
      case 3:
        cacheUp.setValue(0, 0, -1);
        cacheDir.setValue(0, -1, 0);
        break;
      case 4:
        cacheUp.setValue(0, -1, 0);
        cacheDir.setValue(0, 0, 1);
        break;
      case 5:
        cacheUp.setValue(0, -1, 0);
        cacheDir.setValue(0, 0, -1);
        break;
    }
    Vector3.add(this.position, cacheDir, cacheTarget);
    Matrix.lookAt(this.position, cacheTarget, cacheUp, this.camera.viewMatrix);
    Matrix.invert(this.camera.viewMatrix, this.camera.inverseViewMatrix);
    Matrix.perspective(fovRadian, 1, this.camera.nearClipPlane, this.camera.farClipPlane, this.camera.projectionMatrix);
    Matrix.invert(this.camera.projectionMatrix, this.camera.inverseProjectionMatrix);
  }
}

class LightShadow {
  constructor(props = {engine: null, width: 512, height: 512}) {
    this._mapSize = new Vector2(props.width, props.height);
    this._renderTarget = new RenderTarget(props.engine, props.width, props.height, new RenderColorTexture(props.engine, props.width, props.height));
    this.bias = 5e-3;
    this.intensity = 0.2;
    this.radius = 1;
    this.projectionMatrix = new Matrix();
  }
  get renderTarget() {
    return this._renderTarget;
  }
  get map() {
    return this._renderTarget.getColorTexture();
  }
  get mapSize() {
    return this._mapSize;
  }
  initShadowProjectionMatrix(light) {
    if (light instanceof DirectLight) {
      Matrix.ortho(-5, 5, -5, 5, 0.1, 50, this.projectionMatrix);
    }
    if (light instanceof PointLight) {
      Matrix.perspective(MathUtil.degreeToRadian(50), 1, 0.5, 50, this.projectionMatrix);
    }
    if (light instanceof SpotLight) {
      const fov = Math.min(Math.PI / 2, light.angle * 2 * Math.sqrt(2));
      Matrix.perspective(fov, 1, 0.1, light.distance + 5, this.projectionMatrix);
    }
  }
  bindShadowValues(mtl, index, light) {
    mtl.setValue(`u_viewMatFromLight[${index}]`, light.viewMatrix);
    mtl.setValue(`u_projMatFromLight[${index}]`, this.projectionMatrix);
    const uniformName = `u_shadows[${index}]`;
    mtl.setValue(uniformName + ".bias", this.bias);
    mtl.setValue(uniformName + ".intensity", this.intensity);
    mtl.setValue(uniformName + ".radius", this.radius);
    mtl.setValue(uniformName + ".mapSize", this._mapSize);
    mtl.setValue(`u_shadowMaps[${index}]`, this.map);
  }
  static getUniformDefine(index) {
    const uniforms = {};
    uniforms[`u_viewMatFromLight[${index}]`] = {
      name: `u_viewMatFromLight[${index}]`,
      type: DataType.FLOAT_MAT4
    };
    uniforms[`u_projMatFromLight[${index}]`] = {
      name: `u_projMatFromLight[${index}]`,
      type: DataType.FLOAT_MAT4
    };
    const uniformName = `u_shadows[${index}]`;
    uniforms[uniformName + ".bias"] = {
      name: uniformName + ".bias",
      type: DataType.FLOAT
    };
    uniforms[uniformName + ".intensity"] = {
      name: uniformName + ".intensity",
      type: DataType.FLOAT
    };
    uniforms[uniformName + ".radius"] = {
      name: uniformName + ".radius",
      type: DataType.FLOAT
    };
    uniforms[uniformName + ".mapSize"] = {
      name: uniformName + ".mapSize",
      type: DataType.FLOAT_VEC2
    };
    uniforms[`u_shadowMaps[${index}]`] = {
      name: `u_shadowMaps[${index}]`,
      type: DataType.SAMPLER_2D
    };
    return uniforms;
  }
}

Object.defineProperty(Light.prototype, "enableShadow", {
  get: function() {
    return this._enableShadow;
  },
  set: function(enabled) {
    this._enableShadow = enabled;
    if (this._enableShadow) {
      if (this instanceof AmbientLight) {
        Logger.warn("Has no shadow!");
        return;
      }
      this.shadow = this.shadow || new LightShadow({engine: this.engine, width: 512, height: 512});
      this.shadow.initShadowProjectionMatrix(this);
    }
  }
});
Object.defineProperty(Component.prototype, "recieveShadow", {
  get: function() {
    return this._recieveShadow;
  },
  set: function(enabled) {
    this._recieveShadow = enabled;
  }
});
Object.defineProperty(Component.prototype, "castShadow", {
  get: function() {
    return this._castShadow;
  },
  set: function(enabled) {
    this._castShadow = enabled;
  }
});

var fs$2 = "precision mediump float;\n\n/**\n * \n*/\nvec4 pack (float depth) {\n\n  // rgba 432z,11/256\n  const vec4 bitShift = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);\n  const vec4 bitMask = vec4(1.0/256.0, 1.0/256.0, 1.0/256.0, 0.0);\n\n  vec4 rgbaDepth = fract(depth * bitShift); //z\n\n  // Cut off the value which do not fit in 8 bits\n  rgbaDepth -= rgbaDepth.gbaa * bitMask;\n\n  return rgbaDepth;\n}\n\nvoid main() {\n\n  // zrgba,z\n  gl_FragColor = pack(gl_FragCoord.z);\n\n}";

var vs$2 = "#include <common_vert>\n#include <normal_share>\n#include <shadow_share>\n\nvoid main() {\n\n    #include <begin_position_vert>\n    #include <begin_normal_vert>\n    #include <skinning_vert>\n    #include <shadow_vert>\n    #include <position_vert>\n\n}\n";

class ShadowMapMaterial extends ComplexMaterial {
  _generateTechnique(camera, component) {
    const customMacros = this._generateMacros();
    const uniforms = this._generateFragmentUniform();
    const tech = new RenderTechnique(this.name);
    tech.isValid = true;
    tech.uniforms = uniforms;
    tech.attributes = {};
    tech.states = {};
    tech.customMacros = customMacros;
    tech.vertexShader = vs$2;
    tech.fragmentShader = fs$2;
    return tech;
  }
  _generateFragmentUniform() {
    const uniforms = {
      u_viewMatFromLight: {
        name: "u_viewMatFromLight",
        type: DataType.FLOAT_MAT4
      },
      u_projMatFromLight: {
        name: "u_projMatFromLight",
        type: DataType.FLOAT_MAT4
      }
    };
    return uniforms;
  }
  _generateMacros() {
    const macros = [];
    macros.push("O3_GENERATE_SHADOW_MAP");
    return macros;
  }
}

class ShadowMapPass extends RenderPass {
  constructor(name, priority, renderTarget, replaceMaterial, mask, light) {
    super(name, priority, renderTarget, replaceMaterial, mask);
    this.light = light;
  }
  preRender(camera, opaqueQueue, transparentQueue) {
    this.replaceMaterial.setValue("u_viewMatFromLight", this.light.viewMatrix);
    this.replaceMaterial.setValue("u_projMatFromLight", this.light.shadow.projectionMatrix);
  }
}

var fs$3 = "varying vec2 v_uv;\n\nuniform vec4 u_ambientLight;\n\n#ifdef O3_SHADOW_MAP_COUNT\n\nstruct Shadow {\n  float     bias;\n  float     intensity;\n  vec2      mapSize;\n  float     radius;\n};\n\nuniform Shadow u_shadows[O3_SHADOW_MAP_COUNT];\n\nuniform sampler2D u_shadowMaps[O3_SHADOW_MAP_COUNT];\n\nvarying vec4 v_PositionFromLight[O3_SHADOW_MAP_COUNT];\n\nconst vec4 bitShift = vec4(1.0, 1.0/256.0, 1.0/(256.0*256.0), 1.0/(256.0*256.0*256.0));\n\n/**\n* \n*/\nfloat unpack(const in vec4 rgbaDepth) {\n  return dot(rgbaDepth, bitShift);\n}\n\n/**\n* \n*/\nfloat getVisibility(vec4 positionFromLight, const in sampler2D shadowMap, vec2 mapSize, float intensity, float bias, float radius) {\n\n    vec3 shadowCoord = (positionFromLight.xyz/positionFromLight.w)/2.0 + 0.5;\n    float filterX = step(0.0, shadowCoord.x) * (1.0 - step(1.0, shadowCoord.x));\n    float filterY = step(0.0, shadowCoord.y) * (1.0 - step(1.0, shadowCoord.y));\n\n    shadowCoord.z -= bias;\n    vec2 texelSize = vec2( 1.0 ) / mapSize;\n\n    float visibility = 0.0;\n    for (float y = -1.0 ; y <=1.0 ; y+=1.0) {\n      for (float x = -1.0 ; x <=1.0 ; x+=1.0) {\n        vec2 uv = shadowCoord.xy + texelSize * vec2(x, y) * radius;\n        vec4 rgbaDepth = texture2D(shadowMap, uv);\n        float depth = unpack(rgbaDepth);\n        visibility += step(depth, shadowCoord.z) * intensity;\n      }\n    }\n\n    visibility *= ( 1.0 / 9.0 );\n    return visibility * filterX * filterY;\n\n}\n\n#endif\n\nvoid main() {\n\n  vec4 shadowColor = vec4(1.0, 1.0, 1.0, 1.0);\n\n#ifdef O3_SHADOW_MAP_COUNT\n\n  float visibility = 1.0;\n\n  for(int i = 0; i < O3_SHADOW_MAP_COUNT; i++) {\n\n   visibility -= getVisibility(v_PositionFromLight[i], u_shadowMaps[i], u_shadows[i].mapSize, u_shadows[i].intensity, u_shadows[i].bias, u_shadows[i].radius);\n\n  }\n\n  visibility = clamp(visibility, 0.0, 1.0);\n  shadowColor = vec4(visibility, visibility, visibility, 1.0);\n\n#endif\n\n  gl_FragColor = shadowColor;\n}";

class ShadowMaterial extends ComplexMaterial {
  _generateTechnique(camera, component) {
    const customMacros = this._generateMacros();
    const uniforms = this._generateFragmentUniform();
    const tech = new RenderTechnique(this.name);
    tech.autoConvert = false;
    tech.isValid = true;
    tech.uniforms = uniforms;
    tech.attributes = {};
    tech.states = {};
    tech.customMacros = customMacros;
    tech.vertexShader = vs$2;
    tech.fragmentShader = fs$3;
    tech.states = {
      enable: [RenderState.BLEND],
      functions: {
        depthFunc: [CompFunc.LEQUAL],
        blendFunc: [BlendFunc.DST_COLOR, BlendFunc.ZERO]
      }
    };
    return tech;
  }
  _generateFragmentUniform() {
    let uniforms = {};
    for (let i = 0; i < this.shadowMapCount; i++) {
      const lgtUniforms = LightShadow.getUniformDefine(i);
      uniforms = {...uniforms, ...lgtUniforms};
    }
    return uniforms;
  }
  _generateMacros() {
    const macros = [];
    if (this.shadowMapCount > 0) {
      macros.push(`O3_SHADOW_MAP_COUNT ${this.shadowMapCount}`);
    }
    return macros;
  }
}

class ShadowPass extends RenderPass {
  constructor(...args) {
    super(...args);
    this.clearMode = ClearMode.DONT_CLEAR;
  }
  preRender(camera, opaqueQueue, transparentQueue) {
    this.enabled = false;
    const lightMgr = camera.scene.findFeature(LightFeature);
    if (lightMgr) {
      const pass = camera._renderPipeline.defaultRenderPass;
      this.renderTarget = pass.renderTarget;
      const lights = lightMgr.visibleLights;
      let shadowMapCount = 0;
      for (let i = 0, len = lights.length; i < len; i++) {
        const lgt = lights[i];
        if (lgt.enableShadow) {
          lgt.shadow.bindShadowValues(this.replaceMaterial, shadowMapCount, lgt);
          shadowMapCount++;
        }
      }
      if (shadowMapCount !== this.replaceMaterial.shadowMapCount) {
        this.replaceMaterial.shadowMapCount = shadowMapCount;
        this.replaceMaterial.clearTechniques();
      }
      if (shadowMapCount)
        this.enabled = true;
    }
  }
}

class ShadowFeature extends SceneFeature {
  preRender(scene, camera) {
    const lightMgr = camera.scene.findFeature(LightFeature);
    if (lightMgr && lightMgr.visibleLights.length > 0) {
      if (!this._shadowPass) {
        this.addShadowPass(camera);
      }
      const lights = lightMgr.visibleLights;
      for (let i = 0, len = lights.length; i < len; i++) {
        const lgt = lights[i];
        if (lgt.enableShadow && !lgt.shadowMapPass) {
          lgt.shadowMapPass = this.addShadowMapPass(camera, lgt);
        } else if (!lgt.enableShadow && lgt.shadowMapPass) {
          const renderer = camera._renderPipeline;
          renderer.removeRenderPass(lgt.shadowMapPass);
          lgt.shadowMapPass = null;
        }
      }
      this.updatePassRenderFlag(camera._renderPipeline.opaqueQueue);
      this.updatePassRenderFlag(camera._renderPipeline.transparentQueue);
    }
  }
  addShadowPass(camera) {
    const shadowMaterial = new ShadowMaterial(camera.engine, "shadowMaterial");
    this._shadowPass = new ShadowPass("ShadowPass", 1, null, shadowMaterial, MaskList.SHADOW);
    const renderer = camera._renderPipeline;
    renderer.addRenderPass(this._shadowPass);
  }
  addShadowMapPass(camera, light) {
    this._shadowMapMaterial = this._shadowMapMaterial || new ShadowMapMaterial(camera.engine, "shadowMapMaterial");
    const shadowMapPass = new ShadowMapPass("ShadowMapPass", -1, light.shadow.renderTarget, this._shadowMapMaterial, MaskList.SHADOW_MAP, light);
    const renderer = camera._renderPipeline;
    renderer.addRenderPass(shadowMapPass);
    return shadowMapPass;
  }
  updatePassRenderFlag(renderQueue) {
    const items = renderQueue.items;
    for (let i = 0, len = items.length; i < len; i++) {
      const item = items[i];
      const ability = item.component;
      const recieveShadow = ability.recieveShadow;
      const castShadow = ability.castShadow;
      if (recieveShadow === true) {
        ability.addPassMasks(MaskList.SHADOW);
      } else if (recieveShadow === false) {
        ability.removePassMasks(MaskList.SHADOW);
      }
      if (castShadow === true) {
        ability.addPassMasks(MaskList.SHADOW_MAP);
      } else if (castShadow === false) {
        ability.removePassMasks(MaskList.SHADOW_MAP);
      }
    }
  }
}

Scene.registerFeature(ShadowFeature);

Scene.registerFeature(LightFeature);
Scene.prototype.hasLight = hasLight;

export { ABoxCollider, Collider as ACollider, ASphereCollider, AmbientLight, Animation, AnimationClip, AnimationEventType as AnimationEvent, AssetObject, AssetPromise, AssetPromiseStatus, AssetType, BasicRenderPipeline, BlendFunc, BlinnPhongMaterial, BoundingType, BoxCollider, Buffer, BufferBindFlag, BufferGeometry, BufferUsage, BufferUtil, Camera, CircleGeometry, ClearMode, ColliderFeature, CollisionDetection, CommonMaterial, CompFunc, ComplexMaterial, Component, ConstantMaterial, CubeProbe, CuboidGeometry, CullFace, CylinderGeometry, DataType, DirectLight, EXP2Fog, Engine, EngineFeature, EngineObject, Entity, EnvironmentMapLight, Event, EventDispatcher, FogFeature, FrontFace, GLCapabilityType, GLCompressedTextureInternalFormat, GPUParticleSystem, GeometryRenderer, IndexBufferBinding, IndexFormat, InternalAssetType, InterpolationType, LODGroup, LambertMaterial, Layer, Light, LightFeature, LinearFog, Loader, Logger, MaskList, Material, MaterialType, Mesh, MeshRenderer, Model, OITMode, ObjectValues, PBRMaterial, Particle, PlaneCollider, PlaneGeometry, PlaneProbe, PointLight, Primitive, PrimitiveTopology, Probe, RefObject, RefreshRate, RenderBufferColorFormat, RenderBufferDepthFormat, RenderColorTexture, RenderContext, RenderDepthTexture, RenderPass, RenderQueue, RenderState, RenderTarget, RenderTechnique, RenderableComponent, ResourceManager, Scene, SceneFeature, SceneVisitor, ScreenQuadGeometry, Script, SetDataOptions, ShaderFactory, ShaderMaterial, ShapeGeometry, Side, Skin, SkinnedMeshRenderer, SkyBox, SphereCollider, SphereGeometry, SpotLight, SpriteRenderer, SubPrimitive, SystemInfo, Texture, Texture2D, TextureCubeFace, TextureCubeMap, TextureFilter, TextureFilterMode, TextureFormat, TextureMaterial, TextureWrapMode, Time, TorusGeometry, TrailMaterial, TrailRenderer, Transform, TransparentMaterial, UniformSemantic, UpdateFlag, Util, VertexBufferBinding, VertexElement, VertexElementFormat, WrapMode, bindFogToMaterial, dependencies, getFogMacro, hasFogFeature, request, resourceLoader };
//# sourceMappingURL=module.js.map
